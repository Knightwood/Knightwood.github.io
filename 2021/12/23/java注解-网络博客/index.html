

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="夜木">
  <meta name="keywords" content="">
  
    <meta name="description" content="一、介绍本文介绍了 Java 源代码级别的注释处理，并提供了使用此技术在编译期间生成其他源文件的示例。 2.注解处理的应用源代码级注释处理首先出现在 Java 5 中。它是一种在编译阶段生成额外源文件的便捷技术。 源文件不必是 Java 文件——您可以根据源代码中的注释生成任何类型的描述、元数据、文档、资源或任何其他类型的文件。 注释处理在许多无处不在的 Java 库中被积极使用，例如，在 Que">
<meta property="og:type" content="article">
<meta property="og:title" content="java注解-网络博客">
<meta property="og:url" content="https://knightwood.github.io/2021/12/23/java%E6%B3%A8%E8%A7%A3-%E7%BD%91%E7%BB%9C%E5%8D%9A%E5%AE%A2/index.html">
<meta property="og:site_name" content="不知名的博客">
<meta property="og:description" content="一、介绍本文介绍了 Java 源代码级别的注释处理，并提供了使用此技术在编译期间生成其他源文件的示例。 2.注解处理的应用源代码级注释处理首先出现在 Java 5 中。它是一种在编译阶段生成额外源文件的便捷技术。 源文件不必是 Java 文件——您可以根据源代码中的注释生成任何类型的描述、元数据、文档、资源或任何其他类型的文件。 注释处理在许多无处不在的 Java 库中被积极使用，例如，在 Que">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-12-23T06:36:09.000Z">
<meta property="article:modified_time" content="2021-12-23T14:11:16.521Z">
<meta property="article:author" content="NightWood">
<meta name="twitter:card" content="summary_large_image">
  
  
  <title>java注解-网络博客 - 不知名的博客</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"knightwood.github.io","root":"/","version":"1.8.13","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="java注解-网络博客">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-12-23 14:36" pubdate>
        2021年12月23日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      47k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      390 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">java注解-网络博客</h1>
            
            <div class="markdown-body">
              <h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a><strong>一、<a target="_blank" rel="noopener" href="https://www.baeldung.com/java-annotation-processing-builder">介绍</a></strong></h2><p>本文<strong>介绍了 Java 源代码级别的注释处理，</strong>并提供了使用此技术在编译期间生成其他源文件的示例。</p>
<h2 id="2-注解处理的应用"><a href="#2-注解处理的应用" class="headerlink" title="2.注解处理的应用"></a><strong>2.注解处理的应用</strong></h2><p>源代码级注释处理首先出现在 Java 5 中。它是一种在编译阶段生成额外源文件的便捷技术。</p>
<p>源文件不必是 Java 文件——您可以根据源代码中的注释生成任何类型的描述、元数据、文档、资源或任何其他类型的文件。</p>
<p>注释处理在许多无处不在的 Java 库中被积极使用，例如，在 QueryDSL 和 JPA 中生成元类，在 Lombok 库中使用样板代码扩充类。</p>
<p>需要注意的重要一点是<strong>注解处理 API 的局限性——它只能用于生成新文件，不能用于更改现有文件</strong>。</p>
<p>值得注意的例外是<a target="_blank" rel="noopener" href="https://projectlombok.org/">Lombok</a>库，它使用注解处理作为引导机制将自身包含到编译过程中并通过一些内部编译器 API 修改 AST。这种 hacky 技术与注释处理的预期目的无关，因此不在本文中讨论。</p>
<h2 id="3-注解处理API"><a href="#3-注解处理API" class="headerlink" title="3.注解处理API"></a><strong>3.注解处理API</strong></h2><p>注释处理分多轮完成。每一轮都从编译器开始搜索源文件中的注释并选择适合这些注释的注释处理器。依次在相应的源上调用每个注释处理器。</p>
<p>如果在此过程中生成了任何文件，则以生成的文件作为其输入开始另一轮。这个过程一直持续到在处理阶段没有新文件产生。</p>
<p>依次在相应的源上调用每个注释处理器。如果在此过程中生成了任何文件，则以生成的文件作为其输入开始另一轮。这个过程一直持续到在处理阶段没有新文件产生。</p>
<p>注释处理 API 位于<em>javax.annotation.processing</em>包中。您必须实现的主要接口是<em>Processor</em>接口，它具有<em>AbstractProcessor</em>类形式的部分实现。这个类是我们将要扩展以创建我们自己的注释处理器的类。</p>
<h2 id="4-设置项目"><a href="#4-设置项目" class="headerlink" title="4. 设置项目"></a><strong>4. 设置项目</strong></h2><p>为了演示注释处理的可能性，我们将开发一个简单的处理器来为带注释的类生成流畅的对象构建器。</p>
<p>我们将把我们的项目分成两个 Maven 模块。其中一个，<em>注释处理器</em>模块，将包含处理器本身和注释，另一个，<em>注释用户</em>模块，将包含被注释的类。这是注释处理的典型用例。</p>
<p><em>annotation-processor</em>模块的设置如下。我们将使用 Google 的<a target="_blank" rel="noopener" href="https://github.com/google/auto/tree/master/service">自动服务</a>库来生成稍后将讨论的处理器元数据文件，以及针对 Java 8 源代码调整的<em>maven-compiler-plugin</em>。这些依赖项的版本被提取到属性部分。</p>
<p>最新版本的[自动服务](<a target="_blank" rel="noopener" href="https://search.maven.org/classic/#search|gav|1|g%3A&quot;com.google.auto.service&quot;">https://search.maven.org/classic/#search|gav|1|g%3A&quot;com.google.auto.service&quot;</a> AND a%3A”auto-service”)库和[maven-compiler-plugin](<a target="_blank" rel="noopener" href="https://search.maven.org/classic/#search|gav|1|g%3A&quot;org.apache.maven.plugins&quot;">https://search.maven.org/classic/#search|gav|1|g%3A&quot;org.apache.maven.plugins&quot;</a> AND a%3A”maven-compiler-plugin”)可以在 Maven 中央存储库中找到：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">auto-service.version</span>&gt;</span>1.0-rc2<span class="hljs-tag">&lt;/<span class="hljs-name">auto-service.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">maven-compiler-plugin.version</span>&gt;</span><br>      3.5.1<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">maven-compiler-plugin.version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.auto.service<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>auto-service<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;auto-service.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;maven-compiler-plugin.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>带有注释源的<em>annotation-user</em> Maven 模块不需要任何特殊调整，除了在依赖项部分添加对 annotation-processor 模块的依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baeldung<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>annotation-processing<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h2 id="5-定义注释"><a href="#5-定义注释" class="headerlink" title="5. 定义注释"></a><strong>5. 定义注释</strong></h2><p>假设我们的<em>annotation-user</em>模块中有一个简单的 POJO 类，其中包含几个字段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-comment">// getters and setters …</span><br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们想创建一个构建器助手类来更流畅地实例化<em>Person</em>类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Person person = <span class="hljs-keyword">new</span> PersonBuilder()<br>  .setAge(<span class="hljs-number">25</span>)<br>  .setName(<span class="hljs-string">&quot;John&quot;</span>)<br>  .build();<br></code></pre></td></tr></table></figure>

<p>这个<em>PersonBuilder</em>类是一代的明显选择，因为它的结构完全由<em>Person</em> setter 方法定义。</p>
<p>让我们在<em>注释处理器</em>模块中为 setter 方法创建一个*@BuilderProperty<em>注释。它将允许我们为每个注释了 setter 方法的类生成</em>Builder*类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> BuilderProperty &#123;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>带有<em>ElementType.METHOD</em>参数的*@Target*注解确保此注解只能放在一个方法上。</p>
<p>在<em>SOURCE</em>保留策略的手段，这个注释是唯一可用的源处理过程中，而不是在运行时可用。</p>
<p>带有*@BuilderProperty<em>注解的属性的</em>Person*类将如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-meta">@BuilderProperty</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-meta">@BuilderProperty</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-comment">// getters …</span><br><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="6-实现-处理器"><a href="#6-实现-处理器" class="headerlink" title="6. 实现*处理器*"></a><strong>6. 实现*处理器*</strong></h2><h3 id="6-1-创建一个-AbstractProcessor-子类"><a href="#6-1-创建一个-AbstractProcessor-子类" class="headerlink" title="6.1. 创建一个*AbstractProcessor*子类"></a><strong>6.1. 创建一个*AbstractProcessor*子类</strong></h3><p>我们将从在<em>注释处理器</em>Maven 模块中扩展<em>AbstractProcessor</em>类开始。</p>
<p>首先，我们应该指定该处理器能够处理的注释，以及支持的源代码版本。这可以通过实施方法进行<em>getSupportedAnnotationTypes</em>和<em>getSupportedSourceVersion</em>的的<em>处理器</em>接口或通过注释你的类*@SupportedAnnotationTypes<em>和</em>@SupportedSourceVersion*注解。</p>
<p>所述*@AutoService<em>注释是的一部分</em>自动服务*库，并允许生成，这将在下面的章节进行说明处理器的元数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SupportedAnnotationTypes(</span><br><span class="hljs-meta">  &quot;com.baeldung.annotation.processor.BuilderProperty&quot;)</span><br><span class="hljs-meta">@SupportedSourceVersion(SourceVersion.RELEASE_8)</span><br><span class="hljs-meta">@AutoService(Processor.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BuilderProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractProcessor</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">process</span><span class="hljs-params">(Set&lt;? extends TypeElement&gt; annotations, </span></span><br><span class="hljs-params"><span class="hljs-function">      RoundEnvironment roundEnv)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>您不仅可以指定具体的注释类名称，还可以指定通配符，例如<em>“com.baeldung.annotation.*”</em>来处理<em>com.baeldung.annotation</em>包及其所有子包中的注释，甚至可以<em>“*”</em>来处理所有注释.</p>
<p>我们必须实现的单一方法是处理本身的<em>process</em>方法。编译器为每个包含匹配注释的源文件调用它。</p>
<p>注释作为第一个<em>Set&lt;? extends TypeElement&gt; annotations</em>参数，有关当前处理轮次的信息作为<em>RoundEnviroment roundEnv</em>参数传递。</p>
<p>如果您的注释处理器已经处理了所有传递的注释，并且您不希望它们被传递到列表中的其他注释处理器，则返回<em>布尔</em>值应该为<em>true</em>。</p>
<h3 id="6-2-收集数据"><a href="#6-2-收集数据" class="headerlink" title="6.2. 收集数据"></a><strong>6.2. 收集数据</strong></h3><p>我们的处理器还没有真正做任何有用的事情，所以让我们用代码填充它。</p>
<p>首先，我们需要遍历在类中找到的所有注释类型——在我们的例子中，<em>注释</em>集将有一个与*@BuilderProperty*注释相对应的元素，即使这个注释在源文件中多次出现。</p>
<p>尽管如此，为了完整起见，最好将<em>process</em>方法实现为迭代周期：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">process</span><span class="hljs-params">(Set&lt;? extends TypeElement&gt; annotations, </span></span><br><span class="hljs-params"><span class="hljs-function">  RoundEnvironment roundEnv)</span> </span>&#123;<br><br>    <span class="hljs-keyword">for</span> (TypeElement annotation : annotations) &#123;<br>        Set&lt;? extends Element&gt; annotatedElements <br>          = roundEnv.getElementsAnnotatedWith(annotation);<br>        <br>        <span class="hljs-comment">// …</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在此代码中，我们使用<em>RoundEnvironment</em>实例接收所有使用*@BuilderProperty<em>注释的元素。对于</em>Person<em>类，这些元素对应于</em>setName<em>和</em>setAge*方法。</p>
<p><em>@BuilderProperty</em>注释的用户可能会错误地注释实际上不是 setter 的方法。setter 方法名称应以<em>set</em>开头，并且该方法应接收单个参数。所以让我们把小麦和谷壳分开。</p>
<p>在以下代码中，我们使用*Collectors.partitioningBy()*收集器将带注释的方法拆分为两个集合：正确注释的 setter 和其他错误注释的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;Boolean, List&lt;Element&gt;&gt; annotatedMethods = annotatedElements.stream().collect(<br>  Collectors.partitioningBy(element -&gt;<br>    ((ExecutableType) element.asType()).getParameterTypes().size() == <span class="hljs-number">1</span><br>    &amp;&amp; element.getSimpleName().toString().startsWith(<span class="hljs-string">&quot;set&quot;</span>)));<br><br>List&lt;Element&gt; setters = annotatedMethods.get(<span class="hljs-keyword">true</span>);<br>List&lt;Element&gt; otherMethods = annotatedMethods.get(<span class="hljs-keyword">false</span>);<br></code></pre></td></tr></table></figure>

<p>在这里，我们使用<em>Element.asType()<em>方法来接收</em>TypeMirror</em>类的实例，即使我们仅处于源处理阶段，它也为我们提供了一些内省类型的能力。</p>
<p>我们应该警告用户有关错误注释的方法，因此让我们使用可从<em>AbstractProcessor.processingEnv</em>保护字段访问的<em>Messager</em>实例。以下几行将在源处理阶段为每个错误注释的元素输出错误：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">otherMethods.forEach(element -&gt;<br>  processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,<br>    <span class="hljs-string">&quot;@BuilderProperty must be applied to a setXxx method &quot;</span> <br>      + <span class="hljs-string">&quot;with a single argument&quot;</span>, element));<br></code></pre></td></tr></table></figure>

<p>当然，如果正确的 setters 集合为空，则继续当前类型元素集合迭代是没有意义的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (setters.isEmpty()) &#123;<br>    <span class="hljs-keyword">continue</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果 setter 集合至少有一个元素，我们将使用它从封闭元素中获取完全限定的类名，在 setter 方法的情况下，它似乎是源类本身：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">String className = ((TypeElement) setters.get(<span class="hljs-number">0</span>)<br>  .getEnclosingElement()).getQualifiedName().toString();<br></code></pre></td></tr></table></figure>

<p>生成构建器类所需的最后一点信息是 setter 名称与其参数类型名称之间的映射：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;String, String&gt; setterMap = setters.stream().collect(Collectors.toMap(<br>    setter -&gt; setter.getSimpleName().toString(),<br>    setter -&gt; ((ExecutableType) setter.asType())<br>      .getParameterTypes().get(<span class="hljs-number">0</span>).toString()<br>));<br></code></pre></td></tr></table></figure>

<h3 id="6-3-生成输出文件"><a href="#6-3-生成输出文件" class="headerlink" title="6.3. 生成输出文件"></a><strong>6.3. 生成输出文件</strong></h3><p>现在我们有了生成构建器类所需的所有信息：源类的名称、它的所有 setter 名称以及它们的参数类型。</p>
<p>为了生成输出文件，我们将使用<em>AbstractProcessor.processingEnv</em>受保护属性中的对象再次提供的<em>Filer</em>实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">JavaFileObject builderFile = processingEnv.getFiler()<br>  .createSourceFile(builderClassName);<br><span class="hljs-keyword">try</span> (PrintWriter out = <span class="hljs-keyword">new</span> PrintWriter(builderFile.openWriter())) &#123;<br>    <span class="hljs-comment">// writing generated file to out …</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>下面提供了<em>writeBuilderFile</em>方法的完整代码。我们只需要计算源类和构建器类的包名、完全限定的构建器类名和简单类名。其余的代码非常简单。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeBuilderFile</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  String className, Map&lt;String, String&gt; setterMap)</span> </span><br><span class="hljs-function">  <span class="hljs-keyword">throws</span> IOException </span>&#123;<br><br>    String packageName = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">int</span> lastDot = className.lastIndexOf(<span class="hljs-string">&#x27;.&#x27;</span>);<br>    <span class="hljs-keyword">if</span> (lastDot &gt; <span class="hljs-number">0</span>) &#123;<br>        packageName = className.substring(<span class="hljs-number">0</span>, lastDot);<br>    &#125;<br><br>    String simpleClassName = className.substring(lastDot + <span class="hljs-number">1</span>);<br>    String builderClassName = className + <span class="hljs-string">&quot;Builder&quot;</span>;<br>    String builderSimpleClassName = builderClassName<br>      .substring(lastDot + <span class="hljs-number">1</span>);<br><br>    JavaFileObject builderFile = processingEnv.getFiler()<br>      .createSourceFile(builderClassName);<br>    <br>    <span class="hljs-keyword">try</span> (PrintWriter out = <span class="hljs-keyword">new</span> PrintWriter(builderFile.openWriter())) &#123;<br><br>        <span class="hljs-keyword">if</span> (packageName != <span class="hljs-keyword">null</span>) &#123;<br>            out.print(<span class="hljs-string">&quot;package &quot;</span>);<br>            out.print(packageName);<br>            out.println(<span class="hljs-string">&quot;;&quot;</span>);<br>            out.println();<br>        &#125;<br><br>        out.print(<span class="hljs-string">&quot;public class &quot;</span>);<br>        out.print(builderSimpleClassName);<br>        out.println(<span class="hljs-string">&quot; &#123;&quot;</span>);<br>        out.println();<br><br>        out.print(<span class="hljs-string">&quot;    private &quot;</span>);<br>        out.print(simpleClassName);<br>        out.print(<span class="hljs-string">&quot; object = new &quot;</span>);<br>        out.print(simpleClassName);<br>        out.println(<span class="hljs-string">&quot;();&quot;</span>);<br>        out.println();<br><br>        out.print(<span class="hljs-string">&quot;    public &quot;</span>);<br>        out.print(simpleClassName);<br>        out.println(<span class="hljs-string">&quot; build() &#123;&quot;</span>);<br>        out.println(<span class="hljs-string">&quot;        return object;&quot;</span>);<br>        out.println(<span class="hljs-string">&quot;    &#125;&quot;</span>);<br>        out.println();<br><br>        setterMap.entrySet().forEach(setter -&gt; &#123;<br>            String methodName = setter.getKey();<br>            String argumentType = setter.getValue();<br><br>            out.print(<span class="hljs-string">&quot;    public &quot;</span>);<br>            out.print(builderSimpleClassName);<br>            out.print(<span class="hljs-string">&quot; &quot;</span>);<br>            out.print(methodName);<br><br>            out.print(<span class="hljs-string">&quot;(&quot;</span>);<br><br>            out.print(argumentType);<br>            out.println(<span class="hljs-string">&quot; value) &#123;&quot;</span>);<br>            out.print(<span class="hljs-string">&quot;        object.&quot;</span>);<br>            out.print(methodName);<br>            out.println(<span class="hljs-string">&quot;(value);&quot;</span>);<br>            out.println(<span class="hljs-string">&quot;        return this;&quot;</span>);<br>            out.println(<span class="hljs-string">&quot;    &#125;&quot;</span>);<br>            out.println();<br>        &#125;);<br><br>        out.println(<span class="hljs-string">&quot;&#125;&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="7-运行示例"><a href="#7-运行示例" class="headerlink" title="7. 运行示例"></a><strong>7. 运行示例</strong></h2><p>要查看代码生成的运行情况，您应该从公共父根编译两个模块，或者首先编译<em>annotation-processor</em>模块，然后编译<em>annotation-user</em>模块。</p>
<p>生成的<em>PersonBuilder</em>类可以在<em>annotation-user/target/generated-sources/annotations/com/baeldung/annotation/PersonBuilder.java</em>文件中找到，应该如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.baeldung.annotation;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonBuilder</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Person object = <span class="hljs-keyword">new</span> Person();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Person <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> object;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PersonBuilder <span class="hljs-title">setName</span><span class="hljs-params">(java.lang.String value)</span> </span>&#123;<br>        object.setName(value);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PersonBuilder <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        object.setAge(value);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="8-注册处理器的其他方式"><a href="#8-注册处理器的其他方式" class="headerlink" title="8. 注册处理器的其他方式"></a><strong>8. 注册处理器的其他方式</strong></h2><p>要在编译阶段使用注释处理器，您还有其他几个选项，具体取决于您的用例和您使用的工具。</p>
<h3 id="8-1-使用注释处理器工具"><a href="#8-1-使用注释处理器工具" class="headerlink" title="8.1. 使用注释处理器工具"></a><strong>8.1. 使用注释处理器工具</strong></h3><p>该<em>贴切</em>工具是用于处理源文件一个特殊的命令行实用程序。它是 Java 5 的一部分，但从 Java 7 开始，它被弃用，取而代之的是其他选项，并在 Java 8 中完全删除。本文不会讨论它。</p>
<h3 id="8-2-使用编译器密钥"><a href="#8-2-使用编译器密钥" class="headerlink" title="8.2. 使用编译器密钥"></a><strong>8.2. 使用编译器密钥</strong></h3><p>该*-processor*编译器关键是一个标准的JDK设施，以增加编译器的源处理阶段，自己的注释处理器。</p>
<p>请注意，处理器本身和注释必须已经在单独的编译中编译为类并存在于类路径中，因此您应该做的第一件事是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">javac com/baeldung/annotation/processor/BuilderProcessor<br>javac com/baeldung/annotation/processor/BuilderProperty<br></code></pre></td></tr></table></figure>

<p>然后，您使用*-processor*键对您的源代码进行实际编译，指定您刚刚编译的注释处理器类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">javac -processor com.baeldung.annotation.processor.MyProcessor Person.java<br></code></pre></td></tr></table></figure>

<p>要一次性指定多个注释处理器，您可以用逗号分隔它们的类名，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">javac -processor package1.Processor1,package2.Processor2 SourceFile.java<br></code></pre></td></tr></table></figure>

<h3 id="8-3-使用-Maven"><a href="#8-3-使用-Maven" class="headerlink" title="8.3. 使用 Maven"></a><strong>8.3. 使用 Maven</strong></h3><p>的<em>Maven的编译器插件</em>允许指定注释处理器作为其结构的一部分。</p>
<p>这是为编译器插件添加注释处理器的示例。您还可以使用<em>generateSourcesDirectory</em>配置参数指定将生成的源放入的目录。</p>
<p>请注意，<em>BuilderProcessor</em>类应该已经被编译，例如，从构建依赖项中的另一个 jar 导入：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">encoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">encoding</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">generatedSourcesDirectory</span>&gt;</span>$&#123;project.build.directory&#125;<br>                  /generated-sources/<span class="hljs-tag">&lt;/<span class="hljs-name">generatedSourcesDirectory</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">annotationProcessors</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">annotationProcessor</span>&gt;</span><br>                        com.baeldung.annotation.processor.BuilderProcessor<br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">annotationProcessor</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">annotationProcessors</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="8-4-将处理器-Jar-添加到类路径"><a href="#8-4-将处理器-Jar-添加到类路径" class="headerlink" title="8.4. 将处理器 Jar 添加到类路径"></a><strong>8.4. 将处理器 Jar 添加到类路径</strong></h3><p>您可以简单地将带有处理器类的特殊结构的 jar 添加到编译器的类路径中，而不是在编译器选项中指定注释处理器。</p>
<p>要自动选择它，编译器必须知道处理器类的名称。因此，您必须在<em>META-INF/services/javax.annotation.processing.Processor</em>文件中将其指定为处理器的完全限定类名：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">com.baeldung.annotation.processor.BuilderProcessor<br></code></pre></td></tr></table></figure>

<p>您还可以从这个 jar 中指定多个处理器，通过用新行分隔它们来自动拾取：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">package1.Processor1<br>package2.Processor2<br>package3.Processor3<br></code></pre></td></tr></table></figure>

<p>如果使用Maven构建这个jar，并尝试将这个文件直接放到<em>src/main/resources/META-INF/services</em>目录下，会遇到如下错误：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">[ERROR] Bad service configuration file, or exception thrown <span class="hljs-keyword">while</span> <br>constructing Processor object: javax.annotation.processing.Processor: <br>Provider com.baeldung.annotation.processor.BuilderProcessor not found<br></code></pre></td></tr></table></figure>

<p>这是因为当<em>BuilderProcessor</em>文件尚未编译时，编译器会在模块本身的<em>源代码处理</em>阶段尝试使用此文件。在 Maven 构建的资源复制阶段，该文件必须放在另一个资源目录中并复制到<em>META-INF/services</em>目录，或者（甚至更好）在构建期间生成。</p>
<p>下一节中讨论的 Google<em>自动服务</em>库允许使用简单的注释生成此文件。</p>
<h3 id="8-5-使用-Google“auto-service”库"><a href="#8-5-使用-Google“auto-service”库" class="headerlink" title="8.5. 使用 Google“auto service”库"></a><strong>8.5. 使用 Google“auto service”库</strong></h3><p>要自动生成注册文件，您可以使用Google 的<em>自动服务</em>库中的*@AutoService*注释，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AutoService(Processor.class)</span><br><span class="hljs-keyword">public</span> BuilderProcessor extends AbstractProcessor &#123;<br>    <span class="hljs-comment">// …</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>此注释本身由来自自动服务库的注释处理器处理。该处理器生成包含<em>BuilderProcessor</em>类名的<em>META-INF/services/javax.annotation.processing.Processor</em>文件。</p>
<h2 id="9-结论"><a href="#9-结论" class="headerlink" title="9. 结论"></a><strong>9. 结论</strong></h2><p>在本文中，我们使用为 POJO 生成 Builder 类的示例演示了源级注释处理。我们还提供了几种在您的项目中注册注释处理器的替代方法。</p>
<p>本文的源代码可<a target="_blank" rel="noopener" href="https://github.com/eugenp/tutorials/tree/master/annotations">在 GitHub 上找到</a>。</p>
<h1 id="原文："><a href="#原文：" class="headerlink" title="原文："></a>原文：</h1><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a><strong>1. <a target="_blank" rel="noopener" href="https://www.baeldung.com/java-annotation-processing-builder">Introduction</a></strong></h2><p>This article is <strong>an intro to Java source-level annotation processing</strong> and provides examples of using this technique for generating additional source files during compilation.</p>
<h2 id="2-Applications-of-Annotation-Processing"><a href="#2-Applications-of-Annotation-Processing" class="headerlink" title="2. Applications of Annotation Processing"></a><strong>2. Applications of Annotation Processing</strong></h2><p>The source-level annotation processing first appeared in Java 5. It is a handy technique for generating additional source files during the compilation stage.</p>
<p>The source files don’t have to be Java files — you can generate any kind of description, metadata, documentation, resources, or any other type of files, based on annotations in your source code.</p>
<p>Annotation processing is actively used in many ubiquitous Java libraries, for instance, to generate metaclasses in QueryDSL and JPA, to augment classes with boilerplate code in Lombok library.</p>
<p>An important thing to note is <strong>the limitation of the annotation processing API — it can only be used to generate new files, not to change existing ones</strong>.</p>
<p>The notable exception is the <a target="_blank" rel="noopener" href="https://projectlombok.org/">Lombok</a> library which uses annotation processing as a bootstrapping mechanism to include itself into the compilation process and modify the AST via some internal compiler APIs. This hacky technique has nothing to do with the intended purpose of annotation processing and therefore is not discussed in this article.</p>
<h2 id="3-Annotation-Processing-API"><a href="#3-Annotation-Processing-API" class="headerlink" title="3. Annotation Processing API"></a><strong>3. Annotation Processing API</strong></h2><p>The annotation processing is done in multiple rounds. Each round starts with the compiler searching for the annotations in the source files and choosing the annotation processors suited for these annotations. Each annotation processor, in turn, is called on the corresponding sources.</p>
<p>If any files are generated during this process, another round is started with the generated files as its input. This process continues until no new files are generated during the processing stage.</p>
<p>Each annotation processor, in turn, is called on the corresponding sources. If any files are generated during this process, another round is started with the generated files as its input. This process continues until no new files are generated during the processing stage.</p>
<p>The annotation processing API is located in the <em>javax.annotation.processing</em> package. The main interface that you’ll have to implement is the <em>Processor</em> interface, which has a partial implementation in the form of <em>AbstractProcessor</em> class. This class is the one we’re going to extend to create our own annotation processor.</p>
<h2 id="4-Setting-Up-the-Project"><a href="#4-Setting-Up-the-Project" class="headerlink" title="4. Setting Up the Project"></a><strong>4. Setting Up the Project</strong></h2><p>To demonstrate the possibilities of annotation processing, we will develop a simple processor for generating fluent object builders for annotated classes.</p>
<p>We’re going to split our project into two Maven modules. One of them, <em>annotation-processor</em> module, will contain the processor itself together with the annotation, and another, the <em>annotation-user</em> module, will contain the annotated class. This is a typical use case of annotation processing.</p>
<p>The settings for the <em>annotation-processor</em> module are as follows. We’re going to use the Google’s <a target="_blank" rel="noopener" href="https://github.com/google/auto/tree/master/service">auto-service</a> library to generate processor metadata file which will be discussed later, and the <em>maven-compiler-plugin</em> tuned for the Java 8 source code. The versions of these dependencies are extracted to the properties section.</p>
<p>Latest versions of the [auto-service](<a target="_blank" rel="noopener" href="https://search.maven.org/classic/#search|gav|1|g%3A&quot;com.google.auto.service&quot;">https://search.maven.org/classic/#search|gav|1|g%3A&quot;com.google.auto.service&quot;</a> AND a%3A”auto-service”) library and [maven-compiler-plugin](<a target="_blank" rel="noopener" href="https://search.maven.org/classic/#search|gav|1|g%3A&quot;org.apache.maven.plugins&quot;">https://search.maven.org/classic/#search|gav|1|g%3A&quot;org.apache.maven.plugins&quot;</a> AND a%3A”maven-compiler-plugin”) can be found in Maven Central repository:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">auto-service.version</span>&gt;</span>1.0-rc2<span class="hljs-tag">&lt;/<span class="hljs-name">auto-service.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">maven-compiler-plugin.version</span>&gt;</span><br>      3.5.1<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">maven-compiler-plugin.version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.auto.service<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>auto-service<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;auto-service.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;maven-compiler-plugin.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>The <em>annotation-user</em> Maven module with the annotated sources does not need any special tuning, except adding a dependency on the annotation-processor module in the dependencies section:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baeldung<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>annotation-processing<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h2 id="5-Defining-an-Annotation"><a href="#5-Defining-an-Annotation" class="headerlink" title="5. Defining an Annotation"></a><strong>5. Defining an Annotation</strong></h2><p>Suppose we have a simple POJO class in our <em>annotation-user</em> module with several fields:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-comment">// getters and setters …</span><br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>We want to create a builder helper class to instantiate the <em>Person</em> class more fluently:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Person person = <span class="hljs-keyword">new</span> PersonBuilder()<br>  .setAge(<span class="hljs-number">25</span>)<br>  .setName(<span class="hljs-string">&quot;John&quot;</span>)<br>  .build();<br></code></pre></td></tr></table></figure>

<p>This <em>PersonBuilder</em> class is an obvious choice for a generation, as its structure is completely defined by the <em>Person</em> setter methods.</p>
<p>Let’s create a <em>@BuilderProperty</em> annotation in the <em>annotation-processor</em> module for the setter methods. It will allow us to generate the <em>Builder</em> class for each class that has its setter methods annotated:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> BuilderProperty &#123;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>The <em>@Target</em> annotation with the <em>ElementType.METHOD</em> parameter ensures that this annotation can be only put on a method.</p>
<p>The <em>SOURCE</em> retention policy means that this annotation is only available during source processing and is not available at runtime.</p>
<p>The <em>Person</em> class with properties annotated with the <em>@BuilderProperty</em> annotation will look as follows:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-meta">@BuilderProperty</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-meta">@BuilderProperty</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-comment">// getters …</span><br><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="6-Implementing-a-Processor"><a href="#6-Implementing-a-Processor" class="headerlink" title="6. Implementing a *Processor*"></a><strong>6. Implementing a *Processor*</strong></h2><h3 id="6-1-Creating-an-AbstractProcessor-Subclass"><a href="#6-1-Creating-an-AbstractProcessor-Subclass" class="headerlink" title="6.1. Creating an *AbstractProcessor* Subclass"></a><strong>6.1. Creating an *AbstractProcessor* Subclass</strong></h3><p>We’ll start with extending the <em>AbstractProcessor</em> class inside the <em>annotation-processor</em> Maven module.</p>
<p>First, we should specify annotations that this processor is capable of processing, and also the supported source code version. This can be done either by implementing the methods <em>getSupportedAnnotationTypes</em> and <em>getSupportedSourceVersion</em> of the <em>Processor</em> interface or by annotating your class with <em>@SupportedAnnotationTypes</em> and <em>@SupportedSourceVersion</em> annotations.</p>
<p>The <em>@AutoService</em> annotation is a part of the <em>auto-service</em> library and allows to generate the processor metadata which will be explained in the following sections.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SupportedAnnotationTypes(</span><br><span class="hljs-meta">  &quot;com.baeldung.annotation.processor.BuilderProperty&quot;)</span><br><span class="hljs-meta">@SupportedSourceVersion(SourceVersion.RELEASE_8)</span><br><span class="hljs-meta">@AutoService(Processor.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BuilderProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractProcessor</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">process</span><span class="hljs-params">(Set&lt;? extends TypeElement&gt; annotations, </span></span><br><span class="hljs-params"><span class="hljs-function">      RoundEnvironment roundEnv)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>You can specify not only the concrete annotation class names but also wildcards, like <em>“com.baeldung.annotation.*”</em> to process annotations inside the <em>com.baeldung.annotation</em> package and all its sub packages, or even <em>“*”</em> to process all annotations.</p>
<p>The single method that we’ll have to implement is the <em>process</em> method that does the processing itself. It is called by the compiler for every source file containing the matching annotations.</p>
<p>Annotations are passed as the first <em>Set&lt;? extends TypeElement&gt; annotations</em> argument, and the information about the current processing round is passed as the <em>RoundEnviroment roundEnv</em> argument.</p>
<p>The return <em>boolean</em> value should be <em>true</em> if your annotation processor has processed all the passed annotations, and you don’t want them to be passed to other annotation processors down the list.</p>
<h3 id="6-2-Gathering-Data"><a href="#6-2-Gathering-Data" class="headerlink" title="6.2. Gathering Data"></a><strong>6.2. Gathering Data</strong></h3><p>Our processor does not really do anything useful yet, so let’s fill it with code.</p>
<p>First, we’ll need to iterate through all annotation types that are found in the class — in our case, the <em>annotations</em> set will have a single element corresponding to the <em>@BuilderProperty</em> annotation, even if this annotation occurs multiple times in the source file.</p>
<p>Still, it’s better to implement the <em>process</em> method as an iteration cycle, for completeness sake:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">process</span><span class="hljs-params">(Set&lt;? extends TypeElement&gt; annotations, </span></span><br><span class="hljs-params"><span class="hljs-function">  RoundEnvironment roundEnv)</span> </span>&#123;<br><br>    <span class="hljs-keyword">for</span> (TypeElement annotation : annotations) &#123;<br>        Set&lt;? extends Element&gt; annotatedElements <br>          = roundEnv.getElementsAnnotatedWith(annotation);<br>        <br>        <span class="hljs-comment">// …</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>In this code, we use the <em>RoundEnvironment</em> instance to receive all elements annotated with the <em>@BuilderProperty</em> annotation. In the case of the <em>Person</em> class, these elements correspond to the <em>setName</em> and <em>setAge</em> methods.</p>
<p><em>@BuilderProperty</em> annotation’s user could erroneously annotate methods that are not actually setters. The setter method name should start with <em>set</em>, and the method should receive a single argument. So let’s separate the wheat from the chaff.</p>
<p>In the following code, we use the <em>Collectors.partitioningBy()</em> collector to split annotated methods into two collections: correctly annotated setters and other erroneously annotated methods:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;Boolean, List&lt;Element&gt;&gt; annotatedMethods = annotatedElements.stream().collect(<br>  Collectors.partitioningBy(element -&gt;<br>    ((ExecutableType) element.asType()).getParameterTypes().size() == <span class="hljs-number">1</span><br>    &amp;&amp; element.getSimpleName().toString().startsWith(<span class="hljs-string">&quot;set&quot;</span>)));<br><br>List&lt;Element&gt; setters = annotatedMethods.get(<span class="hljs-keyword">true</span>);<br>List&lt;Element&gt; otherMethods = annotatedMethods.get(<span class="hljs-keyword">false</span>);<br></code></pre></td></tr></table></figure>

<p>Here we use the <em>Element.asType()</em> method to receive an instance of the <em>TypeMirror</em> class which gives us some ability to introspect types even though we are only at the source processing stage.</p>
<p>We should warn the user about incorrectly annotated methods, so let’s use the <em>Messager</em> instance accessible from the <em>AbstractProcessor.processingEnv</em> protected field. The following lines will output an error for each erroneously annotated element during the source processing stage:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">otherMethods.forEach(element -&gt;<br>  processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,<br>    <span class="hljs-string">&quot;@BuilderProperty must be applied to a setXxx method &quot;</span> <br>      + <span class="hljs-string">&quot;with a single argument&quot;</span>, element));<br></code></pre></td></tr></table></figure>

<p>Of course, if the correct setters collection is empty, there is no point of continuing the current type element set iteration:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (setters.isEmpty()) &#123;<br>    <span class="hljs-keyword">continue</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>If the setters collection has at least one element, we’re going to use it to get the fully qualified class name from the enclosing element, which in case of the setter method appears to be the source class itself:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">String className = ((TypeElement) setters.get(<span class="hljs-number">0</span>)<br>  .getEnclosingElement()).getQualifiedName().toString();<br></code></pre></td></tr></table></figure>

<p>The last bit of information we need to generate a builder class is a map between the names of the setters and the names of their argument types:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;String, String&gt; setterMap = setters.stream().collect(Collectors.toMap(<br>    setter -&gt; setter.getSimpleName().toString(),<br>    setter -&gt; ((ExecutableType) setter.asType())<br>      .getParameterTypes().get(<span class="hljs-number">0</span>).toString()<br>));<br></code></pre></td></tr></table></figure>

<h3 id="6-3-Generating-the-Output-File"><a href="#6-3-Generating-the-Output-File" class="headerlink" title="6.3. Generating the Output File"></a><strong>6.3. Generating the Output File</strong></h3><p>Now we have all the information we need to generate a builder class: the name of the source class, all its setter names, and their argument types.</p>
<p>To generate the output file, we’ll use the <em>Filer</em> instance provided again by the object in the <em>AbstractProcessor.processingEnv</em> protected property:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">JavaFileObject builderFile = processingEnv.getFiler()<br>  .createSourceFile(builderClassName);<br><span class="hljs-keyword">try</span> (PrintWriter out = <span class="hljs-keyword">new</span> PrintWriter(builderFile.openWriter())) &#123;<br>    <span class="hljs-comment">// writing generated file to out …</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>The complete code of the <em>writeBuilderFile</em> method is provided below. We only need to calculate the package name, fully qualified builder class name, and simple class names for the source class and the builder class. The rest of the code is pretty straightforward.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeBuilderFile</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  String className, Map&lt;String, String&gt; setterMap)</span> </span><br><span class="hljs-function">  <span class="hljs-keyword">throws</span> IOException </span>&#123;<br><br>    String packageName = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">int</span> lastDot = className.lastIndexOf(<span class="hljs-string">&#x27;.&#x27;</span>);<br>    <span class="hljs-keyword">if</span> (lastDot &gt; <span class="hljs-number">0</span>) &#123;<br>        packageName = className.substring(<span class="hljs-number">0</span>, lastDot);<br>    &#125;<br><br>    String simpleClassName = className.substring(lastDot + <span class="hljs-number">1</span>);<br>    String builderClassName = className + <span class="hljs-string">&quot;Builder&quot;</span>;<br>    String builderSimpleClassName = builderClassName<br>      .substring(lastDot + <span class="hljs-number">1</span>);<br><br>    JavaFileObject builderFile = processingEnv.getFiler()<br>      .createSourceFile(builderClassName);<br>    <br>    <span class="hljs-keyword">try</span> (PrintWriter out = <span class="hljs-keyword">new</span> PrintWriter(builderFile.openWriter())) &#123;<br><br>        <span class="hljs-keyword">if</span> (packageName != <span class="hljs-keyword">null</span>) &#123;<br>            out.print(<span class="hljs-string">&quot;package &quot;</span>);<br>            out.print(packageName);<br>            out.println(<span class="hljs-string">&quot;;&quot;</span>);<br>            out.println();<br>        &#125;<br><br>        out.print(<span class="hljs-string">&quot;public class &quot;</span>);<br>        out.print(builderSimpleClassName);<br>        out.println(<span class="hljs-string">&quot; &#123;&quot;</span>);<br>        out.println();<br><br>        out.print(<span class="hljs-string">&quot;    private &quot;</span>);<br>        out.print(simpleClassName);<br>        out.print(<span class="hljs-string">&quot; object = new &quot;</span>);<br>        out.print(simpleClassName);<br>        out.println(<span class="hljs-string">&quot;();&quot;</span>);<br>        out.println();<br><br>        out.print(<span class="hljs-string">&quot;    public &quot;</span>);<br>        out.print(simpleClassName);<br>        out.println(<span class="hljs-string">&quot; build() &#123;&quot;</span>);<br>        out.println(<span class="hljs-string">&quot;        return object;&quot;</span>);<br>        out.println(<span class="hljs-string">&quot;    &#125;&quot;</span>);<br>        out.println();<br><br>        setterMap.entrySet().forEach(setter -&gt; &#123;<br>            String methodName = setter.getKey();<br>            String argumentType = setter.getValue();<br><br>            out.print(<span class="hljs-string">&quot;    public &quot;</span>);<br>            out.print(builderSimpleClassName);<br>            out.print(<span class="hljs-string">&quot; &quot;</span>);<br>            out.print(methodName);<br><br>            out.print(<span class="hljs-string">&quot;(&quot;</span>);<br><br>            out.print(argumentType);<br>            out.println(<span class="hljs-string">&quot; value) &#123;&quot;</span>);<br>            out.print(<span class="hljs-string">&quot;        object.&quot;</span>);<br>            out.print(methodName);<br>            out.println(<span class="hljs-string">&quot;(value);&quot;</span>);<br>            out.println(<span class="hljs-string">&quot;        return this;&quot;</span>);<br>            out.println(<span class="hljs-string">&quot;    &#125;&quot;</span>);<br>            out.println();<br>        &#125;);<br><br>        out.println(<span class="hljs-string">&quot;&#125;&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="7-Running-the-Example"><a href="#7-Running-the-Example" class="headerlink" title="7. Running the Example"></a><strong>7. Running the Example</strong></h2><p>To see the code generation in action, you should either compile both modules from the common parent root or first compile the <em>annotation-processor</em> module and then the <em>annotation-user</em> module.</p>
<p>The generated <em>PersonBuilder</em> class can be found inside the <em>annotation-user/target/generated-sources/annotations/com/baeldung/annotation/PersonBuilder.java</em> file and should look like this:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.baeldung.annotation;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonBuilder</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Person object = <span class="hljs-keyword">new</span> Person();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Person <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> object;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PersonBuilder <span class="hljs-title">setName</span><span class="hljs-params">(java.lang.String value)</span> </span>&#123;<br>        object.setName(value);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PersonBuilder <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        object.setAge(value);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="8-Alternative-Ways-of-Registering-a-Processor"><a href="#8-Alternative-Ways-of-Registering-a-Processor" class="headerlink" title="8. Alternative Ways of Registering a Processor"></a><strong>8. Alternative Ways of Registering a Processor</strong></h2><p>To use your annotation processor during the compilation stage, you have several other options, depending on your use case and the tools you use.</p>
<h3 id="8-1-Using-the-Annotation-Processor-Tool"><a href="#8-1-Using-the-Annotation-Processor-Tool" class="headerlink" title="8.1. Using the Annotation Processor Tool"></a><strong>8.1. Using the Annotation Processor Tool</strong></h3><p>The <em>apt</em> tool was a special command line utility for processing source files. It was a part of Java 5, but since Java 7 it was deprecated in favour of other options and removed completely in Java 8. It will not be discussed in this article.</p>
<h3 id="8-2-Using-the-Compiler-Key"><a href="#8-2-Using-the-Compiler-Key" class="headerlink" title="8.2. Using the Compiler Key"></a><strong>8.2. Using the Compiler Key</strong></h3><p>The <em>-processor</em> compiler key is a standard JDK facility to augment the source processing stage of the compiler with your own annotation processor.</p>
<p>Note that the processor itself and the annotation have to be already compiled as classes in a separate compilation and present on the classpath, so the first thing you should do is:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">javac com/baeldung/annotation/processor/BuilderProcessor<br>javac com/baeldung/annotation/processor/BuilderProperty<br></code></pre></td></tr></table></figure>

<p>Then you do the actual compilation of your sources with the <em>-processor</em> key specifying the annotation processor class you’ve just compiled:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">javac -processor com.baeldung.annotation.processor.MyProcessor Person.java<br></code></pre></td></tr></table></figure>

<p>To specify several annotation processors in one go, you can separate their class names with commas, like this:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">javac -processor package1.Processor1,package2.Processor2 SourceFile.java<br></code></pre></td></tr></table></figure>

<h3 id="8-3-Using-Maven"><a href="#8-3-Using-Maven" class="headerlink" title="8.3. Using Maven"></a><strong>8.3. Using Maven</strong></h3><p>The <em>maven-compiler-plugin</em> allows specifying annotation processors as part of its configuration.</p>
<p>Here’s an example of adding annotation processor for the compiler plugin. You could also specify the directory to put generated sources into, using the <em>generatedSourcesDirectory</em> configuration parameter.</p>
<p>Note that the <em>BuilderProcessor</em> class should already be compiled, for instance, imported from another jar in the build dependencies:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">encoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">encoding</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">generatedSourcesDirectory</span>&gt;</span>$&#123;project.build.directory&#125;<br>                  /generated-sources/<span class="hljs-tag">&lt;/<span class="hljs-name">generatedSourcesDirectory</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">annotationProcessors</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">annotationProcessor</span>&gt;</span><br>                        com.baeldung.annotation.processor.BuilderProcessor<br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">annotationProcessor</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">annotationProcessors</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="8-4-Adding-a-Processor-Jar-to-the-Classpath"><a href="#8-4-Adding-a-Processor-Jar-to-the-Classpath" class="headerlink" title="8.4. Adding a Processor Jar to the Classpath"></a><strong>8.4. Adding a Processor Jar to the Classpath</strong></h3><p>Instead of specifying the annotation processor in the compiler options, you may simply add a specially structured jar with the processor class to the classpath of the compiler.</p>
<p>To pick it up automatically, the compiler has to know the name of the processor class. So you have to specify it in the <em>META-INF/services/javax.annotation.processing.Processor</em> file as a fully qualified class name of the processor:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">com.baeldung.annotation.processor.BuilderProcessor<br></code></pre></td></tr></table></figure>

<p>You can also specify several processors from this jar to pick up automatically by separating them with a new line:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">package1.Processor1<br>package2.Processor2<br>package3.Processor3<br></code></pre></td></tr></table></figure>

<p>If you use Maven to build this jar and try to put this file directly into the <em>src/main/resources/META-INF/services</em> directory, you’ll encounter the following error:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">[ERROR] Bad service configuration file, or exception thrown <span class="hljs-keyword">while</span> <br>constructing Processor object: javax.annotation.processing.Processor: <br>Provider com.baeldung.annotation.processor.BuilderProcessor not found<br></code></pre></td></tr></table></figure>

<p>This is because the compiler tries to use this file during the <em>source-processing</em> stage of the module itself when the <em>BuilderProcessor</em> file is not yet compiled. The file has to be either put inside another resource directory and copied to the <em>META-INF/services</em> directory during the resource copying stage of the Maven build, or (even better) generated during the build.</p>
<p>The Google <em>auto-service</em> library, discussed in the following section, allows generating this file using a simple annotation.</p>
<h3 id="8-5-Using-the-Google-auto-service-Library"><a href="#8-5-Using-the-Google-auto-service-Library" class="headerlink" title="8.5. Using the Google *auto-service* Library"></a><strong>8.5. Using the Google *auto-service* Library</strong></h3><p>To generate the registration file automatically, you can use the <em>@AutoService</em> annotation from the Google’s <em>auto-service</em> library, like this:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AutoService(Processor.class)</span><br><span class="hljs-keyword">public</span> BuilderProcessor extends AbstractProcessor &#123;<br>    <span class="hljs-comment">// …</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>This annotation is itself processed by the annotation processor from the auto-service library. This processor generates the <em>META-INF/services/javax.annotation.processing.Processor</em> file containing the <em>BuilderProcessor</em> class name.</p>
<h2 id="9-Conclusion"><a href="#9-Conclusion" class="headerlink" title="9. Conclusion"></a><strong>9. Conclusion</strong></h2><p>In this article, we’ve demonstrated source-level annotation processing using an example of generating a Builder class for a POJO. We have also provided several alternative ways of registering annotation processors in your project.</p>
<p>The source code for the article is available <a target="_blank" rel="noopener" href="https://github.com/eugenp/tutorials/tree/master/annotations">on GitHub</a>.</p>
<hr>
<h1 id="官方qpi文档"><a href="#官方qpi文档" class="headerlink" title="官方qpi文档"></a>官方qpi文档</h1><p>可以看到,AbstractProcessor实现了接口Processor,那么,我们在来看下Processor的api文档:</p>
<blockquote>
<p>javax.annotation.processing<br> Interface Processor</p>
<p>All Known Implementing Classes:<br> <a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/AbstractProcessor.html">AbstractProcessor</a></p>
<hr>
<p>public interface Processor</p>
</blockquote>
<blockquote>
<p>The interface for an annotation processor.</p>
</blockquote>
<blockquote>
<p>Annotation processing happens in a sequence of <a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/RoundEnvironment.html">rounds</a>. On each round, a processor may be asked to [process](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/Processor.html#process">https://link.jianshu.com?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/Processor.html#process</a>(java.util.Set, javax.annotation.processing.RoundEnvironment)) a subset of the annotations found on the source and class files produced by a prior round. The inputs to the first round of processing are the initial inputs to a run of the tool; these initial inputs can be regarded as the output of a virtual zeroth round of processing. If a processor was asked to process on a given round, it will be asked to process on subsequent rounds, including the last round, even if there are no annotations for it to process. The tool infrastructure may also ask a processor to process files generated implicitly by the tool’s operation.<br> Each implementation of a Processor  must provide a public no-argument constructor to be used by tools to instantiate the processor. The tool infrastructure will interact with classes implementing this interface as follows:</p>
<ol>
<li>If an existing Processor object is not being used, to create an instance of a processor the tool calls the no-arg constructor of the processor class.</li>
<li>Next, the tool calls the <a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/Processor.html#init(javax.annotation.processing.ProcessingEnvironment)">init
 </a> method with an appropriate ProcessingEnvironment .</li>
<li>Afterwards, the tool calls <a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/Processor.html#getSupportedAnnotationTypes()">getSupportedAnnotationTypes
 </a>, <a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/Processor.html#getSupportedOptions()">getSupportedOptions
 </a>, and <a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/Processor.html#getSupportedSourceVersion()">getSupportedSourceVersion
 </a>. These methods are only called once per run, not on each round.</li>
<li>As appropriate, the tool calls the [process<br> ](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/Processor.html#process">https://link.jianshu.com?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/Processor.html#process</a>(java.util.Set, javax.annotation.processing.RoundEnvironment)) method on the Processor object; a new Processor object is <em>not</em> created for each round.</li>
</ol>
<p>If a processor object is created and used without the above protocol being followed, then the processor’s behavior is not defined by this interface specification.The tool uses a <em>discovery process</em> to find annotation processors and decide whether or not they should be run. By configuring the tool, the set of potential processors can be controlled. For example, for a <a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/tools/JavaCompiler.html">JavaCompiler
 </a> the list of candidate processors to run can be <a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/tools/JavaCompiler.CompilationTask.html#setProcessors(java.lang.Iterable)">set directly</a> or controlled by a <a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/tools/StandardLocation.html#ANNOTATION_PROCESSOR_PATH">search path</a> used for a <a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/java/util/ServiceLoader.html">service-style</a> lookup. Other tool implementations may have different configuration mechanisms, such as command line options; for details, refer to the particular tool’s documentation. Which processors the tool asks to [run](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/Processor.html#process">https://link.jianshu.com?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/Processor.html#process</a>(java.util.Set, javax.annotation.processing.RoundEnvironment)) is a function of what annotations are present on the <a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/RoundEnvironment.html#getRootElements()">root elements</a>, what <a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/Processor.html#getSupportedAnnotationTypes()">annotation types a processor processes</a>, and whether or not a processor [claims the annotations it processes](<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/Processor.html#process">https://link.jianshu.com?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/Processor.html#process</a>(java.util.Set, javax.annotation.processing.RoundEnvironment)). A processor will be asked to process a subset of the annotation types it supports, possibly an empty set. For a given round, the tool computes the set of annotation types on the root elements. If there is at least one annotation type present, as processors claim annotation types, they are removed from the set of unmatched annotations. When the set is empty or no more processors are available, the round has run to completion. If there are no annotation types present, annotation processing still occurs but only <em>universal processors</em> which support processing “<em>“<br> can claim the (empty) set of annotation types.<br> Note that if a processor supports “</em>“<br> and returns true<br> , all annotations are claimed. Therefore, a universal processor being used to, for example, implement additional validity checks should return false<br> so as to not prevent other such checkers from being able to run.<br> If a processor throws an uncaught exception, the tool may cease other active annotation processors. If a processor raises an error, the current round will run to completion and the subsequent round will indicate an <a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/RoundEnvironment.html#errorRaised()">error was raised</a>. Since annotation processors are run in a cooperative environment, a processor should throw an uncaught exception only in situations where no error recovery or reporting is feasible.<br> The tool environment is not required to support annotation processors that access environmental resources, either <a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/RoundEnvironment.html">per round</a> or <a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/ProcessingEnvironment.html">cross-round</a>, in a multi-threaded fashion.<br> If the methods that return configuration information about the annotation processor return null<br> , return other invalid input, or throw an exception, the tool infrastructure must treat this as an error condition.<br> To be robust when running in different tool implementations, an annotation processor should have the following properties:</p>
<ol>
<li>The result of processing a given input is not a function of the presence or absence of other inputs (orthogonality).</li>
<li>Processing the same input produces the same output (consistency).</li>
<li>Processing input <em>A</em> followed by processing input <em>B</em> is equivalent to processing <em>B</em> then <em>A</em>(commutativity)</li>
<li>Processing an input does not rely on the presence of the output of other annotation processors (independence)</li>
</ol>
<p>The <a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/Filer.html">Filer
 </a> interface discusses restrictions on how processors can operate on files.<br> Note that implementors of this interface may find it convenient to extend <a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/AbstractProcessor.html">AbstractProcessor
 </a> rather than implementing this interface directly.</p>
<p>Since:<br> 1.6</p>
</blockquote>
<p>注解处理发生在一系列回合中.每个回合中,注解处理器都有可能被叫去处理由上一次注解产生的源码和类文件中的找到的注解子集.第一次注解处理回合的输入就是工具第一次运行的输入;这些初始输入可以认为是一个虚拟的第零次注解处理回合的输出.如果注解处理器被叫去处理一个特定的回合,那么接下来的回合它都会继续处理,即使后续回合没有它需要处理的注解.注解处理器有可能会被叫去处理由(编译)工具隐式生成的文件.每个注解处理器的实现都必须提供一个公有的无参构造函数,由工具进行实例化.工具会与实现该接口(Processor)的类进行如下交互:</p>
<ol>
<li>如果一个已存在的Processor实例未被使用,(编译)工具会调用注解处理器的无参构造函数实例化出一个Processor对象.</li>
<li>接下来,(编译)工具会调用init函数,并传入一个合适的ProcessingEnvironment.</li>
<li>之后,(编译)工具会调用getSupportedAnnotationTypes,getSupportedOptions和getSupportedSourceVersion.这些方法只会在每一次运行时被调用一次,而不会在每个注解回合都被调用.</li>
<li>正常情况下,(编译)工具会调用注解处理器实例的process函数;每个注解回合并不会产生新的注解实例.</li>
</ol>
<p>如果一个注解处理器实例被创建,但是使用却没有遵循上述协议,那么这个注解处理器的行为并未被该接口规范定义.(编译)工具使用搜索程序去找到注解处理器并决定它们是否得以运行.通过配置(编译)工具,潜在的注解处理器可以被控制.比如,对于javaCompiler,候选处理器可以直接被指定或者通过使用service-style查找指定搜索路径进行控制.其他(编译)工具可以具有不同的配置机制,比如控制行选项;具体点讲,参考特定工具文档.(编译)工具会调用运行的注解处理器是由root elements指示的注解,是注解处理器处理的注解类型和注解处理器声明它要处理的注解的方法.注解处理器会被叫去处理它支持的注解类型子集,有可能是一个空的集合.在给定回合,(编译)工具会计算root elements的注解类型集合.如果有最少一个注解类型存在,就是注解处理器声明的注解类型之一,它们就会被从未匹配的注解类型集合中移除.当(未匹配)注解集合为空或者没有其它的注解处理器,那么该注解处理回合就结束了.如果没有声明注解类型,只有通用处理器(支持处理”<em>“声明(空)所有注解类型集合)仍然会进行注解处理.注意如果一个注解处理器支持”</em>“并且返回true,则所有的注解类型都被声明.因此,一个通用注解处理器如果被用于实现附加有效检验,那么应该返回false,为了不防止这类检验器得以运行.如果一个注解处理器抛出了一个未捕获异常,(编译)工具可能会停止其他活动的注解处理器.如果一个注解处理器引起了一个错误,当前注解回合会结束,并且后续回合会指明一个错误产生了.因为注解处理器都是运行在共同协作的环境中,只有当错误恢复或报告提交是无法执行的情况下,注解处理器才允许抛出一个未捕获异常.<br> (编译)工具环境不要求要支持注解处理器能以多线程方式在每一回合或交叉回合能访问环境资源.<br> 如果返回注解处理器的配置信息的方法返回null,返回其他无效输入,或者抛出一个异常,(编译)工具必须将这些当做是一个错误条件.<br> 为了在不同的工具实现能够健壮运行,注解处理器必须有以下性能:</p>
<ol>
<li>对于一个给定的输入的处理结果,不影响其他输入的存在或缺失(正交性)</li>
<li>处于相同的输入会产生相同的输出(一致性)</li>
<li>先处理输入A,然后处于输入B等同于先处理B在处理A(可交换性)</li>
<li>处理输入会依赖于其他注解处理器的输出(独立性)</li>
</ol>
<p>Filer接口讨论了注解处理器操作文件的限定.<br> 请知悉Processor的实现通过继承AbstractProcessor会比直接实现该接口更加方便.</p>
<p>简单总结如下:</p>
<ul>
<li>Annotation Processor可能会被多次调用.</li>
<li>Annotation Processor被调用一次后,后续若还有注解处理,该Annotation Processor仍然会继续被调用.</li>
<li>自定义Annotation Processor必须带有一个无参构造函数,让javac进行实例化.</li>
<li>如果Annotation Processor抛出一个未捕获异常,javac可能会停止其他的Annotation Processor.只有在无法抛出错误或报告的情况下,才允许抛出异常.</li>
<li>Annotation Processor运行在一个独立的jvm中,所以可以将它看成是一个java应用程序.</li>
</ul>
<p>作者：Whyn<br>链接：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/b6b3283968e0">https://www.jianshu.com/p/b6b3283968e0</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<hr>
<h1 id="插件化注解处理API-Pluggable-Annotation-Processing-API"><a href="#插件化注解处理API-Pluggable-Annotation-Processing-API" class="headerlink" title="插件化注解处理API(Pluggable Annotation Processing API)"></a><a target="_blank" rel="noopener" href="https://www.cnblogs.com/throwable/p/9139908.html">插件化注解处理API(Pluggable Annotation Processing API)</a></h1><h1 id="Java奇技淫巧-插件化注解处理API-Pluggable-Annotation-Processing-API"><a href="#Java奇技淫巧-插件化注解处理API-Pluggable-Annotation-Processing-API" class="headerlink" title="Java奇技淫巧-插件化注解处理API(Pluggable Annotation Processing API)"></a>Java奇技淫巧-插件化注解处理API(Pluggable Annotation Processing API)</h1><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/Chinajash/article/details/1471081">JDK6的新特性之六:插入式注解处理API(Pluggable Annotation Processing API)</a></li>
<li><a target="_blank" rel="noopener" href="http://www.baeldung.com/java-annotation-processing-builder">Java Annotation Processing and Creating a Builder</a></li>
</ul>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>插件化注解处理(Pluggable Annotation Processing)API<a target="_blank" rel="noopener" href="http://jcp.org/en/jsr/detail?id=269">JSR 269</a>提供一套标准API来处理Annotations<a target="_blank" rel="noopener" href="http://jcp.org/en/jsr/detail?id=175">JSR 175</a>,实际上JSR 269不仅仅用来处理Annotation，我觉得更强大的功能是它建立了Java 语言本身的一个模型,它把method、package、constructor、type、variable、enum、annotation等Java语言元素映射为Types和Elements，从而将Java语言的语义映射成为对象，我们可以在javax.lang.model包下面可以看到这些类。所以我们可以利用JSR 269提供的API来构建一个功能丰富的元编程(metaprogramming)环境。JSR 269用Annotation Processor在编译期间而不是运行期间处理Annotation, Annotation Processor相当于编译器的一个插件,所以称为插入式注解处理.如果Annotation Processor处理Annotation时(执行process方法)产生了新的Java代码，编译器会再调用一次Annotation Processor，如果第二次处理还有新代码产生，就会接着调用Annotation Processor，直到没有新代码产生为止。每执行一次process()方法被称为一个”round”，这样整个Annotation processing过程可以看作是一个round的序列。JSR 269主要被设计成为针对Tools或者容器的API。这个特性虽然在JavaSE 6已经存在，但是很少人知道它的存在。下一篇介绍的<strong>Java奇技淫巧-lombok</strong>就是使用这个特性实现编译期的代码插入的。另外，如果没有猜错，像IDEA在编写代码时候的标记语法错误的红色下划线也是通过这个特性实现的。KAPT(Annotation Processing for Kotlin)，也就是Kotlin的编译也是通过此特性的。</p>
<p>Pluggable Annotation Processing API的核心是Annotation Processor即注解处理器，一般需要继承抽象类<code>javax.annotation.processing.AbstractProcessor</code>。注意，与运行时注解<code>RetentionPolicy.RUNTIME</code>不同，注解处理器只会处理编译期注解，也就是<code>RetentionPolicy.SOURCE</code>的注解类型，处理的阶段位于Java代码编译期间。</p>
<h1 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h1><p>插件化注解处理API的使用步骤大概如下：</p>
<ul>
<li>1、自定义一个Annotation Processor，需要继承<code>javax.annotation.processing.AbstractProcessor</code>，并覆写process方法。</li>
<li>2、自定义一个注解，注解的元注解需要指定<code>@Retention(RetentionPolicy.SOURCE)</code>。</li>
<li>3、需要在声明的自定义Annotation Processor中使用<code>javax.annotation.processing.SupportedAnnotationTypes</code>指定在第2步创建的注解类型的名称(注意需要全类名，”包名.注解类型名称”，否则会不生效)。</li>
<li>4、需要在声明的自定义Annotation Processor中使用<code>javax.annotation.processing.SupportedSourceVersion</code>指定编译版本。</li>
<li>5、可选操作，可以通在声明的自定义Annotation Processor中使用<code>javax.annotation.processing.SupportedOptions</code>指定编译参数。</li>
</ul>
<h1 id="实战例子"><a href="#实战例子" class="headerlink" title="实战例子"></a>实战例子</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础#"></a>基础<a target="_blank" rel="noopener" href="https://www.cnblogs.com/throwable/p/9139908.html#%E5%9F%BA%E7%A1%80">#</a></h2><p>下面我们模仿一下测试框架Junit里面的@Test注解，在运行时通过Annotation Processor获取到使用了自定义的@Test注解对应的方法的信息。因为如果想要动态修改一个类或者方法的代码内容，需要使用到字节码修改工具例如ASM等，这些操作过于深入，日后再谈。先定义一个注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> club.throwable.processor;<br><br><span class="hljs-keyword">import</span> java.lang.annotation.ElementType;<br><span class="hljs-keyword">import</span> java.lang.annotation.Retention;<br><span class="hljs-keyword">import</span> java.lang.annotation.RetentionPolicy;<br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> throwable</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> v1.0</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 2018/5/27 11:18</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Target(&#123;ElementType.METHOD&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Test &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<p>定义一个注解处理器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SupportedAnnotationTypes(value = &#123;&quot;club.throwable.processor.Test&quot;&#125;)</span><br><span class="hljs-meta">@SupportedSourceVersion(value = SourceVersion.RELEASE_8)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnnotationProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractProcessor</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">process</span><span class="hljs-params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Log in AnnotationProcessor.process&quot;</span>);<br>        <span class="hljs-keyword">for</span> (TypeElement typeElement : annotations) &#123;<br>            System.out.println(typeElement);<br>        &#125;<br>        System.out.println(roundEnv);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>编写一个主类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;success&quot;</span>);<br>        test();<br>    &#125;<br><br>    <span class="hljs-meta">@Test(value = &quot;method is test&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span><span class="hljs-keyword">throws</span> Exception</span>&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>接着需要指定Processor，如果使用IDEA的话，Compiler-&gt;Annotation Processors中的Enable annotation processing必须勾选。然后可以通过下面几种方式指定指定Processor。</p>
<ul>
<li>1、直接使用编译参数指定，例如：javac -processor club.throwable.processor.AnnotationProcessor Main.java。</li>
<li>2、通过服务注册指定，就是META-INF/services/javax.annotation.processing.Processor文件中添加club.throwable.processor.AnnotationProcessor。</li>
<li>3、通过Maven的编译插件的配置指定如下：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">encoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">encoding</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">annotationProcessors</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">annotationProcessor</span>&gt;</span><br>                club.throwable.processor.AnnotationProcessor<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">annotationProcessor</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">annotationProcessors</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>值得注意的是，以上三点生效的前提是club.throwable.processor.AnnotationProcessor已经被编译过，否则编译的时候就会报错：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-attr">[ERROR]</span> Bad service configuration file, or exception thrown while<br>constructing Processor <span class="hljs-selector-tag">object</span>: javax<span class="hljs-selector-class">.annotation</span><span class="hljs-selector-class">.processing</span><span class="hljs-selector-class">.Processor</span>: <br>Provider club<span class="hljs-selector-class">.throwable</span><span class="hljs-selector-class">.processor</span><span class="hljs-selector-class">.AnnotationProcessor</span> not found<br></code></pre></td></tr></table></figure>

<p>解决方法有两种，第一种是提前使用命令或者IDEA右键club.throwable.processor.AnnotationProcessor对它进行编译；第二种是把club.throwable.processor.AnnotationProcessor放到一个独立的Jar包引入。我在这里使用第一种方式解决。</p>
<p>最后，使用Maven命令mvn compile进行编译。输出如下：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Log <span class="hljs-keyword">in</span> AnnotationProcessor.process<br>[<span class="hljs-attribute">errorRaised</span>=<span class="hljs-literal">false</span>, rootElements=[club.throwable.processor.Test,club.throwable.processor.Main, club.throwable.processor.AnnotationProcessor, <span class="hljs-attribute">processingOver</span>=<span class="hljs-literal">false</span>]<br>Log <span class="hljs-keyword">in</span> AnnotationProcessor.process<br>[<span class="hljs-attribute">errorRaised</span>=<span class="hljs-literal">false</span>, rootElements=[], <span class="hljs-attribute">processingOver</span>=<span class="hljs-literal">false</span>]<br>Log <span class="hljs-keyword">in</span> AnnotationProcessor.process<br>[<span class="hljs-attribute">errorRaised</span>=<span class="hljs-literal">false</span>, rootElements=[], <span class="hljs-attribute">processingOver</span>=<span class="hljs-literal">true</span>]<br></code></pre></td></tr></table></figure>

<p>可见编译期间AnnotationProcessor生效了。</p>
<h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶#"></a>进阶<a target="_blank" rel="noopener" href="https://www.cnblogs.com/throwable/p/9139908.html#%E8%BF%9B%E9%98%B6">#</a></h2><p>下面是一个例子直接修改类的代码，为实体类的Setter方法对应的属性生成一个Builder类，也就是原来的类如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-meta">@Builder</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(Integer age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-meta">@Builder</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>生成的Builder类如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonBuilder</span> </span>&#123;<br> <br>    <span class="hljs-keyword">private</span> Person object = <span class="hljs-keyword">new</span> Person();<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Person <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> object;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PersonBuilder <span class="hljs-title">setName</span><span class="hljs-params">(java.lang.String value)</span> </span>&#123;<br>        object.setName(value);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PersonBuilder <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        object.setAge(value);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>自定义的注解如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.METHOD&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Builder &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>自定义的注解处理器如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> javax.annotation.processing.AbstractProcessor;<br><span class="hljs-keyword">import</span> javax.annotation.processing.RoundEnvironment;<br><span class="hljs-keyword">import</span> javax.annotation.processing.SupportedAnnotationTypes;<br><span class="hljs-keyword">import</span> javax.annotation.processing.SupportedSourceVersion;<br><span class="hljs-keyword">import</span> javax.lang.model.SourceVersion;<br><span class="hljs-keyword">import</span> javax.lang.model.element.Element;<br><span class="hljs-keyword">import</span> javax.lang.model.element.TypeElement;<br><span class="hljs-keyword">import</span> javax.lang.model.type.ExecutableType;<br><span class="hljs-keyword">import</span> javax.tools.Diagnostic;<br><span class="hljs-keyword">import</span> javax.tools.JavaFileObject;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.PrintWriter;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.util.Set;<br><span class="hljs-keyword">import</span> java.util.stream.Collectors;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> throwable</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> v1.0</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 2018/5/27 11:21</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@SupportedAnnotationTypes(value = &#123;&quot;club.throwable.processor.builder.Builder&quot;&#125;)</span><br><span class="hljs-meta">@SupportedSourceVersion(value = SourceVersion.RELEASE_8)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BuilderProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractProcessor</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">process</span><span class="hljs-params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (TypeElement typeElement : annotations) &#123;<br>            Set&lt;? extends Element&gt; annotatedElements = roundEnv.getElementsAnnotatedWith(typeElement);<br>            Map&lt;Boolean, List&lt;Element&gt;&gt; annotatedMethods<br>                    = annotatedElements.stream().collect(Collectors.partitioningBy(<br>                    element -&gt; ((ExecutableType) element.asType()).getParameterTypes().size() == <span class="hljs-number">1</span><br>                            &amp;&amp; element.getSimpleName().toString().startsWith(<span class="hljs-string">&quot;set&quot;</span>)));<br>            List&lt;Element&gt; setters = annotatedMethods.get(<span class="hljs-keyword">true</span>);<br>            List&lt;Element&gt; otherMethods = annotatedMethods.get(<span class="hljs-keyword">false</span>);<br>            otherMethods.forEach(element -&gt;<br>                    processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,<br>                            <span class="hljs-string">&quot;@Builder must be applied to a setXxx method &quot;</span><br>                                    + <span class="hljs-string">&quot;with a single argument&quot;</span>, element));<br>            Map&lt;String, String&gt; setterMap = setters.stream().collect(Collectors.toMap(<br>                    setter -&gt; setter.getSimpleName().toString(),<br>                    setter -&gt; ((ExecutableType) setter.asType())<br>                            .getParameterTypes().get(<span class="hljs-number">0</span>).toString()<br>            ));<br>            String className = ((TypeElement) setters.get(<span class="hljs-number">0</span>)<br>                    .getEnclosingElement()).getQualifiedName().toString();<br>            <span class="hljs-keyword">try</span> &#123;<br>                writeBuilderFile(className, setterMap);<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeBuilderFile</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">            String className, Map&lt;String, String&gt; setterMap)</span></span><br><span class="hljs-function">            <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        String packageName = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">int</span> lastDot = className.lastIndexOf(<span class="hljs-string">&#x27;.&#x27;</span>);<br>        <span class="hljs-keyword">if</span> (lastDot &gt; <span class="hljs-number">0</span>) &#123;<br>            packageName = className.substring(<span class="hljs-number">0</span>, lastDot);<br>        &#125;<br>        String simpleClassName = className.substring(lastDot + <span class="hljs-number">1</span>);<br>        String builderClassName = className + <span class="hljs-string">&quot;Builder&quot;</span>;<br>        String builderSimpleClassName = builderClassName<br>                .substring(lastDot + <span class="hljs-number">1</span>);<br><br>        JavaFileObject builderFile = processingEnv.getFiler().createSourceFile(builderClassName);<br><br>        <span class="hljs-keyword">try</span> (PrintWriter out = <span class="hljs-keyword">new</span> PrintWriter(builderFile.openWriter())) &#123;<br><br>            <span class="hljs-keyword">if</span> (packageName != <span class="hljs-keyword">null</span>) &#123;<br>                out.print(<span class="hljs-string">&quot;package &quot;</span>);<br>                out.print(packageName);<br>                out.println(<span class="hljs-string">&quot;;&quot;</span>);<br>                out.println();<br>            &#125;<br>            out.print(<span class="hljs-string">&quot;public class &quot;</span>);<br>            out.print(builderSimpleClassName);<br>            out.println(<span class="hljs-string">&quot; &#123;&quot;</span>);<br>            out.println();<br>            out.print(<span class="hljs-string">&quot;    private &quot;</span>);<br>            out.print(simpleClassName);<br>            out.print(<span class="hljs-string">&quot; object = new &quot;</span>);<br>            out.print(simpleClassName);<br>            out.println(<span class="hljs-string">&quot;();&quot;</span>);<br>            out.println();<br>            out.print(<span class="hljs-string">&quot;    public &quot;</span>);<br>            out.print(simpleClassName);<br>            out.println(<span class="hljs-string">&quot; build() &#123;&quot;</span>);<br>            out.println(<span class="hljs-string">&quot;        return object;&quot;</span>);<br>            out.println(<span class="hljs-string">&quot;    &#125;&quot;</span>);<br>            out.println();<br>            setterMap.forEach((methodName, argumentType) -&gt; &#123;<br>                out.print(<span class="hljs-string">&quot;    public &quot;</span>);<br>                out.print(builderSimpleClassName);<br>                out.print(<span class="hljs-string">&quot; &quot;</span>);<br>                out.print(methodName);<br><br>                out.print(<span class="hljs-string">&quot;(&quot;</span>);<br><br>                out.print(argumentType);<br>                out.println(<span class="hljs-string">&quot; value) &#123;&quot;</span>);<br>                out.print(<span class="hljs-string">&quot;        object.&quot;</span>);<br>                out.print(methodName);<br>                out.println(<span class="hljs-string">&quot;(value);&quot;</span>);<br>                out.println(<span class="hljs-string">&quot;        return this;&quot;</span>);<br>                out.println(<span class="hljs-string">&quot;    &#125;&quot;</span>);<br>                out.println();<br>            &#125;);<br>            out.println(<span class="hljs-string">&quot;&#125;&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>主类如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>      <span class="hljs-comment">//PersonBuilder在编译之后才会生成，这里需要编译后才能这样写</span><br>      Person person  = <span class="hljs-keyword">new</span> PersonBuilder().setAge(<span class="hljs-number">25</span>).setName(<span class="hljs-string">&quot;doge&quot;</span>).build();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>先手动编译BuilderProcessor，然后在META-INF/services/javax.annotation.processing.Processor文件中添加<code>club.throwable.processor.builder.BuilderProcessor</code>，最后执行Maven命令mvn compile进行编译。</p>
<p>编译后控制台输出:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[errorRaised=<span class="hljs-literal">false</span>, rootElements=[club.throwable.processor.builder.PersonBuilder], processingOver=<span class="hljs-literal">false</span>]<br></code></pre></td></tr></table></figure>

<p>编译成功之后，target/classes包下面的club.throwable.processor.builder子包路径中会新增了一个类<code>PersonBuilder</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> club.throwable.processor.builder;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonBuilder</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Person object = <span class="hljs-keyword">new</span> Person();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PersonBuilder</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Person <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.object;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PersonBuilder <span class="hljs-title">setName</span><span class="hljs-params">(String value)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.object.setName(value);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PersonBuilder <span class="hljs-title">setAge</span><span class="hljs-params">(Integer value)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.object.setAge(value);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个类就是编译期新增的。在这个例子中，编译期新增的类貌似没有什么作用。但是，如果像lombok那样对原来的实体类添加新的方法，那样的话就比较有用了。因为些类或者方法是编译期添加的，因此在代码中直接使用会标红。因此，lombok提供了IDEA或者eclipse的插件，插件的功能的实现估计也是用了插件式注解处理API。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/12/23/java%E6%B3%A8%E8%A7%A3/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">java注解</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/12/22/hello-world/">
                        <span class="hidden-mobile">Hello World</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
