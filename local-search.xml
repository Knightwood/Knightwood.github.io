<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>idea配置java注解处理器</title>
    <link href="/2021/12/25/idea%20%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8/"/>
    <url>/2021/12/25/idea%20%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="IntelliJ-IDEA-和-Gradle：为什么每个子模块有-3-个模块？"><a href="#IntelliJ-IDEA-和-Gradle：为什么每个子模块有-3-个模块？" class="headerlink" title="IntelliJ IDEA 和 Gradle：为什么每个子模块有 3 个模块？"></a><a href="https://stackoverflow.com/questions/36372571/intellij-idea-and-gradle-why-there-are-3-modules-per-sub-module">IntelliJ IDEA 和 Gradle：为什么每个子模块有 3 个模块？</a></h1><p>如果您只想为之前导入的项目禁用此选项，您可以通过编辑位于**.idea/gradle.xml 中的** idea gradle 配置文件来实现 。</p><p>添加将<strong>resolveModulePerSourceSet</strong>设置为<strong>false 的</strong>这一行：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;4&quot;</span>&gt;</span><br>  ...<br>  <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;GradleSettings&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;linkedExternalProjectsSettings&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">GradleProjectSettings</span>&gt;</span><br>        ...<br>        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;resolveModulePerSourceSet&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span> /&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">GradleProjectSettings</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后刷新gradle项目。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>在idea+gradle的环境中使用annotation processor生成代码，但是代码生成在了build文件夹下的classes里，且程序无法引用生成的类，若强行使用则报错找不到类。</p><h2 id="第一步-配置idea"><a href="#第一步-配置idea" class="headerlink" title="第一步 配置idea"></a>第一步 配置idea</h2><p>file -&gt; settting -&gt; Build,Execution,Deployment -&gt; compiler -&gt; annotation processor 进入此界面，然后：</p><ol><li>勾上<code>启用注解处理器</code></li><li>选中<code>从项目类路径获取处理器</code></li><li>选中<code>模块项目根</code></li><li><code>生产源目录</code>输入<code>../main/src/generated/java</code></li></ol><h2 id="第二步-配置gradle"><a href="#第二步-配置gradle" class="headerlink" title="第二步 配置gradle"></a>第二步 配置gradle</h2><p>这个项目有三个module：</p><p>一个是main 测试ProcessorLib库</p><p>一个是ProcessorLib 处理注解</p><p>一个是AnnotationsLib 定义注解</p><ul><li>ProcessorLib 的gradle</li></ul><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">//使编译时将文件生成到指定目录</span><br>compileJava &#123;<br><span class="hljs-comment">//配置编译时生成代码的目录</span><br>        <span class="hljs-keyword">options</span>.compilerArgs &lt;&lt; <span class="hljs-string">&quot;-s&quot;</span><br>        <span class="hljs-keyword">options</span>.compilerArgs &lt;&lt; <span class="hljs-string">&quot;$projectDir/src/main/generated/java&quot;</span><br><span class="hljs-comment">//确保文件夹存在</span><br>        <span class="hljs-keyword">doFirst</span> &#123;<br>            <span class="hljs-keyword">file</span>(<span class="hljs-keyword">new</span> <span class="hljs-keyword">File</span>(projectDir, <span class="hljs-string">&quot;/src/main/generated/java&quot;</span>)).mkdirs()<br>        &#125;<br>    &#125;<br><span class="hljs-comment">//在clean时删除编译生成的代码</span><br>    clean.<span class="hljs-keyword">doLast</span> &#123;<br>        <span class="hljs-comment">// clean-up directory when necessary</span><br>        <span class="hljs-keyword">file</span>(<span class="hljs-keyword">new</span> <span class="hljs-keyword">File</span>(projectDir, <span class="hljs-string">&quot;/src/main/generated&quot;</span>)).deleteDir()<br>    &#125;<br><span class="hljs-comment">//依赖  </span><br><span class="hljs-keyword">dependencies</span> &#123;<br>    implementation <span class="hljs-keyword">project</span>(path: <span class="hljs-string">&#x27;:AnnotationsLib&#x27;</span>)<span class="hljs-comment">//自己的注解定义module</span><br>    implementation <span class="hljs-string">&#x27;com.google.auto.service:auto-service-annotations:1.0.1&#x27;</span><span class="hljs-comment">//autoservice</span><br>    annotationProcessor <span class="hljs-string">&#x27;com.google.auto.service:auto-service:1.0.1&#x27;</span><span class="hljs-comment">//autoservice</span><br>    implementation <span class="hljs-string">&#x27;com.squareup:javapoet:1.13.0&#x27;</span><br>    testImplementation <span class="hljs-string">&#x27;org.junit.jupiter:junit-jupiter-api:5.7.2&#x27;</span><br>    testRuntimeOnly <span class="hljs-string">&#x27;org.junit.jupiter:junit-jupiter-engine:5.7.2&#x27;</span><br>&#125;<br><br><span class="hljs-comment">//详细日志打印，没有调用处理器，可能是跳过了，直接进行编译了</span><br><span class="hljs-comment">// 参数可选，重点是 -verbose -XprintRounds -XprintProcessorInfo</span><br><span class="hljs-keyword">allprojects</span> &#123;<br>    gradle.projectsEvaluated &#123;<br>        tasks.withType(JavaCompile) &#123;<br>            <span class="hljs-keyword">options</span>.compilerArgs &lt;&lt; <span class="hljs-string">&quot;-Xlint&quot;</span> &lt;&lt; <span class="hljs-string">&quot;-verbose&quot;</span> &lt;&lt; <span class="hljs-string">&quot;-XprintRounds&quot;</span> &lt;&lt; <span class="hljs-string">&quot;-XprintProcessorInfo&quot;</span> &lt;&lt; <span class="hljs-string">&quot;-Xmaxerrs&quot;</span> &lt;&lt; <span class="hljs-string">&quot;100000&quot;</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在main module的gradle中</li></ul><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs puppet"><span class="hljs-keyword">dependencies</span> &#123;<br>    implementation <span class="hljs-literal">project</span>(<span class="hljs-built_in">path</span>: <span class="hljs-string">&#x27;:ProcessorLib&#x27;</span>)<br>    annotationProcessor <span class="hljs-literal">project</span>(<span class="hljs-built_in">path</span>: <span class="hljs-string">&#x27;:ProcessorLib&#x27;</span>)<br>    implementation <span class="hljs-literal">project</span>(<span class="hljs-built_in">path</span>: <span class="hljs-string">&#x27;:AnnotationsLib&#x27;</span>)<br>    testImplementation <span class="hljs-string">&#x27;org.junit.jupiter:junit-jupiter-api:5.7.2&#x27;</span><br>    testRuntimeOnly <span class="hljs-string">&#x27;org.junit.jupiter:junit-jupiter-engine:5.7.2&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第三步-配置文件夹类型"><a href="#第三步-配置文件夹类型" class="headerlink" title="第三步 配置文件夹类型"></a>第三步 配置文件夹类型</h2><p>在执行gradle的build任务后，会在src/main下生成指定目录以及代码，但是在我们的源文件中依然没有提示，那么我们需要指定其文件夹类型。</p><p>前面用gradle生成的目录：<code>src/main/generated/java</code></p><p>把这个目录右键，将目录标记为<code>“生成文件夹的根目录”</code>。</p><h1 id="需要注意的细节"><a href="#需要注意的细节" class="headerlink" title="需要注意的细节"></a>需要注意的细节</h1><ul><li>在编写自定义Processor可能会出现处理器不起作用的情况<br>答:其很有可能是你将Processor.class写成了Process.class</li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">//正确的写法</span><br><span class="hljs-variable">@AutoService</span>(Processor.class)<br><span class="hljs-comment">//错误的写法</span><br><span class="hljs-variable">@AutoService</span>(Process.class)<br></code></pre></td></tr></table></figure><p>即使是按照上面的步骤配置，但仍然无法引用生成的代码(删除线即当时认知错误，在第4点会讲原因)<br>答:可能是由于你生成代码的文件夹与你的源文件不在一个module中，由于idea中使用gradle创建一个module，他会识别为三个module。</p><p>两种解决方式：</p><p>1.开头部分。</p><p>2.在创建项目时取消 <code>create separate per source set</code> 。</p><ul><li>annotation processor 生成类时报异常:错误: <strong>类重复: com.cxyz.test.Test</strong><br>答:其实annotation processor只能生成额外的类，而不能在原先类的基础上做改动</li></ul><hr><p>写过自定义注解处理器的老司机们乍一看这个问题觉得挺简单，是的，因为网上基本通篇都在教你怎么打日志，但是你有没有想过如果连日志都打印不出来的时候你怎么定位呢？譬如如下代码：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 确认 META-INF/services/javax.annotation.processing.Processor 没问题</span><br><span class="hljs-comment">// 确认构建脚本没问题，确认注解 Bridge 有被使用且有参与构建</span><br><span class="hljs-meta">@AutoService</span>(Processor.class)<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestAnnotationProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractProcessor</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">TestAnnotationProcessor</span>(<span class="hljs-params"></span>)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;TestAnnotationProcessor constrator&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> synchronized <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">init</span>(<span class="hljs-params">ProcessingEnvironment processingEnvironment</span>)</span> &#123;<br>        <span class="hljs-built_in">super</span>.init(processingEnvironment);<br>        System.out.println(<span class="hljs-string">&quot;TestAnnotationProcessor init&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">Set</span>&lt;<span class="hljs-built_in">String</span>&gt; <span class="hljs-function"><span class="hljs-title">getSupportedAnnotationTypes</span>(<span class="hljs-params"></span>)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;TestAnnotationProcessor getSupportedAnnotationTypes&quot;</span>);<br>        <span class="hljs-built_in">Set</span>&lt;<span class="hljs-built_in">String</span>&gt; supported = <span class="hljs-keyword">new</span> HashSet&lt;<span class="hljs-built_in">String</span>&gt;();<br>        supported.add(Bridge.class.getCanonicalName());<br>        <span class="hljs-keyword">return</span> supported;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-function"><span class="hljs-title">process</span>(<span class="hljs-params"><span class="hljs-built_in">Set</span>&lt;? <span class="hljs-keyword">extends</span> TypeElement&gt; set, RoundEnvironment roundEnvironment</span>)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;TestAnnotationProcessor process&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行构建后compileReleaseJavaWithJavac过程中没有先吐我 Annotation Processor 的任意一行日志，直接报错找不到我注解处理器产物类引用（即直接进行了 compile class 环节）。</p><p>你懵逼吗？反正我懵逼了！打印日志不好使了，哈哈，环境确认没问题，什么鬼，直接越过 Annotation Processor 进行 compile 了。</p><p>这时候就需要你稍微深入定位分析（撸javac源码的巨佬请自行飘过），前提就是你需要熟悉下 Annotation Processor 基本原理，然后我们通过一些额外的javac详细日志进行举例分析。</p><p>Annotation Processor 机制<br>注解和注解处理器是 JDK5 引入的机制，主要用来为类、方法、字段和参数等 Java 结构提供额外的信息。譬如常见的@Override就是仅仅对 Java 编译器生效的一个注解。Java 允许我们自定义注解，自定义的注解处理器就是用来处理这些自定义注解的（废话），注解处理器触发时机是由javac来处理的，所以整个javac过程的简要步骤如下图：</p><p>![在这里插入图片描述](TyporaRaw/idea 注解处理器.assets/20210111193442602.png)</p><p>可以看到，javac编译概要图主要分为如下几步：</p><p>把源文件解析为抽象语法树。<br>调用已注册的注解处理器。<br>如果注解处理器处理过程中生成了新的源文件，编译器重复第 1、2 步，当注解处理器不再生成新的源文件则进入最后一轮。<br>进入真正的 compile 字节码环节生成字节码。<br>如上就是注解处理器的核心机制，有了这个核心机制的认识我们就继续往下探索。</p><p>构建工具下 Annotation Processor 的本质<br>我们日常开发中（无论是 Java 后端还是 Android 移动端）总是多多少少会用到 JDK 提供的annotation processor能力，无论是什么构建工具（Gradle 或者 Maven 等）本质都是通过javac -processorpath命令参数显式指定哪些 Processer，或者显式声明META-INF/services/javax.annotation.processing.Processor来被javac发现并调用的（参见 google 的 AutoService 框架）。</p><p>正常情况下我们开发中使用及构建 Annotation Processor 技术都是上面几步走的方案，而且大多数照着网络上抄的都能正常工作，每次只用自己处理 process 就挺香的，因为只要按照规则声明放置，其他的 javac都能自己完美调用。</p><p>增强 javac 过程打印暴露问题<br>要解决一开始说的 Annotation Processor 中自己加的日志都不打印场景问题，我们需要获取一些额外的信息辅助定位。由于直接使用命令行javac的方式是最原始的操作，我们构建一般采用 Gradle，而 Gradle 的本质还是调用javac，所以下面我们以 Gradle 为例来分析如何定位 Annotation Processor 问题。</p><p>下面简单粗暴点就是直接在根目录的build.gradle中给所有模块添加参数：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><br><span class="hljs-comment">// 参数可选，重点是 -verbose -XprintRounds -XprintProcessorInfo</span><br>allprojects &#123;<br>    gradle<span class="hljs-selector-class">.projectsEvaluated</span> &#123;<br>        tasks<span class="hljs-selector-class">.withType</span>(JavaCompile) &#123;<br>            options<span class="hljs-selector-class">.compilerArgs</span> &lt;&lt; <span class="hljs-string">&quot;-Xlint&quot;</span> &lt;&lt; <span class="hljs-string">&quot;-verbose&quot;</span> &lt;&lt; <span class="hljs-string">&quot;-XprintRounds&quot;</span> &lt;&lt; <span class="hljs-string">&quot;-XprintProcessorInfo&quot;</span> &lt;&lt; <span class="hljs-string">&quot;-Xmaxerrs&quot;</span> &lt;&lt; <span class="hljs-string">&quot;100000&quot;</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>你也可以仅仅在自己有注解处理器的模块中添加，与上面一样，只要加给JavaCompile的参数就行。这里的参数其实就是我们平时命令行javac是否的参数，不懂的可以去命令行执行下javac -help观摩下含义吧，如下（JDK8，不同版本 JDK 略有差异）：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">yan@yanDeMackbookPro:~$ javac -help<br>用法: javac &lt;options&gt; &lt;source files&gt;<br>其中, 可能的选项包括:<br>-g                         生成所有调试信息<br><span class="hljs-code">......</span><br><span class="hljs-code">-verbose                   输出有关编译器正在执行的操作的消息</span><br><span class="hljs-code">......</span><br>-processor &lt;class1&gt;[,&lt;class2&gt;,&lt;class3&gt;...] 要运行的注释处理程序的名称; 绕过默认的搜索进程<br>-processorpath &lt;路径&gt;        指定查找注释处理程序的位置<br>......<br></code></pre></td></tr></table></figure><p>至于脚本中其他几个在javac -help中没有的参数可以看下官方文档<a href="https://docs.oracle.com/en/java/javase/11/tools/javac.html">https://docs.oracle.com/en/java/javase/11/tools/javac.html</a> ，里面详细解释了参数含义。</p><p>添加上面参数后一定要将你的构建日志追加到一个磁盘文件中，因为日志会变得非常庞大，同时也变得很容易定位问题。</p><p>通过构建日志分析定位问题<br>执行你的构建任务，完毕后分析定位主要分为如下几个步骤，每一步都是一种场景的定位，循序渐进定位分析即可。</p><p>在你的日志中搜索你的 Processor 类名，譬如TestAnnotationProcessor.class，看到的日志会是如下。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 如果你的注解处理器在项目中是源码形式的日志<br>[loading RegularFileObject[<span class="hljs-regexp">/home/u</span>ser<span class="hljs-regexp">/yan/</span>test<span class="hljs-regexp">/target/</span>classes<span class="hljs-regexp">/cn/y</span>an<span class="hljs-regexp">/test/</span>TestAnnotationProcessor.class]]<br><br><span class="hljs-regexp">//</span> 如果你的注解处理器在项目中是依赖 jar 形式的日志<br>[loading ZipFileIndexFileObject[......<span class="hljs-regexp">/test.jar(cn/y</span>an<span class="hljs-regexp">/test/</span>TestAnnotationProcessor.class)]]<br></code></pre></td></tr></table></figure><p>分析： 如果你的日志中搜不到上面信息，说明你的注解处理器没有被添加到javac的 classpath 中。一般问题就是你的META-INF/services/javax.annotation.processing.Processor声明有问题，javac无法找到你的注解处理器。有些同学可能是通过 google 的 AutoService 来生成META-INF/services/javax.annotation.processing.Processor的，这种情况下也要自己检查是否 OK（譬如之前安卓中 AGP 有一段时间的中间过渡版本就修改了 classpath，需要手动将 compile 改成 annotationProcessor 才行）。</p><p>在你的日志中搜索Round关键字，建议直接搜Round 1:这样的格式容易点，看到的日志会是如下。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vim">Round <span class="hljs-number">1</span>:<br>        <span class="hljs-built_in">input</span> <span class="hljs-keyword">file</span><span class="hljs-variable">s:</span> &#123;<span class="hljs-keyword">cn</span>.yan.test.Application, ......, <span class="hljs-keyword">cn</span>.yan.test.UseMarkedAnnotation&#125;<br>                annotation<span class="hljs-variable">s:</span> [java.lang.Override, <span class="hljs-keyword">cn</span>.yan.annotation.Bridge]<br>                <span class="hljs-keyword">last</span> <span class="hljs-built_in">round</span>: false<br></code></pre></td></tr></table></figure><p>上面日志中的input files:部分是扫到的你的源码，annotations:部分就是扫到你代码中使用了哪些注解，如果你注解处理器声明了要处理这种注解（譬如@cn.yan.annotation.Bridge），则日志如上才是正常的。</p><p>分析： 如果你日志中没搜到上面的Round，则说明javac没有触发调用任何注解处理器（无论是你写的还是依赖三方框架的），最大的可疑点就是检查下自己有没有禁用javac注解处理器，也就是确认javac执行时没有-proc:none参数。如果你的日志中有Round，但是input files:和annotations:没有你的注解类和使用类，则说明你没有在代码中使用你注解处理器要处理的注解。</p><p>在你的日志中搜索Loaded cn.yan.test.TestAnnotationProcessor关键字，看到的日志会是如下。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">[Loaded cn.yan.test.TestAnnotationProcessor <span class="hljs-keyword">from</span> <span class="hljs-keyword">file</span>:<span class="hljs-regexp">/home/u</span>ser<span class="hljs-regexp">/yan/</span>test<span class="hljs-regexp">/target/</span>classes<span class="hljs-regexp">/cn/y</span>an<span class="hljs-regexp">/test/</span>TestAnnotationProcessor.<span class="hljs-keyword">class</span>]<br></code></pre></td></tr></table></figure><p>分析： 如果你看不到上面这行日志，说明你的注解处理器类自己没有被加载成功，为什么没有我也不知道怎么分析了，但是至少说明没加载成功，你可能需要仔细核对哪里不规范或者不合法导致的了。</p><p>上面都排查完了，如果还是找不到问题原因，不妨换个思路，去仔细检查下你参与构建的普通 java 文件，是否存在语法错误或者什么问题（譬如常量没声明等）；如果有，解决完了再试试，别问我为什么，我也没有深入研究javac这块源码，只是我遇到过，且也没有异常堆栈信息，最终发现是合并解决冲突后代码少了一个变量声明，就是单纯的越过了 Annotation Processor 过程直接进行 compile to class 流程了）。<br>这个技能有什么鸟用？<br>不瞒你说，我也算是老司机了，好些年前 Annotation Processor 就玩的很 6 了，但是最近项目升级构建和 Java8 及 androidX 支持后 merge 了下代码，然后项目中的注解处理器、dataBinding 全部都不工作了，更可气的是，这个不工作是真的很吝啬，什么错误堆栈都没有，大致如下奇葩构建日志：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">FAILURE: Build failed <span class="hljs-keyword">with</span> an <span class="hljs-keyword">exception</span>.<span class="hljs-operator"></span><br><span class="hljs-operator"></span><br><span class="hljs-operator">* </span>What went wrong:<br>Execution failed <span class="hljs-keyword">for</span> task &#x27;:test:compileReleaseJavaWithJavac&#x27;.<br><span class="hljs-comment">// 本来这里该先吐我注解处理器内部的日志，然后才继续 javac 编译，实际什么都没吐</span><br>&gt; Compilation failed; see the compiler error output <span class="hljs-keyword">for</span> details.<span class="hljs-operator"></span><br><span class="hljs-operator">* </span>Exception is:<br>org.gradle.api.tasks.TaskExecutionException: Execution failed <span class="hljs-keyword">for</span> task &#x27;:moffice:compileReleaseJavaWithJavac&#x27;.<br>at org.gradle.api.internal.tasks.execution.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ExecuteActionsTaskExecuter</span>.</span></span>lambda<span class="hljs-constructor">$executeIfValid$1(ExecuteActionsTaskExecuter.<span class="hljs-params">java</span>:200)</span><br>......<br>Caused by: org.gradle.api.internal.tasks.compile.CompilationFailedException: Compilation failed; see the compiler error output <span class="hljs-keyword">for</span> details.<br>at org.gradle.api.internal.tasks.compile.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JdkJavaCompiler</span>.</span></span>execute(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JdkJavaCompiler</span>.</span></span>java:<span class="hljs-number">57</span>)<br><br></code></pre></td></tr></table></figure><p>Gradle 构建命令已经添加了各种详细参数供查看堆栈和详细日志，但奇妙的事情就是他走到compileReleaseJavaWithJavac就直接出错了，前后没有任何错误提示（有的只是一坨 Gradle 自己的 task 调用链）。我特么大意了，我就同步了下代码，编不过就编不过啊，你倒是提示下问题啊！啥也不提示直接干到 compile class 环节了，跳过了 Annotation Processor 流程，这就很恼火了。好在按照上面方式定位修复了，哈哈。</p><hr><p><a href="https://blog.csdn.net/qq_40985294/article/details/90041296#t4">引用</a></p><p><a href="https://blog.csdn.net/yanbober/article/details/112487959">引用</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>hexo整理</title>
    <link href="/2021/12/23/hexo/"/>
    <url>/2021/12/23/hexo/</url>
    
    <content type="html"><![CDATA[<h1 id="简单安装"><a href="#简单安装" class="headerlink" title="简单安装"></a>简单安装</h1><p><a href="https://hexo.io/zh-cn/docs/">hexo官网</a></p><h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装<code>git</code></h2><p>​    不再赘述</p><h1 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装<code>node.js</code></h1><p>可以通过以下命令查看主机中是否安装了<code>node.js</code>和<code>npm</code></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ <span class="hljs-keyword">node</span> <span class="hljs-title">--version</span>    <span class="hljs-comment">#检查是否安装了node.js</span><br>$ npm --<span class="hljs-keyword">version</span>     <span class="hljs-comment">#检查是否安装了npm</span><br></code></pre></td></tr></table></figure><p>如下所示表示已经安装了<code>node.js</code>和<code>npm</code></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">root</span>@***:~# node --version<br><span class="hljs-attribute">v8</span>.<span class="hljs-number">11</span>.<span class="hljs-number">3</span><br><span class="hljs-attribute">root</span>@***:~# npm --version<br><span class="hljs-attribute">6</span>.<span class="hljs-number">7</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><a href="https://nodejs.org/en/download/package-manager/">没有安装的话查看官方指南</a></p><h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装<code>hexo</code></h2><ul><li>使用<code>npm</code>安装    </li></ul><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">$ npm install -g hexo-<span class="hljs-keyword">cli</span><br></code></pre></td></tr></table></figure><ul><li><p>安装以后，可以使用以下两种方式执行 <code>Hexo</code>：</p><ol><li><code>npx hexo &lt;command&gt;</code></li><li>将 <code>Hexo</code> 所在的目录下的 <code>node_modules</code> 添加到环境变量之中即可直接使用 <code>hexo &lt;command&gt;</code>：</li></ol><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">echo</span> &#x27;PATH=<span class="hljs-string">&quot;$PATH:./node_modules/.bin&quot;</span>&#x27; &gt;&gt; ~<span class="hljs-string">/.profile</span><br>我使用的zsh,所以把<span class="hljs-string">&quot;~/.profile&quot;</span>改为<span class="hljs-string">&quot;~/.zshrc&quot;</span><br><br></code></pre></td></tr></table></figure></li></ul><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><ul><li>初始化hexo（在自己建立的任意文件夹里，如果没有添加环境变量，需要使用<code>npx hexo &lt;command&gt;</code>）</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> hexo init &lt;folder&gt;<br><span class="hljs-variable">$</span> <span class="hljs-built_in">cd</span> &lt;folder&gt;<br><span class="hljs-variable">$</span> npm install<br></code></pre></td></tr></table></figure><ul><li>接下来,输入两条命令</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog">hexo <span class="hljs-keyword">generate</span>  <br>hexo server  <br>或者输入命令的简写:  <br>hexo g<br>hexo s<br></code></pre></td></tr></table></figure><p>解释:<br>首先执行”hexo generate”生成相应的静态网页，生成的静态网页以及相关资源都会在public目录下<br>hexo-server模块的主要命令如下，输入”hexo generate”以启动服务器，您的网站会在 <a href="http://localhost:4000/">http://localhost:4000</a> 下启动。在服务器启动期间，Hexo 会监视文件变动并自动更新，您无须重启服务器。<br>注: 如果您想要更改端口，或是在执行时遇到了 EADDRINUSE 错误，可以在执行时使用 -p 选项指定其他端口，如下:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">hexo</span> server -p <span class="hljs-number">5000</span><br></code></pre></td></tr></table></figure><ul><li>接下来, 将hexo部署到github</li></ul><p>1 .首先将我们的Hexo与GitHub关联起来，打开站点的配置文件_config.yml，翻到最后修改为：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">type:</span> git<br><span class="hljs-symbol">repo:</span> https:<span class="hljs-comment">//github.com/用户名/用户名.github.io.git</span><br><span class="hljs-symbol">branch:</span> master<br></code></pre></td></tr></table></figure><p>其实就是给hexo d 这个命令做相应的配置，让hexo知道你要把blog部署在哪个位置，很显然，我们部署在我们GitHub的仓库里。<br>2 .安装Git部署插件，输入命令：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install hexo-deployer-git <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><p>接着，我们分别输入三条命令：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs excel">hexo <span class="hljs-built_in">clean</span> <br>hexo g <br>hexo d  将会部署到github<br></code></pre></td></tr></table></figure><p>全部完成  </p><h1 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h1><ul><li><a href="https://github.com/zthxxx/hexo-theme-Wikitten">wiki样式</a></li><li><a href="https://github.com/jerryc127/hexo-theme-butterfly">md样式<code>hexo-theme-butterfly</code></a></li><li> <a href="https://github.com/bollnh/hexo-theme-material">md样式<code>hexo-theme-material</code></a></li><li><a href="https://github.com/fluid-dev/hexo-theme-fluid">md样式<code>hexo-theme-fluid</code></a></li></ul><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>您可以在 <code>_config.yml</code> 中修改大部分的配置。</p><h2 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h2><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>title</code></td><td align="left">网站标题</td></tr><tr><td align="left"><code>subtitle</code></td><td align="left">网站副标题</td></tr><tr><td align="left"><code>description</code></td><td align="left">网站描述</td></tr><tr><td align="left"><code>keywords</code></td><td align="left">网站的关键词。支持多个关键词。</td></tr><tr><td align="left"><code>author</code></td><td align="left">您的名字</td></tr><tr><td align="left"><code>language</code></td><td align="left">网站使用的语言。对于简体中文用户来说，使用不同的主题可能需要设置成不同的值，请参考你的主题的文档自行设置，常见的有 <code>zh-Hans</code>和 <code>zh-CN</code>。</td></tr><tr><td align="left"><code>timezone</code></td><td align="left">网站时区。Hexo 默认使用您电脑的时区。请参考 <a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones">时区列表</a> 进行设置，如 <code>America/New_York</code>, <code>Japan</code>, 和 <code>UTC</code> 。一般的，对于中国大陆地区可以使用 <code>Asia/Shanghai</code>。</td></tr></tbody></table><p>其中，<code>description</code>主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。<code>author</code>参数用于主题显示文章的作者。</p><h2 id="网址"><a href="#网址" class="headerlink" title="网址"></a>网址</h2><table><thead><tr><th align="left">参数</th><th align="left">描述</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left"><code>url</code></td><td align="left">网址, 必须以 <code>http://</code> 或 <code>https://</code> 开头</td><td align="left"></td></tr><tr><td align="left"><code>root</code></td><td align="left">网站根目录</td><td align="left"><code>url&#39;s pathname</code></td></tr><tr><td align="left"><code>permalink</code></td><td align="left">文章的 <a href="https://hexo.io/zh-cn/docs/permalinks">永久链接</a> 格式</td><td align="left"><code>:year/:month/:day/:title/</code></td></tr><tr><td align="left"><code>permalink_defaults</code></td><td align="left">永久链接中各部分的默认值</td><td align="left"></td></tr><tr><td align="left"><code>pretty_urls</code></td><td align="left">改写 <a href="https://hexo.io/zh-cn/docs/variables"><code>permalink</code></a> 的值来美化 URL</td><td align="left"></td></tr><tr><td align="left"><code>pretty_urls.trailing_index</code></td><td align="left">是否在永久链接中保留尾部的 <code>index.html</code>，设置为 <code>false</code> 时去除</td><td align="left"><code>true</code></td></tr><tr><td align="left"><code>pretty_urls.trailing_html</code></td><td align="left">是否在永久链接中保留尾部的 <code>.html</code>, 设置为 <code>false</code> 时去除 (<em>对尾部的 <code>index.html</code>无效</em>)</td><td align="left"><code>true</code></td></tr></tbody></table><blockquote><p>网站存放在子目录</p><p>如果您的网站存放在子目录中，例如 <code>http://example.com/blog</code>，则请将您的 <code>url</code> 设为 <code>http://example.com/blog</code> 并把 <code>root</code> 设为 <code>/blog/</code>。</p></blockquote><p>例如：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-meta"># 比如，一个页面的永久链接是 http:<span class="hljs-comment">//example.com/foo/bar/index.html</span></span><br><span class="hljs-symbol">pretty_urls:</span><br><span class="hljs-symbol">  trailing_index:</span> false<br><span class="hljs-meta"># 此时页面的永久链接会变为 http:<span class="hljs-comment">//example.com/foo/bar/</span></span><br></code></pre></td></tr></table></figure><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><table><thead><tr><th align="left">参数</th><th align="left">描述</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left"><code>source_dir</code></td><td align="left">资源文件夹，这个文件夹用来存放内容。</td><td align="left"><code>source</code></td></tr><tr><td align="left"><code>public_dir</code></td><td align="left">公共文件夹，这个文件夹用于存放生成的站点文件。</td><td align="left"><code>public</code></td></tr><tr><td align="left"><code>tag_dir</code></td><td align="left">标签文件夹</td><td align="left"><code>tags</code></td></tr><tr><td align="left"><code>archive_dir</code></td><td align="left">归档文件夹</td><td align="left"><code>archives</code></td></tr><tr><td align="left"><code>category_dir</code></td><td align="left">分类文件夹</td><td align="left"><code>categories</code></td></tr><tr><td align="left"><code>code_dir</code></td><td align="left">Include code 文件夹，<code>source_dir</code> 下的子目录</td><td align="left"><code>downloads/code</code></td></tr><tr><td align="left"><code>i18n_dir</code></td><td align="left">国际化（i18n）文件夹</td><td align="left"><code>:lang</code></td></tr><tr><td align="left"><code>skip_render</code></td><td align="left">跳过指定文件的渲染。匹配到的文件将会被不做改动地复制到 <code>public</code> 目录中。您可使用 <a href="https://github.com/micromatch/micromatch#extended-globbing">glob 表达式</a>来匹配路径。</td><td align="left"></td></tr></tbody></table><p>例如：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gradle">skip_render: <span class="hljs-string">&quot;mypage/**/*&quot;</span><br># 将会直接将 `<span class="hljs-keyword">source</span><span class="hljs-regexp">/mypage/i</span>ndex.html` 和 `<span class="hljs-keyword">source</span><span class="hljs-regexp">/mypage/</span>code.js` 不做改动地输出到 <span class="hljs-string">&#x27;public&#x27;</span> 目录<br># 你也可以用这种方法来跳过对指定文章文件的渲染<br>skip_render: <span class="hljs-string">&quot;_posts/test-post.md&quot;</span><br># 这将会忽略对 <span class="hljs-string">&#x27;test-post.md&#x27;</span> 的渲染<br></code></pre></td></tr></table></figure><blockquote><p>提示</p><p>如果您刚刚开始接触 Hexo，通常没有必要修改这一部分的值。</p></blockquote><h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><table><thead><tr><th align="left">参数</th><th align="left">描述</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left"><code>new_post_name</code></td><td align="left">新文章的文件名称</td><td align="left">:title.md</td></tr><tr><td align="left"><code>default_layout</code></td><td align="left">预设布局</td><td align="left">post</td></tr><tr><td align="left"><code>auto_spacing</code></td><td align="left">在中文和英文之间加入空格</td><td align="left">false</td></tr><tr><td align="left"><code>titlecase</code></td><td align="left">把标题转换为 title case</td><td align="left">false</td></tr><tr><td align="left"><code>external_link</code></td><td align="left">在新标签中打开链接</td><td align="left">true</td></tr><tr><td align="left"><code>external_link.enable</code></td><td align="left">在新标签中打开链接</td><td align="left"><code>true</code></td></tr><tr><td align="left"><code>external_link.field</code></td><td align="left">对整个网站（<code>site</code>）生效或仅对文章（<code>post</code>）生效</td><td align="left"><code>site</code></td></tr><tr><td align="left"><code>external_link.exclude</code></td><td align="left">需要排除的域名。主域名和子域名如 <code>www</code> 需分别配置</td><td align="left"><code>[]</code></td></tr><tr><td align="left"><code>filename_case</code></td><td align="left">把文件名称转换为 (1) 小写或 (2) 大写</td><td align="left">0</td></tr><tr><td align="left"><code>render_drafts</code></td><td align="left">显示草稿</td><td align="left">false</td></tr><tr><td align="left"><code>post_asset_folder</code></td><td align="left">启动 <a href="https://hexo.io/zh-cn/docs/asset-folders">Asset 文件夹</a></td><td align="left">false</td></tr><tr><td align="left"><code>relative_link</code></td><td align="left">把链接改为与根目录的相对位址</td><td align="left">false</td></tr><tr><td align="left"><code>future</code></td><td align="left">显示未来的文章</td><td align="left">true</td></tr><tr><td align="left"><code>highlight</code></td><td align="left">代码块的设置, 请参考 <a href="https://hexo.io/docs/syntax-highlight#Highlight-js">Highlight.js</a> 进行设置</td><td align="left"></td></tr><tr><td align="left"><code>prismjs</code></td><td align="left">代码块的设置, 请参考 <a href="https://hexo.io/docs/syntax-highlight#PrismJS">PrismJS</a> 进行设置</td><td align="left"></td></tr></tbody></table><blockquote><p>相对地址</p><p>默认情况下，Hexo 生成的超链接都是绝对地址。例如，如果您的网站域名为 <code>example.com</code>,您有一篇文章名为 <code>hello</code>，那么绝对链接可能像这样：<code>http://example.com/hello.html</code>，它是<strong>绝对</strong>于域名的。相对链接像这样：<code>/hello.html</code>，也就是说，无论用什么域名访问该站点，都没有关系，这在进行反向代理时可能用到。通常情况下，建议使用绝对地址。</p></blockquote><h2 id="分类-amp-标签"><a href="#分类-amp-标签" class="headerlink" title="分类 &amp; 标签"></a>分类 &amp; 标签</h2><table><thead><tr><th align="left">参数</th><th align="left">描述</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left"><code>default_category</code></td><td align="left">默认分类</td><td align="left"><code>uncategorized</code></td></tr><tr><td align="left"><code>category_map</code></td><td align="left">分类别名</td><td align="left"></td></tr><tr><td align="left"><code>tag_map</code></td><td align="left">标签别名</td><td align="left"></td></tr></tbody></table><h2 id="日期-时间格式"><a href="#日期-时间格式" class="headerlink" title="日期 / 时间格式"></a>日期 / 时间格式</h2><p>Hexo 使用 <a href="http://momentjs.com/">Moment.js</a> 来解析和显示时间。</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left"><code>date_format</code></td><td align="left">日期格式</td><td align="left"><code>YYYY-MM-DD</code></td></tr><tr><td align="left"><code>time_format</code></td><td align="left">时间格式</td><td align="left"><code>HH:mm:ss</code></td></tr><tr><td align="left"><code>updated_option</code></td><td align="left">当 Front Matter 中没有指定 <a href="https://hexo.io/zh-cn/docs/variables#%E9%A1%B5%E9%9D%A2%E5%8F%98%E9%87%8F"><code>updated</code></a> 时 <code>updated</code> 的取值</td><td align="left"><code>mtime</code></td></tr></tbody></table><blockquote><p>updated_option</p><p><code>updated_option</code> 控制了当 Front Matter 中没有指定 <code>updated</code> 时，<code>updated</code> 如何取值：</p><ul><li><code>mtime</code>: 使用文件的最后修改时间。这是从 Hexo 3.0.0 开始的默认行为。</li><li><code>date</code>: 使用 <code>date</code> 作为 <code>updated</code> 的值。可被用于 Git 工作流之中，因为使用 Git 管理站点时，文件的最后修改日期常常会发生改变</li><li><code>empty</code>: 直接删除 <code>updated</code>。使用这一选项可能会导致大部分主题和插件无法正常工作。</li></ul><p><code>use_date_for_updated</code> 选项已经被废弃，将会在下个重大版本发布时去除。请改为使用 <code>updated_option: &#39;date&#39;</code>。</p></blockquote><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso">use_date_for_updated<span class="hljs-string">` | 启用以后，如果 Front Matter 中没有指定 `</span>updated<span class="hljs-string">`， [`</span>post.updated<span class="hljs-string">`](https://hexo.io/zh-cn/docs/configuration) 将会使用 `</span><span class="hljs-built_in">date</span><span class="hljs-string">` 的值而不是文件的创建时间。在 Git 工作流中这个选项会很有用 | `</span><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><table><thead><tr><th align="left">参数</th><th align="left">描述</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left"><code>per_page</code></td><td align="left">每页显示的文章量 (0 = 关闭分页功能)</td><td align="left"><code>10</code></td></tr><tr><td align="left"><code>pagination_dir</code></td><td align="left">分页目录</td><td align="left"><code>page</code></td></tr></tbody></table><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>theme</code></td><td align="left">当前主题名称。值为<code>false</code>时禁用主题</td></tr><tr><td align="left"><code>theme_config</code></td><td align="left">主题的配置文件。在这里放置的配置会覆盖主题目录下的 <code>_config.yml</code> 中的配置</td></tr><tr><td align="left"><code>deploy</code></td><td align="left">部署部分的设置</td></tr><tr><td align="left"><code>meta_generator</code></td><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta#%E5%B1%9E%E6%80%A7">Meta generator</a> 标签。 值为 <code>false</code> 时 Hexo 不会在头部插入该标签</td></tr></tbody></table><h3 id="包括或不包括目录和文件"><a href="#包括或不包括目录和文件" class="headerlink" title="包括或不包括目录和文件"></a>包括或不包括目录和文件</h3><p>在 Hexo 配置文件中，通过设置 include/exclude 可以让 Hexo 进行处理或忽略某些目录和文件夹。你可以使用 <a href="https://github.com/isaacs/minimatch">glob 表达式</a> 对目录和文件进行匹配。</p><p><code>include</code> and <code>exclude</code> options only apply to the <code>source/</code> folder, whereas <code>ignore</code> option applies to all folders.</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>include</code></td><td align="left">Hexo 默认会忽略隐藏文件和文件夹（包括名称以下划线和 <code>.</code> 开头的文件和文件夹，Hexo 的 <code>_posts</code> 和 <code>_data</code> 等目录除外）。通过设置此字段将使 Hexo 处理他们并将它们复制到 <code>source</code> 目录下。</td></tr><tr><td align="left"><code>exclude</code></td><td align="left">Hexo 会忽略这些文件和目录</td></tr><tr><td align="left"><code>ignore</code></td><td align="left">Ignore files/folders</td></tr></tbody></table><p>举例：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-meta"># <span class="hljs-meta-keyword">Include</span>/Exclude Files/Folders</span><br>include:<br>  - <span class="hljs-string">&quot;.nojekyll&quot;</span><br>  <span class="hljs-meta"># 包括 <span class="hljs-string">&#x27;source/css/_typing.css&#x27;</span></span><br>  - <span class="hljs-string">&quot;css/_typing.css&quot;</span><br>  <span class="hljs-meta"># 包括 <span class="hljs-string">&#x27;source/_css/&#x27;</span> 中的任何文件，但不包括子目录及其其中的文件。</span><br>  - <span class="hljs-string">&quot;_css/*&quot;</span><br>  <span class="hljs-meta"># 包含 <span class="hljs-string">&#x27;source/_css/&#x27;</span> 中的任何文件和子目录下的任何文件</span><br>  - <span class="hljs-string">&quot;_css/**/*&quot;</span><br><br>exclude:<br>  <span class="hljs-meta"># 不包括 <span class="hljs-string">&#x27;source/js/test.js&#x27;</span></span><br>  - <span class="hljs-string">&quot;js/test.js&quot;</span><br>  <span class="hljs-meta"># 不包括 <span class="hljs-string">&#x27;source/js/&#x27;</span> 中的文件、但包括子目录下的所有目录和文件</span><br>  - <span class="hljs-string">&quot;js/*&quot;</span><br>  <span class="hljs-meta"># 不包括 <span class="hljs-string">&#x27;source/js/&#x27;</span> 中的文件和子目录下的任何文件</span><br>  - <span class="hljs-string">&quot;js/**/*&quot;</span><br>  <span class="hljs-meta"># 不包括 <span class="hljs-string">&#x27;source/js/&#x27;</span> 目录下的所有文件名以 <span class="hljs-string">&#x27;test&#x27;</span> 开头的文件，但包括其它文件和子目录下的单文件</span><br>  - <span class="hljs-string">&quot;js/test*&quot;</span><br>  <span class="hljs-meta"># 不包括 <span class="hljs-string">&#x27;source/js/&#x27;</span> 及其子目录中任何以 <span class="hljs-string">&#x27;test&#x27;</span> 开头的文件</span><br>  - <span class="hljs-string">&quot;js/**/test*&quot;</span><br>  <span class="hljs-meta"># 不要用 exclude 来忽略 <span class="hljs-string">&#x27;source/_posts/&#x27;</span> 中的文件。你应该使用 <span class="hljs-string">&#x27;skip_render&#x27;</span>，或者在要忽略的文件的文件名之前加一个下划线 <span class="hljs-string">&#x27;_&#x27;</span></span><br>  <span class="hljs-meta"># 在这里配置一个 - <span class="hljs-string">&quot;_posts/hello-world.md&quot;</span> 是没有用的。</span><br><br>ignore:<br>  <span class="hljs-meta"># Ignore any folder named <span class="hljs-string">&#x27;foo&#x27;</span>.</span><br>  - <span class="hljs-string">&quot;**/foo&quot;</span><br>  <span class="hljs-meta"># Ignore <span class="hljs-string">&#x27;foo&#x27;</span> folder in <span class="hljs-string">&#x27;themes/&#x27;</span> only.</span><br>  - <span class="hljs-string">&quot;**/themes/*/foo&quot;</span><br>  <span class="hljs-meta"># Same as above, but applies to every subfolders of <span class="hljs-string">&#x27;themes/&#x27;</span>.</span><br>  - <span class="hljs-string">&quot;**/themes/**/foo&quot;</span><br></code></pre></td></tr></table></figure><p>列表中的每一项都必须用单引号或双引号包裹起来。</p><p><code>include</code> 和 <code>exclude</code> 并不适用于 <code>themes/</code> 目录下的文件。如果需要忽略 <code>themes/</code> 目录下的部分文件或文件夹，可以使用 <code>ignore</code> 或在文件名之前添加下划线 <code>_</code>。</p><h3 id="使用代替配置文件"><a href="#使用代替配置文件" class="headerlink" title="使用代替配置文件"></a>使用代替配置文件</h3><p>可以在 hexo-cli 中使用 <code>--config</code> 参数来指定自定义配置文件的路径。你可以使用一个 YAML 或 JSON 文件的路径，也可以使用逗号分隔（无空格）的多个 YAML 或 JSON 文件的路径。例如：</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sml"># use <span class="hljs-symbol">&#x27;custom</span>.yml&#x27; <span class="hljs-keyword">in</span> place <span class="hljs-keyword">of</span> <span class="hljs-symbol">&#x27;_config</span>.yml&#x27;<br>$ hexo server --config custom.yml<br><br># use <span class="hljs-symbol">&#x27;custom</span>.yml&#x27; &amp; <span class="hljs-symbol">&#x27;custom2</span>.json&#x27;, prioritizing <span class="hljs-symbol">&#x27;custom3</span>.yml&#x27;, <span class="hljs-keyword">then</span> <span class="hljs-symbol">&#x27;custom2</span>.json&#x27;<br>$ hexo generate --config custom.yml,custom2.json,custom3.yml<br></code></pre></td></tr></table></figure><p>当你指定了多个配置文件以后，Hexo 会按顺序将这部分配置文件合并成一个 <code>_multiconfig.yml</code>。如果遇到重复的配置，排在后面的文件的配置会覆盖排在前面的文件的配置。这个原则适用于任意数量、任意深度的 YAML 和 JSON 文件。</p><p>例如，使用 <code>--options</code> 指定了两个自定义配置文件：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog">$ hexo <span class="hljs-keyword">generate</span> --<span class="hljs-keyword">config</span> custom<span class="hljs-variable">.yml</span>,custom2<span class="hljs-variable">.json</span><br></code></pre></td></tr></table></figure><p>如果 <code>custom.yml</code> 中指定了 <code>foo: bar</code>，在 custom2.json 中指定了 <code>&quot;foo&quot;: &quot;dinosaur&quot;</code>，那么在 <code>_multiconfig.yml</code> 中你会得到 <code>foo: dinosaur</code>。</p><h3 id="使用代替主题配置文件"><a href="#使用代替主题配置文件" class="headerlink" title="使用代替主题配置文件"></a>使用代替主题配置文件</h3><p>通常情况下，Hexo 主题是一个独立的项目，并拥有一个独立的 <code>_config.yml</code> 配置文件。</p><p>除了自行维护独立的主题配置文件，你也可以在其它地方对主题进行配置。</p><p><strong>配置文件中的 <code>theme_config</code></strong></p><blockquote><p>该特性自 Hexo 2.8.2 起提供</p></blockquote><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-meta"># _config.yml</span><br><span class="hljs-symbol">theme:</span> <span class="hljs-string">&quot;my-theme&quot;</span><br><span class="hljs-symbol">theme_config:</span><br><span class="hljs-symbol">  bio:</span> <span class="hljs-string">&quot;My awesome bio&quot;</span><br><span class="hljs-symbol">  foo:</span><br><span class="hljs-symbol">    bar:</span> <span class="hljs-string">&#x27;a&#x27;</span><br><span class="hljs-meta"># themes/my-theme/_config.yml</span><br><span class="hljs-symbol">bio:</span> <span class="hljs-string">&quot;Some generic bio&quot;</span><br><span class="hljs-symbol">logo:</span> <span class="hljs-string">&quot;a-cool-image.png&quot;</span><br><span class="hljs-symbol">  foo:</span><br><span class="hljs-symbol">    baz:</span> <span class="hljs-string">&#x27;b&#x27;</span><br></code></pre></td></tr></table></figure><p>最终主题配置的输出是：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dts">&#123;<br><span class="hljs-symbol">  bio:</span> <span class="hljs-string">&quot;My awesome bio&quot;</span>,<br><span class="hljs-symbol">  logo:</span> <span class="hljs-string">&quot;a-cool-image.png&quot;</span>,<br><span class="hljs-symbol">  foo:</span> &#123;<br><span class="hljs-symbol">    bar:</span> <span class="hljs-string">&quot;a&quot;</span>,<br><span class="hljs-symbol">    baz:</span> <span class="hljs-string">&quot;b&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>独立的 <code>_config.[theme].yml</code> 文件</strong></p><blockquote><p>该特性自 Hexo 5.0.0 起提供</p></blockquote><p>独立的主题配置文件应放置于站点根目录下，支持 <code>yml</code> 或 <code>json</code> 格式。需要配置站点 <code>_config.yml</code> 文件中的 <code>theme</code> 以供 Hexo 寻找 <code>_config.[theme].yml</code> 文件。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-meta"># _config.yml</span><br><span class="hljs-symbol">theme:</span> <span class="hljs-string">&quot;my-theme&quot;</span><br><span class="hljs-meta"># _config.my-theme.yml</span><br><span class="hljs-symbol">bio:</span> <span class="hljs-string">&quot;My awesome bio&quot;</span><br><span class="hljs-symbol">foo:</span><br><span class="hljs-symbol">  bar:</span> <span class="hljs-string">&#x27;a&#x27;</span><br><span class="hljs-meta"># themes/my-theme/_config.yml</span><br><span class="hljs-symbol">bio:</span> <span class="hljs-string">&quot;Some generic bio&quot;</span><br><span class="hljs-symbol">logo:</span> <span class="hljs-string">&quot;a-cool-image.png&quot;</span><br><span class="hljs-symbol">  foo:</span><br><span class="hljs-symbol">    baz:</span> <span class="hljs-string">&#x27;b&#x27;</span><br></code></pre></td></tr></table></figure><p>最终主题配置的输出是：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dts">&#123;<br><span class="hljs-symbol">  bio:</span> <span class="hljs-string">&quot;My awesome bio&quot;</span>,<br><span class="hljs-symbol">  logo:</span> <span class="hljs-string">&quot;a-cool-image.png&quot;</span>,<br><span class="hljs-symbol">  foo:</span> &#123;<br><span class="hljs-symbol">    bar:</span> <span class="hljs-string">&quot;a&quot;</span>,<br><span class="hljs-symbol">    baz:</span> <span class="hljs-string">&quot;b&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>我们强烈建议你将所有的主题配置集中在一处。如果你不得不在多处配置你的主题，那么这些信息对你将会非常有用：Hexo 在合并主题配置时，Hexo 配置文件中的 <code>theme_config</code> 的优先级最高，其次是 <code>_config.[theme].yml</code> 文件，最后是位于主题目录下的 <code>_config.yml</code> 文件。</p></blockquote><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>安装 <code>Hexo </code>完成后，请执行下列命令，<code>Hexo</code> 将会在指定文件夹中新建所需要的文件。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> hexo init &lt;folder&gt;<br><span class="hljs-variable">$</span> <span class="hljs-built_in">cd</span> &lt;folder&gt;<br><span class="hljs-variable">$</span> npm install<br></code></pre></td></tr></table></figure><p>新建完成后，指定文件夹的目录如下：</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sqf">.<br>├── <span class="hljs-variable">_config</span>.yml<br>├── package.json<br>├── scaffolds<br>├── source<br>|   ├── <span class="hljs-variable">_drafts</span><br>|   └── <span class="hljs-variable">_posts</span><br>└── themes<br></code></pre></td></tr></table></figure><h3 id="config-yml"><a href="#config-yml" class="headerlink" title="_config.yml"></a><code>_config.yml</code></h3><p>网站的 <a href="https://hexo.io/zh-cn/docs/configuration">配置</a> 信息，您可以在此配置大部分的参数。</p><h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a><code>package.json</code></h3><p>应用程序的信息。<a href="https://ejs.co/">EJS</a>, <a href="http://learnboost.github.io/stylus/">Stylus</a> 和 <a href="http://daringfireball.net/projects/markdown/">Markdown</a> renderer 已默认安装，您可以自由移除。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">package</span>.json&#123;<br>  <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;hexo-site&quot;</span>,<br>  <span class="hljs-string">&quot;version&quot;</span>: <span class="hljs-string">&quot;0.0.0&quot;</span>,<br>  <span class="hljs-string">&quot;private&quot;</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-string">&quot;hexo&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;version&quot;</span>: <span class="hljs-string">&quot;&quot;</span><br>  &#125;,<br>  <span class="hljs-string">&quot;dependencies&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;hexo&quot;</span>: <span class="hljs-string">&quot;^3.8.0&quot;</span>,<br>    <span class="hljs-string">&quot;hexo-generator-archive&quot;</span>: <span class="hljs-string">&quot;^0.1.5&quot;</span>,<br>    <span class="hljs-string">&quot;hexo-generator-category&quot;</span>: <span class="hljs-string">&quot;^0.1.3&quot;</span>,<br>    <span class="hljs-string">&quot;hexo-generator-index&quot;</span>: <span class="hljs-string">&quot;^0.2.1&quot;</span>,<br>    <span class="hljs-string">&quot;hexo-generator-tag&quot;</span>: <span class="hljs-string">&quot;^0.2.0&quot;</span>,<br>    <span class="hljs-string">&quot;hexo-renderer-ejs&quot;</span>: <span class="hljs-string">&quot;^0.3.1&quot;</span>,<br>    <span class="hljs-string">&quot;hexo-renderer-stylus&quot;</span>: <span class="hljs-string">&quot;^0.3.3&quot;</span>,<br>    <span class="hljs-string">&quot;hexo-renderer-marked&quot;</span>: <span class="hljs-string">&quot;^0.3.2&quot;</span>,<br>    <span class="hljs-string">&quot;hexo-server&quot;</span>: <span class="hljs-string">&quot;^0.3.3&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="scaffolds"><a href="#scaffolds" class="headerlink" title="scaffolds"></a>scaffolds</h3><p><a href="https://hexo.io/zh-cn/docs/writing">模版</a> 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。</p><p>Hexo的模板是指在新建的文章文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。</p><h3 id="source"><a href="#source" class="headerlink" title="source"></a>source</h3><p>资源文件夹是存放用户资源的地方。除 <code>_posts</code> 文件夹之外，开头命名为 <code>_</code> (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 <code>public</code> 文件夹，而其他文件会被拷贝过去。</p><h3 id="themes"><a href="#themes" class="headerlink" title="themes"></a>themes</h3><p><a href="https://hexo.io/zh-cn/docs/themes">主题</a> 文件夹。Hexo 会根据主题来生成静态页面。</p><h1 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h1><p>可以在命令中指定文章的布局（layout），默认为 <code>post</code>，可以通过修改 <code>_config.yml</code> 中的 <code>default_layout</code> 参数来指定默认布局。</p><h3 id="布局（Layout）"><a href="#布局（Layout）" class="headerlink" title="布局（Layout）"></a>布局（Layout）</h3><p>Hexo 有三种默认布局：<code>post</code>、<code>page</code> 和 <code>draft</code>。在创建这三种不同类型的文件时，它们将会被保存到不同的路径；而您自定义的其他布局和 <code>post</code> 相同，都将储存到 <code>source/_posts</code> 文件夹。</p><table><thead><tr><th align="left">布局</th><th align="left">路径</th></tr></thead><tbody><tr><td align="left"><code>post</code></td><td align="left"><code>source/_posts</code></td></tr><tr><td align="left"><code>page</code></td><td align="left"><code>source</code></td></tr><tr><td align="left"><code>draft</code></td><td align="left"><code>source/_drafts</code></td></tr></tbody></table><blockquote><p>Disabling layout</p><p>If you don’t want an article (post/page) to be processed with a theme, set <code>layout: false</code> in its front-matter. Refer to <a href="https://hexo.io/zh-cn/docs/front-matter#%E5%B8%83%E5%B1%80">this section</a> for more details.</p></blockquote><h3 id="文件名称"><a href="#文件名称" class="headerlink" title="文件名称"></a>文件名称</h3><p>Hexo 默认以标题做为文件名称，但您可编辑 <code>new_post_name</code> 参数来改变默认的文件名称，举例来说，设为 <code>:year-:month-:day-:title.md</code> 可让您更方便的通过日期来管理文章。</p><table><thead><tr><th align="left">变量</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>:title</code></td><td align="left">标题（小写，空格将会被替换为短杠）</td></tr><tr><td align="left"><code>:year</code></td><td align="left">建立的年份，比如， <code>2015</code></td></tr><tr><td align="left"><code>:month</code></td><td align="left">建立的月份（有前导零），比如， <code>04</code></td></tr><tr><td align="left"><code>:i_month</code></td><td align="left">建立的月份（无前导零），比如， <code>4</code></td></tr><tr><td align="left"><code>:day</code></td><td align="left">建立的日期（有前导零），比如， <code>07</code></td></tr><tr><td align="left"><code>:i_day</code></td><td align="left">建立的日期（无前导零），比如， <code>7</code></td></tr></tbody></table><h3 id="草稿"><a href="#草稿" class="headerlink" title="草稿"></a>草稿</h3><p>刚刚提到了 Hexo 的一种特殊布局：<code>draft</code>，这种布局在建立时会被保存到 <code>source/_drafts</code> 文件夹，您可通过 <code>publish</code> 命令将草稿移动到 <code>source/_posts</code> 文件夹，该命令的使用方式与 <code>new</code> 十分类似，您也可在命令中指定 <code>layout</code> 来指定布局。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">$ hexo publish [layout] <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><br></code></pre></td></tr></table></figure><p>草稿默认不会显示在页面中，您可在执行时加上 <code>--draft</code> 参数，或是把 <code>render_drafts</code> 参数设为 <code>true</code> 来预览草稿。</p><h2 id="模版（Scaffold）"><a href="#模版（Scaffold）" class="headerlink" title="模版（Scaffold）"></a>模版（Scaffold）</h2><p>在新建文章时，Hexo 会根据 <code>scaffolds</code> 文件夹内相对应的文件来建立文件，例如：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">$ hexo <span class="hljs-keyword">new</span> <span class="hljs-type">photo</span> <span class="hljs-string">&quot;My Gallery&quot;</span><br></code></pre></td></tr></table></figure><p>在执行这行指令时，Hexo 会尝试在 <code>scaffolds</code> 文件夹中寻找 <code>photo.md</code>，并根据其内容建立文章，以下是您可以在模版中使用的变量：</p><table><thead><tr><th align="left">变量</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>layout</code></td><td align="left">布局</td></tr><tr><td align="left"><code>title</code></td><td align="left">标题</td></tr><tr><td align="left"><code>date</code></td><td align="left">文件建立日期</td></tr></tbody></table><h3 id="支持的格式"><a href="#支持的格式" class="headerlink" title="支持的格式"></a>支持的格式</h3><p>Hexo 支持以任何格式书写文章，只要安装了相应的渲染插件。</p><p>例如，Hexo 默认安装了 <code>hexo-renderer-marked</code> 和 <code>hexo-renderer-ejs</code>，因此你不仅可以用 Markdown 写作，你还可以用 EJS 写作。如果你安装了 <code>hexo-renderer-pug</code>，你甚至可以用 Pug 模板语言书写文章。</p><p>只需要将文章的扩展名从 <code>md</code> 改成 <code>ejs</code>，Hexo 就会使用 <code>hexo-renderer-ejs</code> 渲染这个文件，其他格式同理。</p><h1 id="npm相关问题"><a href="#npm相关问题" class="headerlink" title="npm相关问题"></a><code>npm</code>相关问题</h1><h2 id="1-使用npm命令时报错误Error-EACCES-permission-denied，如何解决？"><a href="#1-使用npm命令时报错误Error-EACCES-permission-denied，如何解决？" class="headerlink" title="1.使用npm命令时报错误Error: EACCES: permission denied，如何解决？"></a>1.使用<code>npm</code>命令时报错误<code>Error: EACCES: permission denied</code>，如何解决？</h2><p>官方的解决方案：<a href="https://docs.npmjs.com/getting-started/fixing-npm-permissions">https://docs.npmjs.com/getting-started/fixing-npm-permissions</a></p><p>官方提供了两种解决方案：</p><ol><li><p>重新安装一个node version manager。（官方推荐）<br>参考地址：<a href="https://docs.npmjs.com/getting-started/installing-node">https://docs.npmjs.com/getting-started/installing-node</a><br>注：这个方法比较繁琐，我选择的是第二种方案。</p></li><li><p>改变<code>npm</code>默认的路径。</p><p>步骤如下：</p></li></ol><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">进入终端，依次输入一下命令<br>（<span class="hljs-number">1</span>）创建<span class="hljs-built_in">global</span>安装任务的目录<br>mkdir ~/.<span class="hljs-built_in">npm</span>-<span class="hljs-built_in">global</span><br>（<span class="hljs-number">2</span>）配置<span class="hljs-built_in">npm</span>使用新的目录<br><span class="hljs-built_in">npm</span> config set prefix <span class="hljs-string">&#x27;~/.npm-global&#x27;</span><br>（<span class="hljs-number">3</span>）在~/.profile文件中增加配置<br><span class="hljs-keyword">export</span> PATH=~/.<span class="hljs-built_in">npm</span>-<span class="hljs-built_in">global</span>/bin:$PATH<br>（<span class="hljs-number">4</span>）配置文件立即生效<br>source ~<span class="hljs-regexp">/.profile 注：我用的zsh,所以命令是（source ~/</span>.zshrc）<br>（<span class="hljs-number">5</span>）重新执行命令<br><span class="hljs-built_in">npm</span> install -g xxxx <br></code></pre></td></tr></table></figure><h2 id="2-通过npm安装主题在哪"><a href="#2-通过npm安装主题在哪" class="headerlink" title="2.通过npm安装主题在哪"></a>2.通过npm安装主题在哪</h2><ul><li>在博客文件夹的node_modules目录下</li></ul><h2 id="3-查看本地安装的所有npm包"><a href="#3-查看本地安装的所有npm包" class="headerlink" title="3. 查看本地安装的所有npm包"></a>3. 查看本地安装的所有npm包</h2><ol><li>查看</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">$ npm list -g --depth 0  // 若需要权限 请加上 sudo 命令<br></code></pre></td></tr></table></figure><ol start="2"><li>更新</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">$ npm update -g xxx<br></code></pre></td></tr></table></figure><ol start="3"><li>删除</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">$ npm uninstall -g xxx<br></code></pre></td></tr></table></figure><h1 id="将-Hexo-部署到-GitHub-Pages"><a href="#将-Hexo-部署到-GitHub-Pages" class="headerlink" title="将 Hexo 部署到 GitHub Pages"></a>将 Hexo 部署到 GitHub Pages</h1><p>Hexo 提供了快速方便的一键部署功能，让您只需一条命令就能将网站部署到服务器上。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>hexo deploy<br></code></pre></td></tr></table></figure><p>在开始之前，您必须先在 <code>_config.yml</code> 中修改参数，一个正确的部署配置中至少要有 <code>type</code> 参数，例如：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br></code></pre></td></tr></table></figure><p>您可同时使用多个 deployer，Hexo 会依照顺序执行每个 deployer。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repo:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">type:</span> <span class="hljs-string">heroku</span><br>  <span class="hljs-attr">repo:</span><br></code></pre></td></tr></table></figure><p>Refer to the <a href="https://hexo.io/plugins/">Plugins</a> list for more deployment plugins.</p><blockquote><p>缩进</p><p>YAML依靠缩进来确定元素间的从属关系。因此，请确保每个deployer的缩进长度相同，并且使用空格缩进。</p></blockquote><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><ol><li>安装 <a href="https://github.com/hexojs/hexo-deployer-git">hexo-deployer-git</a>。</li></ol><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">$ npm install hexo-deployer-git <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><ol><li>修改配置。</li></ol><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repo:</span> <span class="hljs-params">&lt;repository url&gt;</span> <span class="hljs-meta">#https:<span class="hljs-comment">//bitbucket.org/JohnSmith/johnsmith.bitbucket.io</span></span><br><span class="hljs-symbol">  branch:</span> [branch]<br><span class="hljs-symbol">  message:</span> [message]<br></code></pre></td></tr></table></figure><table><thead><tr><th align="left">参数</th><th align="left">描述</th><th align="left">默认</th></tr></thead><tbody><tr><td align="left"><code>repo</code></td><td align="left">库（Repository）地址</td><td align="left"></td></tr><tr><td align="left"><code>branch</code></td><td align="left">分支名称</td><td align="left"><code>gh-pages</code> (GitHub) <code>coding-pages</code> (Coding.net) <code>master</code> (others)</td></tr><tr><td align="left"><code>message</code></td><td align="left">自定义提交信息</td><td align="left"><code>Site updated: &#123;&#123; now('YYYY-MM-DD HH:mm:ss') &#125;&#125;</code>)</td></tr><tr><td align="left"><code>token</code></td><td align="left">Optional token value to authenticate with the repo. Prefix with <code>$</code> to read token from environment variable</td><td align="left"></td></tr></tbody></table><ol><li>生成站点文件并推送至远程库。执行 <code>hexo clean &amp;&amp; hexo deploy</code>。</li></ol><ul><li>You will be prompted with username and password of the target repository, unless you authenticate with a token or ssh key.</li><li>hexo-deployer-git does not store your username and password. Use <a href="https://git-scm.com/docs/git-credential-cache">git-credential-cache</a> to store them temporarily.</li></ul><ol><li>登入 Github/BitBucket/Gitlab，请在库设置（Repository Settings）中将默认分支设置为<code>_config.yml</code>配置中的分支名称。稍等片刻，您的站点就会显示在您的Github Pages中。</li></ol><h3 id="这一切是如何发生的？"><a href="#这一切是如何发生的？" class="headerlink" title="这一切是如何发生的？"></a>这一切是如何发生的？</h3><p>当执行 <code>hexo deploy</code> 时，Hexo 会将 <code>public</code> 目录中的文件和目录推送至 <code>_config.yml</code> 中指定的远端仓库和分支中，并且<strong>完全覆盖</strong>该分支下的已有内容。</p><blockquote><p>For 使用 Git 管理站点目录的用户</p><p>由于 Hexo 的部署默认使用分支 <code>master</code>，所以如果你同时正在使用 Git 管理你的站点目录，你应当注意你的部署分支应当不同于写作分支。<br>一个好的实践是将站点目录和 Pages 分别存放在两个不同的 Git 仓库中，可以有效避免相互覆盖。<br>Hexo 在部署你的站点生成的文件时并不会更新你的站点目录。因此你应该手动提交并推送你的写作分支。</p></blockquote><p>此外，如果您的 Github Pages 需要使用 CNAME 文件<strong>自定义域名</strong>，请将 CNAME 文件置于 <code>source</code> 目录下，只有这样 <code>hexo deploy</code> 才能将 CNAME 文件一并推送至部署分支。</p><h2 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h2><p>Hexo 生成的所有文件都放在 <code>public</code> 文件夹中，您可以将它们复制到您喜欢的地方。</p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><ol><li>安装 <a href="https://github.com/hexojs/hexo-deployer-git">hexo-deployer-git</a>.</li><li>在 <strong>_config.yml</strong>（如果有已存在的请删除）添加如下配置：</li></ol><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repo:</span> https:<span class="hljs-comment">//github.com/&lt;username&gt;/&lt;project&gt;</span><br>  <span class="hljs-meta"># example, https:<span class="hljs-comment">//github.com/hexojs/hexojs.github.io</span></span><br><span class="hljs-symbol">  branch:</span> gh-pages<br></code></pre></td></tr></table></figure><ol><li>运行 <code>hexo clean &amp;&amp; hexo deploy</code> 。</li><li>查看 <em>username</em>.github.io 上的网页是否部署成功。</li></ol><h1 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h1><h2 id="init"><a href="#init" class="headerlink" title="init"></a>init</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">$ hexo <span class="hljs-keyword">init</span> [folder]<br></code></pre></td></tr></table></figure><p>新建一个网站。如果没有设置 <code>folder</code> ，Hexo 默认在目前的文件夹建立网站。</p><p>本命令相当于执行了以下几步：</p><ol><li>Git clone <a href="https://github.com/hexojs/hexo-starter">hexo-starter</a> 和 <a href="https://github.com/hexojs/hexo-theme-landscape">hexo-theme-landscape</a> 主题到当前目录或指定目录。</li><li>使用 <a href="https://classic.yarnpkg.com/lang/en/">Yarn 1</a>、<a href="https://pnpm.js.org/">pnpm</a> 或 <a href="https://docs.npmjs.com/cli/install">npm</a> 包管理器下载依赖（如有已安装多个，则列在前面的优先）。npm 默认随 <a href="https://hexo.io/docs/#Install-Node-js">Node.js</a> 安装。</li></ol><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss">$ hexo <span class="hljs-keyword">new</span> [layout] &lt;<span class="hljs-built_in">title</span>&gt;<br></code></pre></td></tr></table></figure><p>新建一篇文章。如果没有设置 <code>layout</code> 的话，默认使用 <a href="https://hexo.io/zh-cn/docs/configuration">_config.yml</a> 中的 <code>default_layout</code> 参数代替。如果标题包含空格的话，请使用引号括起来。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">$ hexo <span class="hljs-keyword">new</span> <span class="hljs-string">&quot;post title with whitespace&quot;</span><br></code></pre></td></tr></table></figure><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-p</code>, <code>--path</code></td><td align="left">自定义新文章的路径</td></tr><tr><td align="left"><code>-r</code>, <code>--replace</code></td><td align="left">如果存在同名文章，将其替换</td></tr><tr><td align="left"><code>-s</code>, <code>--slug</code></td><td align="left">文章的 Slug，作为新文章的文件名和发布后的 URL</td></tr></tbody></table><p>默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 <code>index.md</code> 文件。你可以使用 <code>--path</code> 参数来覆盖上述行为、自行决定文件的目录：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">hexo <span class="hljs-keyword">new</span> <span class="hljs-type">page</span> --path about/me <span class="hljs-string">&quot;About me&quot;</span><br></code></pre></td></tr></table></figure><p>以上命令会创建一个 <code>source/about/me.md</code> 文件，同时 Front Matter 中的 title 为 <code>&quot;About me&quot;</code></p><p>注意！title 是必须指定的！如果你这么做并不能达到你的目的：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">hexo <span class="hljs-keyword">new</span> page <span class="hljs-comment">--path about/me</span><br></code></pre></td></tr></table></figure><p>此时 Hexo 会创建 <code>source/_posts/about/me.md</code>，同时 <code>me.md</code> 的 Front Matter 中的 title 为 <code>&quot;page&quot;</code>。这是因为在上述命令中，hexo-cli 将 <code>page</code> 视为指定文章的标题、并采用默认的 <code>layout</code>。</p><h2 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h2><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog">$ hexo <span class="hljs-keyword">generate</span><br></code></pre></td></tr></table></figure><p>生成静态文件。</p><table><thead><tr><th align="left">选项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-d</code>, <code>--deploy</code></td><td align="left">文件生成后立即部署网站</td></tr><tr><td align="left"><code>-w</code>, <code>--watch</code></td><td align="left">监视文件变动</td></tr><tr><td align="left"><code>-b</code>, <code>--bail</code></td><td align="left">生成过程中如果发生任何未处理的异常则抛出异常</td></tr><tr><td align="left"><code>-f</code>, <code>--force</code></td><td align="left">强制重新生成文件 Hexo 引入了差分机制，如果 <code>public</code> 目录存在，那么 <code>hexo g</code> 只会重新生成改动的文件。 使用该参数的效果接近 <code>hexo clean &amp;&amp; hexo generate</code></td></tr><tr><td align="left"><code>-c</code>, <code>--concurrency</code></td><td align="left">最大同时生成文件的数量，默认无限制</td></tr></tbody></table><p>该命令可以简写为</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>hexo g<br></code></pre></td></tr></table></figure><h2 id="publish"><a href="#publish" class="headerlink" title="publish"></a>publish</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">$ hexo publish [layout] <span class="hljs-tag">&lt;<span class="hljs-name">filename</span>&gt;</span><br></code></pre></td></tr></table></figure><p>发表草稿。</p><h2 id="server"><a href="#server" class="headerlink" title="server"></a>server</h2><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">$ hexo <span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><p>启动服务器。默认情况下，访问网址为： <code>http://localhost:4000/</code>。</p><table><thead><tr><th align="left">选项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-p</code>, <code>--port</code></td><td align="left">重设端口</td></tr><tr><td align="left"><code>-s</code>, <code>--static</code></td><td align="left">只使用静态文件</td></tr><tr><td align="left"><code>-l</code>, <code>--log</code></td><td align="left">启动日记记录，使用覆盖记录格式</td></tr></tbody></table><h2 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h2><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>hexo deploy<br></code></pre></td></tr></table></figure><p>部署网站。</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-g</code>, <code>--generate</code></td><td align="left">部署之前预先生成静态文件</td></tr></tbody></table><p>该命令可以简写为：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>hexo d<br></code></pre></td></tr></table></figure><h2 id="render"><a href="#render" class="headerlink" title="render"></a>render</h2><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs prolog">$ hexo render &lt;file1&gt; [file2] ...<br></code></pre></td></tr></table></figure><p>渲染文件。</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-o</code>, <code>--output</code></td><td align="left">设置输出路径</td></tr></tbody></table><h2 id="migrate"><a href="#migrate" class="headerlink" title="migrate"></a>migrate</h2><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm">$ hexo migrate &lt;<span class="hljs-keyword">type</span>&gt;<br></code></pre></td></tr></table></figure><p>从其他博客系统 <a href="https://hexo.io/zh-cn/docs/migration">迁移内容</a>。</p><h2 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h2><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>hexo clean<br></code></pre></td></tr></table></figure><p>清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。</p><p>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p><h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm">$ hexo list &lt;<span class="hljs-keyword">type</span>&gt;<br></code></pre></td></tr></table></figure><p>列出网站资料。</p><h2 id="version"><a href="#version" class="headerlink" title="version"></a>version</h2><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">$ hexo <span class="hljs-built_in">version</span><br></code></pre></td></tr></table></figure><p>显示 Hexo 版本。</p><h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><p>其实第三条的 hexo d 就是部署网站命令，d是deploy的缩写。完成后，打开浏览器，在地址栏输入你的放置个人网站的仓库路径，即” <a href="http://xxxx.github.io&quot;,就可以看到你的博客,使用hexo/">http://xxxx.github.io&quot;,就可以看到你的博客,使用Hexo</a> Admin 插件写博客, <a href="%E2%80%9Dhttps://jaredforsyth.com/hexo-admin/%22">官网链接:</a><br>    安装方法<br>    第一步:下载启动</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">npm install --save hexo-admin<br>hexo server -d<br>open http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">4000</span><span class="hljs-regexp">/admin/</span><br></code></pre></td></tr></table></figure><p>第二步：配置<br>在Hexo 全局配置文件_config.yml最后添加类似如下内容</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">admin</span>:<span class="hljs-string"></span><br>  <span class="hljs-attr">username</span>: <span class="hljs-string">AlexLin</span><br>  <span class="hljs-attr">password_hash</span>: <span class="hljs-string">be121740bf988b2225a313fa1f107ca1</span><br>  <span class="hljs-attr">secret</span>: <span class="hljs-string">your admin password</span><br><br><span class="hljs-attr">secret</span> :<span class="hljs-string">你的后台管理密码</span><br><span class="hljs-attr">password_hash</span>: <span class="hljs-string">用密码生成的哈希串.</span><br><span class="hljs-meta">若是部署到github</span> <span class="hljs-string">pages,,是不会上传hexo admin的,没有必要添加密码.</span><br></code></pre></td></tr></table></figure><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ul><li>hexo使用theme出现<code>“ &#123;% extends ‘_layout.swig‘ %&#125; &#123;% import ‘_macro/post.swig‘ as post_template %&#125;“</code>问题：</li></ul><p>​    原因是hexo在5.0之后把swig给删除了需要自己手动安装</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> i hexo-renderer-swig<br></code></pre></td></tr></table></figure><p>​    安装时有可能highlights提示版本过低。（install the latest v10 version of Highlight.js）</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> install highlight.js@latest<br></code></pre></td></tr></table></figure><h6 id="注-常用命令"><a href="#注-常用命令" class="headerlink" title="注: 常用命令"></a>注: 常用命令</h6><ul><li>想要删除hexo</li></ul><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">npm uninstall hexo-<span class="hljs-keyword">cli</span> -g<br></code></pre></td></tr></table></figure><p>文件夹中的blog，手动删除。<br>另外，进行重装之前，如果还是在原来位置，必须手动清理了才能迁移安装。  </p><ul><li>其他常用的Hexo 命令  </li></ul><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs axapta">npm install hexo -g <span class="hljs-meta">#安装Hexo</span><br>npm update hexo -g <span class="hljs-meta">#升级  </span><br>hexo init <span class="hljs-meta">#初始化博客  </span><br>hexo n <span class="hljs-string">&quot;我的博客&quot;</span> == hexo <span class="hljs-keyword">new</span> <span class="hljs-string">&quot;我的博客&quot;</span> <span class="hljs-meta">#新建文章(在/source/_posts文件夹中创建)  </span><br>hexo g == hexo generate <span class="hljs-meta">#生成  </span><br>hexo s == hexo <span class="hljs-keyword">server</span> <span class="hljs-meta">#本地部署, 启动服务预览  </span><br>hexo d == hexo deploy <span class="hljs-meta">#部署,部署到github等  </span><br>hexo <span class="hljs-keyword">server</span> <span class="hljs-meta">#Hexo会监视文件变动并自动更新，无须重启服务器  </span><br>hexo <span class="hljs-keyword">server</span> -s <span class="hljs-meta">#静态模式  </span><br>hexo <span class="hljs-keyword">server</span> -p <span class="hljs-number">5000</span> <span class="hljs-meta">#更改端口  </span><br>hexo <span class="hljs-keyword">server</span> -i <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span> <span class="hljs-meta">#自定义 IP  </span><br>hexo clean <span class="hljs-meta">#清除缓存，若是网页正常情况下可以忽略这条命令,清除缓存文件为了避免不必要的错误，在生成静态文件前，强烈建议先运行此命令.它会清除本地站点文件夹下的缓存文件（db.json）和已有的静态文件（public)  </span><br><br>注: 修改配置后,需要 “hexo g”重新生成 . 若是修改了themes的配置 , 可以不用重新生成,直接F5刷新浏览器页面就可以预览.<br>对于上面的两种常用命令, hexo提供了简写 hexo s -g(生成并预览)和hexo g -d(生成并远程部署)  <br></code></pre></td></tr></table></figure><ul><li>完善配置文件  </li></ul><p><a href="%22https://hexo.io/zh-cn/docs/configuration%22">官网链接</a><br>修改hexo的根文件夹里的_config.yml :  </p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs vbnet">先修改<br><span class="hljs-symbol">title:</span> <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-symbol">subtitle:</span> <span class="hljs-comment">&#x27;&#x27;</span><br><span class="hljs-symbol">description:</span> <span class="hljs-comment">&#x27;&#x27;</span><br><span class="hljs-symbol">keywords:</span><br><span class="hljs-symbol">author:</span>  <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-symbol">language:</span> zh-CN #此项注意, language文件夹里可能没有zh-Han , 但是由zh-CN .  <br><span class="hljs-symbol">url:</span><span class="hljs-string">&quot;此处修改为自己的网址&quot;</span><br>主题  <br><span class="hljs-symbol">theme:</span> 修改为themes文件夹下的主题名称<br></code></pre></td></tr></table></figure><p>使用init命令后,有如下文件夹  </p><pre><code>.├── _config.yml├── package.json├── scaffolds├── source|   ├── _drafts|   └── _posts└── themes</code></pre><ol><li>node_modules 是node.js各种库的目录  </li><li>public是生成的网页文件目录  </li><li>Scaffold(模版文件夹)<br>在新建文章时，Hexo 会根据 scaffolds 文件夹内相对应的文件来建立文件.<br>Hexo的模板是指在新建的markdown文件中默认填充的内容。<br>例如，如果修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。也就是说，通过hexo命令每新建一个文章，都会包含指定模板文件中的内容。  </li><li>Cource<br>资源文件夹是存放用户资源的地方，如markdown文章。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去.<br>注意：除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略.  </li><li>themes<br>主题文件夹。Hexo 会根据主题来解析source目录中的markdown文件生成静态页面。官网主题详述</li><li>package.json<br>应用程序的信息，以及需要安装的模块信息</li></ol><ul><li>写作,可以执行下列命令来创建一篇新文章。  </li></ul><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss">$ hexo <span class="hljs-keyword">new</span> [layout] &lt;<span class="hljs-built_in">title</span>&gt;<br></code></pre></td></tr></table></figure><p>可以在命令中指定文章的布局（layout），不指定默认为 post，也可以通过修改 _config.yml 中的 default_layout 参数来指定默认布局。创建的新文章会自动加上指定布局对应的模板文件中的内容。 </p><ul><li><p>布局<br>Hexo 有三种默认布局（Layout）：post、page 和 draft，它们分别对应不同的路径，而自定义的其他布局和 post 相同，都将储存到 source/_posts 文件夹.<br>如果你不想你的文章被处理，你可以将 Front-Matter 中的layout: 设为 false  </p></li><li><p>模板<br>例如  </p></li></ul><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">$ hexo <span class="hljs-keyword">new</span> <span class="hljs-type">photo</span> <span class="hljs-string">&quot;My Gallery&quot;</span><br></code></pre></td></tr></table></figure><p>在执行这行指令时，Hexo 会尝试在 scaffolds 文件夹中寻找 photo.md，并根据其内容建立文章. 以下是您可以在模版中使用的变量：<br>变量描述 :<br><code>layout</code>布局<br><code>title</code>标题<br><code>date</code>文件建立日期  </p><ul><li>Front-matter<br>Front-matter是文件最上方以 — 分隔的区域，用于指定个别文件的变量，举例来说：</li></ul><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs applescript"> <span class="hljs-comment">---</span><br>title: Hello World<br><span class="hljs-built_in">date</span>: <span class="hljs-number">2013</span>/<span class="hljs-number">7</span>/<span class="hljs-number">13</span> <span class="hljs-number">20</span>:<span class="hljs-number">46</span>:<span class="hljs-number">25</span><br> <span class="hljs-comment">---</span><br></code></pre></td></tr></table></figure><p><code>注意：一般Front-matter使用的yaml语法，yaml语法需要注意空格，如title: Hello World冒号需要有一个空格，当然除YAML 外，你也可以使用 JSON 来编写 Front-matter。</code></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>java注解-网络博客</title>
    <link href="/2021/12/23/java%E6%B3%A8%E8%A7%A3-%E7%BD%91%E7%BB%9C%E5%8D%9A%E5%AE%A2/"/>
    <url>/2021/12/23/java%E6%B3%A8%E8%A7%A3-%E7%BD%91%E7%BB%9C%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a><strong>一、<a href="https://www.baeldung.com/java-annotation-processing-builder">介绍</a></strong></h2><p>本文<strong>介绍了 Java 源代码级别的注释处理，</strong>并提供了使用此技术在编译期间生成其他源文件的示例。</p><h2 id="2-注解处理的应用"><a href="#2-注解处理的应用" class="headerlink" title="2.注解处理的应用"></a><strong>2.注解处理的应用</strong></h2><p>源代码级注释处理首先出现在 Java 5 中。它是一种在编译阶段生成额外源文件的便捷技术。</p><p>源文件不必是 Java 文件——您可以根据源代码中的注释生成任何类型的描述、元数据、文档、资源或任何其他类型的文件。</p><p>注释处理在许多无处不在的 Java 库中被积极使用，例如，在 QueryDSL 和 JPA 中生成元类，在 Lombok 库中使用样板代码扩充类。</p><p>需要注意的重要一点是<strong>注解处理 API 的局限性——它只能用于生成新文件，不能用于更改现有文件</strong>。</p><p>值得注意的例外是<a href="https://projectlombok.org/">Lombok</a>库，它使用注解处理作为引导机制将自身包含到编译过程中并通过一些内部编译器 API 修改 AST。这种 hacky 技术与注释处理的预期目的无关，因此不在本文中讨论。</p><h2 id="3-注解处理API"><a href="#3-注解处理API" class="headerlink" title="3.注解处理API"></a><strong>3.注解处理API</strong></h2><p>注释处理分多轮完成。每一轮都从编译器开始搜索源文件中的注释并选择适合这些注释的注释处理器。依次在相应的源上调用每个注释处理器。</p><p>如果在此过程中生成了任何文件，则以生成的文件作为其输入开始另一轮。这个过程一直持续到在处理阶段没有新文件产生。</p><p>依次在相应的源上调用每个注释处理器。如果在此过程中生成了任何文件，则以生成的文件作为其输入开始另一轮。这个过程一直持续到在处理阶段没有新文件产生。</p><p>注释处理 API 位于<em>javax.annotation.processing</em>包中。您必须实现的主要接口是<em>Processor</em>接口，它具有<em>AbstractProcessor</em>类形式的部分实现。这个类是我们将要扩展以创建我们自己的注释处理器的类。</p><h2 id="4-设置项目"><a href="#4-设置项目" class="headerlink" title="4. 设置项目"></a><strong>4. 设置项目</strong></h2><p>为了演示注释处理的可能性，我们将开发一个简单的处理器来为带注释的类生成流畅的对象构建器。</p><p>我们将把我们的项目分成两个 Maven 模块。其中一个，<em>注释处理器</em>模块，将包含处理器本身和注释，另一个，<em>注释用户</em>模块，将包含被注释的类。这是注释处理的典型用例。</p><p><em>annotation-processor</em>模块的设置如下。我们将使用 Google 的<a href="https://github.com/google/auto/tree/master/service">自动服务</a>库来生成稍后将讨论的处理器元数据文件，以及针对 Java 8 源代码调整的<em>maven-compiler-plugin</em>。这些依赖项的版本被提取到属性部分。</p><p>最新版本的[自动服务](<a href="https://search.maven.org/classic/#search|gav|1|g%3A&quot;com.google.auto.service&quot;">https://search.maven.org/classic/#search|gav|1|g%3A&quot;com.google.auto.service&quot;</a> AND a%3A”auto-service”)库和[maven-compiler-plugin](<a href="https://search.maven.org/classic/#search|gav|1|g%3A&quot;org.apache.maven.plugins&quot;">https://search.maven.org/classic/#search|gav|1|g%3A&quot;org.apache.maven.plugins&quot;</a> AND a%3A”maven-compiler-plugin”)可以在 Maven 中央存储库中找到：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">auto-service.version</span>&gt;</span>1.0-rc2<span class="hljs-tag">&lt;/<span class="hljs-name">auto-service.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">maven-compiler-plugin.version</span>&gt;</span><br>      3.5.1<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">maven-compiler-plugin.version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.auto.service<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>auto-service<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;auto-service.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;maven-compiler-plugin.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><p>带有注释源的<em>annotation-user</em> Maven 模块不需要任何特殊调整，除了在依赖项部分添加对 annotation-processor 模块的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baeldung<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>annotation-processing<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="5-定义注释"><a href="#5-定义注释" class="headerlink" title="5. 定义注释"></a><strong>5. 定义注释</strong></h2><p>假设我们的<em>annotation-user</em>模块中有一个简单的 POJO 类，其中包含几个字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-comment">// getters and setters …</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>我们想创建一个构建器助手类来更流畅地实例化<em>Person</em>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Person person = <span class="hljs-keyword">new</span> PersonBuilder()<br>  .setAge(<span class="hljs-number">25</span>)<br>  .setName(<span class="hljs-string">&quot;John&quot;</span>)<br>  .build();<br></code></pre></td></tr></table></figure><p>这个<em>PersonBuilder</em>类是一代的明显选择，因为它的结构完全由<em>Person</em> setter 方法定义。</p><p>让我们在<em>注释处理器</em>模块中为 setter 方法创建一个*@BuilderProperty<em>注释。它将允许我们为每个注释了 setter 方法的类生成</em>Builder*类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> BuilderProperty &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>带有<em>ElementType.METHOD</em>参数的*@Target*注解确保此注解只能放在一个方法上。</p><p>在<em>SOURCE</em>保留策略的手段，这个注释是唯一可用的源处理过程中，而不是在运行时可用。</p><p>带有*@BuilderProperty<em>注解的属性的</em>Person*类将如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-meta">@BuilderProperty</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-meta">@BuilderProperty</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-comment">// getters …</span><br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-实现-处理器"><a href="#6-实现-处理器" class="headerlink" title="6. 实现*处理器*"></a><strong>6. 实现*处理器*</strong></h2><h3 id="6-1-创建一个-AbstractProcessor-子类"><a href="#6-1-创建一个-AbstractProcessor-子类" class="headerlink" title="6.1. 创建一个*AbstractProcessor*子类"></a><strong>6.1. 创建一个*AbstractProcessor*子类</strong></h3><p>我们将从在<em>注释处理器</em>Maven 模块中扩展<em>AbstractProcessor</em>类开始。</p><p>首先，我们应该指定该处理器能够处理的注释，以及支持的源代码版本。这可以通过实施方法进行<em>getSupportedAnnotationTypes</em>和<em>getSupportedSourceVersion</em>的的<em>处理器</em>接口或通过注释你的类*@SupportedAnnotationTypes<em>和</em>@SupportedSourceVersion*注解。</p><p>所述*@AutoService<em>注释是的一部分</em>自动服务*库，并允许生成，这将在下面的章节进行说明处理器的元数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SupportedAnnotationTypes(</span><br><span class="hljs-meta">  &quot;com.baeldung.annotation.processor.BuilderProperty&quot;)</span><br><span class="hljs-meta">@SupportedSourceVersion(SourceVersion.RELEASE_8)</span><br><span class="hljs-meta">@AutoService(Processor.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BuilderProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractProcessor</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">process</span><span class="hljs-params">(Set&lt;? extends TypeElement&gt; annotations, </span></span><br><span class="hljs-params"><span class="hljs-function">      RoundEnvironment roundEnv)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>您不仅可以指定具体的注释类名称，还可以指定通配符，例如<em>“com.baeldung.annotation.*”</em>来处理<em>com.baeldung.annotation</em>包及其所有子包中的注释，甚至可以<em>“*”</em>来处理所有注释.</p><p>我们必须实现的单一方法是处理本身的<em>process</em>方法。编译器为每个包含匹配注释的源文件调用它。</p><p>注释作为第一个<em>Set&lt;? extends TypeElement&gt; annotations</em>参数，有关当前处理轮次的信息作为<em>RoundEnviroment roundEnv</em>参数传递。</p><p>如果您的注释处理器已经处理了所有传递的注释，并且您不希望它们被传递到列表中的其他注释处理器，则返回<em>布尔</em>值应该为<em>true</em>。</p><h3 id="6-2-收集数据"><a href="#6-2-收集数据" class="headerlink" title="6.2. 收集数据"></a><strong>6.2. 收集数据</strong></h3><p>我们的处理器还没有真正做任何有用的事情，所以让我们用代码填充它。</p><p>首先，我们需要遍历在类中找到的所有注释类型——在我们的例子中，<em>注释</em>集将有一个与*@BuilderProperty*注释相对应的元素，即使这个注释在源文件中多次出现。</p><p>尽管如此，为了完整起见，最好将<em>process</em>方法实现为迭代周期：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">process</span><span class="hljs-params">(Set&lt;? extends TypeElement&gt; annotations, </span></span><br><span class="hljs-params"><span class="hljs-function">  RoundEnvironment roundEnv)</span> </span>&#123;<br><br>    <span class="hljs-keyword">for</span> (TypeElement annotation : annotations) &#123;<br>        Set&lt;? extends Element&gt; annotatedElements <br>          = roundEnv.getElementsAnnotatedWith(annotation);<br>        <br>        <span class="hljs-comment">// …</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在此代码中，我们使用<em>RoundEnvironment</em>实例接收所有使用*@BuilderProperty<em>注释的元素。对于</em>Person<em>类，这些元素对应于</em>setName<em>和</em>setAge*方法。</p><p><em>@BuilderProperty</em>注释的用户可能会错误地注释实际上不是 setter 的方法。setter 方法名称应以<em>set</em>开头，并且该方法应接收单个参数。所以让我们把小麦和谷壳分开。</p><p>在以下代码中，我们使用*Collectors.partitioningBy()*收集器将带注释的方法拆分为两个集合：正确注释的 setter 和其他错误注释的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;Boolean, List&lt;Element&gt;&gt; annotatedMethods = annotatedElements.stream().collect(<br>  Collectors.partitioningBy(element -&gt;<br>    ((ExecutableType) element.asType()).getParameterTypes().size() == <span class="hljs-number">1</span><br>    &amp;&amp; element.getSimpleName().toString().startsWith(<span class="hljs-string">&quot;set&quot;</span>)));<br><br>List&lt;Element&gt; setters = annotatedMethods.get(<span class="hljs-keyword">true</span>);<br>List&lt;Element&gt; otherMethods = annotatedMethods.get(<span class="hljs-keyword">false</span>);<br></code></pre></td></tr></table></figure><p>在这里，我们使用<em>Element.asType()<em>方法来接收</em>TypeMirror</em>类的实例，即使我们仅处于源处理阶段，它也为我们提供了一些内省类型的能力。</p><p>我们应该警告用户有关错误注释的方法，因此让我们使用可从<em>AbstractProcessor.processingEnv</em>保护字段访问的<em>Messager</em>实例。以下几行将在源处理阶段为每个错误注释的元素输出错误：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">otherMethods.forEach(element -&gt;<br>  processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,<br>    <span class="hljs-string">&quot;@BuilderProperty must be applied to a setXxx method &quot;</span> <br>      + <span class="hljs-string">&quot;with a single argument&quot;</span>, element));<br></code></pre></td></tr></table></figure><p>当然，如果正确的 setters 集合为空，则继续当前类型元素集合迭代是没有意义的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (setters.isEmpty()) &#123;<br>    <span class="hljs-keyword">continue</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果 setter 集合至少有一个元素，我们将使用它从封闭元素中获取完全限定的类名，在 setter 方法的情况下，它似乎是源类本身：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">String className = ((TypeElement) setters.get(<span class="hljs-number">0</span>)<br>  .getEnclosingElement()).getQualifiedName().toString();<br></code></pre></td></tr></table></figure><p>生成构建器类所需的最后一点信息是 setter 名称与其参数类型名称之间的映射：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;String, String&gt; setterMap = setters.stream().collect(Collectors.toMap(<br>    setter -&gt; setter.getSimpleName().toString(),<br>    setter -&gt; ((ExecutableType) setter.asType())<br>      .getParameterTypes().get(<span class="hljs-number">0</span>).toString()<br>));<br></code></pre></td></tr></table></figure><h3 id="6-3-生成输出文件"><a href="#6-3-生成输出文件" class="headerlink" title="6.3. 生成输出文件"></a><strong>6.3. 生成输出文件</strong></h3><p>现在我们有了生成构建器类所需的所有信息：源类的名称、它的所有 setter 名称以及它们的参数类型。</p><p>为了生成输出文件，我们将使用<em>AbstractProcessor.processingEnv</em>受保护属性中的对象再次提供的<em>Filer</em>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">JavaFileObject builderFile = processingEnv.getFiler()<br>  .createSourceFile(builderClassName);<br><span class="hljs-keyword">try</span> (PrintWriter out = <span class="hljs-keyword">new</span> PrintWriter(builderFile.openWriter())) &#123;<br>    <span class="hljs-comment">// writing generated file to out …</span><br>&#125;<br></code></pre></td></tr></table></figure><p>下面提供了<em>writeBuilderFile</em>方法的完整代码。我们只需要计算源类和构建器类的包名、完全限定的构建器类名和简单类名。其余的代码非常简单。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeBuilderFile</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  String className, Map&lt;String, String&gt; setterMap)</span> </span><br><span class="hljs-function">  <span class="hljs-keyword">throws</span> IOException </span>&#123;<br><br>    String packageName = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">int</span> lastDot = className.lastIndexOf(<span class="hljs-string">&#x27;.&#x27;</span>);<br>    <span class="hljs-keyword">if</span> (lastDot &gt; <span class="hljs-number">0</span>) &#123;<br>        packageName = className.substring(<span class="hljs-number">0</span>, lastDot);<br>    &#125;<br><br>    String simpleClassName = className.substring(lastDot + <span class="hljs-number">1</span>);<br>    String builderClassName = className + <span class="hljs-string">&quot;Builder&quot;</span>;<br>    String builderSimpleClassName = builderClassName<br>      .substring(lastDot + <span class="hljs-number">1</span>);<br><br>    JavaFileObject builderFile = processingEnv.getFiler()<br>      .createSourceFile(builderClassName);<br>    <br>    <span class="hljs-keyword">try</span> (PrintWriter out = <span class="hljs-keyword">new</span> PrintWriter(builderFile.openWriter())) &#123;<br><br>        <span class="hljs-keyword">if</span> (packageName != <span class="hljs-keyword">null</span>) &#123;<br>            out.print(<span class="hljs-string">&quot;package &quot;</span>);<br>            out.print(packageName);<br>            out.println(<span class="hljs-string">&quot;;&quot;</span>);<br>            out.println();<br>        &#125;<br><br>        out.print(<span class="hljs-string">&quot;public class &quot;</span>);<br>        out.print(builderSimpleClassName);<br>        out.println(<span class="hljs-string">&quot; &#123;&quot;</span>);<br>        out.println();<br><br>        out.print(<span class="hljs-string">&quot;    private &quot;</span>);<br>        out.print(simpleClassName);<br>        out.print(<span class="hljs-string">&quot; object = new &quot;</span>);<br>        out.print(simpleClassName);<br>        out.println(<span class="hljs-string">&quot;();&quot;</span>);<br>        out.println();<br><br>        out.print(<span class="hljs-string">&quot;    public &quot;</span>);<br>        out.print(simpleClassName);<br>        out.println(<span class="hljs-string">&quot; build() &#123;&quot;</span>);<br>        out.println(<span class="hljs-string">&quot;        return object;&quot;</span>);<br>        out.println(<span class="hljs-string">&quot;    &#125;&quot;</span>);<br>        out.println();<br><br>        setterMap.entrySet().forEach(setter -&gt; &#123;<br>            String methodName = setter.getKey();<br>            String argumentType = setter.getValue();<br><br>            out.print(<span class="hljs-string">&quot;    public &quot;</span>);<br>            out.print(builderSimpleClassName);<br>            out.print(<span class="hljs-string">&quot; &quot;</span>);<br>            out.print(methodName);<br><br>            out.print(<span class="hljs-string">&quot;(&quot;</span>);<br><br>            out.print(argumentType);<br>            out.println(<span class="hljs-string">&quot; value) &#123;&quot;</span>);<br>            out.print(<span class="hljs-string">&quot;        object.&quot;</span>);<br>            out.print(methodName);<br>            out.println(<span class="hljs-string">&quot;(value);&quot;</span>);<br>            out.println(<span class="hljs-string">&quot;        return this;&quot;</span>);<br>            out.println(<span class="hljs-string">&quot;    &#125;&quot;</span>);<br>            out.println();<br>        &#125;);<br><br>        out.println(<span class="hljs-string">&quot;&#125;&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-运行示例"><a href="#7-运行示例" class="headerlink" title="7. 运行示例"></a><strong>7. 运行示例</strong></h2><p>要查看代码生成的运行情况，您应该从公共父根编译两个模块，或者首先编译<em>annotation-processor</em>模块，然后编译<em>annotation-user</em>模块。</p><p>生成的<em>PersonBuilder</em>类可以在<em>annotation-user/target/generated-sources/annotations/com/baeldung/annotation/PersonBuilder.java</em>文件中找到，应该如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.baeldung.annotation;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonBuilder</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Person object = <span class="hljs-keyword">new</span> Person();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Person <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> object;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PersonBuilder <span class="hljs-title">setName</span><span class="hljs-params">(java.lang.String value)</span> </span>&#123;<br>        object.setName(value);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PersonBuilder <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        object.setAge(value);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-注册处理器的其他方式"><a href="#8-注册处理器的其他方式" class="headerlink" title="8. 注册处理器的其他方式"></a><strong>8. 注册处理器的其他方式</strong></h2><p>要在编译阶段使用注释处理器，您还有其他几个选项，具体取决于您的用例和您使用的工具。</p><h3 id="8-1-使用注释处理器工具"><a href="#8-1-使用注释处理器工具" class="headerlink" title="8.1. 使用注释处理器工具"></a><strong>8.1. 使用注释处理器工具</strong></h3><p>该<em>贴切</em>工具是用于处理源文件一个特殊的命令行实用程序。它是 Java 5 的一部分，但从 Java 7 开始，它被弃用，取而代之的是其他选项，并在 Java 8 中完全删除。本文不会讨论它。</p><h3 id="8-2-使用编译器密钥"><a href="#8-2-使用编译器密钥" class="headerlink" title="8.2. 使用编译器密钥"></a><strong>8.2. 使用编译器密钥</strong></h3><p>该*-processor*编译器关键是一个标准的JDK设施，以增加编译器的源处理阶段，自己的注释处理器。</p><p>请注意，处理器本身和注释必须已经在单独的编译中编译为类并存在于类路径中，因此您应该做的第一件事是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">javac com/baeldung/annotation/processor/BuilderProcessor<br>javac com/baeldung/annotation/processor/BuilderProperty<br></code></pre></td></tr></table></figure><p>然后，您使用*-processor*键对您的源代码进行实际编译，指定您刚刚编译的注释处理器类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">javac -processor com.baeldung.annotation.processor.MyProcessor Person.java<br></code></pre></td></tr></table></figure><p>要一次性指定多个注释处理器，您可以用逗号分隔它们的类名，如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">javac -processor package1.Processor1,package2.Processor2 SourceFile.java<br></code></pre></td></tr></table></figure><h3 id="8-3-使用-Maven"><a href="#8-3-使用-Maven" class="headerlink" title="8.3. 使用 Maven"></a><strong>8.3. 使用 Maven</strong></h3><p>的<em>Maven的编译器插件</em>允许指定注释处理器作为其结构的一部分。</p><p>这是为编译器插件添加注释处理器的示例。您还可以使用<em>generateSourcesDirectory</em>配置参数指定将生成的源放入的目录。</p><p>请注意，<em>BuilderProcessor</em>类应该已经被编译，例如，从构建依赖项中的另一个 jar 导入：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">encoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">encoding</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">generatedSourcesDirectory</span>&gt;</span>$&#123;project.build.directory&#125;<br>                  /generated-sources/<span class="hljs-tag">&lt;/<span class="hljs-name">generatedSourcesDirectory</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">annotationProcessors</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">annotationProcessor</span>&gt;</span><br>                        com.baeldung.annotation.processor.BuilderProcessor<br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">annotationProcessor</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">annotationProcessors</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="8-4-将处理器-Jar-添加到类路径"><a href="#8-4-将处理器-Jar-添加到类路径" class="headerlink" title="8.4. 将处理器 Jar 添加到类路径"></a><strong>8.4. 将处理器 Jar 添加到类路径</strong></h3><p>您可以简单地将带有处理器类的特殊结构的 jar 添加到编译器的类路径中，而不是在编译器选项中指定注释处理器。</p><p>要自动选择它，编译器必须知道处理器类的名称。因此，您必须在<em>META-INF/services/javax.annotation.processing.Processor</em>文件中将其指定为处理器的完全限定类名：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">com.baeldung.annotation.processor.BuilderProcessor<br></code></pre></td></tr></table></figure><p>您还可以从这个 jar 中指定多个处理器，通过用新行分隔它们来自动拾取：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">package1.Processor1<br>package2.Processor2<br>package3.Processor3<br></code></pre></td></tr></table></figure><p>如果使用Maven构建这个jar，并尝试将这个文件直接放到<em>src/main/resources/META-INF/services</em>目录下，会遇到如下错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">[ERROR] Bad service configuration file, or exception thrown <span class="hljs-keyword">while</span> <br>constructing Processor object: javax.annotation.processing.Processor: <br>Provider com.baeldung.annotation.processor.BuilderProcessor not found<br></code></pre></td></tr></table></figure><p>这是因为当<em>BuilderProcessor</em>文件尚未编译时，编译器会在模块本身的<em>源代码处理</em>阶段尝试使用此文件。在 Maven 构建的资源复制阶段，该文件必须放在另一个资源目录中并复制到<em>META-INF/services</em>目录，或者（甚至更好）在构建期间生成。</p><p>下一节中讨论的 Google<em>自动服务</em>库允许使用简单的注释生成此文件。</p><h3 id="8-5-使用-Google“auto-service”库"><a href="#8-5-使用-Google“auto-service”库" class="headerlink" title="8.5. 使用 Google“auto service”库"></a><strong>8.5. 使用 Google“auto service”库</strong></h3><p>要自动生成注册文件，您可以使用Google 的<em>自动服务</em>库中的*@AutoService*注释，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AutoService(Processor.class)</span><br><span class="hljs-keyword">public</span> BuilderProcessor extends AbstractProcessor &#123;<br>    <span class="hljs-comment">// …</span><br>&#125;<br></code></pre></td></tr></table></figure><p>此注释本身由来自自动服务库的注释处理器处理。该处理器生成包含<em>BuilderProcessor</em>类名的<em>META-INF/services/javax.annotation.processing.Processor</em>文件。</p><h2 id="9-结论"><a href="#9-结论" class="headerlink" title="9. 结论"></a><strong>9. 结论</strong></h2><p>在本文中，我们使用为 POJO 生成 Builder 类的示例演示了源级注释处理。我们还提供了几种在您的项目中注册注释处理器的替代方法。</p><p>本文的源代码可<a href="https://github.com/eugenp/tutorials/tree/master/annotations">在 GitHub 上找到</a>。</p><h1 id="原文："><a href="#原文：" class="headerlink" title="原文："></a>原文：</h1><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a><strong>1. <a href="https://www.baeldung.com/java-annotation-processing-builder">Introduction</a></strong></h2><p>This article is <strong>an intro to Java source-level annotation processing</strong> and provides examples of using this technique for generating additional source files during compilation.</p><h2 id="2-Applications-of-Annotation-Processing"><a href="#2-Applications-of-Annotation-Processing" class="headerlink" title="2. Applications of Annotation Processing"></a><strong>2. Applications of Annotation Processing</strong></h2><p>The source-level annotation processing first appeared in Java 5. It is a handy technique for generating additional source files during the compilation stage.</p><p>The source files don’t have to be Java files — you can generate any kind of description, metadata, documentation, resources, or any other type of files, based on annotations in your source code.</p><p>Annotation processing is actively used in many ubiquitous Java libraries, for instance, to generate metaclasses in QueryDSL and JPA, to augment classes with boilerplate code in Lombok library.</p><p>An important thing to note is <strong>the limitation of the annotation processing API — it can only be used to generate new files, not to change existing ones</strong>.</p><p>The notable exception is the <a href="https://projectlombok.org/">Lombok</a> library which uses annotation processing as a bootstrapping mechanism to include itself into the compilation process and modify the AST via some internal compiler APIs. This hacky technique has nothing to do with the intended purpose of annotation processing and therefore is not discussed in this article.</p><h2 id="3-Annotation-Processing-API"><a href="#3-Annotation-Processing-API" class="headerlink" title="3. Annotation Processing API"></a><strong>3. Annotation Processing API</strong></h2><p>The annotation processing is done in multiple rounds. Each round starts with the compiler searching for the annotations in the source files and choosing the annotation processors suited for these annotations. Each annotation processor, in turn, is called on the corresponding sources.</p><p>If any files are generated during this process, another round is started with the generated files as its input. This process continues until no new files are generated during the processing stage.</p><p>Each annotation processor, in turn, is called on the corresponding sources. If any files are generated during this process, another round is started with the generated files as its input. This process continues until no new files are generated during the processing stage.</p><p>The annotation processing API is located in the <em>javax.annotation.processing</em> package. The main interface that you’ll have to implement is the <em>Processor</em> interface, which has a partial implementation in the form of <em>AbstractProcessor</em> class. This class is the one we’re going to extend to create our own annotation processor.</p><h2 id="4-Setting-Up-the-Project"><a href="#4-Setting-Up-the-Project" class="headerlink" title="4. Setting Up the Project"></a><strong>4. Setting Up the Project</strong></h2><p>To demonstrate the possibilities of annotation processing, we will develop a simple processor for generating fluent object builders for annotated classes.</p><p>We’re going to split our project into two Maven modules. One of them, <em>annotation-processor</em> module, will contain the processor itself together with the annotation, and another, the <em>annotation-user</em> module, will contain the annotated class. This is a typical use case of annotation processing.</p><p>The settings for the <em>annotation-processor</em> module are as follows. We’re going to use the Google’s <a href="https://github.com/google/auto/tree/master/service">auto-service</a> library to generate processor metadata file which will be discussed later, and the <em>maven-compiler-plugin</em> tuned for the Java 8 source code. The versions of these dependencies are extracted to the properties section.</p><p>Latest versions of the [auto-service](<a href="https://search.maven.org/classic/#search|gav|1|g%3A&quot;com.google.auto.service&quot;">https://search.maven.org/classic/#search|gav|1|g%3A&quot;com.google.auto.service&quot;</a> AND a%3A”auto-service”) library and [maven-compiler-plugin](<a href="https://search.maven.org/classic/#search|gav|1|g%3A&quot;org.apache.maven.plugins&quot;">https://search.maven.org/classic/#search|gav|1|g%3A&quot;org.apache.maven.plugins&quot;</a> AND a%3A”maven-compiler-plugin”) can be found in Maven Central repository:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">auto-service.version</span>&gt;</span>1.0-rc2<span class="hljs-tag">&lt;/<span class="hljs-name">auto-service.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">maven-compiler-plugin.version</span>&gt;</span><br>      3.5.1<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">maven-compiler-plugin.version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.auto.service<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>auto-service<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;auto-service.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;maven-compiler-plugin.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><p>The <em>annotation-user</em> Maven module with the annotated sources does not need any special tuning, except adding a dependency on the annotation-processor module in the dependencies section:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baeldung<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>annotation-processing<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="5-Defining-an-Annotation"><a href="#5-Defining-an-Annotation" class="headerlink" title="5. Defining an Annotation"></a><strong>5. Defining an Annotation</strong></h2><p>Suppose we have a simple POJO class in our <em>annotation-user</em> module with several fields:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-comment">// getters and setters …</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>We want to create a builder helper class to instantiate the <em>Person</em> class more fluently:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Person person = <span class="hljs-keyword">new</span> PersonBuilder()<br>  .setAge(<span class="hljs-number">25</span>)<br>  .setName(<span class="hljs-string">&quot;John&quot;</span>)<br>  .build();<br></code></pre></td></tr></table></figure><p>This <em>PersonBuilder</em> class is an obvious choice for a generation, as its structure is completely defined by the <em>Person</em> setter methods.</p><p>Let’s create a <em>@BuilderProperty</em> annotation in the <em>annotation-processor</em> module for the setter methods. It will allow us to generate the <em>Builder</em> class for each class that has its setter methods annotated:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> BuilderProperty &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>The <em>@Target</em> annotation with the <em>ElementType.METHOD</em> parameter ensures that this annotation can be only put on a method.</p><p>The <em>SOURCE</em> retention policy means that this annotation is only available during source processing and is not available at runtime.</p><p>The <em>Person</em> class with properties annotated with the <em>@BuilderProperty</em> annotation will look as follows:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-meta">@BuilderProperty</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-meta">@BuilderProperty</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-comment">// getters …</span><br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-Implementing-a-Processor"><a href="#6-Implementing-a-Processor" class="headerlink" title="6. Implementing a *Processor*"></a><strong>6. Implementing a *Processor*</strong></h2><h3 id="6-1-Creating-an-AbstractProcessor-Subclass"><a href="#6-1-Creating-an-AbstractProcessor-Subclass" class="headerlink" title="6.1. Creating an *AbstractProcessor* Subclass"></a><strong>6.1. Creating an *AbstractProcessor* Subclass</strong></h3><p>We’ll start with extending the <em>AbstractProcessor</em> class inside the <em>annotation-processor</em> Maven module.</p><p>First, we should specify annotations that this processor is capable of processing, and also the supported source code version. This can be done either by implementing the methods <em>getSupportedAnnotationTypes</em> and <em>getSupportedSourceVersion</em> of the <em>Processor</em> interface or by annotating your class with <em>@SupportedAnnotationTypes</em> and <em>@SupportedSourceVersion</em> annotations.</p><p>The <em>@AutoService</em> annotation is a part of the <em>auto-service</em> library and allows to generate the processor metadata which will be explained in the following sections.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SupportedAnnotationTypes(</span><br><span class="hljs-meta">  &quot;com.baeldung.annotation.processor.BuilderProperty&quot;)</span><br><span class="hljs-meta">@SupportedSourceVersion(SourceVersion.RELEASE_8)</span><br><span class="hljs-meta">@AutoService(Processor.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BuilderProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractProcessor</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">process</span><span class="hljs-params">(Set&lt;? extends TypeElement&gt; annotations, </span></span><br><span class="hljs-params"><span class="hljs-function">      RoundEnvironment roundEnv)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>You can specify not only the concrete annotation class names but also wildcards, like <em>“com.baeldung.annotation.*”</em> to process annotations inside the <em>com.baeldung.annotation</em> package and all its sub packages, or even <em>“*”</em> to process all annotations.</p><p>The single method that we’ll have to implement is the <em>process</em> method that does the processing itself. It is called by the compiler for every source file containing the matching annotations.</p><p>Annotations are passed as the first <em>Set&lt;? extends TypeElement&gt; annotations</em> argument, and the information about the current processing round is passed as the <em>RoundEnviroment roundEnv</em> argument.</p><p>The return <em>boolean</em> value should be <em>true</em> if your annotation processor has processed all the passed annotations, and you don’t want them to be passed to other annotation processors down the list.</p><h3 id="6-2-Gathering-Data"><a href="#6-2-Gathering-Data" class="headerlink" title="6.2. Gathering Data"></a><strong>6.2. Gathering Data</strong></h3><p>Our processor does not really do anything useful yet, so let’s fill it with code.</p><p>First, we’ll need to iterate through all annotation types that are found in the class — in our case, the <em>annotations</em> set will have a single element corresponding to the <em>@BuilderProperty</em> annotation, even if this annotation occurs multiple times in the source file.</p><p>Still, it’s better to implement the <em>process</em> method as an iteration cycle, for completeness sake:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">process</span><span class="hljs-params">(Set&lt;? extends TypeElement&gt; annotations, </span></span><br><span class="hljs-params"><span class="hljs-function">  RoundEnvironment roundEnv)</span> </span>&#123;<br><br>    <span class="hljs-keyword">for</span> (TypeElement annotation : annotations) &#123;<br>        Set&lt;? extends Element&gt; annotatedElements <br>          = roundEnv.getElementsAnnotatedWith(annotation);<br>        <br>        <span class="hljs-comment">// …</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>In this code, we use the <em>RoundEnvironment</em> instance to receive all elements annotated with the <em>@BuilderProperty</em> annotation. In the case of the <em>Person</em> class, these elements correspond to the <em>setName</em> and <em>setAge</em> methods.</p><p><em>@BuilderProperty</em> annotation’s user could erroneously annotate methods that are not actually setters. The setter method name should start with <em>set</em>, and the method should receive a single argument. So let’s separate the wheat from the chaff.</p><p>In the following code, we use the <em>Collectors.partitioningBy()</em> collector to split annotated methods into two collections: correctly annotated setters and other erroneously annotated methods:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;Boolean, List&lt;Element&gt;&gt; annotatedMethods = annotatedElements.stream().collect(<br>  Collectors.partitioningBy(element -&gt;<br>    ((ExecutableType) element.asType()).getParameterTypes().size() == <span class="hljs-number">1</span><br>    &amp;&amp; element.getSimpleName().toString().startsWith(<span class="hljs-string">&quot;set&quot;</span>)));<br><br>List&lt;Element&gt; setters = annotatedMethods.get(<span class="hljs-keyword">true</span>);<br>List&lt;Element&gt; otherMethods = annotatedMethods.get(<span class="hljs-keyword">false</span>);<br></code></pre></td></tr></table></figure><p>Here we use the <em>Element.asType()</em> method to receive an instance of the <em>TypeMirror</em> class which gives us some ability to introspect types even though we are only at the source processing stage.</p><p>We should warn the user about incorrectly annotated methods, so let’s use the <em>Messager</em> instance accessible from the <em>AbstractProcessor.processingEnv</em> protected field. The following lines will output an error for each erroneously annotated element during the source processing stage:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">otherMethods.forEach(element -&gt;<br>  processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,<br>    <span class="hljs-string">&quot;@BuilderProperty must be applied to a setXxx method &quot;</span> <br>      + <span class="hljs-string">&quot;with a single argument&quot;</span>, element));<br></code></pre></td></tr></table></figure><p>Of course, if the correct setters collection is empty, there is no point of continuing the current type element set iteration:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (setters.isEmpty()) &#123;<br>    <span class="hljs-keyword">continue</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>If the setters collection has at least one element, we’re going to use it to get the fully qualified class name from the enclosing element, which in case of the setter method appears to be the source class itself:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">String className = ((TypeElement) setters.get(<span class="hljs-number">0</span>)<br>  .getEnclosingElement()).getQualifiedName().toString();<br></code></pre></td></tr></table></figure><p>The last bit of information we need to generate a builder class is a map between the names of the setters and the names of their argument types:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;String, String&gt; setterMap = setters.stream().collect(Collectors.toMap(<br>    setter -&gt; setter.getSimpleName().toString(),<br>    setter -&gt; ((ExecutableType) setter.asType())<br>      .getParameterTypes().get(<span class="hljs-number">0</span>).toString()<br>));<br></code></pre></td></tr></table></figure><h3 id="6-3-Generating-the-Output-File"><a href="#6-3-Generating-the-Output-File" class="headerlink" title="6.3. Generating the Output File"></a><strong>6.3. Generating the Output File</strong></h3><p>Now we have all the information we need to generate a builder class: the name of the source class, all its setter names, and their argument types.</p><p>To generate the output file, we’ll use the <em>Filer</em> instance provided again by the object in the <em>AbstractProcessor.processingEnv</em> protected property:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">JavaFileObject builderFile = processingEnv.getFiler()<br>  .createSourceFile(builderClassName);<br><span class="hljs-keyword">try</span> (PrintWriter out = <span class="hljs-keyword">new</span> PrintWriter(builderFile.openWriter())) &#123;<br>    <span class="hljs-comment">// writing generated file to out …</span><br>&#125;<br></code></pre></td></tr></table></figure><p>The complete code of the <em>writeBuilderFile</em> method is provided below. We only need to calculate the package name, fully qualified builder class name, and simple class names for the source class and the builder class. The rest of the code is pretty straightforward.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeBuilderFile</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  String className, Map&lt;String, String&gt; setterMap)</span> </span><br><span class="hljs-function">  <span class="hljs-keyword">throws</span> IOException </span>&#123;<br><br>    String packageName = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">int</span> lastDot = className.lastIndexOf(<span class="hljs-string">&#x27;.&#x27;</span>);<br>    <span class="hljs-keyword">if</span> (lastDot &gt; <span class="hljs-number">0</span>) &#123;<br>        packageName = className.substring(<span class="hljs-number">0</span>, lastDot);<br>    &#125;<br><br>    String simpleClassName = className.substring(lastDot + <span class="hljs-number">1</span>);<br>    String builderClassName = className + <span class="hljs-string">&quot;Builder&quot;</span>;<br>    String builderSimpleClassName = builderClassName<br>      .substring(lastDot + <span class="hljs-number">1</span>);<br><br>    JavaFileObject builderFile = processingEnv.getFiler()<br>      .createSourceFile(builderClassName);<br>    <br>    <span class="hljs-keyword">try</span> (PrintWriter out = <span class="hljs-keyword">new</span> PrintWriter(builderFile.openWriter())) &#123;<br><br>        <span class="hljs-keyword">if</span> (packageName != <span class="hljs-keyword">null</span>) &#123;<br>            out.print(<span class="hljs-string">&quot;package &quot;</span>);<br>            out.print(packageName);<br>            out.println(<span class="hljs-string">&quot;;&quot;</span>);<br>            out.println();<br>        &#125;<br><br>        out.print(<span class="hljs-string">&quot;public class &quot;</span>);<br>        out.print(builderSimpleClassName);<br>        out.println(<span class="hljs-string">&quot; &#123;&quot;</span>);<br>        out.println();<br><br>        out.print(<span class="hljs-string">&quot;    private &quot;</span>);<br>        out.print(simpleClassName);<br>        out.print(<span class="hljs-string">&quot; object = new &quot;</span>);<br>        out.print(simpleClassName);<br>        out.println(<span class="hljs-string">&quot;();&quot;</span>);<br>        out.println();<br><br>        out.print(<span class="hljs-string">&quot;    public &quot;</span>);<br>        out.print(simpleClassName);<br>        out.println(<span class="hljs-string">&quot; build() &#123;&quot;</span>);<br>        out.println(<span class="hljs-string">&quot;        return object;&quot;</span>);<br>        out.println(<span class="hljs-string">&quot;    &#125;&quot;</span>);<br>        out.println();<br><br>        setterMap.entrySet().forEach(setter -&gt; &#123;<br>            String methodName = setter.getKey();<br>            String argumentType = setter.getValue();<br><br>            out.print(<span class="hljs-string">&quot;    public &quot;</span>);<br>            out.print(builderSimpleClassName);<br>            out.print(<span class="hljs-string">&quot; &quot;</span>);<br>            out.print(methodName);<br><br>            out.print(<span class="hljs-string">&quot;(&quot;</span>);<br><br>            out.print(argumentType);<br>            out.println(<span class="hljs-string">&quot; value) &#123;&quot;</span>);<br>            out.print(<span class="hljs-string">&quot;        object.&quot;</span>);<br>            out.print(methodName);<br>            out.println(<span class="hljs-string">&quot;(value);&quot;</span>);<br>            out.println(<span class="hljs-string">&quot;        return this;&quot;</span>);<br>            out.println(<span class="hljs-string">&quot;    &#125;&quot;</span>);<br>            out.println();<br>        &#125;);<br><br>        out.println(<span class="hljs-string">&quot;&#125;&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-Running-the-Example"><a href="#7-Running-the-Example" class="headerlink" title="7. Running the Example"></a><strong>7. Running the Example</strong></h2><p>To see the code generation in action, you should either compile both modules from the common parent root or first compile the <em>annotation-processor</em> module and then the <em>annotation-user</em> module.</p><p>The generated <em>PersonBuilder</em> class can be found inside the <em>annotation-user/target/generated-sources/annotations/com/baeldung/annotation/PersonBuilder.java</em> file and should look like this:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.baeldung.annotation;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonBuilder</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Person object = <span class="hljs-keyword">new</span> Person();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Person <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> object;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PersonBuilder <span class="hljs-title">setName</span><span class="hljs-params">(java.lang.String value)</span> </span>&#123;<br>        object.setName(value);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PersonBuilder <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        object.setAge(value);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-Alternative-Ways-of-Registering-a-Processor"><a href="#8-Alternative-Ways-of-Registering-a-Processor" class="headerlink" title="8. Alternative Ways of Registering a Processor"></a><strong>8. Alternative Ways of Registering a Processor</strong></h2><p>To use your annotation processor during the compilation stage, you have several other options, depending on your use case and the tools you use.</p><h3 id="8-1-Using-the-Annotation-Processor-Tool"><a href="#8-1-Using-the-Annotation-Processor-Tool" class="headerlink" title="8.1. Using the Annotation Processor Tool"></a><strong>8.1. Using the Annotation Processor Tool</strong></h3><p>The <em>apt</em> tool was a special command line utility for processing source files. It was a part of Java 5, but since Java 7 it was deprecated in favour of other options and removed completely in Java 8. It will not be discussed in this article.</p><h3 id="8-2-Using-the-Compiler-Key"><a href="#8-2-Using-the-Compiler-Key" class="headerlink" title="8.2. Using the Compiler Key"></a><strong>8.2. Using the Compiler Key</strong></h3><p>The <em>-processor</em> compiler key is a standard JDK facility to augment the source processing stage of the compiler with your own annotation processor.</p><p>Note that the processor itself and the annotation have to be already compiled as classes in a separate compilation and present on the classpath, so the first thing you should do is:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">javac com/baeldung/annotation/processor/BuilderProcessor<br>javac com/baeldung/annotation/processor/BuilderProperty<br></code></pre></td></tr></table></figure><p>Then you do the actual compilation of your sources with the <em>-processor</em> key specifying the annotation processor class you’ve just compiled:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">javac -processor com.baeldung.annotation.processor.MyProcessor Person.java<br></code></pre></td></tr></table></figure><p>To specify several annotation processors in one go, you can separate their class names with commas, like this:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">javac -processor package1.Processor1,package2.Processor2 SourceFile.java<br></code></pre></td></tr></table></figure><h3 id="8-3-Using-Maven"><a href="#8-3-Using-Maven" class="headerlink" title="8.3. Using Maven"></a><strong>8.3. Using Maven</strong></h3><p>The <em>maven-compiler-plugin</em> allows specifying annotation processors as part of its configuration.</p><p>Here’s an example of adding annotation processor for the compiler plugin. You could also specify the directory to put generated sources into, using the <em>generatedSourcesDirectory</em> configuration parameter.</p><p>Note that the <em>BuilderProcessor</em> class should already be compiled, for instance, imported from another jar in the build dependencies:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">encoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">encoding</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">generatedSourcesDirectory</span>&gt;</span>$&#123;project.build.directory&#125;<br>                  /generated-sources/<span class="hljs-tag">&lt;/<span class="hljs-name">generatedSourcesDirectory</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">annotationProcessors</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">annotationProcessor</span>&gt;</span><br>                        com.baeldung.annotation.processor.BuilderProcessor<br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">annotationProcessor</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">annotationProcessors</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="8-4-Adding-a-Processor-Jar-to-the-Classpath"><a href="#8-4-Adding-a-Processor-Jar-to-the-Classpath" class="headerlink" title="8.4. Adding a Processor Jar to the Classpath"></a><strong>8.4. Adding a Processor Jar to the Classpath</strong></h3><p>Instead of specifying the annotation processor in the compiler options, you may simply add a specially structured jar with the processor class to the classpath of the compiler.</p><p>To pick it up automatically, the compiler has to know the name of the processor class. So you have to specify it in the <em>META-INF/services/javax.annotation.processing.Processor</em> file as a fully qualified class name of the processor:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">com.baeldung.annotation.processor.BuilderProcessor<br></code></pre></td></tr></table></figure><p>You can also specify several processors from this jar to pick up automatically by separating them with a new line:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">package1.Processor1<br>package2.Processor2<br>package3.Processor3<br></code></pre></td></tr></table></figure><p>If you use Maven to build this jar and try to put this file directly into the <em>src/main/resources/META-INF/services</em> directory, you’ll encounter the following error:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">[ERROR] Bad service configuration file, or exception thrown <span class="hljs-keyword">while</span> <br>constructing Processor object: javax.annotation.processing.Processor: <br>Provider com.baeldung.annotation.processor.BuilderProcessor not found<br></code></pre></td></tr></table></figure><p>This is because the compiler tries to use this file during the <em>source-processing</em> stage of the module itself when the <em>BuilderProcessor</em> file is not yet compiled. The file has to be either put inside another resource directory and copied to the <em>META-INF/services</em> directory during the resource copying stage of the Maven build, or (even better) generated during the build.</p><p>The Google <em>auto-service</em> library, discussed in the following section, allows generating this file using a simple annotation.</p><h3 id="8-5-Using-the-Google-auto-service-Library"><a href="#8-5-Using-the-Google-auto-service-Library" class="headerlink" title="8.5. Using the Google *auto-service* Library"></a><strong>8.5. Using the Google *auto-service* Library</strong></h3><p>To generate the registration file automatically, you can use the <em>@AutoService</em> annotation from the Google’s <em>auto-service</em> library, like this:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AutoService(Processor.class)</span><br><span class="hljs-keyword">public</span> BuilderProcessor extends AbstractProcessor &#123;<br>    <span class="hljs-comment">// …</span><br>&#125;<br></code></pre></td></tr></table></figure><p>This annotation is itself processed by the annotation processor from the auto-service library. This processor generates the <em>META-INF/services/javax.annotation.processing.Processor</em> file containing the <em>BuilderProcessor</em> class name.</p><h2 id="9-Conclusion"><a href="#9-Conclusion" class="headerlink" title="9. Conclusion"></a><strong>9. Conclusion</strong></h2><p>In this article, we’ve demonstrated source-level annotation processing using an example of generating a Builder class for a POJO. We have also provided several alternative ways of registering annotation processors in your project.</p><p>The source code for the article is available <a href="https://github.com/eugenp/tutorials/tree/master/annotations">on GitHub</a>.</p><hr><h1 id="官方qpi文档"><a href="#官方qpi文档" class="headerlink" title="官方qpi文档"></a>官方qpi文档</h1><p>可以看到,AbstractProcessor实现了接口Processor,那么,我们在来看下Processor的api文档:</p><blockquote><p>javax.annotation.processing<br> Interface Processor</p><p>All Known Implementing Classes:<br> <a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/AbstractProcessor.html">AbstractProcessor</a></p><hr><p>public interface Processor</p></blockquote><blockquote><p>The interface for an annotation processor.</p></blockquote><blockquote><p>Annotation processing happens in a sequence of <a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/RoundEnvironment.html">rounds</a>. On each round, a processor may be asked to [process](<a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/Processor.html#process">https://link.jianshu.com?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/Processor.html#process</a>(java.util.Set, javax.annotation.processing.RoundEnvironment)) a subset of the annotations found on the source and class files produced by a prior round. The inputs to the first round of processing are the initial inputs to a run of the tool; these initial inputs can be regarded as the output of a virtual zeroth round of processing. If a processor was asked to process on a given round, it will be asked to process on subsequent rounds, including the last round, even if there are no annotations for it to process. The tool infrastructure may also ask a processor to process files generated implicitly by the tool’s operation.<br> Each implementation of a Processor  must provide a public no-argument constructor to be used by tools to instantiate the processor. The tool infrastructure will interact with classes implementing this interface as follows:</p><ol><li>If an existing Processor object is not being used, to create an instance of a processor the tool calls the no-arg constructor of the processor class.</li><li>Next, the tool calls the <a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/Processor.html#init(javax.annotation.processing.ProcessingEnvironment)">init </a> method with an appropriate ProcessingEnvironment .</li><li>Afterwards, the tool calls <a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/Processor.html#getSupportedAnnotationTypes()">getSupportedAnnotationTypes </a>, <a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/Processor.html#getSupportedOptions()">getSupportedOptions </a>, and <a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/Processor.html#getSupportedSourceVersion()">getSupportedSourceVersion </a>. These methods are only called once per run, not on each round.</li><li>As appropriate, the tool calls the [process<br> ](<a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/Processor.html#process">https://link.jianshu.com?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/Processor.html#process</a>(java.util.Set, javax.annotation.processing.RoundEnvironment)) method on the Processor object; a new Processor object is <em>not</em> created for each round.</li></ol><p>If a processor object is created and used without the above protocol being followed, then the processor’s behavior is not defined by this interface specification.The tool uses a <em>discovery process</em> to find annotation processors and decide whether or not they should be run. By configuring the tool, the set of potential processors can be controlled. For example, for a <a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/tools/JavaCompiler.html">JavaCompiler </a> the list of candidate processors to run can be <a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/tools/JavaCompiler.CompilationTask.html#setProcessors(java.lang.Iterable)">set directly</a> or controlled by a <a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/tools/StandardLocation.html#ANNOTATION_PROCESSOR_PATH">search path</a> used for a <a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/java/util/ServiceLoader.html">service-style</a> lookup. Other tool implementations may have different configuration mechanisms, such as command line options; for details, refer to the particular tool’s documentation. Which processors the tool asks to [run](<a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/Processor.html#process">https://link.jianshu.com?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/Processor.html#process</a>(java.util.Set, javax.annotation.processing.RoundEnvironment)) is a function of what annotations are present on the <a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/RoundEnvironment.html#getRootElements()">root elements</a>, what <a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/Processor.html#getSupportedAnnotationTypes()">annotation types a processor processes</a>, and whether or not a processor [claims the annotations it processes](<a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/Processor.html#process">https://link.jianshu.com?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/Processor.html#process</a>(java.util.Set, javax.annotation.processing.RoundEnvironment)). A processor will be asked to process a subset of the annotation types it supports, possibly an empty set. For a given round, the tool computes the set of annotation types on the root elements. If there is at least one annotation type present, as processors claim annotation types, they are removed from the set of unmatched annotations. When the set is empty or no more processors are available, the round has run to completion. If there are no annotation types present, annotation processing still occurs but only <em>universal processors</em> which support processing “<em>“<br> can claim the (empty) set of annotation types.<br> Note that if a processor supports “</em>“<br> and returns true<br> , all annotations are claimed. Therefore, a universal processor being used to, for example, implement additional validity checks should return false<br> so as to not prevent other such checkers from being able to run.<br> If a processor throws an uncaught exception, the tool may cease other active annotation processors. If a processor raises an error, the current round will run to completion and the subsequent round will indicate an <a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/RoundEnvironment.html#errorRaised()">error was raised</a>. Since annotation processors are run in a cooperative environment, a processor should throw an uncaught exception only in situations where no error recovery or reporting is feasible.<br> The tool environment is not required to support annotation processors that access environmental resources, either <a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/RoundEnvironment.html">per round</a> or <a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/ProcessingEnvironment.html">cross-round</a>, in a multi-threaded fashion.<br> If the methods that return configuration information about the annotation processor return null<br> , return other invalid input, or throw an exception, the tool infrastructure must treat this as an error condition.<br> To be robust when running in different tool implementations, an annotation processor should have the following properties:</p><ol><li>The result of processing a given input is not a function of the presence or absence of other inputs (orthogonality).</li><li>Processing the same input produces the same output (consistency).</li><li>Processing input <em>A</em> followed by processing input <em>B</em> is equivalent to processing <em>B</em> then <em>A</em>(commutativity)</li><li>Processing an input does not rely on the presence of the output of other annotation processors (independence)</li></ol><p>The <a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/Filer.html">Filer </a> interface discusses restrictions on how processors can operate on files.<br> Note that implementors of this interface may find it convenient to extend <a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/AbstractProcessor.html">AbstractProcessor </a> rather than implementing this interface directly.</p><p>Since:<br> 1.6</p></blockquote><p>注解处理发生在一系列回合中.每个回合中,注解处理器都有可能被叫去处理由上一次注解产生的源码和类文件中的找到的注解子集.第一次注解处理回合的输入就是工具第一次运行的输入;这些初始输入可以认为是一个虚拟的第零次注解处理回合的输出.如果注解处理器被叫去处理一个特定的回合,那么接下来的回合它都会继续处理,即使后续回合没有它需要处理的注解.注解处理器有可能会被叫去处理由(编译)工具隐式生成的文件.每个注解处理器的实现都必须提供一个公有的无参构造函数,由工具进行实例化.工具会与实现该接口(Processor)的类进行如下交互:</p><ol><li>如果一个已存在的Processor实例未被使用,(编译)工具会调用注解处理器的无参构造函数实例化出一个Processor对象.</li><li>接下来,(编译)工具会调用init函数,并传入一个合适的ProcessingEnvironment.</li><li>之后,(编译)工具会调用getSupportedAnnotationTypes,getSupportedOptions和getSupportedSourceVersion.这些方法只会在每一次运行时被调用一次,而不会在每个注解回合都被调用.</li><li>正常情况下,(编译)工具会调用注解处理器实例的process函数;每个注解回合并不会产生新的注解实例.</li></ol><p>如果一个注解处理器实例被创建,但是使用却没有遵循上述协议,那么这个注解处理器的行为并未被该接口规范定义.(编译)工具使用搜索程序去找到注解处理器并决定它们是否得以运行.通过配置(编译)工具,潜在的注解处理器可以被控制.比如,对于javaCompiler,候选处理器可以直接被指定或者通过使用service-style查找指定搜索路径进行控制.其他(编译)工具可以具有不同的配置机制,比如控制行选项;具体点讲,参考特定工具文档.(编译)工具会调用运行的注解处理器是由root elements指示的注解,是注解处理器处理的注解类型和注解处理器声明它要处理的注解的方法.注解处理器会被叫去处理它支持的注解类型子集,有可能是一个空的集合.在给定回合,(编译)工具会计算root elements的注解类型集合.如果有最少一个注解类型存在,就是注解处理器声明的注解类型之一,它们就会被从未匹配的注解类型集合中移除.当(未匹配)注解集合为空或者没有其它的注解处理器,那么该注解处理回合就结束了.如果没有声明注解类型,只有通用处理器(支持处理”<em>“声明(空)所有注解类型集合)仍然会进行注解处理.注意如果一个注解处理器支持”</em>“并且返回true,则所有的注解类型都被声明.因此,一个通用注解处理器如果被用于实现附加有效检验,那么应该返回false,为了不防止这类检验器得以运行.如果一个注解处理器抛出了一个未捕获异常,(编译)工具可能会停止其他活动的注解处理器.如果一个注解处理器引起了一个错误,当前注解回合会结束,并且后续回合会指明一个错误产生了.因为注解处理器都是运行在共同协作的环境中,只有当错误恢复或报告提交是无法执行的情况下,注解处理器才允许抛出一个未捕获异常.<br> (编译)工具环境不要求要支持注解处理器能以多线程方式在每一回合或交叉回合能访问环境资源.<br> 如果返回注解处理器的配置信息的方法返回null,返回其他无效输入,或者抛出一个异常,(编译)工具必须将这些当做是一个错误条件.<br> 为了在不同的工具实现能够健壮运行,注解处理器必须有以下性能:</p><ol><li>对于一个给定的输入的处理结果,不影响其他输入的存在或缺失(正交性)</li><li>处于相同的输入会产生相同的输出(一致性)</li><li>先处理输入A,然后处于输入B等同于先处理B在处理A(可交换性)</li><li>处理输入会依赖于其他注解处理器的输出(独立性)</li></ol><p>Filer接口讨论了注解处理器操作文件的限定.<br> 请知悉Processor的实现通过继承AbstractProcessor会比直接实现该接口更加方便.</p><p>简单总结如下:</p><ul><li>Annotation Processor可能会被多次调用.</li><li>Annotation Processor被调用一次后,后续若还有注解处理,该Annotation Processor仍然会继续被调用.</li><li>自定义Annotation Processor必须带有一个无参构造函数,让javac进行实例化.</li><li>如果Annotation Processor抛出一个未捕获异常,javac可能会停止其他的Annotation Processor.只有在无法抛出错误或报告的情况下,才允许抛出异常.</li><li>Annotation Processor运行在一个独立的jvm中,所以可以将它看成是一个java应用程序.</li></ul><p>作者：Whyn<br>链接：<a href="https://www.jianshu.com/p/b6b3283968e0">https://www.jianshu.com/p/b6b3283968e0</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><hr><h1 id="插件化注解处理API-Pluggable-Annotation-Processing-API"><a href="#插件化注解处理API-Pluggable-Annotation-Processing-API" class="headerlink" title="插件化注解处理API(Pluggable Annotation Processing API)"></a><a href="https://www.cnblogs.com/throwable/p/9139908.html">插件化注解处理API(Pluggable Annotation Processing API)</a></h1><h1 id="Java奇技淫巧-插件化注解处理API-Pluggable-Annotation-Processing-API"><a href="#Java奇技淫巧-插件化注解处理API-Pluggable-Annotation-Processing-API" class="headerlink" title="Java奇技淫巧-插件化注解处理API(Pluggable Annotation Processing API)"></a>Java奇技淫巧-插件化注解处理API(Pluggable Annotation Processing API)</h1><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://blog.csdn.net/Chinajash/article/details/1471081">JDK6的新特性之六:插入式注解处理API(Pluggable Annotation Processing API)</a></li><li><a href="http://www.baeldung.com/java-annotation-processing-builder">Java Annotation Processing and Creating a Builder</a></li></ul><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>插件化注解处理(Pluggable Annotation Processing)API<a href="http://jcp.org/en/jsr/detail?id=269">JSR 269</a>提供一套标准API来处理Annotations<a href="http://jcp.org/en/jsr/detail?id=175">JSR 175</a>,实际上JSR 269不仅仅用来处理Annotation，我觉得更强大的功能是它建立了Java 语言本身的一个模型,它把method、package、constructor、type、variable、enum、annotation等Java语言元素映射为Types和Elements，从而将Java语言的语义映射成为对象，我们可以在javax.lang.model包下面可以看到这些类。所以我们可以利用JSR 269提供的API来构建一个功能丰富的元编程(metaprogramming)环境。JSR 269用Annotation Processor在编译期间而不是运行期间处理Annotation, Annotation Processor相当于编译器的一个插件,所以称为插入式注解处理.如果Annotation Processor处理Annotation时(执行process方法)产生了新的Java代码，编译器会再调用一次Annotation Processor，如果第二次处理还有新代码产生，就会接着调用Annotation Processor，直到没有新代码产生为止。每执行一次process()方法被称为一个”round”，这样整个Annotation processing过程可以看作是一个round的序列。JSR 269主要被设计成为针对Tools或者容器的API。这个特性虽然在JavaSE 6已经存在，但是很少人知道它的存在。下一篇介绍的<strong>Java奇技淫巧-lombok</strong>就是使用这个特性实现编译期的代码插入的。另外，如果没有猜错，像IDEA在编写代码时候的标记语法错误的红色下划线也是通过这个特性实现的。KAPT(Annotation Processing for Kotlin)，也就是Kotlin的编译也是通过此特性的。</p><p>Pluggable Annotation Processing API的核心是Annotation Processor即注解处理器，一般需要继承抽象类<code>javax.annotation.processing.AbstractProcessor</code>。注意，与运行时注解<code>RetentionPolicy.RUNTIME</code>不同，注解处理器只会处理编译期注解，也就是<code>RetentionPolicy.SOURCE</code>的注解类型，处理的阶段位于Java代码编译期间。</p><h1 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h1><p>插件化注解处理API的使用步骤大概如下：</p><ul><li>1、自定义一个Annotation Processor，需要继承<code>javax.annotation.processing.AbstractProcessor</code>，并覆写process方法。</li><li>2、自定义一个注解，注解的元注解需要指定<code>@Retention(RetentionPolicy.SOURCE)</code>。</li><li>3、需要在声明的自定义Annotation Processor中使用<code>javax.annotation.processing.SupportedAnnotationTypes</code>指定在第2步创建的注解类型的名称(注意需要全类名，”包名.注解类型名称”，否则会不生效)。</li><li>4、需要在声明的自定义Annotation Processor中使用<code>javax.annotation.processing.SupportedSourceVersion</code>指定编译版本。</li><li>5、可选操作，可以通在声明的自定义Annotation Processor中使用<code>javax.annotation.processing.SupportedOptions</code>指定编译参数。</li></ul><h1 id="实战例子"><a href="#实战例子" class="headerlink" title="实战例子"></a>实战例子</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础#"></a>基础<a href="https://www.cnblogs.com/throwable/p/9139908.html#%E5%9F%BA%E7%A1%80">#</a></h2><p>下面我们模仿一下测试框架Junit里面的@Test注解，在运行时通过Annotation Processor获取到使用了自定义的@Test注解对应的方法的信息。因为如果想要动态修改一个类或者方法的代码内容，需要使用到字节码修改工具例如ASM等，这些操作过于深入，日后再谈。先定义一个注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> club.throwable.processor;<br><br><span class="hljs-keyword">import</span> java.lang.annotation.ElementType;<br><span class="hljs-keyword">import</span> java.lang.annotation.Retention;<br><span class="hljs-keyword">import</span> java.lang.annotation.RetentionPolicy;<br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> throwable</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> v1.0</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 2018/5/27 11:18</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Target(&#123;ElementType.METHOD&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Test &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>定义一个注解处理器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SupportedAnnotationTypes(value = &#123;&quot;club.throwable.processor.Test&quot;&#125;)</span><br><span class="hljs-meta">@SupportedSourceVersion(value = SourceVersion.RELEASE_8)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnnotationProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractProcessor</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">process</span><span class="hljs-params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Log in AnnotationProcessor.process&quot;</span>);<br>        <span class="hljs-keyword">for</span> (TypeElement typeElement : annotations) &#123;<br>            System.out.println(typeElement);<br>        &#125;<br>        System.out.println(roundEnv);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编写一个主类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;success&quot;</span>);<br>        test();<br>    &#125;<br><br>    <span class="hljs-meta">@Test(value = &quot;method is test&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span><span class="hljs-keyword">throws</span> Exception</span>&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着需要指定Processor，如果使用IDEA的话，Compiler-&gt;Annotation Processors中的Enable annotation processing必须勾选。然后可以通过下面几种方式指定指定Processor。</p><ul><li>1、直接使用编译参数指定，例如：javac -processor club.throwable.processor.AnnotationProcessor Main.java。</li><li>2、通过服务注册指定，就是META-INF/services/javax.annotation.processing.Processor文件中添加club.throwable.processor.AnnotationProcessor。</li><li>3、通过Maven的编译插件的配置指定如下：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">encoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">encoding</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">annotationProcessors</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">annotationProcessor</span>&gt;</span><br>                club.throwable.processor.AnnotationProcessor<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">annotationProcessor</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">annotationProcessors</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br></code></pre></td></tr></table></figure><p>值得注意的是，以上三点生效的前提是club.throwable.processor.AnnotationProcessor已经被编译过，否则编译的时候就会报错：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-attr">[ERROR]</span> Bad service configuration file, or exception thrown while<br>constructing Processor <span class="hljs-selector-tag">object</span>: javax<span class="hljs-selector-class">.annotation</span><span class="hljs-selector-class">.processing</span><span class="hljs-selector-class">.Processor</span>: <br>Provider club<span class="hljs-selector-class">.throwable</span><span class="hljs-selector-class">.processor</span><span class="hljs-selector-class">.AnnotationProcessor</span> not found<br></code></pre></td></tr></table></figure><p>解决方法有两种，第一种是提前使用命令或者IDEA右键club.throwable.processor.AnnotationProcessor对它进行编译；第二种是把club.throwable.processor.AnnotationProcessor放到一个独立的Jar包引入。我在这里使用第一种方式解决。</p><p>最后，使用Maven命令mvn compile进行编译。输出如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Log <span class="hljs-keyword">in</span> AnnotationProcessor.process<br>[<span class="hljs-attribute">errorRaised</span>=<span class="hljs-literal">false</span>, rootElements=[club.throwable.processor.Test,club.throwable.processor.Main, club.throwable.processor.AnnotationProcessor, <span class="hljs-attribute">processingOver</span>=<span class="hljs-literal">false</span>]<br>Log <span class="hljs-keyword">in</span> AnnotationProcessor.process<br>[<span class="hljs-attribute">errorRaised</span>=<span class="hljs-literal">false</span>, rootElements=[], <span class="hljs-attribute">processingOver</span>=<span class="hljs-literal">false</span>]<br>Log <span class="hljs-keyword">in</span> AnnotationProcessor.process<br>[<span class="hljs-attribute">errorRaised</span>=<span class="hljs-literal">false</span>, rootElements=[], <span class="hljs-attribute">processingOver</span>=<span class="hljs-literal">true</span>]<br></code></pre></td></tr></table></figure><p>可见编译期间AnnotationProcessor生效了。</p><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶#"></a>进阶<a href="https://www.cnblogs.com/throwable/p/9139908.html#%E8%BF%9B%E9%98%B6">#</a></h2><p>下面是一个例子直接修改类的代码，为实体类的Setter方法对应的属性生成一个Builder类，也就是原来的类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-meta">@Builder</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(Integer age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-meta">@Builder</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>生成的Builder类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonBuilder</span> </span>&#123;<br> <br>    <span class="hljs-keyword">private</span> Person object = <span class="hljs-keyword">new</span> Person();<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Person <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> object;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PersonBuilder <span class="hljs-title">setName</span><span class="hljs-params">(java.lang.String value)</span> </span>&#123;<br>        object.setName(value);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PersonBuilder <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        object.setAge(value);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>自定义的注解如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.METHOD&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Builder &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>自定义的注解处理器如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> javax.annotation.processing.AbstractProcessor;<br><span class="hljs-keyword">import</span> javax.annotation.processing.RoundEnvironment;<br><span class="hljs-keyword">import</span> javax.annotation.processing.SupportedAnnotationTypes;<br><span class="hljs-keyword">import</span> javax.annotation.processing.SupportedSourceVersion;<br><span class="hljs-keyword">import</span> javax.lang.model.SourceVersion;<br><span class="hljs-keyword">import</span> javax.lang.model.element.Element;<br><span class="hljs-keyword">import</span> javax.lang.model.element.TypeElement;<br><span class="hljs-keyword">import</span> javax.lang.model.type.ExecutableType;<br><span class="hljs-keyword">import</span> javax.tools.Diagnostic;<br><span class="hljs-keyword">import</span> javax.tools.JavaFileObject;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.PrintWriter;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.util.Set;<br><span class="hljs-keyword">import</span> java.util.stream.Collectors;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> throwable</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> v1.0</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 2018/5/27 11:21</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@SupportedAnnotationTypes(value = &#123;&quot;club.throwable.processor.builder.Builder&quot;&#125;)</span><br><span class="hljs-meta">@SupportedSourceVersion(value = SourceVersion.RELEASE_8)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BuilderProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractProcessor</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">process</span><span class="hljs-params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (TypeElement typeElement : annotations) &#123;<br>            Set&lt;? extends Element&gt; annotatedElements = roundEnv.getElementsAnnotatedWith(typeElement);<br>            Map&lt;Boolean, List&lt;Element&gt;&gt; annotatedMethods<br>                    = annotatedElements.stream().collect(Collectors.partitioningBy(<br>                    element -&gt; ((ExecutableType) element.asType()).getParameterTypes().size() == <span class="hljs-number">1</span><br>                            &amp;&amp; element.getSimpleName().toString().startsWith(<span class="hljs-string">&quot;set&quot;</span>)));<br>            List&lt;Element&gt; setters = annotatedMethods.get(<span class="hljs-keyword">true</span>);<br>            List&lt;Element&gt; otherMethods = annotatedMethods.get(<span class="hljs-keyword">false</span>);<br>            otherMethods.forEach(element -&gt;<br>                    processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,<br>                            <span class="hljs-string">&quot;@Builder must be applied to a setXxx method &quot;</span><br>                                    + <span class="hljs-string">&quot;with a single argument&quot;</span>, element));<br>            Map&lt;String, String&gt; setterMap = setters.stream().collect(Collectors.toMap(<br>                    setter -&gt; setter.getSimpleName().toString(),<br>                    setter -&gt; ((ExecutableType) setter.asType())<br>                            .getParameterTypes().get(<span class="hljs-number">0</span>).toString()<br>            ));<br>            String className = ((TypeElement) setters.get(<span class="hljs-number">0</span>)<br>                    .getEnclosingElement()).getQualifiedName().toString();<br>            <span class="hljs-keyword">try</span> &#123;<br>                writeBuilderFile(className, setterMap);<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeBuilderFile</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">            String className, Map&lt;String, String&gt; setterMap)</span></span><br><span class="hljs-function">            <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        String packageName = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">int</span> lastDot = className.lastIndexOf(<span class="hljs-string">&#x27;.&#x27;</span>);<br>        <span class="hljs-keyword">if</span> (lastDot &gt; <span class="hljs-number">0</span>) &#123;<br>            packageName = className.substring(<span class="hljs-number">0</span>, lastDot);<br>        &#125;<br>        String simpleClassName = className.substring(lastDot + <span class="hljs-number">1</span>);<br>        String builderClassName = className + <span class="hljs-string">&quot;Builder&quot;</span>;<br>        String builderSimpleClassName = builderClassName<br>                .substring(lastDot + <span class="hljs-number">1</span>);<br><br>        JavaFileObject builderFile = processingEnv.getFiler().createSourceFile(builderClassName);<br><br>        <span class="hljs-keyword">try</span> (PrintWriter out = <span class="hljs-keyword">new</span> PrintWriter(builderFile.openWriter())) &#123;<br><br>            <span class="hljs-keyword">if</span> (packageName != <span class="hljs-keyword">null</span>) &#123;<br>                out.print(<span class="hljs-string">&quot;package &quot;</span>);<br>                out.print(packageName);<br>                out.println(<span class="hljs-string">&quot;;&quot;</span>);<br>                out.println();<br>            &#125;<br>            out.print(<span class="hljs-string">&quot;public class &quot;</span>);<br>            out.print(builderSimpleClassName);<br>            out.println(<span class="hljs-string">&quot; &#123;&quot;</span>);<br>            out.println();<br>            out.print(<span class="hljs-string">&quot;    private &quot;</span>);<br>            out.print(simpleClassName);<br>            out.print(<span class="hljs-string">&quot; object = new &quot;</span>);<br>            out.print(simpleClassName);<br>            out.println(<span class="hljs-string">&quot;();&quot;</span>);<br>            out.println();<br>            out.print(<span class="hljs-string">&quot;    public &quot;</span>);<br>            out.print(simpleClassName);<br>            out.println(<span class="hljs-string">&quot; build() &#123;&quot;</span>);<br>            out.println(<span class="hljs-string">&quot;        return object;&quot;</span>);<br>            out.println(<span class="hljs-string">&quot;    &#125;&quot;</span>);<br>            out.println();<br>            setterMap.forEach((methodName, argumentType) -&gt; &#123;<br>                out.print(<span class="hljs-string">&quot;    public &quot;</span>);<br>                out.print(builderSimpleClassName);<br>                out.print(<span class="hljs-string">&quot; &quot;</span>);<br>                out.print(methodName);<br><br>                out.print(<span class="hljs-string">&quot;(&quot;</span>);<br><br>                out.print(argumentType);<br>                out.println(<span class="hljs-string">&quot; value) &#123;&quot;</span>);<br>                out.print(<span class="hljs-string">&quot;        object.&quot;</span>);<br>                out.print(methodName);<br>                out.println(<span class="hljs-string">&quot;(value);&quot;</span>);<br>                out.println(<span class="hljs-string">&quot;        return this;&quot;</span>);<br>                out.println(<span class="hljs-string">&quot;    &#125;&quot;</span>);<br>                out.println();<br>            &#125;);<br>            out.println(<span class="hljs-string">&quot;&#125;&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>主类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>      <span class="hljs-comment">//PersonBuilder在编译之后才会生成，这里需要编译后才能这样写</span><br>      Person person  = <span class="hljs-keyword">new</span> PersonBuilder().setAge(<span class="hljs-number">25</span>).setName(<span class="hljs-string">&quot;doge&quot;</span>).build();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>先手动编译BuilderProcessor，然后在META-INF/services/javax.annotation.processing.Processor文件中添加<code>club.throwable.processor.builder.BuilderProcessor</code>，最后执行Maven命令mvn compile进行编译。</p><p>编译后控制台输出:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[errorRaised=<span class="hljs-literal">false</span>, rootElements=[club.throwable.processor.builder.PersonBuilder], processingOver=<span class="hljs-literal">false</span>]<br></code></pre></td></tr></table></figure><p>编译成功之后，target/classes包下面的club.throwable.processor.builder子包路径中会新增了一个类<code>PersonBuilder</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> club.throwable.processor.builder;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonBuilder</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Person object = <span class="hljs-keyword">new</span> Person();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PersonBuilder</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Person <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.object;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PersonBuilder <span class="hljs-title">setName</span><span class="hljs-params">(String value)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.object.setName(value);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PersonBuilder <span class="hljs-title">setAge</span><span class="hljs-params">(Integer value)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.object.setAge(value);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个类就是编译期新增的。在这个例子中，编译期新增的类貌似没有什么作用。但是，如果像lombok那样对原来的实体类添加新的方法，那样的话就比较有用了。因为些类或者方法是编译期添加的，因此在代码中直接使用会标红。因此，lombok提供了IDEA或者eclipse的插件，插件的功能的实现估计也是用了插件式注解处理API。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>java注解</title>
    <link href="/2021/12/23/java%E6%B3%A8%E8%A7%A3/"/>
    <url>/2021/12/23/java%E6%B3%A8%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="process方法的调用方式"><a href="#process方法的调用方式" class="headerlink" title="process方法的调用方式"></a>process方法的调用方式</h1><p>注释处理分多轮完成。每一轮都从编译器开始搜索源文件中的注释并选择适合这些注释的注释处理器。依次在相应的源上调用每个注释处理器。</p><p>如果在此过程中生成了任何文件，则以生成的文件作为其输入开始另一轮。这个过程一直持续到在处理阶段没有新文件产生。</p><p>依次在相应的源上调用每个注释处理器。如果在此过程中生成了任何文件，则以生成的文件作为其输入开始另一轮。这个过程一直持续到在处理阶段没有新文件产生。</p><p>注释处理 <code>API </code>位于<code>javax.annotation.processing</code>包中。您必须实现的主要接口是<em>Processor</em>接口，它具有<code>AbstractProcessor</code>类形式的部分实现。这个类是我们将要扩展以创建我们自己的注释处理器的类。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">原文：<br>The annotation processing <span class="hljs-keyword">is</span> done <span class="hljs-keyword">in</span> multiple rounds. <span class="hljs-keyword">Each</span> round starts <span class="hljs-keyword">with</span> the compiler searching <span class="hljs-keyword">for</span> the annotations <span class="hljs-keyword">in</span> the source files <span class="hljs-keyword">and</span> choosing the annotation processors suited <span class="hljs-keyword">for</span> these annotations. <span class="hljs-keyword">Each</span> annotation processor, <span class="hljs-keyword">in</span> turn, <span class="hljs-keyword">is</span> <span class="hljs-keyword">called</span> <span class="hljs-keyword">on</span> the corresponding sources.<br><br><span class="hljs-keyword">If</span> <span class="hljs-keyword">any</span> files are <span class="hljs-keyword">generated</span> during this process, another round <span class="hljs-keyword">is</span> started <span class="hljs-keyword">with</span> the <span class="hljs-keyword">generated</span> files <span class="hljs-keyword">as</span> its <span class="hljs-keyword">input</span>. This process continues <span class="hljs-keyword">until</span> <span class="hljs-keyword">no</span> <span class="hljs-built_in">new</span> files are <span class="hljs-keyword">generated</span> during the processing stage.<br><br><span class="hljs-keyword">Each</span> annotation processor, <span class="hljs-keyword">in</span> turn, <span class="hljs-keyword">is</span> <span class="hljs-keyword">called</span> <span class="hljs-keyword">on</span> the corresponding sources. <span class="hljs-keyword">If</span> <span class="hljs-keyword">any</span> files are <span class="hljs-keyword">generated</span> during this process, another round <span class="hljs-keyword">is</span> started <span class="hljs-keyword">with</span> the <span class="hljs-keyword">generated</span> files <span class="hljs-keyword">as</span> its <span class="hljs-keyword">input</span>. This process continues <span class="hljs-keyword">until</span> <span class="hljs-keyword">no</span> <span class="hljs-built_in">new</span> files are <span class="hljs-keyword">generated</span> during the processing stage.<br><br>The annotation processing API <span class="hljs-keyword">is</span> located <span class="hljs-keyword">in</span> the javax.annotation.processing package. The main interface that you’ll have <span class="hljs-keyword">to</span> implement <span class="hljs-keyword">is</span> the Processor interface, which has a partial implementation <span class="hljs-keyword">in</span> the form <span class="hljs-keyword">of</span> AbstractProcessor <span class="hljs-keyword">class</span>. This <span class="hljs-keyword">class</span> <span class="hljs-keyword">is</span> the one we’re going <span class="hljs-keyword">to</span> extend <span class="hljs-keyword">to</span> <span class="hljs-keyword">create</span> our own annotation processor.<br><br><br></code></pre></td></tr></table></figure><p>这是一个实现处理器的例子：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@SupportedAnnotationTypes</span>(<span class="hljs-string">&quot;com.baeldung.annotation.processor.BuilderProperty&quot;</span>)<span class="hljs-comment">//指定这个处理器能处理的注解</span><br><span class="hljs-variable">@SupportedSourceVersion</span>(SourceVersion.RELEASE_8)<br><span class="hljs-variable">@AutoService</span>(Processor.class)<br>public class BuilderProcessor extends AbstractProcessor &#123;<br><br>    <span class="hljs-variable">@Override</span><br>    public boolean process(Set&lt;? extends TypeElement&gt; annotations, <br>      RoundEnvironment roundEnv) &#123;<br>        <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不仅可以指定具体的注释类名称，还可以指定通配符，例如<code>“com.baeldung.annotation.\*”</code> 来处理<code>com.baeldung.annotation</code>包及其所有子包中的注释，甚至可以<em>“*”</em>来处理所有注释.</p><p>我们必须实现的单一方法是处理本身的<code>process</code>方法。编译器为每个包含匹配注释的源文件调用它。</p><p>注释作为第一个<code>Set&lt;? extends TypeElement&gt; annotations</code>参数，有关当前处理轮次的信息作为<code>RoundEnviroment roundEnv</code>参数传递。</p><p>如果您的注释处理器已经处理了所有传递的注释，并且您不希望它们被传递到列表中的其他注释处理器，则返回<em>布尔</em>值应该为<em>true</em>。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">原文：<br>You can specify <span class="hljs-keyword">not</span> only <span class="hljs-keyword">the</span> concrete annotation class names but also wildcards, like “com.baeldung.annotation.*” <span class="hljs-built_in">to</span> <span class="hljs-built_in">process</span> annotations inside <span class="hljs-keyword">the</span> com.baeldung.annotation package <span class="hljs-keyword">and</span> all its sub packages, <span class="hljs-keyword">or</span> even “*” <span class="hljs-built_in">to</span> <span class="hljs-built_in">process</span> all annotations.<br><br>The single method that we’ll have <span class="hljs-built_in">to</span> implement is <span class="hljs-keyword">the</span> <span class="hljs-built_in">process</span> method that does <span class="hljs-keyword">the</span> processing itself. It is called <span class="hljs-keyword">by</span> <span class="hljs-keyword">the</span> compiler <span class="hljs-keyword">for</span> every source <span class="hljs-built_in">file</span> containing <span class="hljs-keyword">the</span> matching annotations.<br><br>Annotations are passed <span class="hljs-keyword">as</span> <span class="hljs-keyword">the</span> <span class="hljs-keyword">first</span> Set<span class="hljs-meta">&lt;?</span> extends TypeElement&gt; annotations argument, <span class="hljs-keyword">and</span> <span class="hljs-keyword">the</span> information about <span class="hljs-keyword">the</span> current processing <span class="hljs-built_in">round</span> is passed <span class="hljs-keyword">as</span> <span class="hljs-keyword">the</span> RoundEnviroment roundEnv argument.<br><br>The <span class="hljs-literal">return</span> boolean <span class="hljs-built_in">value</span> should be <span class="hljs-literal">true</span> <span class="hljs-keyword">if</span> your annotation processor has processed all <span class="hljs-keyword">the</span> passed annotations, <span class="hljs-keyword">and</span> you don<span class="hljs-string">&#x27;t want them to be passed to other annotation processors down the list.</span><br></code></pre></td></tr></table></figure><p>总结：</p><p>在我们自定义的处理器类中，我们指定了这个处理器类可以处理的注解。</p><p>然后，<code>java</code>编译器会依次调用注册好的注解处理器处理注解，这会有多轮处理。</p><p>在调用注解处理器的时候，编译器会筛选出这个注解处理器可以处理的注解信息给它处理。</p><p>在当前注解处理器处理注解的时候，如果产生的新类里依旧包含注解，那么，在其他所有注解处理器完成处理之后，会进行第二轮处理，第三轮，直到没有新的注解产生。</p><ul><li><p>例子：</p><ul><li><p><strong>MainActivity</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>&#123;<br><br>    <span class="hljs-meta">@BindView</span>(<span class="hljs-type">R</span>.id.tv_hello)<br>    <span class="hljs-type">TextView</span> tvHello;<br>  &#125;<br></code></pre></td></tr></table></figure></li><li><p>在第一轮处理注解时，我们生成了新的类,而这个类使用**@Keep**注解标记了，那么注解处理器就会        开始下一轮的处理，直到生成的类里面再也没有任何注解了。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">@Keep<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">MainActivity</span>$<span class="hljs-symbol">Binding</span> &#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h1 id="解析注解的步骤"><a href="#解析注解的步骤" class="headerlink" title="解析注解的步骤"></a>解析注解的步骤</h1><h2 id="插件化注解处理API的使用步骤大概如下："><a href="#插件化注解处理API的使用步骤大概如下：" class="headerlink" title="插件化注解处理API的使用步骤大概如下："></a>插件化注解处理API的使用步骤大概如下：</h2><ul><li>1、自定义一个Annotation Processor，需要继承<code>javax.annotation.processing.AbstractProcessor</code>，需要重写<code>process()</code>方法。<ul><li> 1.1、此外还需要实现几个简单的方法<code>init ()</code>、<code>getSupportedSourceVersion()</code>、<code>getSupportedAnnotationTypes()</code> </li></ul></li><li>2、自定义一个注解，注解的元注解需要指定<code>@Retention(RetentionPolicy.SOURCE)</code>。</li><li>3、需要在声明的自定义Annotation Processor中使用<code>javax.annotation.processing.SupportedAnnotationTypes</code>指定在第2步创建的注解类型的名称(注意需要全类名，”包名.注解类型名称”，否则会不生效)。</li><li>4、需要在声明的自定义Annotation Processor中使用<code>javax.annotation.processing.SupportedSourceVersion</code>指定编译版本。</li><li>5、可选操作，可以通在声明的自定义Annotation Processor中使用<code>javax.annotation.processing.SupportedOptions</code>指定编译参数。</li></ul><h2 id="配置和注册"><a href="#配置和注册" class="headerlink" title="配置和注册"></a>配置和注册</h2><ul><li>创建一个自定义Annotation Processor继承于AbstractProcessor</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AutoService(Processor.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractProcessor</span> </span>&#123;<br> 。。。省略。。。<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>@AutoService(Processor.class) :向javac注册我们这个自定义的注解处理器，这样，在javac编译时，才会调用到我们这个自定义的注解处理器方法。<br> AutoService这里主要是用来生成<br> <strong>建议直接采用@AutoService(Processor.class)进行自定义注解处理器注册，简洁方便</strong></p></li><li><p>其他方式注册</p><p>例如：</p><p>我们模仿一下测试框架Junit里面的@Test注解，在运行时通过Annotation Processor获取到使用了自定义的@Test注解对应的方法的信息。因为如果想要动态修改一个类或者方法的代码内容，需要使用到字节码修改工具例如ASM等，这些操作过于深入，日后再谈。先定义一个注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> club.throwable.processor;<br><br><span class="hljs-keyword">import</span> java.lang.annotation.ElementType;<br><span class="hljs-keyword">import</span> java.lang.annotation.Retention;<br><span class="hljs-keyword">import</span> java.lang.annotation.RetentionPolicy;<br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> throwable</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> v1.0</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 2018/5/27 11:18</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Target(&#123;ElementType.METHOD&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Test &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>定义一个注解处理器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SupportedAnnotationTypes(value = &#123;&quot;club.throwable.processor.Test&quot;&#125;)</span><br><span class="hljs-meta">@SupportedSourceVersion(value = SourceVersion.RELEASE_8)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnnotationProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractProcessor</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">process</span><span class="hljs-params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Log in AnnotationProcessor.process&quot;</span>);<br>        <span class="hljs-keyword">for</span> (TypeElement typeElement : annotations) &#123;<br>            System.out.println(typeElement);<br>        &#125;<br>        System.out.println(roundEnv);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编写一个主类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;success&quot;</span>);<br>        test();<br>    &#125;<br><br>    <span class="hljs-meta">@Test(value = &quot;method is test&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span><span class="hljs-keyword">throws</span> Exception</span>&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着需要指定Processor，如果使用IDEA的话，Compiler-&gt;Annotation Processors中的Enable annotation processing必须勾选。然后可以通过下面几种方式指定指定Processor。</p><ul><li><p>1、直接使用编译参数指定，例如：javac -processor club.throwable.processor.AnnotationProcessor Main.java。</p></li><li><p>2、<strong>通过服务注册指定</strong>，就是META-INF/services/javax.annotation.processing.Processor文件中添加club.throwable.processor.AnnotationProcessor。</p><ul><li><p>具体手动注册方法如下：</p><ol><li><p>创建一个<br>META-INF/services/javax.annotation.processing.Processor文件，<br>其内容是一系列的自定义注解处理器完整有效类名集合，以换行切割。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.MyProcessor</span><br>com<span class="hljs-selector-class">.foo</span><span class="hljs-selector-class">.OtherProcessor</span><br>net<span class="hljs-selector-class">.blabla</span>.SpecialProcessor<br></code></pre></td></tr></table></figure><ul><li>文件放在<code>/src/main/resources/META-INF/services/javax.annotation.processing.Processor</code></li><li>处理器类文件放在<code>/src/main/java/com/example/annotationcomplierlib/AnnotationComplier.java</code></li></ul></li><li><p>将自定义注解处理器和<br>META-INF/services/javax.annotation.processing.Processor打包成一个.jar文件。所以其目录结构大概如下所示：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css">MyProcessor<span class="hljs-selector-class">.jar</span><br>    - com<br>        - example<br>            - MyProcessor<span class="hljs-selector-class">.class</span><br><br>    - META-INF<br>        - services<br>            - javax<span class="hljs-selector-class">.annotation</span><span class="hljs-selector-class">.processing</span><span class="hljs-selector-class">.Processor</span><br></code></pre></td></tr></table></figure></li></ol></li></ul></li><li><p>3、通过Maven的编译插件的配置指定如下：</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">encoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">encoding</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">annotationProcessors</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">annotationProcessor</span>&gt;</span><br>                club.throwable.processor.AnnotationProcessor<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">annotationProcessor</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">annotationProcessors</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br></code></pre></td></tr></table></figure><p>值得注意的是，以上三点生效的前提是club.throwable.processor.AnnotationProcessor已经被编译过，否则编译的时候就会报错：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-attr">[ERROR]</span> Bad service configuration file, or exception thrown while<br>constructing Processor <span class="hljs-selector-tag">object</span>: javax<span class="hljs-selector-class">.annotation</span><span class="hljs-selector-class">.processing</span><span class="hljs-selector-class">.Processor</span>: <br>Provider club<span class="hljs-selector-class">.throwable</span><span class="hljs-selector-class">.processor</span><span class="hljs-selector-class">.AnnotationProcessor</span> not found<br></code></pre></td></tr></table></figure><p>解决方法有两种，第一种是提前使用命令或者IDEA右键club.throwable.processor.AnnotationProcessor对它进行编译；第二种是把club.throwable.processor.AnnotationProcessor放到一个独立的Jar包引入。我在这里使用第一种方式解决。</p><p>最后，使用Maven命令mvn compile进行编译。输出如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Log <span class="hljs-keyword">in</span> AnnotationProcessor.process<br>[<span class="hljs-attribute">errorRaised</span>=<span class="hljs-literal">false</span>, rootElements=[club.throwable.processor.Test,club.throwable.processor.Main, club.throwable.processor.AnnotationProcessor, <span class="hljs-attribute">processingOver</span>=<span class="hljs-literal">false</span>]<br>Log <span class="hljs-keyword">in</span> AnnotationProcessor.process<br>[<span class="hljs-attribute">errorRaised</span>=<span class="hljs-literal">false</span>, rootElements=[], <span class="hljs-attribute">processingOver</span>=<span class="hljs-literal">false</span>]<br>Log <span class="hljs-keyword">in</span> AnnotationProcessor.process<br>[<span class="hljs-attribute">errorRaised</span>=<span class="hljs-literal">false</span>, rootElements=[], <span class="hljs-attribute">processingOver</span>=<span class="hljs-literal">true</span>]<br></code></pre></td></tr></table></figure><p>可见编译期间AnnotationProcessor生效了。</p></li></ul><h2 id="备注："><a href="#备注：" class="headerlink" title="备注："></a>备注：</h2><ul><li>Gradle配置如下：</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs php"><br>dependencies &#123;<br>    implementation fileTree(<span class="hljs-keyword">include</span>: [<span class="hljs-string">&#x27;*.jar&#x27;</span>], dir: <span class="hljs-string">&#x27;libs&#x27;</span>)<br><br>    implementation project(<span class="hljs-string">&#x27;:annotation&#x27;</span>)<br>    <span class="hljs-comment">//用于自动为 JAVA Processor 生成 META-INF 信息。</span><br>    implementation <span class="hljs-string">&#x27;com.google.auto.service:auto-service:1.0-rc3&#x27;</span><br>    <span class="hljs-comment">//快速生成.java文件的库</span><br>    implementation <span class="hljs-string">&#x27;com.squareup:javapoet:1.8.0&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><code>Processor</code> 重写父类的几个方法：</p><ul><li><code>process()</code>方法，这里是处理注解内部逻辑的，也是本文的关键点之一；</li><li><code>getSupportedSourceVersion()</code>：设置支持的版本，一般用最新的就好；</li></ul><ul><li><p><code>getSupportedAnnotationTypes()</code>：添加支持的注解类型，可以是单个／多个，用Set存储；</p></li><li><p><code>init ()</code>：一些初始化操作，获取一些有用的系统工具类，比如生成文件、打印信息、处理元素等；</p></li></ul></li></ul><p>​            <code>getSupportedSourceVersion()</code>、<code>getSupportedAnnotationTypes()</code>这2个方法还有一种    简单的方式来实现，如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@AutoService</span>(Processor.class)<br>@SupportedAnnotationTypes(&#123;&quot;com<span class="hljs-selector-class">.zx</span><span class="hljs-selector-class">.annotation</span>&quot;&#125;)<br><span class="hljs-keyword">@SupportedSourceVersion</span>(SourceVersion.RELEASE_8)<br>public class ViewInjectProcessor extends AbstractProcessor &#123;&#125;<br></code></pre></td></tr></table></figure><p>是通过注解来实现的，看上去是比较简洁</p><ul><li><code>@SupportedAnnotationTypes()</code>可以申明一个注解数组，但是这种字符串拼接容易出错；</li><li><code>@SupportedSourceVersion</code>：设置支持的源码版本，可以是RELEASE_0～RELEASE_8，但是不能使用<code>latestSupported()</code>设置最新的版本；</li></ul><h1 id="方法讲解"><a href="#方法讲解" class="headerlink" title="方法讲解"></a>方法讲解</h1><p>我们今天只说Processor。先从接口的方法介绍起把。</p><table><thead><tr><th>变量和类型</th><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>Iterable&lt;? extends Completion&gt;</code></td><td>getCompletions(Element element, AnnotationMirror annotation, ExecutableElement member, String userText)</td><td>返回一个空的迭代完成。</td></tr><tr><td><code>Set&lt;String&gt;</code></td><td>getSupportedAnnotationTypes()</td><td>如果处理器类使用SupportedAnnotationTypes进行批注，则返回与注释具有相同字符串集的不可修改集。</td></tr><tr><td><code>Set&lt;String&gt;</code></td><td>getSupportedOptions()</td><td>如果处理器类使用SupportedOptions进行批注，则返回具有与批注相同的字符串集的不可修改集。</td></tr><tr><td><code>SourceVersion</code></td><td>getSupportedSourceVersion()</td><td>如果处理器类使用SupportedSourceVersion进行批注，请在批注中返回源版本。</td></tr><tr><td><code>void</code></td><td>init(ProcessingEnvironment processingEnv)</td><td>通过将 processingEnv字段设置为 processingEnv参数的值，使用处理环境初始化处理器。</td></tr><tr><td><code>boolean</code></td><td>process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</td><td>处理源自前一轮的类型元素的一组注释类型，并返回此处理器是否声明了这些注释类型。 如果返回true ，则声明注释类型，并且不会要求后续处理器处理它们; 如果返回false ，则注释类型无人认领，可能会要求后续处理器处理它们。 处理器可以总是返回相同的布尔值，或者可以根据其自己选择的标准改变结果。</td></tr></tbody></table><ul><li><p>init：<br>初始化工作，我们可以得到一些有用的工具，例如 Filer，我们需要它将生成的代码写入文件中</p><p>init(ProcessingEnvironment env):每个Annotation Processor必须***<br> 有一个空的构造函数 ***。编译期间，init()会自动被注解处理工具调用，并传入ProcessingEnviroment参数，通过该参数可以获取到很多有用的工具类:  <strong>Elements , Types , Filer</strong>  等等</p></li><li><p>process：<br>最重要的方法，所有的注解处理都是在此完成</p><p>process(Set&lt;? extends TypeElement&gt; annoations, RoundEnvironment roundEnv):Annotation Processor扫描出的结果会存储进roundEnv中，可以在这里获取到注解内容，编写你的操作逻辑。注意,process()函数中不能直接进行异常抛出,否则的话,运行Annotation Processor的进程会异常崩溃,然后弹出一大堆让人捉摸不清的堆栈调用日志显示.</p></li><li><p>getSupportedAnnotationTypes：<br>返回我们所要处理的注解的一个集合</p><p>getSupportedAnnotationTypes(): 该函数用于指定该自定义注解处理器(Annotation Processor)是注册给哪些注解的(Annotation),注解(Annotation)指定必须是完整的包名+类名(eg:com.example.MyAnnotation)</p></li><li><p>getSupportedSourceVersion：<br>要支持的java版本</p><p>getSupportedSourceVersion():用于指定你的java版本，一般返回：SourceVersion.latestSupported()。当然，你也可以指定具体java版本：<br> return SourceVersion.RELEASE_7;</p></li></ul><h2 id="ProcessingEnvironment"><a href="#ProcessingEnvironment" class="headerlink" title="ProcessingEnvironment"></a>ProcessingEnvironment</h2><p>这个类很重要，要考的。这个类会在函数init的时候被传入，主要的工具类方法都在这个类上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ProcessingEnvironment</span> </span>&#123;<br>    <span class="hljs-function">Map&lt;String, String&gt; <span class="hljs-title">getOptions</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">Messager <span class="hljs-title">getMessager</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">Filer <span class="hljs-title">getFiler</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">Elements <span class="hljs-title">getElementUtils</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">Types <span class="hljs-title">getTypeUtils</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">SourceVersion <span class="hljs-title">getSourceVersion</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">Locale <span class="hljs-title">getLocale</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Filer 就是文件流输出路径，当我们用AbstractProcess生成一个java类的时候，我们需要保存在Filer指定的目录下。</p><p>Messager 输出日志工具，需要输出一些日志相关的时候我们就要使用这个了。</p><p>Elements 获取元素信息的工具，比如说一些类信息继承关系等。</p><p>Types 类型相关的工具类，processor java代码不同的是，当process执行的时候，class的由于类并没有被传递出来，所以大部分都行都是用element来代替了，所以很多类型比较等等的就会转化成type相关的进行比较了。</p><p>类型相关的都被转化成了一个叫TypeMirror，其getKind方法返回类型信息，其中包含了基础类型以及引用类型。</p><p>举个简单的例子，当一个实现了注解的Element被传入的时候，我们要判断Element是不是实现了特定接口，那么应该如何做呢？</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">private</span> Elements elementUtils;<br><span class="hljs-keyword">private</span> Types types;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> synchronized <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">init</span>(<span class="hljs-params">ProcessingEnvironment processingEnv</span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>.init(processingEnv);<br>    types = processingEnv.getTypeUtils();<br>    elementUtils = processingEnv.getElementUtils();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-function"><span class="hljs-title">isSubType</span>(<span class="hljs-params">Element element, <span class="hljs-built_in">String</span> className</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> element != <span class="hljs-literal">null</span> &amp;&amp; isSubType(element.asType(), className);<br>&#125;<br><br><span class="hljs-keyword">public</span> TypeMirror <span class="hljs-function"><span class="hljs-title">typeMirror</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> className</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> typeElement(className).asType();<br>&#125;<br><br><span class="hljs-keyword">public</span> TypeElement <span class="hljs-function"><span class="hljs-title">typeElement</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> className</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> elementUtils.getTypeElement(className);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-function"><span class="hljs-title">isSubType</span>(<span class="hljs-params">TypeMirror <span class="hljs-keyword">type</span>, <span class="hljs-built_in">String</span> className</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">type</span> != <span class="hljs-literal">null</span> &amp;&amp; types.isSubtype(<span class="hljs-keyword">type</span>, typeMirror(className));<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>其中isSubType方法是判断传入的Element是不是一个接口的实现类。首先我们要将对象都转化成Element, 然后将两个element转化成TypeMirror，之后调用Types的isSubtype方法对两个TypeMirror进行比较，如果发现类型一样，则该输入的Element是特定接口的实现类。</strong></p><h2 id="process"><a href="#process" class="headerlink" title="process()"></a>process()</h2><p>扫描代码的时候会把当前获取到的，此processer能处理的annotations传入当前方法</p><h3 id="Processor的kapt优化"><a href="#Processor的kapt优化" class="headerlink" title="Processor的kapt优化"></a>Processor的kapt优化</h3><p>kotlin对apt做了很多优化，内部完成了增量编译。但是对于低版本的autoservice，其增量编译会被关闭。</p><p>这里简单给各位大佬做下这方面的升级就好了。</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs clean">apply plugin: <span class="hljs-string">&#x27;java-library&#x27;</span><br>apply plugin: <span class="hljs-string">&#x27;kotlin&#x27;</span><br>apply plugin: <span class="hljs-string">&#x27;kotlin-kapt&#x27;</span><br><br>dependencies &#123;<br>    <span class="hljs-keyword">implementation</span> <span class="hljs-string">&#x27;com.google.auto.service:auto-service:1.0-rc5&#x27;</span><br>    <span class="hljs-keyword">implementation</span> <span class="hljs-string">&#x27;com.squareup:javapoet:1.10.0&#x27;</span><br>    <span class="hljs-keyword">implementation</span> <span class="hljs-string">&#x27;com.github.leifzhang:RouterAnnotation:0.5.0&#x27;</span><br>    <span class="hljs-keyword">implementation</span> <span class="hljs-string">&quot;org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version&quot;</span><br>    kapt <span class="hljs-string">&quot;com.google.auto.service:auto-service:1.0-rc5&quot;</span><br>&#125;<br>sourceCompatibility = <span class="hljs-number">1.8</span><br>targetCompatibility = <span class="hljs-number">1.8</span><br><br></code></pre></td></tr></table></figure><p>简单的说就是把processor 升级到rc5，然后用kapt的方式去把它注册起来就行了。</p><h2 id="缺点和总结"><a href="#缺点和总结" class="headerlink" title="缺点和总结"></a>缺点和总结</h2><p>缺点：apt能做的事情还是比较有限的</p><ol><li>javapoet只能新增一个类，而不能对当前类进行更改。</li><li>proessor在javac执行之前，所以只能对当前moudule生效</li><li>当Module一多，可能会有类名冲突的问题</li></ol><p>但是apt还是能帮助我们解决很多问题的，我们可以把一些机械化的操作，通过anntation的方式去简化，比如butterknife，这样开发就可以有更多的精力去专注做写别的事情。一部分abtest赋值的操作其实也可以用同样的方式去调整。</p><hr><h2 id="一些疑问"><a href="#一些疑问" class="headerlink" title="一些疑问"></a>一些疑问</h2><ul><li>注解处理器processor为什么要在META-INF注册？</li><li>注解处理器processor是如何被系统调用的？</li><li>注解申明和注解处理器为什么要分Module处理？</li><li>apt项目不会增加apk体积？</li></ul><p>先来回顾一下之前项目的部分目录结构</p><p><img src="https://upload-images.jianshu.io/upload_images/4134622-6cfb718f3055b89b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image.png</p><p>先明确一些概念：<br> <code>AbstractProcessor</code>是抽象处理器，开发apt时都必须继承这个类来生成<code>.java</code>文件，实现的这个类后叫做注解处理器，也就是这里的<code>ButterKnifeProcessor</code>。</p><h4 id="Q1-注解处理器processor为什么要在META-INF注册？"><a href="#Q1-注解处理器processor为什么要在META-INF注册？" class="headerlink" title="Q1:注解处理器processor为什么要在META-INF注册？"></a>Q1:注解处理器processor为什么要在META-INF注册？</h4><hr><p><code>META-INF</code>的作用<br> META-INF, 相当于一个信息包，用于存放一些meta information相关的文件。用来配置应用程序、扩展程序、类加载器和服务<a href="https://links.jianshu.com/go?to=https://www.baidu.com/s?wd=manifest.mf&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">manifest.mf</a>文件，在用jar打包时自动生成。</p><p>在之前的文章中说过，通过<code>@AutoService(Processor.class)</code>注解把注解处理器<code>ButterKnifeProcessor</code>注册到META-INF/services中，这里的包名是<code>META-INF/services/javax.annotation.processing.Processor</code>,<br> 这个文件的内容是</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">com<span class="hljs-selector-class">.zx</span><span class="hljs-selector-class">.processor</span><span class="hljs-selector-class">.ButterKnifeProcessor</span><br></code></pre></td></tr></table></figure><p>这个包名其实就是<code>@AutoService(Processor.class)</code>里面的<code>Processor</code>类；而文件内容就是注解处理器。</p><p><strong>在编译时，java编译器（javac）会去META-INF中查找实现了的AbstractProcessor的子类，并且调用该类的process函数，最终生成<code>.java</code>文件。</strong>其实就像activity需要注册一样，就是要到META-INF注册 ，javac才知道要给你调用哪个类来处理注解。</p><h4 id="Q2：注解处理器processor是如何被系统调用的？"><a href="#Q2：注解处理器processor是如何被系统调用的？" class="headerlink" title="Q2：注解处理器processor是如何被系统调用的？"></a>Q2：注解处理器processor是如何被系统调用的？</h4><hr><p>一些细心的同学应该发现了这个问题，我们并没有手动调用<code>AbstractProcessor</code>这个注解处理器类，那系统是什么时间调用的？又是如何调用的？这其实就牵扯到apt工作机制。</p><p>在上一问中，我们已经了解到，在编译时javac会查找所有的 在META_INF 中注册的注解处理器来处理注解。</p><p>到这里，好像有点清楚了，大概知道javac会去找到Processor并调用。但是呢还是没找到直接源头，因为它不像我们面向对象编程中可以准确追踪到是哪个对象调用的。</p><p>别着急，先来看这么个东西.<br> 是我项目中使用到注解的<code>app.Gradle</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp">dependencies &#123;<br>    <span class="hljs-function">implementation <span class="hljs-title">project</span>(<span class="hljs-params"><span class="hljs-string">&#x27;:annotation&#x27;</span></span>)</span><br><span class="hljs-function">    implementation <span class="hljs-title">project</span>(<span class="hljs-params"><span class="hljs-string">&#x27;:inject_api&#x27;</span></span>)</span><br><span class="hljs-function">    <span class="hljs-comment">//gradle3.0以上apt的实现方式</span></span><br><span class="hljs-function">    annotationProcessor <span class="hljs-title">project</span>(<span class="hljs-params"><span class="hljs-string">&#x27;:processor&#x27;</span></span>)</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><p>这里的<code>annotationProcessor</code>有点特别，没错，它是<strong>APT</strong>实现方案的一种。这里简单介绍一下：</p><blockquote><p>APT实现方案<br> <code>android-apt</code>和<code>annotationProcessor</code>功能是一样的，都是apt的实现方案，前者是个人开发者提供，比较早（现在不再维护了），后者是google官方开发的内置在<code>gradle</code>里的apt。</p><p>annotationProcessor是APT工具中的一种，是google开发的内置框架，不需要引入，可以直接在<code>build.gradle</code>文件中使用。</p></blockquote><p>只有在你使用注解的地方引入了<code>annotationProcessor</code>，系统才会主动调用注解处理类<code>Processor</code>,才会最终生成如下的<code>.java</code>文件</p><p><img src="TyporaRaw/java%E6%B3%A8%E8%A7%A3.assets/4134622-86775724faaeaa3e.png" alt="img"></p><p>apt生成类.png</p><p>这里先简单总结一下：<br> 2.1、在完成注解处理类<code>Processor</code>之后，需要做2件事情：</p><ul><li>1、在META-INF目录下注册<code>Processor</code>；</li><li>2、在项目中使用注解的地方添加apt工具<code>annotationProcessor</code></li></ul><p>2.2、APT 4要素<br> 　<strong>注解处理器（AbstractProcess）+ 代码处理（javaPoet）+ 处理器注册（AutoService）+ apt（annotationProcessor）</strong></p><p><code>APT(Annotation Processing Tool)总结</code><br> 首先，APT是javac提供的一种工具，它在编译时扫描、解析、处理注解。它会对源代码文件进行检测，找出用户自定义的注解，根据注解、注解处理器和相应的apt工具自动生成代码。这段代码是根据用户编写的注解处理逻辑去生成的。<strong>最终将生成的新的源文件与原来的源文件共同编译（注意：APT并不能对源文件进行修改操作，只能生成新的文件，例如往原来的类中添加方法）</strong>。具体流程图如下图所示：</p><p><img src="TyporaRaw/java%E6%B3%A8%E8%A7%A3.assets/4134622-b1f7494d18e216d1.png" alt="img"></p><p>apt工作流程.png</p><p>APT技术的使用，需要我们遵守一定的规则。大家先看一下整个APT项目项目构建的一个规则图，具体如下所示：</p><p><img src="TyporaRaw/java%E6%B3%A8%E8%A7%A3.assets/4134622-55d88199566ac011.png" alt="img"></p><h4 id="Q3：注解申明和注解处理器为什么要分Module处理？"><a href="#Q3：注解申明和注解处理器为什么要分Module处理？" class="headerlink" title="Q3：注解申明和注解处理器为什么要分Module处理？"></a>Q3：注解申明和注解处理器为什么要分Module处理？</h4><hr><p>先来回顾一下之前的项目结构：</p><p><img src="TyporaRaw/java%E6%B3%A8%E8%A7%A3.assets/4134622-1a701ad9e6425883.png" alt="img"></p><ul><li><code>annotation</code>：申明注解 （java lib）</li><li><code>processor</code>：注解处理器（java lib）</li><li><code>inject_api</code>：调用处理器中生成的类 （android lib）</li><li><code>app</code>：项目使用 （android lib）</li></ul><p>我们都知道注解处理器都需要继承<code>AbstractProcessor</code>类，但是<code>AbstractProcessor</code>是JDK中的类，不在android sdk中，所以需要放在单独的java lib中；而<code>processor</code>中需要依赖自定义注解，把<code>annotation</code>抽成一个独立的lib，便于维护。</p><p><strong>那注解声明和注解处理为什么要分开呢？可不可以放在一起？</strong><br> 先说结论：可以放在一起，放在一起对功能上没有什么影响；但是一般不放在一起，原因如下：</p><blockquote><p>我们都知道<code>processor</code>的作用是：在编译器解析注解、生成新的<code>.java</code>文件。<strong>这个lib只在编译器用到，是不会被打包进apk的。</strong>对于调用者来说，你只是想使用这个注解，而不希望你已经编译好的项目中引进注解处理器相关的内容，所以为了不引入没必要的文件，我们一般选择将注解声明和注解处理分开处理。</p></blockquote><p>到这里apt相关知识就说完了，我们也可以理解为什么<code>ButterKnife</code>这种注解库不会增加项目体积了。</p><p>想了解更多apt知识，可以参考：<br> <a href="https://www.jianshu.com/p/b6b3283968e0">https://www.jianshu.com/p/b6b3283968e0</a></p><p>感谢<br> <a href="https://links.jianshu.com/go?to=https://blog.csdn.net/xx326664162/article/details/68490059">你必须知道的APT、annotationProcessor、android-apt、Provided、自定义注解</a></p><p>作者：唠嗑008<br>链接：<a href="https://www.jianshu.com/p/89ac9a2513c4">https://www.jianshu.com/p/89ac9a2513c4</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/12/22/hello-world/"/>
    <url>/2021/12/22/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>scroller</title>
    <link href="/2021/02/04/scroll/"/>
    <url>/2021/02/04/scroll/</url>
    
    <content type="html"><![CDATA[<p>Scroller的总结<br>内容来自各个博客</p><ul><li>本质及作用：<br>Scroller本质就是一个Helper类，里面保存了目标对象要移动的距离，时间等属性！     </li></ul><p>Android ViewGroup中的Scroller与computeScroll的有什么关系？</p><p>答：没有直接的关系</p><p>1.Scroller到底是什么？</p><p>答：Scroller只是个计算器，提供插值计算，让滚动过程具有动画属性，但它并不是UI，也不是辅助UI滑动，反而是单纯地为滑动提供计算。</p><p>无论从构造方法还是其他方法，以及Scroller的属性可知，其并不会持有View，辅助ViewGroup滑动</p><p>2.Scroller只是提供计算，那谁来调用computeScroll使得ViewGroup滑动</p><p>答：computeScroll也不是来让ViewGroup滑动的，真正让ViewGroup滑动的是scrollTo,scrollBy。computeScroll的作用是计算ViewGroup如何滑动。而computeScroll是通过draw来调用的。</p><p>3.computeScroll和Scroller都是计算，两者有啥关系？</p><p>答：文章开始已作答，没有直接的关系。computeScroll和Scroller要是飞得拉关系的话，那就是computeScroll可以参考Scroller计算结果来影响scrollTo,scrollBy,从而使得滑动发生改变。也就是Scroller不会调用computeScroll，反而是computeScroll调用Scroller。</p><p>4.滑动时连续的，如何让Scroller的计算也是连续的？</p><p>这个就问到了什么时候调用computeScroll了，如上所说computeScroll调用Scroller，只要computeScroll调用连续，Scroller也会连续，实质上computeScroll的连续性又invalidate方法控制，scrollTo,scrollBy都会调用invalidate，而invalidate回去触发draw,从而computeScroll被连续调用，综上，Scroller也会被连续调用，除非invalidate停止调用。</p><p>5.computeScroll如何和Scroller的调用过程保持一致。</p><p>computeScroll参考Scroller影响scrollTo,scrollBy，实质上，为了不重复影响scrollTo,scrollBy，那么Scroller必须终止计算currX，currY。要知道计算有没有终止，需要通过mScroller.computeScrollOffset()</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">computeScroll</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">super</span>.computeScroll();<br><span class="hljs-keyword">if</span>(!mScroll.computeScrollOffset())&#123;<br><span class="hljs-comment">//计算currX,currY,并检测是否已完成&quot;滚动&quot;</span><br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">int</span> tempX=mScroll.getCurrX();<br>scrollTo(tempX,<span class="hljs-number">0</span>);<span class="hljs-comment">//会重复调用invalidate</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>注意：在移动平台中，要明确知道“滑动”与“滚动”的不同，具体来说，滑动和滚动的方向总是相反的。</code></p><p>再来看一下scrollTo,scrollBy这两个方法的区别, scrollTo()方法是让View相对于初始的位置滚动某段距离，由于View的初始位置是不变的，因此不管我们点击多少次scrollTo按钮滚动到的都将是同一个位置。而scrollBy()方法则是让View相对于当前的位置滚动某段距离，那每当我们点击一次scrollBy按钮，View的当前位置都进行了变动，因此不停点击会一直移动。</p><p>通过这个例子来理解，相信大家已经把scrollTo()和scrollBy()这两个方法的区别搞清楚了，但是现在还有一个问题，目前使用这两个方法完成的滚动效果是跳跃式的，没有任何平滑滚动的效果。没错，只靠scrollTo()和scrollBy()这两个方法是很难完成ViewPager这样的效果的，因此我们还需要借助另外一个关键性的工具，也就我们今天的主角Scroller。<br>Scroller的基本用法其实还是比较简单的，主要可以分为以下几个步骤：</p><p>1.创建Scroller的实例<br>2.调用startScroll()方法来初始化滚动数据并刷新界面<br>3.重写computeScroll()方法，并在其内部完成平滑滚动的逻辑<br>那么下面我们就按照上述的步骤，通过一个模仿ViewPager的简易例子来学习和理解一下Scroller的用法。<br>新建一个ScrollerLayout并让它继承自ViewGroup来作为我们的简易ViewPager布局，代码如下所示：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Created by guolin on 16/1/12.</span><br><span class="hljs-comment"> */</span><br>public <span class="hljs-keyword">class</span> ScrollerLayout extends ViewGroup &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用于完成滚动操作的实例</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Scroller mScroller;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判定为拖动的最小移动像素数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> mTouchSlop;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 手机按下时的屏幕坐标</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span> mXDown;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 手机当时所处的屏幕坐标</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span> mXMove;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 上次触发ACTION_MOVE事件时的屏幕坐标</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span> mXLastMove;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 界面可滚动的左边界</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> leftBorder;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 界面可滚动的右边界</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> rightBorder;<br><br>    public <span class="hljs-constructor">ScrollerLayout(Context <span class="hljs-params">context</span>, AttributeSet <span class="hljs-params">attrs</span>)</span> &#123;<br>        super(context, attrs);<br>        <span class="hljs-comment">// 第一步，创建Scroller的实例</span><br>        mScroller = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Scroller(<span class="hljs-params">context</span>)</span>;<br>        ViewConfiguration configuration = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ViewConfiguration</span>.</span></span>get(context);<br>        <span class="hljs-comment">// 获取TouchSlop值</span><br>        mTouchSlop = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ViewConfigurationCompat</span>.</span></span>get<span class="hljs-constructor">ScaledPagingTouchSlop(<span class="hljs-params">configuration</span>)</span>;<br>    &#125;<br><br>    @Override<br>    protected void on<span class="hljs-constructor">Measure(<span class="hljs-params">int</span> <span class="hljs-params">widthMeasureSpec</span>, <span class="hljs-params">int</span> <span class="hljs-params">heightMeasureSpec</span>)</span> &#123;<br>        super.on<span class="hljs-constructor">Measure(<span class="hljs-params">widthMeasureSpec</span>, <span class="hljs-params">heightMeasureSpec</span>)</span>;<br>        <span class="hljs-built_in">int</span> childCount = get<span class="hljs-constructor">ChildCount()</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; childCount; i++) &#123;<br>            View childView = get<span class="hljs-constructor">ChildAt(<span class="hljs-params">i</span>)</span>;<br>            <span class="hljs-comment">// 为ScrollerLayout中的每一个子控件测量大小</span><br>            measure<span class="hljs-constructor">Child(<span class="hljs-params">childView</span>, <span class="hljs-params">widthMeasureSpec</span>, <span class="hljs-params">heightMeasureSpec</span>)</span>;<br>        &#125;<br>    &#125;<br><br>    @Override<br>    protected void on<span class="hljs-constructor">Layout(<span class="hljs-params">boolean</span> <span class="hljs-params">changed</span>, <span class="hljs-params">int</span> <span class="hljs-params">l</span>, <span class="hljs-params">int</span> <span class="hljs-params">t</span>, <span class="hljs-params">int</span> <span class="hljs-params">r</span>, <span class="hljs-params">int</span> <span class="hljs-params">b</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (changed) &#123;<br>            <span class="hljs-built_in">int</span> childCount = get<span class="hljs-constructor">ChildCount()</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; childCount; i++) &#123;<br>                View childView = get<span class="hljs-constructor">ChildAt(<span class="hljs-params">i</span>)</span>;<br>                <span class="hljs-comment">// 为ScrollerLayout中的每一个子控件在水平方向上进行布局</span><br>                childView.layout(i<span class="hljs-operator"> * </span>childView.get<span class="hljs-constructor">MeasuredWidth()</span>, <span class="hljs-number">0</span>, (i + <span class="hljs-number">1</span>)<span class="hljs-operator"> * </span>childView.get<span class="hljs-constructor">MeasuredWidth()</span>, childView.get<span class="hljs-constructor">MeasuredHeight()</span>);<br>            &#125;<br>            <span class="hljs-comment">// 初始化左右边界值</span><br>            leftBorder = get<span class="hljs-constructor">ChildAt(0)</span>.get<span class="hljs-constructor">Left()</span>;<br>            rightBorder = get<span class="hljs-constructor">ChildAt(<span class="hljs-params">getChildCount</span>()</span> - <span class="hljs-number">1</span>).get<span class="hljs-constructor">Right()</span>;<br>        &#125;<br>    &#125;<br><br>    @Override<br>    public boolean on<span class="hljs-constructor">InterceptTouchEvent(MotionEvent <span class="hljs-params">ev</span>)</span> &#123;<br>        switch (ev.get<span class="hljs-constructor">Action()</span>) &#123;<br>            case MotionEvent.ACTION_DOWN:<br>                mXDown = ev.get<span class="hljs-constructor">RawX()</span>;<br>                mXLastMove = mXDown;<br>                break;<br>            case MotionEvent.ACTION_MOVE:<br>                mXMove = ev.get<span class="hljs-constructor">RawX()</span>;<br>                <span class="hljs-built_in">float</span> diff = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>abs(mXMove - mXDown);<br>                mXLastMove = mXMove;<br>                <span class="hljs-comment">// 当手指拖动值大于TouchSlop值时，认为应该进行滚动，拦截子控件的事件</span><br>                <span class="hljs-keyword">if</span> (diff &gt; mTouchSlop) &#123;<br>                    return <span class="hljs-literal">true</span>;<br>                &#125;<br>                break;<br>        &#125;<br>        return super.on<span class="hljs-constructor">InterceptTouchEvent(<span class="hljs-params">ev</span>)</span>;<br>    &#125;<br><br>    @Override<br>    public boolean on<span class="hljs-constructor">TouchEvent(MotionEvent <span class="hljs-params">event</span>)</span> &#123;<br>        switch (event.get<span class="hljs-constructor">Action()</span>) &#123;<br>            case MotionEvent.ACTION_MOVE:<br>                mXMove = event.get<span class="hljs-constructor">RawX()</span>;<br>                <span class="hljs-built_in">int</span> scrolledX = (<span class="hljs-built_in">int</span>) (mXLastMove - mXMove);<br>                <span class="hljs-keyword">if</span> (get<span class="hljs-constructor">ScrollX()</span> + scrolledX &lt; leftBorder) &#123;<br>                    scroll<span class="hljs-constructor">To(<span class="hljs-params">leftBorder</span>, 0)</span>;<br>                    return <span class="hljs-literal">true</span>;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (get<span class="hljs-constructor">ScrollX()</span> + get<span class="hljs-constructor">Width()</span> + scrolledX &gt; rightBorder) &#123;<br>                    scroll<span class="hljs-constructor">To(<span class="hljs-params">rightBorder</span> - <span class="hljs-params">getWidth</span>()</span>, <span class="hljs-number">0</span>);<br>                    return <span class="hljs-literal">true</span>;<br>                &#125;<br>                scroll<span class="hljs-constructor">By(<span class="hljs-params">scrolledX</span>, 0)</span>;<br>                mXLastMove = mXMove;<br>                break;<br>            case MotionEvent.ACTION_UP:<br>                <span class="hljs-comment">// 当手指抬起时，根据当前的滚动值来判定应该滚动到哪个子控件的界面</span><br>                <span class="hljs-built_in">int</span> targetIndex = (get<span class="hljs-constructor">ScrollX()</span> + get<span class="hljs-constructor">Width()</span><span class="hljs-operator"> / </span><span class="hljs-number">2</span>)<span class="hljs-operator"> / </span>get<span class="hljs-constructor">Width()</span>;<br>                <span class="hljs-built_in">int</span> dx = targetIndex<span class="hljs-operator"> * </span>get<span class="hljs-constructor">Width()</span> - get<span class="hljs-constructor">ScrollX()</span>;<br>                <span class="hljs-comment">// 第二步，调用startScroll()方法来初始化滚动数据并刷新界面</span><br>                mScroller.start<span class="hljs-constructor">Scroll(<span class="hljs-params">getScrollX</span>()</span>, <span class="hljs-number">0</span>, dx, <span class="hljs-number">0</span>);<br>                invalidate<span class="hljs-literal">()</span>;<br>                break;<br>        &#125;<br>        return super.on<span class="hljs-constructor">TouchEvent(<span class="hljs-params">event</span>)</span>;<br>    &#125;<br><br>    @Override<br>    public void compute<span class="hljs-constructor">Scroll()</span> &#123;<br>        <span class="hljs-comment">// 第三步，重写computeScroll()方法，并在其内部完成平滑滚动的逻辑</span><br>        <span class="hljs-keyword">if</span> (mScroller.compute<span class="hljs-constructor">ScrollOffset()</span>) &#123;<br>            scroll<span class="hljs-constructor">To(<span class="hljs-params">mScroller</span>.<span class="hljs-params">getCurrX</span>()</span>, mScroller.get<span class="hljs-constructor">CurrY()</span>);<br>            invalidate<span class="hljs-literal">()</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>整个Scroller用法的代码都在这里了，代码并不长，一共才100多行，我们一点点来看。<br>首先在ScrollerLayout的构造函数里面我们进行了上述步骤中的第一步操作，即创建Scroller的实例，由于Scroller的实例只需创建一次，因此我们把它放到构造函数里面执行。另外在构建函数中我们还初始化的TouchSlop的值，这个值在后面将用于判断当前用户的操作是否是拖动。</p><p>接着重写onMeasure()方法和onLayout()方法，在onMeasure()方法中测量ScrollerLayout里的每一个子控件的大小，在onLayout()方法中为ScrollerLayout里的每一个子控件在水平方向上进行布局。</p><p>接着重写onInterceptTouchEvent()方法， 在这个方法中我们记录了用户手指按下时的X坐标位置，以及用户手指在屏幕上拖动时的X坐标位置，当两者之间的距离大于TouchSlop值时，就认为用户正在拖动布局，然后我们就将事件在这里拦截掉，阻止事件传递到子控件当中。</p><p>那么当我们把事件拦截掉之后，就会将事件交给ScrollerLayout的onTouchEvent()方法来处理。如果当前事件是ACTION_MOVE，说明用户正在拖动布局，那么我们就应该对布局内容进行滚动从而影响拖动事件，实现的方式就是使用我们刚刚所学的scrollBy()方法，用户拖动了多少这里就scrollBy多少。另外为了防止用户拖出边界这里还专门做了边界保护，当拖出边界时就调用scrollTo()方法来回到边界位置。</p><p>如果当前事件是ACTION_UP时，说明用户手指抬起来了，但是目前很有可能用户只是将布局拖动到了中间，我们不可能让布局就这么停留在中间的位置，因此接下来就需要借助Scroller来完成后续的滚动操作。首先这里我们先根据当前的滚动位置来计算布局应该继续滚动到哪一个子控件的页面，然后计算出距离该页面还需滚动多少距离。接下来我们就该进行上述步骤中的第二步操作，调用startScroll()方法来初始化滚动数据并调用invalidate()来刷新界面。startScroll()方法接收四个参数，第一个参数是滚动开始时X的坐标，第二个参数是滚动开始时Y的坐标，第三个参数是横向滚动的距离，正值表示向左滚动，第四个参数是纵向滚动的距离，正值表示向上滚动。紧接着调用invalidate()方法来刷新界面。</p><p>现在前两步都已经完成了，最后我们还需要进行第三步操作，即重写computeScroll()方法，并在其内部完成平滑滚动的逻辑 。在整个后续的平滑滚动过程中，computeScroll()方法是会一直被调用的，因此我们需要不断调用Scroller的computeScrollOffset()方法来进行判断滚动操作是否已经完成了，如果还没完成的话，那就继续调用scrollTo()方法，并把Scroller的curX和curY坐标传入，然后刷新界面从而完成平滑滚动的操作。</p><hr><p>实现惯性滚动 (Scroller的妙用)<br><a href="%22https://blog.csdn.net/u011387817/article/details/80313184%22">Android实现圆弧滑动效果之ArcSlidingHelper篇</a><br>说到Scroller，相信大家第一时间想到要配合View中的computeScroll方法来使用对吧，但是呢，我们这篇文章的主题是辅助类，并不打算继承View，而且不持有Context引用，这个时候，可能有同学就会有以下疑问了：</p><ul><li>这种情况下，Scroller还能正常工作吗？</li><li>调用它的startScroll或fling方法后，不是还要调用View中的invalidate方法来触发的吗？</li><li>不继承View，哪来的 invalidate方法？  </li><li>不继承View，怎么重写computeScroll方法？在哪里处理惯性滚动？  </li><li>哈哈，其实Scroller是完全可以脱离View来使用的，既然说是妙用，妙在哪里呢？在开始之前，我们先来了解一下Scroller：  </li></ul><p>1.它看上去更像是一个ValueAnimator，但它跟ValueAnimator有个明显的区别就是：它不会主动更新动画的值。我们在获取最新值之前，总是要先调用computeScrollOffset方法来刷新内部的mCurrX、mCurrY的值，如果是惯性滚动模式(调用fling方法)，还会刷新mCurrVelocity的值。  </p><p>2.在这里先分享大家一个理解源码调用顺序的方法：<br>比如我们想知道是哪个方法调用了computeScroll：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">@Override<br>public void compute<span class="hljs-constructor">Scroll()</span> &#123;<br>    StackTraceElement<span class="hljs-literal">[]</span> elements = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">StackTrace()</span>;<br>    <span class="hljs-keyword">for</span> (StackTraceElement element : elements) &#123;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>i(<span class="hljs-string">&quot;computeScroll&quot;</span>, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">String</span>.</span></span>format(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Locale</span>.</span></span>get<span class="hljs-constructor">Default()</span>, <span class="hljs-string">&quot;%s-----&gt;%s\tline: %d&quot;</span>,<br>                element.get<span class="hljs-constructor">ClassName()</span>, element.get<span class="hljs-constructor">MethodName()</span>, element.get<span class="hljs-constructor">LineNumber()</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>日志输出：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">com.wuyr.testview.MyView<span class="hljs-comment">-----&gt;computeScrollline: 141</span><br>android.<span class="hljs-keyword">view</span>.<span class="hljs-keyword">View</span><span class="hljs-comment">-----&gt;updateDisplayListIfDirtyline: 15361</span><br>android.<span class="hljs-keyword">view</span>.<span class="hljs-keyword">View</span><span class="hljs-comment">-----&gt;drawline: 16182</span><br>android.<span class="hljs-keyword">view</span>.ViewGroup<span class="hljs-comment">-----&gt;drawChildline: 3777</span><br>android.<span class="hljs-keyword">view</span>.ViewGroup<span class="hljs-comment">-----&gt;dispatchDrawline: 3567</span><br>android.<span class="hljs-keyword">view</span>.<span class="hljs-keyword">View</span><span class="hljs-comment">-----&gt;updateDisplayListIfDirtyline: 15373</span><br>android.<span class="hljs-keyword">view</span>.<span class="hljs-keyword">View</span><span class="hljs-comment">-----&gt;drawline: 16182</span><br>android.<span class="hljs-keyword">view</span>.ViewGroup<span class="hljs-comment">-----&gt;drawChildline: 3777</span><br>android.<span class="hljs-keyword">view</span>.ViewGroup<span class="hljs-comment">-----&gt;dispatchDrawline: 3567</span><br>android.<span class="hljs-keyword">view</span>.<span class="hljs-keyword">View</span><span class="hljs-comment">-----&gt;updateDisplayListIfDirtyline: 15373</span><br>android.<span class="hljs-keyword">view</span>.<span class="hljs-keyword">View</span><span class="hljs-comment">-----&gt;drawline: 16182</span><br></code></pre></td></tr></table></figure><p>这样我们就能够很清晰的看到它的调用链了。</p><p>回到正题，所谓的调用invalidate方法来触发，是这样的：我们都知道，调用了这个方法之后，onDraw方法就会回调，而调用onDraw的那个方法，是draw(Canvas canvas)，再上一级，是draw(Canvas canvas, ViewGroup parent, long drawingTime)，重点来了：<br>computeScroll也是在这个方法中回调的，现在可以得出一个结论：<br>我们在View中调用invalidate方法，也就是间接地调用computeScroll，而computeScroll中，是我们处理滚动的方法，在使用Scroller时，我们都会重写这个方法，并在里面调用Scroller的computeScrollOffset方法，然后调用getCurrX或getCurrY来获取到最新的值。(好像我前面说的都是多余的) 但是！有没有发现，这个过程，我们完全可以不依赖View来做到的？</p><p>3.现在思路就很清晰了，invalidate方法？对于Scroller来说，它的作用只是回调computeScroll从而更新x和y的值而已。</p><p>4.所以完全可以自己写两个方法来实现Scroller在View中的效果，我们这次打算利用Hanlder来帮我们处理异步的问题，这样的话，我们就不用自己新开线程去不断的调用方法啦。</p><p>好了，现在我们所遇到的问题，都已经有解决方案了，可以动手咯！</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"> <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 处理触摸事件</span><br><span class="hljs-comment">     */</span><br>    public void handle<span class="hljs-constructor">Movement(MotionEvent <span class="hljs-params">event</span>)</span> &#123;<br>     .....<br>        mVelocityTracker.add<span class="hljs-constructor">Movement(<span class="hljs-params">event</span>)</span>;<br>        switch (event.get<span class="hljs-constructor">Action()</span>) &#123;<br>            case MotionEvent.ACTION_DOWN:<br>             .....<br>                break;<br>            case MotionEvent.ACTION_MOVE:<br>                handle<span class="hljs-constructor">ActionMove(<span class="hljs-params">x</span>, <span class="hljs-params">y</span>)</span>;<br>                break;<br>            case MotionEvent.ACTION_UP:<br>            case MotionEvent.ACTION_CANCEL:<br>            case MotionEvent.ACTION_OUTSIDE:<br>                <span class="hljs-keyword">if</span> (isInertialSlidingEnable) &#123;<br>                    mVelocityTracker.compute<span class="hljs-constructor">CurrentVelocity(1000)</span>;<br>                    mScroller.fling(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, (<span class="hljs-built_in">int</span>) mVelocityTracker.get<span class="hljs-constructor">XVelocity()</span>, (<span class="hljs-built_in">int</span>) mVelocityTracker.get<span class="hljs-constructor">YVelocity()</span>,Integer.MIN_VALUE, Integer.MAX_VALUE, Integer.MIN_VALUE, Integer.MAX_VALUE); <br>                    <span class="hljs-comment">//我们在调用Scroller的fling方法之后，并没有调用invalidate方法，而是我们自定义的startFling方法. </span><br>                    start<span class="hljs-constructor">Fling()</span>;<br>                &#125;<br>                break;<br>           .....<br>        &#125;<br> .....<br>    &#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 处理惯性滚动</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> void compute<span class="hljs-constructor">InertialSliding()</span> &#123;<br>        check<span class="hljs-constructor">IsRecycled()</span>;<br>        <span class="hljs-keyword">if</span> (mScroller.compute<span class="hljs-constructor">ScrollOffset()</span>) &#123;<br>            <span class="hljs-built_in">float</span> y = ((isShouldBeGetY ? mScroller.get<span class="hljs-constructor">CurrY()</span> : mScroller.get<span class="hljs-constructor">CurrX()</span>)<span class="hljs-operator"> * </span>mScrollAvailabilityRatio);<br>            <span class="hljs-keyword">if</span> (mLastScrollOffset != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-built_in">float</span> offset = fix<span class="hljs-constructor">Angle(Math.<span class="hljs-params">abs</span>(<span class="hljs-params">y</span> - <span class="hljs-params">mLastScrollOffset</span>)</span>);<br>                mSlidingListener.on<span class="hljs-constructor">Sliding(<span class="hljs-params">isClockwiseScrolling</span> ? <span class="hljs-params">offset</span> : -<span class="hljs-params">offset</span>)</span>;<br>            &#125;<br>            mLastScrollOffset = y;<br>            start<span class="hljs-constructor">Fling()</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mScroller.is<span class="hljs-constructor">Finished()</span>) &#123;<br>            mLastScrollOffset = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (mSlideFinishListener != null) &#123;<br>                mSlideFinishListener.on<span class="hljs-constructor">SlideFinished()</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 开始惯性滚动</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> void start<span class="hljs-constructor">Fling()</span> &#123;<br>        mHandler.send<span class="hljs-constructor">EmptyMessage(0)</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 主线程回调惯性滚动</span><br><span class="hljs-comment">     *Handler来处理异步的问题，这样就不用自己去新开线程了。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> static <span class="hljs-keyword">class</span> InertialSlidingHandler extends Handler &#123;<br><br>        ArcSlidingHelper mHelper;<br><br>        <span class="hljs-constructor">InertialSlidingHandler(ArcSlidingHelper <span class="hljs-params">helper</span>)</span> &#123;<br>            mHelper = helper;<br>        &#125;<br><br>        @Override<br>        public void handle<span class="hljs-constructor">Message(Message <span class="hljs-params">msg</span>)</span> &#123;<br>            mHelper.compute<span class="hljs-constructor">InertialSliding()</span>;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>我们用computeInertialSliding来代替了View中的computeScroll方法，用startFling代替了invalidate，可以说是完全脱离了View来使用Scroller，妙就妙在这里啦，嘻嘻。</p><hr><p>Scroller主要使用的滚动方法有：startScroll、fling。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">start<span class="hljs-constructor">Scroll(<span class="hljs-params">int</span> <span class="hljs-params">startX</span>, <span class="hljs-params">int</span> <span class="hljs-params">startY</span>, <span class="hljs-params">int</span> <span class="hljs-params">dx</span>, <span class="hljs-params">int</span> <span class="hljs-params">dy</span>, <span class="hljs-params">int</span> <span class="hljs-params">duration</span>)</span>：<br>指定起点（startX，startY），从起点平滑变化（dx，dy），耗时duration，通常用于：知道起点与需要改变的距离的平滑滚动等。<br><br>fling(<span class="hljs-built_in">int</span> startX, <span class="hljs-built_in">int</span> startY, <span class="hljs-built_in">int</span> velocityX, <span class="hljs-built_in">int</span> velocityY, <span class="hljs-built_in">int</span> minX, <span class="hljs-built_in">int</span> maxX, <span class="hljs-built_in">int</span> minY, <span class="hljs-built_in">int</span> maxY)：<br>惯性滑动。  给定一个初始速度（ velocityX， velocityY ），该方法内部会根据这个速度去计算需要滑动的距离以及需要耗费的时间。通常用于：界面的惯性滑动等。<br></code></pre></td></tr></table></figure><p>scroller的实例化：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Scroller mScroller = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Scroller(Context <span class="hljs-params">mContext</span>)</span>&#123;&#125;; :采用默认插值器<br>Scroller mScroller = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Scroller(Context <span class="hljs-params">mContext</span>，Interpolator <span class="hljs-params">interpolator</span>)</span>&#123;&#125;;采用指定的插值器<br></code></pre></td></tr></table></figure><p>调用过程：</p><pre><code>   public void startScroll( int startX, int startY, int dx,int dy)&#123;&#125;;</code></pre><p>这方法并不是真正意义上的开始Scroll，它的作用是为Scroller做一些准备工作,比如设置移动的初始位置，滑动的位移以及持续时间等。</p><pre><code>   public boolean computeScrollOffset()&#123;&#125;</code></pre><p>这方法用于判断移动过程是否完成</p><pre><code>   getCurrX、getCurrY、getFinalX、getFinalY、</code></pre><p>这些方法用于获取scroll的一些位置信息</p><ul><li>Scroller与View结合使用：</li></ul><p>首先需要在自定义的View中定义一个私有成员 mScroller，用于记录view滚动的位置，然后再重写View的<code>computeScroll（）</code>方法来实现具体移动</p><p>注意：Scroller的作用只是保存一些信息，以及判断是否移动完成，所以我们得知道<code>computeScroll（）</code>这个方法的调用流程，在查看Android源码时发现<br>View.java中的<code>computeScroll（）</code>方法是一个空函数，所以我们需要在自定义的View中重写这个方法来实现我们想要的功能，那么<code>computeScroll（）</code>是怎么样被调用的呢？</p><p>调用<code>invalidate()</code>（UI线程）或者<code>postInvalidate（）</code>使View（Viewgroup）树重绘.<br>重绘分成两种情况：</p><p>1、Viewgroup的重绘<br><code>ViewGroup的绘制流程：onDraw（）--&gt;dispatchDraw()--&gt;drawChild()--&gt;child.computeScroll()</code></p><p>2、View的重绘：</p><p>View没有子view所以在View的源码中看到<code>dispatchDraw（）</code>方法是一个空方法，那么其调用流程就和ViewGroup是不一样的，那么View是怎样调用<code>computeScroll（）</code>的呢？</p><p>我们注意到invalidate是重绘整个View树或者ViewGroup树，所以当View重绘时其所在父容器也会重绘，so，父容器就会经历<code>onDraw（）--&gt;dispatchDraw()--&gt;drawChild() --&gt;child.computeScroll()</code>流程，这时候自定义View中重写的computeScroll（）方法就会被调用。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"> <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ViewGroup</span>.</span></span>java：<br><br>@Override  <br>protected void dispatch<span class="hljs-constructor">Draw(Canvas <span class="hljs-params">canvas</span>)</span>&#123; <br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;  <br>            final View child = children<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>;  <br>            <span class="hljs-keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK)<span class="hljs-operator"> == </span>VISIBLE<span class="hljs-operator"> || </span>child.get<span class="hljs-constructor">Animation()</span> != null)  <br>  <br>            &#123;  <br>                more <span class="hljs-pattern-match">|= draw<span class="hljs-constructor">Child(<span class="hljs-params">canvas</span>, <span class="hljs-params">child</span>, <span class="hljs-params">drawingTime</span>)</span>;  </span><br><span class="hljs-pattern-match">            &#125;  </span><br><span class="hljs-pattern-match">draw<span class="hljs-constructor">Child</span>函数：</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">protected boolean draw<span class="hljs-constructor">Child(Canvas <span class="hljs-params">canvas</span>, View <span class="hljs-params">child</span>, <span class="hljs-params">long</span> <span class="hljs-params">drawingTime</span>)</span> &#123;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">                  ----------</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">child.compute<span class="hljs-constructor">Scroll()</span>;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">              -----------------</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match"> <span class="hljs-keyword">if</span> ((child.m<span class="hljs-constructor">PrivateFlags</span> &amp; <span class="hljs-constructor">SKIP_DRAW</span>) <span class="hljs-operator">==</span> <span class="hljs-constructor">SKIP_DRAW</span>) &#123;</span><br><span class="hljs-pattern-match">        <span class="hljs-keyword">if</span> (<span class="hljs-constructor">ViewDebug</span>.<span class="hljs-constructor">TRACE_HIERARCHY</span>) &#123;</span><br><span class="hljs-pattern-match">            <span class="hljs-constructor">ViewDebug</span>.trace(this, <span class="hljs-constructor">ViewDebug</span>.<span class="hljs-constructor">HierarchyTraceType</span>.<span class="hljs-constructor">DRAW</span>);</span><br><span class="hljs-pattern-match">        &#125;</span><br><span class="hljs-pattern-match">        child.dispatch<span class="hljs-constructor">Draw(<span class="hljs-params">canvas</span>)</span>;</span><br><span class="hljs-pattern-match">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="hljs-pattern-match">        child.draw(canvas);</span><br><span class="hljs-pattern-match">    &#125;</span><br></code></pre></td></tr></table></figure><ul><li>自定义View：</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> CustomView extends View &#123;  <br>  <br>    <span class="hljs-keyword">private</span> Scroller mScroller;  <br> <br>    public <span class="hljs-constructor">CustomView(Context <span class="hljs-params">context</span>, AttributeSet <span class="hljs-params">attrs</span>)</span> &#123;  <br>        super(context, attrs);  <br>        mScroller = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Scroller(<span class="hljs-params">context</span>)</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//调用此方法滚动到目标位置  </span><br>    public void smooth<span class="hljs-constructor">ScrollTo(<span class="hljs-params">int</span> <span class="hljs-params">fx</span>, <span class="hljs-params">int</span> <span class="hljs-params">fy</span>)</span> &#123;  <br>        <span class="hljs-built_in">int</span> dx = fx - mScroller.get<span class="hljs-constructor">FinalX()</span>;  <br>        <span class="hljs-built_in">int</span> dy = fy - mScroller.get<span class="hljs-constructor">FinalY()</span>;  <br>        smooth<span class="hljs-constructor">ScrollBy(<span class="hljs-params">dx</span>, <span class="hljs-params">dy</span>)</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//调用此方法设置滚动的相对偏移  </span><br>    public void smooth<span class="hljs-constructor">ScrollBy(<span class="hljs-params">int</span> <span class="hljs-params">dx</span>, <span class="hljs-params">int</span> <span class="hljs-params">dy</span>)</span> &#123;  <br>        <span class="hljs-comment">//设置mScroller的滚动偏移量  </span><br>        mScroller.start<span class="hljs-constructor">Scroll(<span class="hljs-params">mScroller</span>.<span class="hljs-params">getFinalX</span>()</span>, mScroller.get<span class="hljs-constructor">FinalY()</span>, dx, dy);  <br>        invalidate<span class="hljs-literal">()</span>;<span class="hljs-comment">//这里必须调用invalidate()才能保证computeScroll()会被调用，否则不一定会刷新界面，看不到滚动效果  </span><br>    &#125;  <br>      <br>    @Override  <br>    public void compute<span class="hljs-constructor">Scroll()</span> &#123;  <br>        <span class="hljs-comment">//先判断mScroller滚动是否完成  </span><br>        <span class="hljs-keyword">if</span> (mScroller.compute<span class="hljs-constructor">ScrollOffset()</span>) &#123;  <br>            <span class="hljs-comment">//这里调用View的scrollTo()完成实际的滚动  </span><br>            scroll<span class="hljs-constructor">To(<span class="hljs-params">mScroller</span>.<span class="hljs-params">getCurrX</span>()</span>, mScroller.get<span class="hljs-constructor">CurrY()</span>);  <br>              <br>            <span class="hljs-comment">//必须调用该方法，否则不一定能看到滚动效果  </span><br>            post<span class="hljs-constructor">Invalidate()</span>;  <br>        &#125;  <br>        super.compute<span class="hljs-constructor">Scroll()</span>;  <br>    &#125;  <br>&#125;  <br></code></pre></td></tr></table></figure><hr><p>android.view.VelocityTracker主要用跟踪触摸屏事件（flinging事件和其他gestures手势事件）的速率。用addMovement(MotionEvent)函数将Motion event加入到VelocityTracker类实例中.你可以使用getXVelocity() 或getXVelocity()获得横向和竖向的速率到速率时，但是使用它们之前请先调用computeCurrentVelocity(int)来初始化速率的单位 。  </p><p>示例： </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> VelocityTracker mVelocityTracker;<span class="hljs-comment">//生命变量 </span><br><span class="hljs-comment">//在onTouchEvent(MotionEvent ev)中 </span><br><span class="hljs-keyword">if</span> (mVelocityTracker<span class="hljs-operator"> == </span>null) &#123; <br>        mVelocityTracker = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">VelocityTracker</span>.</span></span>obtain<span class="hljs-literal">()</span>;<span class="hljs-comment">//获得VelocityTracker类实例 </span><br>&#125; <br>mVelocityTracker.add<span class="hljs-constructor">Movement(<span class="hljs-params">ev</span>)</span>;<span class="hljs-comment">//将事件加入到VelocityTracker类实例中 </span><br><span class="hljs-comment">//判断当ev事件是MotionEvent.ACTION_UP时：计算速率 </span><br>final VelocityTracker velocityTracker = mVelocityTracker; <br><span class="hljs-comment">// 1000 provides pixels per second </span><br>velocityTracker.compute<span class="hljs-constructor">CurrentVelocity(1, (<span class="hljs-params">float</span>)</span><span class="hljs-number">0.01</span>); <span class="hljs-comment">//设置maxVelocity值为0.1时，速率大于0.01时，显示的速率都是0.01,速率小于0.01时，显示正常 </span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>i(<span class="hljs-string">&quot;test&quot;</span>,<span class="hljs-string">&quot;velocityTraker&quot;</span>+velocityTracker.get<span class="hljs-constructor">XVelocity()</span>);                     <br>velocityTracker.compute<span class="hljs-constructor">CurrentVelocity(1000)</span>; <span class="hljs-comment">//设置units的值为1000，意思为一秒时间内运动了多少个像素 </span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>i(<span class="hljs-string">&quot;test&quot;</span>,<span class="hljs-string">&quot;velocityTraker&quot;</span>+velocityTracker.get<span class="hljs-constructor">XVelocity()</span>); <br></code></pre></td></tr></table></figure><p>大体的使用是这样的：<br>当你需要跟踪触摸屏事件的速度的时候,使用obtain()方法来获得VelocityTracker类的一个实例对象<br>在onTouchEvent回调函数中，使用addMovement(MotionEvent)函数将当前的移动事件传递给VelocityTracker对象<br>使用computeCurrentVelocity  (int units)函数来计算当前的速度，使用 getXVelocity  ()、 getYVelocity  ()函数来获得当前的速度</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
