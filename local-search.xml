<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Rsync</title>
    <link href="/posts/899e41d0/"/>
    <url>/posts/899e41d0/</url>
    
    <content type="html"><![CDATA[<p><a href="https://bleepcoder.com/cn/timeshift/362931478/folder-exclusion-doesn-t-work">网页</a></p><p><a href="http://www.voycn.com/article/timeshiftxitongbeifenyuhaiyuan">使用</a></p><hr><ul><li><p>匹配是从父目录到子目录，如果排除了某个目录，那被排除目录的子目录的任何规则不再生效。</p><p>例如: exclude=’/var’ include=’var/opt’</p></li><li><p><code>**</code>表示匹配这个地址的每一层</p></li></ul><p>​        例如 <code>/var/opt/**</code>可以被理解为 include=“/” include=“/var” include=“/var/opt”</p><p>例如</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">$ rsync -anv <span class="hljs-params">--include=</span><span class="hljs-string">&quot;/home/kiylx/文档/Linux学习/**&quot;</span> <span class="hljs-params">--exclude=</span><span class="hljs-string">&quot;.*&quot;</span> <span class="hljs-params">--exclude=</span><span class="hljs-string">&quot;/Linux学习/linux/***&quot;</span> <span class="hljs-string">/home/kiylx/</span>文档<span class="hljs-string">/Linux</span>学习  <span class="hljs-string">/home/kiylx/Android</span><br><br>输出：<br>Linux学习/<br>Linux学习<span class="hljs-string">/Font</span> configuration_Examples - ArchWiki <span class="hljs-params">(2021_9_14 下午5_33_06)</span><span class="hljs-string">.html</span><br>Linux学习<span class="hljs-string">/VimVi</span>使用<span class="hljs-string">.md</span><br>Linux学习<span class="hljs-string">/VimVi</span>使用<span class="hljs-string">.pdf</span><br>Linux学习<span class="hljs-string">/freebsd.md</span><br>Linux学习<span class="hljs-string">/iptables</span>和firewalld.pdf<br>Linux学习<span class="hljs-string">/manjaro</span>配置<span class="hljs-string">.md</span><br>Linux学习<span class="hljs-string">/ranger.svg</span><br>Linux学习<span class="hljs-string">/ranger</span>使用<span class="hljs-string">.md</span><br>Linux学习/背景介绍<span class="hljs-string">.md</span><br>Linux学习<span class="hljs-string">/TyporaRaw/</span><br>Linux学习<span class="hljs-string">/TyporaRaw/ranger</span>使用<span class="hljs-string">.assets/</span><br>Linux学习<span class="hljs-string">/TyporaRaw/ranger</span>使用<span class="hljs-string">.assets/cheatsheet.svg</span><br><br>排除了所有的前缀是`.`的文件，排除了linux文件夹<br></code></pre></td></tr></table></figure><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gradle">$ rsync -anv --<span class="hljs-keyword">exclude</span>=<span class="hljs-string">&#x27;*&#x27;</span>  --<span class="hljs-keyword">include</span>=<span class="hljs-string">&quot;/Linux学习/linux/***&quot;</span> <span class="hljs-regexp">/home/</span>kiylx<span class="hljs-regexp">/文档/</span>Linux学习  <span class="hljs-regexp">/home/</span>kiylx/Android<br><br>输出：<br>空白<br>开头的--<span class="hljs-keyword">exclude</span>=<span class="hljs-string">&#x27;*&#x27;</span> 排除了所有文件，后面的规则不再生效<br></code></pre></td></tr></table></figure><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gradle">$ rsync -anv --<span class="hljs-keyword">include</span>=<span class="hljs-string">&quot;/home/kiylx/文档/Linux学习/**&quot;</span> --<span class="hljs-keyword">exclude</span>=<span class="hljs-string">&#x27;Linux学习/*&#x27;</span> --<span class="hljs-keyword">include</span>=<span class="hljs-string">&quot;/Linux学习/linux/***&quot;</span> <span class="hljs-regexp">/home/</span>kiylx<span class="hljs-regexp">/文档/</span>Linux学习  <span class="hljs-regexp">/home/</span>kiylx/Android<br><br>输出：<br>Linux学习/<br>包含Linux学习<span class="hljs-regexp">/下的东西，又排除了Linux学习/</span>下的东西，所以，包含Linux学习<span class="hljs-regexp">/linux/</span>文件夹的规则不再生效<br></code></pre></td></tr></table></figure><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs gradle">$ rsync -anv --<span class="hljs-keyword">include</span>=<span class="hljs-string">&quot;/home/kiylx/文档/Linux学习/**&quot;</span> --<span class="hljs-keyword">include</span>=<span class="hljs-string">&quot;/Linux学习/linux/***&quot;</span>  --<span class="hljs-keyword">exclude</span>=<span class="hljs-string">&#x27;Linux学习/*&#x27;</span> <span class="hljs-regexp">/home/</span>kiylx<span class="hljs-regexp">/文档/</span>Linux学习  <span class="hljs-regexp">/home/</span>kiylx/Android<br><br>输出：<br>Linux学习/<br>Linux学习<span class="hljs-regexp">/linux/</span><br>Linux学习<span class="hljs-regexp">/linux/</span>.MD文档.md<br>Linux学习<span class="hljs-regexp">/linux/</span>Linux就该这么学（完整目录版）.pdf<br>Linux学习<span class="hljs-regexp">/linux/</span>linux学习.md<br>Linux学习<span class="hljs-regexp">/linux/</span>文件与目录管理.md<br>Linux学习<span class="hljs-regexp">/linux/</span>文件基本属性.md<br>Linux学习<span class="hljs-regexp">/linux/</span>用户与用户组管理.md<br>Linux学习<span class="hljs-regexp">/linux/</span>目录结构.md<br>Linux学习<span class="hljs-regexp">/linux/</span>磁盘管理.md<br>先包含linux学习文件夹和其下的linux文件夹，然后再排除linux学习文件夹下的一切<br><br></code></pre></td></tr></table></figure><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">$ rsync -anv <span class="hljs-params">--include=</span><span class="hljs-string">&quot;/home/kiylx/文档/Linux学习/**&quot;</span> <span class="hljs-params">--exclude=</span>&#x27;Linux学习<span class="hljs-string">/linux</span>*&#x27; <span class="hljs-string">/home/kiylx/</span>文档<span class="hljs-string">/Linux</span>学习  <span class="hljs-string">/home/kiylx/Android</span><br><br>输出：<br>Linux学习/<br>Linux学习<span class="hljs-string">/Font</span> configuration_Examples - ArchWiki <span class="hljs-params">(2021_9_14 下午5_33_06)</span><span class="hljs-string">.html</span><br>Linux学习<span class="hljs-string">/Linux</span> chmod 命令 _ 菜鸟教程 <span class="hljs-params">(2021_3_18 上午10_08_38)</span><span class="hljs-string">.html</span><br>Linux学习<span class="hljs-string">/Manjaro</span> XFCE 安装和调教 _ Azure <span class="hljs-params">(2021_2_26 下午9_47_19)</span><span class="hljs-string">.html</span><br>Linux学习<span class="hljs-string">/VimVi</span>使用<span class="hljs-string">.md</span><br>Linux学习<span class="hljs-string">/VimVi</span>使用<span class="hljs-string">.pdf</span><br>Linux学习<span class="hljs-string">/freebsd.md</span><br>Linux学习<span class="hljs-string">/iptables</span>和firewalld.pdf<br>Linux学习<span class="hljs-string">/manjaro</span>配置<span class="hljs-string">.md</span><br>Linux学习<span class="hljs-string">/ranger.svg</span><br>Linux学习<span class="hljs-string">/ranger</span>使用<span class="hljs-string">.md</span><br>Linux学习/背景介绍<span class="hljs-string">.md</span><br>Linux学习<span class="hljs-string">/.obsidian/</span><br>Linux学习<span class="hljs-string">/.obsidian/app.json</span><br>Linux学习<span class="hljs-string">/.obsidian/appearance.json</span><br>Linux学习<span class="hljs-string">/.obsidian/core-plugins.json</span><br>Linux学习<span class="hljs-string">/.obsidian/graph.json</span><br>Linux学习<span class="hljs-string">/.obsidian/hotkeys.json</span><br>Linux学习<span class="hljs-string">/.obsidian/workspace</span><br>Linux学习<span class="hljs-string">/TyporaRaw/</span><br>Linux学习<span class="hljs-string">/TyporaRaw/ranger</span>使用<span class="hljs-string">.assets/</span><br>Linux学习<span class="hljs-string">/TyporaRaw/ranger</span>使用<span class="hljs-string">.assets/cheatsheet.svg</span><br><br></code></pre></td></tr></table></figure><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">rsync -anv <span class="hljs-params">--exclude=</span><span class="hljs-string">&quot;/home/kiylx/文档/Linux学习/linux&quot;</span> <span class="hljs-params">--include=</span><span class="hljs-string">&quot;/home/kiylx/文档/Linux学习/**&quot;</span> <span class="hljs-string">/home/kiylx/</span>文档<span class="hljs-string">/Linux</span>学习  <span class="hljs-string">/home/kiylx/Android</span><br>sending incremental file list<br>Linux学习/<br>Linux学习<span class="hljs-string">/Font</span> configuration_Examples - ArchWiki <span class="hljs-params">(2021_9_14 下午5_33_06)</span><span class="hljs-string">.html</span><br>Linux学习<span class="hljs-string">/Linux</span> chmod 命令 _ 菜鸟教程 <span class="hljs-params">(2021_3_18 上午10_08_38)</span><span class="hljs-string">.html</span><br>Linux学习<span class="hljs-string">/Manjaro</span> XFCE 安装和调教 _ Azure <span class="hljs-params">(2021_2_26 下午9_47_19)</span><span class="hljs-string">.html</span><br>Linux学习<span class="hljs-string">/VimVi</span>使用<span class="hljs-string">.md</span><br>Linux学习<span class="hljs-string">/VimVi</span>使用<span class="hljs-string">.pdf</span><br>Linux学习<span class="hljs-string">/freebsd.md</span><br>Linux学习<span class="hljs-string">/iptables</span>和firewalld.pdf<br>Linux学习<span class="hljs-string">/manjaro</span>配置<span class="hljs-string">.md</span><br>Linux学习<span class="hljs-string">/ranger.svg</span><br>Linux学习<span class="hljs-string">/ranger</span>使用<span class="hljs-string">.md</span><br>Linux学习/背景介绍<span class="hljs-string">.md</span><br>Linux学习<span class="hljs-string">/.obsidian/</span><br>Linux学习<span class="hljs-string">/.obsidian/app.json</span><br>Linux学习<span class="hljs-string">/.obsidian/appearance.json</span><br>Linux学习<span class="hljs-string">/.obsidian/core-plugins.json</span><br>Linux学习<span class="hljs-string">/.obsidian/graph.json</span><br>Linux学习<span class="hljs-string">/.obsidian/hotkeys.json</span><br>Linux学习<span class="hljs-string">/.obsidian/workspace</span><br>Linux学习<span class="hljs-string">/TyporaRaw/</span><br>Linux学习<span class="hljs-string">/TyporaRaw/ranger</span>使用<span class="hljs-string">.assets/</span><br>Linux学习<span class="hljs-string">/TyporaRaw/ranger</span>使用<span class="hljs-string">.assets/cheatsheet.svg</span><br>Linux学习<span class="hljs-string">/linux/</span><br>Linux学习<span class="hljs-string">/linux/.MD</span>文档<span class="hljs-string">.md</span><br>Linux学习<span class="hljs-string">/linux/Linux</span>就该这么学（完整目录版）<span class="hljs-string">.pdf</span><br>Linux学习<span class="hljs-string">/linux/linux</span>学习<span class="hljs-string">.md</span><br>Linux学习<span class="hljs-string">/linux/</span>文件与目录管理<span class="hljs-string">.md</span><br>Linux学习<span class="hljs-string">/linux/</span>文件基本属性<span class="hljs-string">.md</span><br>Linux学习<span class="hljs-string">/linux/</span>用户与用户组管理<span class="hljs-string">.md</span><br>Linux学习<span class="hljs-string">/linux/</span>目录结构<span class="hljs-string">.md</span><br>Linux学习<span class="hljs-string">/linux/</span>磁盘管理<span class="hljs-string">.md</span><br><br></code></pre></td></tr></table></figure><hr><h1 id="man-page"><a href="#man-page" class="headerlink" title="man page"></a><a href="https://download.samba.org/pub/rsync/rsync.1">man page</a></h1><h2 id="包含-排除模式规则"><a href="#包含-排除模式规则" class="headerlink" title="包含/排除模式规则"></a>包含/排除模式规则</h2><p>您可以通过使用“+”、“-⁠”等过滤规则指定模式来包含和排除文件（如上面的过滤规则部分所述）。每个包含/排除规则都指定了一个模式，该模式与将要传输的文件的名称相匹配。这些模式可以采用多种形式：</p><ul><li>如果模式以 a 开头，<code>/</code>则它被锚定到文件层次结构中的特定位置，否则它与路径名的末尾匹配。这类似于<code>^</code>正则表达式中的前导。因此 <code>/foo</code>将匹配“传输根”（对于全局规则）或合并文件的目录（对于每个目录规则）中的“foo”名称。一个不合格<code>foo</code>将匹配树中任何位置的“foo”名称，因为该算法是从上到下递归应用的；它的行为就像每个路径组件在文件名结尾处轮流。即使未锚定的“sub/foo”也会在层次结构中的任何点匹配，其中在名为“sub”的目录中找到“foo”。有关如何指定在传输的根处匹配的模式的完整讨论，请参阅关于 ANCHORING INCLUDE/EXCLUDE PATTERNS 的部分。</li><li>如果模式以 a 结尾，<code>/</code>那么它只会匹配一个目录，而不是常规文件、符号链接或设备。</li><li>rsync 通过检查模式是否包含以下三个通配符之一来选择进行简单的字符串匹配和通配符匹配：’ <code>*</code>‘、’ <code>?</code>‘ 和 ‘ <code>[</code>‘ 。</li><li>‘ <code>*</code>‘ 匹配任何路径组件，但它在斜线处停止。</li><li>使用 ‘ <code>**</code>‘ 来匹配任何东西，包括斜线。</li><li>‘ <code>?</code>‘ 匹配除斜杠 ( <code>/</code>)之外的任何字符。</li><li>‘ <code>[</code>‘ 引入了一个字符类，例如<code>[a-z]</code>or <code>[[:alpha:]]</code>。</li><li>在通配符模式中，反斜杠可用于转义通配符，但在不存在通配符时按字面匹配。这意味着与没有通配符的模式相比，当模式包含通配符时，反斜杠删除的级别更高。例如，如果您将通配符添加到“ <code>foo\bar</code>”（与反斜杠匹配），您将需要使用“ <code>foo\\bar*</code>”来避免“ <code>\b</code>”变成“b”。</li><li>如果模式包含<code>/</code>（不包括尾随 /）或“ <code>**</code>”，则它与完整路径名匹配，包括任何前导目录。如果模式不包含 a<code>/</code>或 “ <code>**</code>“，则它仅与文件名的最后一部分匹配。（请记住，该算法是递归应用的，因此“完整文件名”实际上可以是从起始目录向下的路径的任何部分。）</li><li>尾随的“ <code>dir_name/***</code>”将匹配目录（就像指定了“dir_name/”）和目录中的所有内容（就像<code>dir_name/**</code>已经指定了“ ”）。此行为是在 2.6.7 版中添加的。</li></ul><p>请注意，当使用<code>--recursive</code>( <code>-r</code>) 选项（由 暗示 <code>-a</code>）时，从左到右访问每个路径的每个子目录组件，每个目录都有机会在其内容之前排除。通过这种方式，包含/排除模式以递归方式应用于文件系统树中每个节点的路径名（传输内部的节点）。当 rsync 找到要发送的文件时，排除模式会使目录遍历阶段短路。</p><p>例如，要包含“ <code>/foo/bar/baz</code>”，不得排除目录“ <code>/foo</code>”和“ <code>/foo/bar</code>”。排除这些父目录之一会阻止检查其内容，切断 rsync 到这些路径的递归并使“ <code>/foo/bar/baz</code>”的包含无效（因为 rsync 无法匹配它在目录层次结构的截止部分中从未见过的内容） .</p><p>使用尾随“ <code>*</code>”规则时，概念路径排除尤其重要。例如，这行不通：</p><blockquote><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle">+ <span class="hljs-regexp">/some/</span>path/<span class="hljs-keyword">this</span>-<span class="hljs-keyword">file</span>-will-not-be-found<br>+ /<span class="hljs-keyword">file</span>-is-included<br>- *<br></code></pre></td></tr></table></figure></blockquote><p>这将失败，因为父目录“some”被 ‘ <code>*</code>‘ 规则排除，所以 rsync 从不访问“some”或“some/path”目录中的任何文件。一种解决方案是通过使用单个规则：“ <code>+ */</code>”（将其放在“ <code>- *</code>”规则之前的某个位置）要求包含层次结构中的所有目录，并且可能使用该<code>--prune-empty-dirs</code>选项。另一种解决方案是为所有需要访问的父目录添加特定的包含规则。例如，这组规则工作正常：</p><blockquote><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gradle">+ <span class="hljs-regexp">/some/</span><br>+ <span class="hljs-regexp">/some/</span>path/<br>+ <span class="hljs-regexp">/some/</span>path/<span class="hljs-keyword">this</span>-<span class="hljs-keyword">file</span>-is-found<br>+ /<span class="hljs-keyword">file</span>-also-included<br>- *<br></code></pre></td></tr></table></figure></blockquote><p>以下是排除/包含匹配的一些示例：</p><ul><li>“ <code>- *.o</code>“ 将排除所有匹配的名称<code>*.o</code></li><li>“ <code>- /foo</code>“ 将排除 transfer-root 目录中名为 foo 的文件（或目录）</li><li>“ <code>- foo/</code>“ 将排除任何名为 foo 的目录</li><li>“ <code>- /foo/*/bar</code>“ 将排除位于 transfer-root 目录中名为 foo 的目录下两级的名为 bar 的任何文件</li><li>“ <code>- /foo/**/bar</code>“ 将排除在 transfer-root 目录中名为 foo 的目录下两级或更多级名为 bar 的任何文件</li><li>“ <code>+ */</code>“、” <code>+ *.c</code>“ 和 “ <code>- *</code>“ 的组合将包含所有目录和 C 源文件，但不包含其他内容（另请参见 <code>--prune-empty-dirs</code>选项）</li><li>“ <code>+ foo/</code>“、” <code>+ foo/bar.c</code>“ 和 “ <code>- *</code>“ 的组合将仅包含 foo 目录和 foo/bar.c（必须明确包含 foo 目录，否则它将被 “ <code>*</code>“排除）</li></ul><p>在 “ <code>+</code>“ 或 “ <code>-</code>“之后接受以下修饰符：</p><ul><li><p>A<code>/</code>指定包含/排除规则应与当前项的绝对路径名匹配。例如，“ <code>-/ /etc/passwd</code>”会在传输从“/etc”目录发送文件时排除 passwd 文件，而“-⁠/subdir/foo”在名为“subdir”的目录中时将始终排除“foo” , 即使“foo”是当前传输的根。</p></li><li><p>A<code>!</code>指定如果模式匹配失败，包含/排除应该生效。例如，“ <code>-! */</code>”将排除所有非目录。</p></li><li><p>A<code>C</code>用于指示所有全局 CVS 排除规则都应作为排除插入来代替“-⁠C”。不应遵循任何 arg。</p></li><li><p>An<code>s</code>用于指示规则适用于发送方。当规则影响发送方时，它会阻止文件传输。除非<code>--delete-excluded</code>指定，否则默认规则会影响双方，在这种情况下，默认规则仅成为发送方。另请参阅隐藏 (H) 和显示 (S) 规则，它们是指定发送方包含/排除的另一种方法。</p></li><li><p>An<code>r</code>用于指示规则适用于接收方。当规则影响接收方时，它可以防止文件被删除。有关<code>s</code>更多信息，请参阅修饰符。另请参阅保护 (P) 和风险 (R) 规则，这是指定接收方包含/排除的另一种方法。</p></li><li><p>A<code>p</code>表示规则易腐烂，这意味着它在被删除的目录中被忽略。例如，<code>-C</code>排除诸如“CVS”和“ <code>*.o</code>”之类的选项的默认规则被标记为易腐烂，并且不会阻止在源上删除的目录在目标上被删除。</p></li><li><p>An<code>x</code>表示规则影响 xattr 复制/删除操作中的 xattr 名称（因此在匹配文件/目录名称时被忽略）。如果未指定 xattr 匹配规则，则使用默认的 xattr 过滤规则（请参阅<code>--xattrs</code>选项）。</p><hr></li></ul><h1 id="博客1-地址"><a href="#博客1-地址" class="headerlink" title="博客1 地址"></a><a href="https://developer.aliyun.com/article/428319">博客1 地址</a></h1><p>   关于rsync的过滤规则：<br>  译者注：这部分其实是man page中关于client的过滤规则的条目！不过，我把daemon中的过滤规则也集合到了里，两部分对比着进行理解。<br>  关于pattern和rule，个人理解是：pattern是用来匹配文件或目录的正则，而rule则是前缀+pattern，也即整条规则。如：</p>  <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">+</span> foo/<br><span class="hljs-bullet">+</span> foo/bar.c<br><span class="hljs-bullet">-</span> <span class="hljs-emphasis">*</span><br></code></pre></td></tr></table></figure><p>  这是三条规则（rule），规则开头的”+”或”-“是前缀，foo/等前缀后面的东西即pattern（模式）。</p><p>  下面是正文：<br>  首先，来看rsyncd.conf官方文档在filter部分的描述（daemon上的过滤规则）：<br>  daemon拥有自己的过滤链，来决定哪些文件允许被client访问。这个过滤链不会被发送到client，并且独立于client中已经指定的过滤规则。<br>  当client拉文件时，那些被daemon过滤链排除的文件会被视为不存在；而当client往server推送文件时，会跳过那些被daemon过滤链排除的文件，并且server会返回client一个错误消息；（当同步文件时）被daemon过滤链排除的文件永远不会从模块中删除。<br>  daemon过滤链由”filter”、”include from”、”include”、”exclude from”、”exclude”参数组成，并以此为先后（生效）顺序。<br>  （译者注：关于规则的生效顺序，应该是最先匹配。rsyncd.conf文档明确指出include规则可以覆盖掉exclude规则，照此理解，如果发生冲突，后面的规则应该不会覆盖掉前面的规则。下面filter rules部分也提到，最先匹配的模式会生效，但是在include/exclude pattern rules部分也提到一个特殊例子，在排除父目录，特别是使用<em>号匹配来排除父目录时，有些地方需要特别留意。<br>  条目中还有一句话：Anchored patterns are anchored at the root of the module.大意似乎是：锚点模式标记的是模块根目录。下面还会有提到Anchored pattern。）<br>  要阻止对整个目录的访问，必须排除该目录下的所有文件，最简单的方法是使用三个星号，如，想要阻止访问/secret，过滤规则就应该这样写：/secret/</em>**</p><p>  再来看rsync的man page对过滤规则的描述（client中的过滤规则），这部分内容很多，由FILTER RULES条目开始，包括了条目：INCLUDE/EXCLUDE PATTERN RULES、MERGE-FILE FILTER RULES、MERGE-FILE FILTER RULES、ANCHORING INCLUDE/EXCLUDE PATTERNS等。</p><p>  <strong>filter rules：</strong><br>  filter规则允许选择传输哪些文件（include），跳过哪些文件（exclude）。filter规则既可以直接指定include/exclude模式，也可以指定一个获取include/exclude模式的途径（如从一个文件中读取）。<br>  当建立了要传输的文件/目录列表后，rsync会依次核查它们是否符合include/exclude模式，匹配到的第一个模式会生效：如果符合exclude模式，则跳过该文件，如果符合include模式，不跳过该，如果不符合任何模式，文件也不会被跳过。<br>  rsync按照命令行中filter规则顺序建立一个有序列表。filter规则的语法如下：<br>  rule [pattern_or_filename]<br>  rule,modfiers [pattern_or_filename]<br>  可以使用完整规则名称，也可以使用简写名称，可用的规则前缀如下：<br>  exclude, - ：排除模式<br>  include, + ：包含模式<br>  merge, . ：指定一个merge-file，供多个规则读取<br>  dir-merge, : ：指定一个per-directory merge-file<br>  hide, H ：指定一个模式，符合该模式的文件将被隐藏，以防止传输<br>  show, S ：不隐藏符合该模式的文件<br>  protect, p ：指定一个模式来防止文件被删除<br>  risk, R ：符合该模式的文件不会被保护<br>  clear, ! ：清除当前的include/exclude模式列表（该选项无参数）<br>  注：关于merge-file和per-directory，见下文。<br>  如果使用简写形式，前面语法中rule和modefiers之间的逗号是可选的，紧跟着的pattern或filename（如果存在）之后必须有一个空格或下划线。<br>  如果规则是从文件中读取的，那么文件中的空白行将被忽略，以#开头的行被视为注释。<br>  注意：–include/–exclude命令行中的选项，不能完全依照上面filter规则的解释。–include/–exclude命令只允许使用指明的include/exclude模式加”!”标识（即：模式+标识）来清除（译者注：排除或许更准确）（文件或目录）列表。如果模式不以”- “（两个字符：减号和空格）或”+ “（两个字符：加号和空格）开头，那么，对于包含选项而言，规则将被解释为字符串前添加了”+”前缀；对于排除选项而言，规则将被解释为字符串前添加了”-“前缀。与之相反，–filter选项必须在规则开头包含一个简写或完整的规则名称。<br>  另外要注意的是，每个–filter选项，–include选项，和–exclude选项只接受一个rule/pattern，如果想添加多个rule/pattern，可以在命令行中的重复这些选项，或在–filter选项中使用merge-file语法，或使用–include-from/–exclude-from选项。</p><p>  <strong>include/exclude pattern ruls：</strong><br>  注：rsync的man page说，–include和–exclude是–filter选项的简化版。<br>  你可以使用”+”、”-“等filter过滤规则来指定模式，用以包含和排除文件。每个include/exclude规则指定一个模式来匹配传输文件。模式可以有以下几种形式：<br>  1）如果”/”出现在模式的开头，那么它标记了层级中的一个特殊位置（译者注：指的应该是文件系统的位置或完整路径的层次结构中的某一层次），否则，它只是匹配路径的结束。（译者注：这里又出现了anchor，计算机术语称之为锚点，它设置一个标记，然后可以在本文档或页面的其它地方创建一个指向本标记的链接：锚点，标记了一个特定位置。）因此，”/foo”将匹配”root of the transfer”中的foo（对全局规则而言），或者merge-file目录中的foo（对per-directory规则而言）。而未经限定的foo将匹配文件系统中任何位置的foo，因为算法是自上而下递归地生效，就像是路径的每个部分轮流变成文件或目录的结尾（译者注：例如foo/a/b/c，算法对该路径的解释将会是foo/a，foo/a/b，foo/a/b/c，算法依次把a、b、c作为文件或目录结尾）。实际上，非锚定的”sub/foo”将会匹配层次结构中包含子目录sub的，任何位置的foo。<br>  2）如果”/”出现在模式的结尾，那么它只匹配目录，而不匹配常规文件、链接，或设备。<br>  3）rsync会检查模式中是否包含下列通配符，以确定做简单的字符匹配还是通配符匹配：”*”、”?”、”[“<br>  * ：匹配路径的任何部分，遇到斜杠终止<br>  ** ：匹配任何东西，包括斜杠<br>  ? ：匹配任何单个字符，斜杠(“/”)除外<br>  [ ：匹配一个字符集，如[a-z]，或[[:alpha:]]<br>  4）在通配符模式中，反斜杠(“\”)对通配符进行转义，如果通配符不存在，它会被解释一个普通字符<br>  5）如果模式包含”/”（尾部的”/”不计算在内）或”<strong>”，它将匹配完整路径，包括前导目录（即foo/a，既匹配a，也匹配前导的foo）；如果模式不包含”/”或”</strong>”，它只匹配路径最后的部分。（注意：算法是递归地应用，所以实际上“完整路径”可能是从起始目录向下，路径的任何一个部分。）<br>  6）以dir_name/***结尾的模式，既匹配目录（就像指定了dir_name/），又匹配目录中的所有文件（就像指定了dir_name/*<em>）。<br>  请注意：如果使用了-r选项（-a选项隐含了此选项），那么，自顶向下，路径的每一个部分都将被访问，所以，include/exclude模式会递归地对路径的每个组成部分生效（如，要包含/foo/bar/baz，就不能排除/foo和/foo/bar）。当rsync寻找要发送的文件时，exclude模式实际上是rsync在历遍目录时的一个短路。如果一个模式排除了特定的父目录，它就能使一个更深的include模式无法生效，因为rsync无法穿过层级中的排除部分而向下（匹配文件）。（译者注：意思应该是，如果模式排除一个指定的父目录，那么它将无法继续匹配该父目录下的子目录或文件。）这一点非常重要，尤其是使用一个以”</em>”结尾的规则时。如下：<br>  + /some/path/this-file-will-not-be-found<br>  + /file-is-included<br>  - *<br>  上述规则链将无法得到你想要的结果，因为父目录some被”*”规则排除了，所以rsync不会去访问some或some/path目录下的任何文件。要解决这个问题，可以使用一个”+ */”规则来包含层级的所有目录（把它放到”- <em>”前面的任意位置），或许还需要–prune-empty-dirs选项。另外一个解决途径是，添加一个include规则来包含所有需要被访问的父目录。下例的规则集就可以很好的工作：<br>  + /some/<br>  + /some/path/<br>  + /some/path/this-file-is-found<br>  + /file-also-included<br>  - *<br>  （译者注：<br>  1）不知道大家是否理解了上面的官方示例。第一个例子本想包含两个文件，但结果只包含到了一个。文件this-file-will-not-be-found没有被包含的原因在于：基于最先匹配原则，文件本身被include规则所匹配，但其父目录以及爷爷目录并没有被include规则所匹配，所以它们被后面的exclude规则所匹配，而由于rsync不能穿过被exclude规则排除的父目录而匹配其中的文件，所以该文件最终将无法出现在匹配结果中。<br>  这一过程有三个关键：一是rsync无法穿过被排除的父目录而向下匹配文件；二是</em>匹配路径任一部分，遇/终止匹配；三是最先匹配。<br>  2）关于–prune-empty-dirs（简写模式为-m）：这个命令行中的选项告诉rsync的接收方从文件列表中删除空目录，包括那些没有非空子目录的嵌套目录。这个选项很有用，当rsync的发送方使用include/exclude/filter规则扫描具有多层次结构的文件时，它可以避免（接收方）创建一系列无用的目录。）</p><p>  下面是一些exclude/include匹配的示例：<br>  - <em>.o：排除所有以o结尾的文件<br>  - /foo：排除transfer-root目录中，名为foo的文件或目录<br>  （译者注：前面也提到了transfer-root，这个概念会在ANCHORING INCLUDE/EXCLUDE PATTERNS条目中讲到，举例来说明，有一个路径/home/me/foo/bar：<br>  rsync -a - /me/foo/bar /home/me /dest<br>  rsync -a - /foo/bar /home/me/ /dest<br>  上述规则要复制/home/me目录及其下所有文件到/dest，但要排除/me/foo/bar文件（或目录）。两条规则的效果是一样的，但是transfer-root不同。第一条规则中，/home目录就是transfer-root；而对于第二条规则，/home/me/才是transfer-root。也就是说，transfer-root是从路径的最末位向前追溯，遇到的第一个以”/“结尾的目录。）<br>  - foo/：排除任何名为foo的目录<br>  - /foo/</em>/bar：从transfer-root中的foo目录向下两级的位置，排除名为bar的文件。<br>  - /foo/**/bar：从transfer-root中的foo目录向下至少两级的位置，排除名为bar的文件。<br>  + */c，+ *.c，和- *的组合，会包含所有目录，以及以c结尾的文件，除此之外，所有文件都排除。<br>  + /foo/，+ foo/bar.c，和- <em>的组合，将只包含foo目录，以及foo/bar.c文件。（必须明确包含foo目录，否则它将被exclude规则中的</em>所匹配，这会导致前面所讲到的排除特定父目录的问题，将无法如你所愿匹配到foo/bar.c文件。）</p><p>  “+”或”-“接受下列修饰符：<br>  /，指定include/exclude规则要匹配当前项目的绝对路径。例如，-/ /etc/passwd，每当从/etc目录中传输文件时，都要排除密码文件；再比如，-/ subdir/foo，当从名为subdir的目录中传输文件时，总是排除文件foo，即使该文件位于当前传输的根目录。<br>  译者注：不要混淆匹配模式中的/和修饰符/ ！<br>  !，告诉rsync，当模式匹配失败时，include/exclude规则才生效。如，-! */，它将匹配所有非目录文件。<br>  C，该修饰符指示，所有全局的CVS-exclude规则将插入到-C的地方。该修饰符后面无参数。（译者注：文档在介绍-C –cvs-exclude选项时说，如果在自己的–filter规则中同时使用-C，那么所有的CVS exclude规则将附加到你自己的规则的末尾，不管-C位于命令行的什么地方。）<br>  s，指示规则作用于发送端。当规则对发送端生效时，它将阻止文件被传输。该修饰符通常用于那些在两端都生效的规则，除非指定了–delete-excluded；它将使规则默认只在发送端生效。另一种指定发送端includes/excludes的途经是使用hide(H)和show(S)。<br>  r，通常用来指示规则应用于接收端。当规则对接收方生效时，它将防止文件被删除。另一种指定接收端includes/excludes的方法是，使用protect(P)和risk(R)规则。</p><p>  本文转自 li_qinshan 51CTO博客，原文链接:<a href="http://blog.51cto.com/share/567578">http://blog.51cto.com/share/567578</a></p><p>  <strong>版权声明：</strong>本文内容由阿里云实名注册用户自发贡献，版权归原作者所有，阿里云开发者社区不拥有其著作权，亦不承担相应法律责任。具体规则请查看《<a href="https://developer.aliyun.com/article/768092">阿里云开发者社区用户服务协议</a>》和《<a href="https://developer.aliyun.com/article/768093">阿里云开发者社区知识产权保护指引</a>》。如果您发现本社区中有涉嫌抄袭的内容，填写<a href="https://yida.alibaba-inc.com/o/right">侵权投诉表单</a>进行举报，一经查实，本社区将立刻删除涉嫌侵权内容。</p><hr><h1 id="博客2-地址"><a href="#博客2-地址" class="headerlink" title="博客2 地址"></a><a href="https://blog.csdn.net/weixin_30657541/article/details/95381658">博客2 地址</a></h1><p>  rsync –include-from –exclude-from的理解：</p><p>  1、同时添加–include-from –exclude-from时。后者是对前者的结果进行排除</p><p>  如：“–include-from include.txt –include-from exclude.txt” #也就是说绝对不会超过–include-from声明的范围</p><p>  2、–include-from 文件前面的符号是有效的有意义的</p><p>  3、–exclude-from 文件前面不管是什么符号、有没有符号都是排除的意思</p><p>  4、每一个目录、子目录、文件都会与这个过滤规则列表进行匹配，直到找到一个命中的（命中的规则说要过滤就过滤，要包含那就包含），</p><p>  5、最重要的一个原则： 只找第一个匹配的规则</p><p>   以下是原文，我把关键词标出来方便阅读：</p><h2 id="FILTER-RULES"><a href="#FILTER-RULES" class="headerlink" title="FILTER RULES"></a>FILTER RULES</h2><p>  The filter rules allow for flexible selection of which files to transfer (include) and which files to skip (exclude). The rules either directly specify include/exclude patterns or they specify a way to acquire more include/exclude patterns (e.g. to read them from a file).</p><p>  As the list of files/directories to transfer is built, rsync checks each name to be transferred against the list of include/exclude patterns in turn, and the first matching pattern is acted on: if it is an exclude pattern, then that file is skipped; if it is an include pattern then that filename is not skipped; if no matching pattern is found, then the filename is not skipped.</p><p>  Rsync builds an ordered list of filter rules as specified on the command-line.</p><p>  以下是一个实例后面添加对相关过滤规则的说明和理解</p><p>  #############################################################################</p><p>  ### include.txt:</p><p>  # CompanyAttachment Files</p><p>  # 限制所有目录只包含2019开头的</p><p>  - ETest/20191/ #如果非要排除 ETest/20191下的文件 这个排除规则应该放前面。每个路径 只找第一个匹配的规则 （ 只找第一个、只找第一个、只找第一个 这很重要，理解了这个原则，才能理解所有的规则）</p><p>  + 2019*/ #这个只是 包含了目录，目录下的文件不会同步</p><p>  + 2019*/** #这个只包含了目录下的文件，如果没有上面的这个也无效</p><p>  + ETest/ #这个只是 包含了目录 但是子目录如果符合上面的其它条件也会被同步（如ETest目录下有2019开头的文件夹，也会同步）</p><p>  - * #排除其它文件</p><p>  - *.tmp #排除所有的.tmp文件。 这是个 错误 的示例，这个不一定会排除所有目录的.tmp文件。因为有些路径会命中前面的规则就直接返回了。这个排除规则要么写到最前面，要么写到exclude.txt里去</p><p>  #############################################################################</p><p>  #############################################################################</p><p>  # exclude.txt</p><p>  *.tmp #exclude-from文件里不管前面加不加+、-号都是排除（测试+号、-号、不要符号结果是一样的,很奇怪，但测试结果是这样，不知道我是不是理解错误）</p><p>  #* #exclude-from 是对include-from的结果进行排除，所以不能加这个。这个相当于禁用同步了。</p><p>  #############################################################################</p><p>  总结一下：</p><p>  1、顺序很重要，重要的、命中范围小的写前面</p><p>  2、最重要的还是理解它的过滤逻辑：每一个目录、子目录、文件都会与这个过滤规则列表进行匹配，直到找到一个命中的（命中的规则说要过滤就过滤，要包含那就包含），</p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>rsync</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>shell学习</title>
    <link href="/posts/f8d5cfbe/"/>
    <url>/posts/f8d5cfbe/</url>
    
    <content type="html"><![CDATA[<h1 id="bash-shell-获取当前正在执行脚本的绝对路径"><a href="#bash-shell-获取当前正在执行脚本的绝对路径" class="headerlink" title="bash shell 获取当前正在执行脚本的绝对路径"></a>bash shell 获取当前正在执行脚本的绝对路径</h1><p>一般我们写Shell脚本的时候，都倾向使用绝对路径，这样无论脚本在什么目录执行，都应该起到相同的效果，但是有些时候，我们设计一个软件包中的工具脚本或者远程调用某个脚本时，可能使用相对路径更加灵活一点，因为你不知道用户会在哪个目录执行你的程序，于是问题就来了，如何获取当前正在执行脚本的绝对路径？</p><p>常见的一种误区，是使用 pwd 命令，该命令的作用是<code>“print name of current/working directory”，</code>这才是此命令的真实含义，当前的工作目录，这里没有任何意思说明，这个目录就是脚本存放的目录。所以，这是不对的。你可以试试<code>bash shell/a.sh</code>，a.sh 内容是 pwd，你会发现，显示的是执行命令的路径 <code>/home/ljl</code>，并不是 a.sh 所在路径：<code>/home/ljl/shell/a.sh</code></p><p>另一个误人子弟的答案，是 <code>$0</code>，这个也是不对的，这个<code>$0</code>是Bash环境下的特殊变量，其真实含义是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">Expands to the name <span class="hljs-keyword">of</span> the shell or shell script. This is set at shell initialization. If bash is invoked <span class="hljs-keyword">with</span> a file <span class="hljs-keyword">of</span> commands, <br>$<span class="hljs-number">0</span><br> is set to the name <span class="hljs-keyword">of</span> that file. If bash is started <span class="hljs-keyword">with</span> the -c option, then <br>$<span class="hljs-number">0</span><br>is set to the first argument after the string to be executed, <span class="hljs-keyword">if</span> one is present. Otherwise, it is set to the file name used to invoke bash, <span class="hljs-keyword">as</span> given by argument zero.<br></code></pre></td></tr></table></figure><p> 这个$0有可能是好几种值，跟调用的方式有关系：</p><ul><li>使用一个文件调用bash，那$0的值，是那个文件的名字(没说是绝对路径噢)</li><li>使用-c选项启动bash的话，真正执行的命令会从一个字符串中读取，字符串后面如果还有别的参数的话，使用从$0开始的特殊变量引用(跟路径无关了)</li><li>除此以外，$0会被设置成调用bash的那个文件的名字(没说是绝对路径)</li></ul><p>下面对比下正确答案：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell">Jun@VAIO 192.168.1.216 23:52:54 ~ &gt;<br>cat shell/a.sh<br><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br>echo &#x27;$0: &#x27;$0<br>echo &quot;pwd: &quot;`pwd`<br>echo &quot;=============================&quot;<br>echo &quot;scriptPath1: &quot;$(cd `dirname $0`; pwd)<br>echo &quot;scriptPath2: &quot;$(pwd)<br>echo &quot;scriptPath3: &quot;$(dirname $(readlink -f $0))<br>echo &quot;scriptPath4: &quot;$(cd $(dirname $&#123;BASH_SOURCE:-$0&#125;);pwd)<br>echo -n &quot;scriptPath5: &quot; &amp;&amp; dirname $(readlink -f $&#123;BASH_SOURCE[0]&#125;)<br>Jun@VAIO 192.168.1.216 23:53:17 ~ &gt;<br>bash shell/a.sh<br><span class="hljs-meta">$</span><span class="bash">0: shell/a.sh</span><br>pwd: /home/Jun<br>=============================<br>scriptPath1: /home/Jun/shell<br>scriptPath2: /home/Jun<br>scriptPath3: /home/Jun/shell<br>scriptPath4: /home/Jun/shell<br>scriptPath5: /home/Jun/shell<br>Jun@VAIO 192.168.1.216 23:54:54 ~ &gt;<br></code></pre></td></tr></table></figure><p>在此解释下 <code>scriptPath1</code> ：</p><ul><li><ul><li><code>dirname $0</code>，取得当前执行的脚本文件的父目录</li><li><code>cd dirname $0</code>，进入这个目录(切换当前工作目录)</li><li><code>pwd</code>，显示当前工作目录(cd执行后的)</li></ul></li></ul><p>由此，我们获得了当前正在执行的脚本的存放路径。</p><hr><p>有时候，我们需要知道当前执行的输出shell脚本的所在绝对路径，可以用dirname实现。<br>我们知道 dirname 可以获取一个文件所在的路径，dirname的用处是：</p><blockquote><p>输出已经去除了尾部的”/”字符部分的名称；如果名称中不包含”/”，<br>则显示”.”(表示当前目录)。</p></blockquote><p>直接从dirname返回的未必是绝对路径，取决于提供给dirname的参数是否是绝对路径。<br>所以下面这样的代码中SHELL_FOLDER中不一定是绝对路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">SHELL_FOLDER=$(dirname &quot;$0&quot;)<br></code></pre></td></tr></table></figure><p>需要用cd和pwd命令配合获取脚本所在绝对路径，正确的写法是这样的，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">! /bin/bash</span><br><span class="hljs-meta">#</span><span class="bash">输出当前目录-版本1</span><br>this_dir=`pwd`<br>echo &quot;$this_dir ,this is pwd&quot;<br>echo &quot;$0 ,this is \$0&quot;<br>dirname $0|grep &quot;^/&quot; &gt;/dev/null<br>if [ $? -eq 0 ];then<br>    this_dir=`dirname $0`<br>else<br>    dirname $0|grep &quot;^\.&quot; &gt;/dev/null<br>     retval=$?<br>if [ $retval -eq 0 ];then<br>    this_dir=`dirname $0|sed &quot;s#^.#$this_dir#&quot;`<br>else<br>    this_dir=`dirname $0|sed &quot;s#^#$this_dir/#&quot;`<br>fi<br> fi<br> echo $this_dir<br></code></pre></td></tr></table></figure><p>简单版一句</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">SHELL_FOLDER=$(cd &quot;$(dirname &quot;$0&quot;)&quot;;pwd)<br></code></pre></td></tr></table></figure><p> 如果你觉得上面的写法比较麻烦，还有一个方式获取脚本的绝对路径,就是借助readlink命令，下面是readlink的命令行说明：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">readlink [选项]<span class="hljs-string">...</span> [文件列表]<span class="hljs-string">...</span><br>描述<br>       请注意，realpath<span class="hljs-params">(1)</span> 是更建议使用的用于标准化（或正规化，canonicalization）功能的命令。<br>       输出符号链接值或权威文件名<br>       -f, <span class="hljs-params">--canonicalize</span><br>              递归跟随给出文件名的所有符号链接以标准化；所有组件都必须存在<br>       -e, <span class="hljs-params">--canonicalize-existing</span><br>              递归跟随给出文件名的所有符号链接以标准化，除最后一个外所有组件必须存在<br>       -m, <span class="hljs-params">--canonicalize-missing</span><br>              递归跟随给出文件名的所有符号链接以标准化；各个组件没有必须存在的要求<br>       -n, <span class="hljs-params">--no-newline</span><br>              不要输出末尾定界符<br></code></pre></td></tr></table></figure><p>所以用readlink命令我们可以直接获取$0参数的全路径文件名，然后再用dirname获取其所在的绝对路径：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">SHELL_FOLDER=<span class="hljs-variable">$</span>(dirname <span class="hljs-variable">$</span>(readlink <span class="hljs-operator">-f</span> <span class="hljs-string">&quot;<span class="hljs-variable">$0</span>&quot;</span>))<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gson的github文档翻译</title>
    <link href="/posts/f0a26b8/"/>
    <url>/posts/f0a26b8/</url>
    
    <content type="html"><![CDATA[<h2 id="Overview-概述"><a href="#Overview-概述" class="headerlink" title="Overview-概述"></a>Overview-概述</h2><p>Gson is a Java library that can be used to convert Java Objects into their JSON representation. It can also be used to convert a JSON string to an equivalent Java object.</p><p>Gson是一个用于将java对象转换为json表示的java库。他也可以用于将json字符串转换为等效的java对象。</p><p>Gson can work with arbitrary Java objects including pre-existing objects that you do not have source code of.</p><p>Gson 可以处理任意 Java 对象，包括您没有源代码的预先存在的对象。</p><h2 id="Goals-for-Gson-Gson-的目标"><a href="#Goals-for-Gson-Gson-的目标" class="headerlink" title="Goals for Gson -Gson 的目标"></a>Goals for Gson -Gson 的目标</h2><ul><li>Provide easy to use mechanisms like <code>toString()</code> and constructor (factory method) to convert Java to JSON and vice-versa -提供易于使用的机制，如<code>toString()</code>构造函数（工厂方法）将 Java 转换为 JSON，反之亦然</li><li>Allow pre-existing unmodifiable objects to be converted to and from JSON -允许预先存在的不可修改对象与 JSON 相互转换</li><li>Allow custom representations for objects -允许对象的自定义表示</li><li>Support arbitrarily complex objects -支持任意复杂的对象</li><li>Generate compact and readable JSON output -生成紧凑且可读的 JSON 输出</li></ul><h2 id="Gson-Performance-and-Scalability-Gson-性能和可扩展性"><a href="#Gson-Performance-and-Scalability-Gson-性能和可扩展性" class="headerlink" title="Gson Performance and Scalability -Gson 性能和可扩展性"></a>Gson Performance and Scalability -Gson 性能和可扩展性</h2><p>Here are some metrics that we obtained on a desktop (dual opteron, 8GB RAM, 64-bit Ubuntu) running lots of other things along-with the tests. You can rerun these tests by using the class <a href="https://github.com/google/gson/blob/master/gson/src/test/java/com/google/gson/metrics/PerformanceTest.java"><code>PerformanceTest</code></a>.</p><ul><li>Strings: Deserialized strings of over 25MB without any problems (see <code>disabled_testStringDeserializationPerformance</code> method in <code>PerformanceTest</code>)</li><li>Large collections:<ul><li>Serialized a collection of 1.4 million objects (see <code>disabled_testLargeCollectionSerialization</code> method in <code>PerformanceTest</code>)</li><li>Deserialized a collection of 87,000 objects (see <code>disabled_testLargeCollectionDeserialization</code> in <code>PerformanceTest</code>)</li></ul></li><li>Gson 1.4 raised the deserialization limit for byte arrays and collection to over 11MB from 80KB.</li></ul><p>Note: Delete the <code>disabled_</code> prefix to run these tests. We use this prefix to prevent running these tests every time we run JUnit tests.</p><h2 id="Gson-Users"><a href="#Gson-Users" class="headerlink" title="Gson Users"></a>Gson Users</h2><p>Gson was originally created for use inside Google where it is currently used in a number of projects. It is now used by a number of public projects and companies.</p><h2 id="Using-Gson-使用-Gson"><a href="#Using-Gson-使用-Gson" class="headerlink" title="Using Gson -使用 Gson"></a>Using Gson -使用 Gson</h2><p>The primary class to use is <a href="https://github.com/google/gson/blob/master/gson/src/main/java/com/google/gson/Gson.java"><code>Gson</code></a> which you can just create by calling <code>new Gson()</code>. There is also a class <a href="https://github.com/google/gson/blob/master/gson/src/main/java/com/google/gson/GsonBuilder.java"><code>GsonBuilder</code></a> available that can be used to create a Gson instance with various settings like version control and so on.</p><p>要使用的主要类是<a href="https://github.com/google/gson/blob/master/gson/src/main/java/com/google/gson/Gson.java"><code>Gson</code></a>您可以通过调用创建的类<code>new Gson()</code>。还有一个<a href="https://github.com/google/gson/blob/master/gson/src/main/java/com/google/gson/GsonBuilder.java"><code>GsonBuilder</code></a>可用的类可用于创建具有各种设置（如版本控制等）的 Gson 实例。</p><p>The Gson instance does not maintain any state while invoking Json operations. So, you are free to reuse the same object for multiple Json serialization and deserialization operations.</p><p>Gson 实例在调用 Json 操作时不维护任何状态。因此，您可以自由地为多个 Json 序列化和反序列化操作重用同一个对象。</p><h2 id="Using-Gson-with-Gradle-Android-在-Gradle-Android-中使用-Gson"><a href="#Using-Gson-with-Gradle-Android-在-Gradle-Android-中使用-Gson" class="headerlink" title="Using Gson with Gradle/Android -在 Gradle/Android 中使用 Gson"></a>Using Gson with Gradle/Android -在 Gradle/Android 中使用 Gson</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">dependencies</span> &#123;<br>    <span class="hljs-attribute">implementation</span> <span class="hljs-string">&#x27;com.google.code.gson:gson:2.8.9&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Using-Gson-with-Maven-在-Maven-中使用-Gson"><a href="#Using-Gson-with-Maven-在-Maven-中使用-Gson" class="headerlink" title="Using Gson with Maven -在 Maven 中使用 Gson"></a>Using Gson with Maven -在 Maven 中使用 Gson</h2><p>To use Gson with Maven2/3, you can use the Gson version available in Maven Central by adding the following dependency:</p><p>要将 Gson 与 Maven2/3 一起使用，您可以通过添加以下依赖项来使用 Maven Central 中可用的 Gson 版本：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--  Gson: Java to Json conversion --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.code.gson<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>gson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.8.9<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>That is it, now your maven project is Gson enabled.</p><p>现在您的 Maven 项目启用了 Gson。</p><h3 id="Primitives-Examples-基本类型示例"><a href="#Primitives-Examples-基本类型示例" class="headerlink" title="Primitives Examples -基本类型示例"></a>Primitives Examples -基本类型示例</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// Serialization 序列化</span><br>Gson gson = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Gson()</span>;<br>gson.<span class="hljs-keyword">to</span><span class="hljs-constructor">Json(1)</span>;            <span class="hljs-comment">// ==&gt; 1</span><br>gson.<span class="hljs-keyword">to</span><span class="hljs-constructor">Json(<span class="hljs-string">&quot;abcd&quot;</span>)</span>;       <span class="hljs-comment">// ==&gt; &quot;abcd&quot;</span><br>gson.<span class="hljs-keyword">to</span><span class="hljs-constructor">Json(<span class="hljs-params">new</span> Long(10)</span>); <span class="hljs-comment">// ==&gt; 10</span><br><span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> values = &#123; <span class="hljs-number">1</span> &#125;;<br>gson.<span class="hljs-keyword">to</span><span class="hljs-constructor">Json(<span class="hljs-params">values</span>)</span>;       <span class="hljs-comment">// ==&gt; [1]</span><br><br><span class="hljs-comment">// Deserialization 反序列化</span><br><span class="hljs-built_in">int</span> one = gson.from<span class="hljs-constructor">Json(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-params">int</span>.<span class="hljs-params">class</span>)</span>;<br>Integer one = gson.from<span class="hljs-constructor">Json(<span class="hljs-string">&quot;1&quot;</span>, Integer.<span class="hljs-params">class</span>)</span>;<br>Long one = gson.from<span class="hljs-constructor">Json(<span class="hljs-string">&quot;1&quot;</span>, Long.<span class="hljs-params">class</span>)</span>;<br>Boolean <span class="hljs-literal">false</span> = gson.from<span class="hljs-constructor">Json(<span class="hljs-string">&quot;false&quot;</span>, Boolean.<span class="hljs-params">class</span>)</span>;<br>String str = gson.from<span class="hljs-constructor">Json(<span class="hljs-string">&quot;\&quot;abc\&quot;&quot;</span>, String.<span class="hljs-params">class</span>)</span>;<br>String<span class="hljs-literal">[]</span> anotherStr = gson.from<span class="hljs-constructor">Json(<span class="hljs-string">&quot;[\&quot;abc\&quot;]&quot;</span>, String[].<span class="hljs-params">class</span>)</span>;<br></code></pre></td></tr></table></figure><h3 id="Object-Examples-对象示例"><a href="#Object-Examples-对象示例" class="headerlink" title="Object Examples -对象示例"></a>Object Examples -对象示例</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> BagOfPrimitives &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> value1 = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">private</span> String value2 = <span class="hljs-string">&quot;abc&quot;</span>;<br>  <span class="hljs-keyword">private</span> transient <span class="hljs-built_in">int</span> value3 = <span class="hljs-number">3</span>;<br>  <span class="hljs-constructor">BagOfPrimitives()</span> &#123;<br>    <span class="hljs-comment">// no-args constructor</span><br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// Serialization</span><br>BagOfPrimitives obj = <span class="hljs-keyword">new</span> <span class="hljs-constructor">BagOfPrimitives()</span>;<br>Gson gson = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Gson()</span>;<br>String json = gson.<span class="hljs-keyword">to</span><span class="hljs-constructor">Json(<span class="hljs-params">obj</span>)</span>;  <br><br><span class="hljs-comment">// ==&gt; json is &#123;&quot;value1&quot;:1,&quot;value2&quot;:&quot;abc&quot;&#125;</span><br></code></pre></td></tr></table></figure><p>Note that you can not serialize objects with circular references since that will result in infinite recursion.</p><p>请注意，您不能使用循环引用序列化对象，因为这会导致无限递归。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// Deserialization</span><br>BagOfPrimitives obj2 = gson.from<span class="hljs-constructor">Json(<span class="hljs-params">json</span>, BagOfPrimitives.<span class="hljs-params">class</span>)</span>;<br><span class="hljs-comment">// ==&gt; obj2 is just like obj</span><br></code></pre></td></tr></table></figure><h4 id="Finer-Points-with-Objects-更精细的点与对象"><a href="#Finer-Points-with-Objects-更精细的点与对象" class="headerlink" title="Finer Points with Objects -更精细的点与对象"></a><strong>Finer Points with Objects</strong> -<strong>更精细的点与对象</strong></h4><ul><li>It is perfectly fine (and recommended) to use private fields.使用私有字段非常好（并且推荐）。</li><li>There is no need to use any annotations to indicate a field is to be included for serialization and deserialization. All fields in the current class (and from all super classes) are included by default.不需要使用任何注释来指示要包含的字段以进行序列化和反序列化。默认情况下包含当前类（以及所有超类）中的所有字段。</li><li>If a field is marked transient, (by default) it is ignored and not included in the JSON serialization or deserialization.如果字段被标记为瞬态，（默认情况下）它将被忽略并且不包含在 JSON 序列化或反序列化中。</li><li>This implementation handles nulls correctly.此实现正确处理空值。<ul><li>While serializing, a null field is omitted from the output.序列化时，输出中会省略空字段。</li><li>While deserializing, a missing entry in JSON results in setting the corresponding field in the object to its default value: null for object types, zero for numeric types, and false for booleans.反序列化时，JSON 中缺少条目会导致将对象中的相应字段设置为其默认值：对象类型为 null，数字类型为零，布尔值为 false。</li></ul></li><li>If a field is <em>synthetic</em>, it is ignored and not included in JSON serialization or deserialization.如果一个字段是<em>合成的</em>，它将被忽略并且不包含在 JSON 序列化或反序列化中。</li><li>Fields corresponding to the outer classes in inner classes, anonymous classes, and local classes are ignored and not included in serialization or deserialization.内部类、匿名类和本地类中对应于外部类的字段将被忽略，不包括在序列化或反序列化中</li></ul><h3 id="Nested-Classes-including-Inner-Classes-嵌套类（包括内部类）"><a href="#Nested-Classes-including-Inner-Classes-嵌套类（包括内部类）" class="headerlink" title="Nested Classes (including Inner Classes)嵌套类（包括内部类）"></a>Nested Classes (including Inner Classes)嵌套类（包括内部类）</h3><p>Gson can serialize static nested classes quite easily.</p><p>Gson 可以很容易地序列化静态嵌套类。</p><p>Gson can also deserialize static nested classes. However, Gson can <strong>not</strong> automatically deserialize the <strong>pure inner classes since their no-args constructor also need a reference to the containing Object</strong> which is not available at the time of deserialization. You can address this problem by either making the inner class static or by providing a custom InstanceCreator for it. Here is an example:</p><p>Gson 还可以反序列化静态嵌套类。但是，Gson<strong>不能</strong>自动反序列化<strong>纯内部类，因为它们的无参数构造函数还需要</strong>对反序列化时不可用<strong>的包含对象的引用</strong>。您可以通过将内部类设为静态或为其提供自定义 InstanceCreator 来解决此问题。下面是一个例子：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123; <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> a; <br><br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> </span>&#123; <br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> b; <br><br>    <span class="hljs-keyword">public</span> B() &#123;<br>      <span class="hljs-comment">// No args constructor for B</span><br>    &#125;<br>  &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>NOTE</strong>: The above class B can not (by default) be serialized with Gson.</p><p><strong>注意</strong>：上面的 B 类不能（默认情况下）用 Gson 序列化。</p><p>Gson can not deserialize <code>&#123;&quot;b&quot;:&quot;abc&quot;&#125;</code> into an instance of B since the class B is an inner class. If it was defined as static class B then Gson would have been able to deserialize the string. Another solution is to write a custom instance creator for B.</p><p>Gson 无法反序列<code>&#123;&quot;b&quot;:&quot;abc&quot;&#125;</code>化为 B 的实例，因为 B 类是内部类。如果它被定义为静态 B 类，那么 Gson 将能够反序列化字符串。另一种解决方案是为 B 编写自定义实例创建者。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InstanceCreatorForB</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InstanceCreator</span>&lt;<span class="hljs-title">A</span>.<span class="hljs-title">B</span>&gt; </span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> A a;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">InstanceCreatorForB</span><span class="hljs-params">(A a)</span>  </span>&#123;<br>    <span class="hljs-keyword">this</span>.a = a;<br>  &#125;<br>  <span class="hljs-keyword">public</span> A.<span class="hljs-function">B <span class="hljs-title">createInstance</span><span class="hljs-params">(Type type)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a.<span class="hljs-function"><span class="hljs-keyword">new</span> <span class="hljs-title">B</span><span class="hljs-params">()</span></span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>The above is possible, but not recommended.以上是可以的，但不推荐。</p><h3 id="Array-Examples数组示例"><a href="#Array-Examples数组示例" class="headerlink" title="Array Examples数组示例"></a>Array Examples数组示例</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Gson gson = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Gson()</span>;<br><span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> ints = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>String<span class="hljs-literal">[]</span> strings = &#123;<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;def&quot;</span>, <span class="hljs-string">&quot;ghi&quot;</span>&#125;;<br><br><span class="hljs-comment">// Serialization</span><br>gson.<span class="hljs-keyword">to</span><span class="hljs-constructor">Json(<span class="hljs-params">ints</span>)</span>;     <span class="hljs-comment">// ==&gt; [1,2,3,4,5]</span><br>gson.<span class="hljs-keyword">to</span><span class="hljs-constructor">Json(<span class="hljs-params">strings</span>)</span>;  <span class="hljs-comment">// ==&gt; [&quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;]</span><br><br><span class="hljs-comment">// Deserialization</span><br><span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> ints2 = gson.from<span class="hljs-constructor">Json(<span class="hljs-string">&quot;[1,2,3,4,5]&quot;</span>, <span class="hljs-params">int</span>[].<span class="hljs-params">class</span>)</span>; <br><span class="hljs-comment">// ==&gt; ints2 will be same as ints</span><br></code></pre></td></tr></table></figure><p>We also support multi-dimensional arrays, with arbitrarily complex element types.</p><p>我们还支持具有任意复杂元素类型的多维数组。</p><h3 id="Collections-Examples集合示例"><a href="#Collections-Examples集合示例" class="headerlink" title="Collections Examples集合示例"></a>Collections Examples集合示例</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Gson gson = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Gson()</span>;<br>Collection&lt;Integer&gt; ints = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Lists</span>.</span></span>immutable<span class="hljs-constructor">List(1,2,3,4,5)</span>;<br><br><span class="hljs-comment">// Serialization</span><br>String json = gson.<span class="hljs-keyword">to</span><span class="hljs-constructor">Json(<span class="hljs-params">ints</span>)</span>;  <span class="hljs-comment">// ==&gt; json is [1,2,3,4,5]</span><br><br><span class="hljs-comment">// Deserialization</span><br>Type collectionType = <span class="hljs-keyword">new</span> TypeToken&lt;Collection&lt;Integer&gt;&gt;<span class="hljs-literal">()</span>&#123;&#125;.get<span class="hljs-constructor">Type()</span>;<br>Collection&lt;Integer&gt; ints2 = gson.from<span class="hljs-constructor">Json(<span class="hljs-params">json</span>, <span class="hljs-params">collectionType</span>)</span>;<br><span class="hljs-comment">// ==&gt; ints2 is same as ints</span><br></code></pre></td></tr></table></figure><p>Fairly hideous: note how we define the type of collection. Unfortunately, there is no way to get around this in Java.</p><p>相当可怕：注意我们如何定义集合的类型。不幸的是，在 Java 中没有办法解决这个问题。</p><h4 id="Collections-Limitations集合限制"><a href="#Collections-Limitations集合限制" class="headerlink" title="Collections Limitations集合限制"></a>Collections Limitations集合限制</h4><p>Gson can serialize collection of arbitrary objects but can not deserialize from it, because there is no way for the user to indicate the type of the resulting object. Instead, while deserializing, the Collection must be of a specific, generic type. This makes sense, and is rarely a problem when following good Java coding practices.</p><p>Gson 可以序列化任意对象的集合，但不能反序列化，因为用户无法指示结果对象的类型。相反，在反序列化时，集合必须是特定的泛型类型。这是有道理的，并且在遵循良好的 Java 编码实践时很少会成为问题。</p><h3 id="Serializing-and-Deserializing-Generic-Types"><a href="#Serializing-and-Deserializing-Generic-Types" class="headerlink" title="Serializing and Deserializing Generic Types"></a>Serializing and Deserializing Generic Types</h3><p>When you call <code>toJson(obj)</code>, Gson calls <code>obj.getClass()</code> to get information on the fields to serialize. Similarly, you can typically pass <code>MyClass.class</code> object in the <code>fromJson(json, MyClass.class)</code> method. This works fine if the object is a non-generic type. However, if the object is of a generic type, then the Generic type information is lost because of Java Type Erasure. Here is an example illustrating the point:</p><p>当您调用 时<code>toJson(obj)</code>，Gson 会调用<code>obj.getClass()</code>以获取有关要序列化的字段的信息。同样，您通常可以<code>MyClass.class</code>在<code>fromJson(json, MyClass.class)</code>方法中传递对象。如果对象是非泛型类型，这可以正常工作。但是，如果对象是泛型类型，那么由于 Java 类型擦除，泛型类型信息将丢失。这是一个说明这一点的例子：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Foo&lt;T&gt; &#123;<br>  T value;<br>&#125;<br>Gson gson = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Gson()</span>;<br>Foo&lt;Bar&gt; foo = <span class="hljs-keyword">new</span> Foo&lt;Bar&gt;<span class="hljs-literal">()</span>;<br>gson.<span class="hljs-keyword">to</span><span class="hljs-constructor">Json(<span class="hljs-params">foo</span>)</span>; <span class="hljs-comment">// May not serialize foo.value correctly</span><br><br>gson.from<span class="hljs-constructor">Json(<span class="hljs-params">json</span>, <span class="hljs-params">foo</span>.<span class="hljs-params">getClass</span>()</span>); <span class="hljs-comment">// Fails to deserialize foo.value as Bar</span><br></code></pre></td></tr></table></figure><p>The above code fails to interpret value as type Bar because Gson invokes <code>foo.getClass()</code> to get its class information, but this method returns a raw class, <code>Foo.class</code>. This means that Gson has no way of knowing that this is an object of type <code>Foo&lt;Bar&gt;</code>, and not just plain <code>Foo</code>.</p><p>上面的代码无法将 value 解释为 Bar 类型，因为 Gson 调用<code>foo.getClass()</code>以获取其类信息，但此方法返回一个原始类<code>Foo.class</code>. 这意味着 Gson 无法知道这是一个类型的对象<code>Foo&lt;Bar&gt;</code>，而不仅仅是普通的<code>Foo</code>。</p><p>You can solve this problem by specifying the correct parameterized type for your generic type. You can do this by using the <a href="https://static.javadoc.io/com.google.code.gson/gson/2.8.5/com/google/gson/reflect/TypeToken.html"><code>TypeToken</code></a> class.</p><p>您可以通过为泛型类型指定正确的参数化类型来解决此问题。您可以通过使用<a href="https://static.javadoc.io/com.google.code.gson/gson/2.8.5/com/google/gson/reflect/TypeToken.html"><code>TypeToken</code></a>该类来做到这一点。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Type fooType = <span class="hljs-keyword">new</span> TypeToken&lt;Foo&lt;Bar&gt;&gt;<span class="hljs-literal">()</span> &#123;&#125;.get<span class="hljs-constructor">Type()</span>;<br>gson.<span class="hljs-keyword">to</span><span class="hljs-constructor">Json(<span class="hljs-params">foo</span>, <span class="hljs-params">fooType</span>)</span>;<br><br>gson.from<span class="hljs-constructor">Json(<span class="hljs-params">json</span>, <span class="hljs-params">fooType</span>)</span>;<br></code></pre></td></tr></table></figure><p>The idiom used to get <code>fooType</code> actually defines an anonymous local inner class containing a method <code>getType()</code> that returns the fully parameterized type.</p><p>用于 get 的习惯用法<code>fooType</code>实际上定义了一个匿名本地内部类，其中包含一个<code>getType()</code>返回完全参数化类型的方法。</p><h3 id="Serializing-and-Deserializing-Collection-with-Objects-of-Arbitrary-Types使用任意类型的对象序列化和反序列化集合"><a href="#Serializing-and-Deserializing-Collection-with-Objects-of-Arbitrary-Types使用任意类型的对象序列化和反序列化集合" class="headerlink" title="Serializing and Deserializing Collection with Objects of Arbitrary Types使用任意类型的对象序列化和反序列化集合"></a>Serializing and Deserializing Collection with Objects of Arbitrary Types使用任意类型的对象序列化和反序列化集合</h3><p>Sometimes you are dealing with JSON array that contains mixed types. For example: <code>[&#39;hello&#39;,5,&#123;name:&#39;GREETINGS&#39;,source:&#39;guest&#39;&#125;]</code></p><p> <code>有时您正在处理包含混合类型的 JSON 数组。例如： </code>[‘hello’,5,{name:’GREETINGS’,source:’guest’}]</p><p>The equivalent <code>Collection</code> containing this is:</p><p><code>Collection</code>包含此内容的等效项是：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Collection collection = new ArrayList();<br>collection.<span class="hljs-builtin-name">add</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>collection.<span class="hljs-builtin-name">add</span>(5);<br>collection.<span class="hljs-builtin-name">add</span>(new Event(<span class="hljs-string">&quot;GREETINGS&quot;</span>, <span class="hljs-string">&quot;guest&quot;</span>));<br></code></pre></td></tr></table></figure><p>where the <code>Event</code> class is defined as:</p><p>其中<code>Event</code>类定义为：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Event</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> name;<br>  <span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> source;<br>  <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-title">Event</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name, <span class="hljs-built_in">String</span> source</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.source = source;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>You can serialize the collection with Gson without doing anything specific: <code>toJson(collection)</code> would write out the desired output.</p><p>您可以使用 Gson 序列化集合，而无需执行任何特定操作：<code>toJson(collection)</code>将写出所需的输出。</p><p>However, deserialization with <code>fromJson(json, Collection.class)</code> will not work since Gson has no way of knowing how to map the input to the types. Gson requires that you provide a genericised version of collection type in <code>fromJson()</code>. So, you have three options:</p><p>但是，反序列化<code>fromJson(json, Collection.class)</code>不会起作用，因为 Gson 无法知道如何将输入映射到类型。Gson 要求您在<code>fromJson()</code>. 所以，你有三个选择：</p><ol><li>Use Gson’s parser API (low-level streaming parser or the DOM parser JsonParser) to parse the array elements and then use <code>Gson.fromJson()</code> on each of the array elements.This is the preferred approach. <a href="https://github.com/google/gson/blob/master/extras/src/main/java/com/google/gson/extras/examples/rawcollections/RawCollectionsExample.java">Here is an example</a> that demonstrates how to do this.使用 Gson 的解析器 API（低级流解析器或 DOM 解析器 JsonParser）解析数组元素，然后<code>Gson.fromJson()</code>在每个数组元素上使用。这是首选方法。<a href="https://github.com/google/gson/blob/master/extras/src/main/java/com/google/gson/extras/examples/rawcollections/RawCollectionsExample.java">这是一个</a>演示如何执行此操作<a href="https://github.com/google/gson/blob/master/extras/src/main/java/com/google/gson/extras/examples/rawcollections/RawCollectionsExample.java">的示例</a>。</li><li>Register a type adapter for <code>Collection.class</code> that looks at each of the array members and maps them to appropriate objects. The disadvantage of this approach is that it will screw up deserialization of other collection types in Gson.注册一个类型适配器，用于<code>Collection.class</code>查看每个数组成员并将它们映射到适当的对象。这种方法的缺点是它会搞砸 Gson 中其他集合类型的反序列化。</li><li>Register a type adapter for <code>MyCollectionMemberType</code> and use <code>fromJson()</code> with <code>Collection&lt;MyCollectionMemberType&gt;</code>.注册一个类型的适配器<code>MyCollectionMemberType</code>和使用<code>fromJson()</code>有<code>Collection&lt;MyCollectionMemberType&gt;</code>。</li></ol><p>This approach is practical only if the array appears as a top-level element or if you can change the field type holding the collection to be of type <code>Collection&lt;MyCollectionMemberType&gt;</code>.</p><p>仅当数组显示为顶级元素或者您可以将保存集合的字段类型更改为 type 时，此方法才实用<code>Collection&lt;MyCollectionMemberType&gt;</code>。</p><h3 id="Built-in-Serializers-and-Deserializers内置序列化器和反序列化器"><a href="#Built-in-Serializers-and-Deserializers内置序列化器和反序列化器" class="headerlink" title="Built-in Serializers and Deserializers内置序列化器和反序列化器"></a>Built-in Serializers and Deserializers内置序列化器和反序列化器</h3><p>Gson has built-in serializers and deserializers for commonly used classes whose default representation may be inappropriate, for instance</p><p>例如，Gson 为常用类内置了序列化器和反序列化器，这些类的默认表示可能不合适</p><ul><li><code>java.net.URL</code> to match it with strings like <code>&quot;https://github.com/google/gson/&quot; 翻译：</code>java.net.URL<code>将它与字符串匹配</code>“<a href="https://github.com/google/gson/&quot;%60%60">https://github.com/google/gson/&quot;``</a></li><li><code>java.net.URI</code> to match it with strings like <code>&quot;/google/gson/&quot; 翻译：</code>java.net.URI<code>将它与字符串匹配</code>“/google/gson/“``</li></ul><p>For many more, see the internal class <a href="https://github.com/google/gson/blob/master/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java"><code>TypeAdapters</code></a>.</p><p>有关更多信息，请参阅内部类<a href="https://github.com/google/gson/blob/master/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java"><code>TypeAdapters</code></a>。</p><p>You can also find source code for some commonly used classes such as JodaTime at <a href="https://sites.google.com/site/gson/gson-type-adapters-for-common-classes-1">this page</a>.</p><p>您还可以在<a href="https://sites.google.com/site/gson/gson-type-adapters-for-common-classes-1">此页面</a>找到一些常用类的源代码，例如 JodaTime 。</p><h3 id="Custom-Serialization-and-Deserialization自定义序列化和反序列化"><a href="#Custom-Serialization-and-Deserialization自定义序列化和反序列化" class="headerlink" title="Custom Serialization and Deserialization自定义序列化和反序列化"></a>Custom Serialization and Deserialization自定义序列化和反序列化</h3><p>Sometimes default representation is not what you want. This is often the case when dealing with library classes (DateTime, etc). Gson allows you to register your own custom serializers and deserializers. This is done by defining two parts:</p><p>有时默认表示不是您想要的。在处理库类（DateTime 等）时，通常就是这种情况。Gson 允许您注册自己的自定义序列化器和反序列化器。这是通过定义两个部分来完成的：</p><ul><li>Json Serializers: Need to define custom serialization for an object需要为对象定义自定义序列化</li><li>Json Deserializers: Needed to define custom deserialization for a type需要为类型定义自定义反序列化</li><li>Instance Creators: Not needed if no-args constructor is available or a deserializer is registered如果无参数构造函数可用或注册了反序列化器，则不需要</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">GsonBuilder gson = <span class="hljs-keyword">new</span> <span class="hljs-constructor">GsonBuilder()</span>;<br>gson.register<span class="hljs-constructor">TypeAdapter(MyType2.<span class="hljs-params">class</span>, <span class="hljs-params">new</span> MyTypeAdapter()</span>);<br>gson.register<span class="hljs-constructor">TypeAdapter(MyType.<span class="hljs-params">class</span>, <span class="hljs-params">new</span> MySerializer()</span>);<br>gson.register<span class="hljs-constructor">TypeAdapter(MyType.<span class="hljs-params">class</span>, <span class="hljs-params">new</span> MyDeserializer()</span>);<br>gson.register<span class="hljs-constructor">TypeAdapter(MyType.<span class="hljs-params">class</span>, <span class="hljs-params">new</span> MyInstanceCreator()</span>);<br></code></pre></td></tr></table></figure><p><code>registerTypeAdapter</code> call checks if the type adapter implements more than one of these interfaces and register it for all of them.</p><p><code>registerTypeAdapter</code> call 检查类型适配器是否实现了多个这些接口并为所有这些接口注册它。</p><h4 id="Writing-a-Serializer-编写序列化程序"><a href="#Writing-a-Serializer-编写序列化程序" class="headerlink" title="Writing a Serializer 编写序列化程序"></a>Writing a Serializer 编写序列化程序</h4><p>Here is an example of how to write a custom serializer for JodaTime <code>DateTime</code> class.</p><p>以下是如何为 JodaTime<code>DateTime</code>类编写自定义序列化程序的示例。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DateTimeSerializer</span> <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">JsonSerializer</span></span>&lt;<span class="hljs-title">DateTime</span>&gt; </span>&#123;<br>  <span class="hljs-keyword">public</span> JsonElement serialize(DateTime src, Type typeOfSrc, JsonSerializationContext context) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">JsonPrimitive</span>(src.toString());<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Gson calls <code>serialize()</code> when it runs into a <code>DateTime</code> object during serialization.</p><p>Gson在序列化过程中<code>serialize()</code>遇到<code>DateTime</code>对象时调用。</p><h4 id="Writing-a-Deserializer编写反序列化器"><a href="#Writing-a-Deserializer编写反序列化器" class="headerlink" title="Writing a Deserializer编写反序列化器"></a>Writing a Deserializer编写反序列化器</h4><p>Here is an example of how to write a custom deserializer for JodaTime DateTime class.</p><p>以下是如何为 JodaTime DateTime 类编写自定义反序列化器的示例。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DateTimeDeserializer</span> <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">JsonDeserializer</span></span>&lt;<span class="hljs-title">DateTime</span>&gt; </span>&#123;<br>  <span class="hljs-keyword">public</span> DateTime deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)<br>      throws JsonParseException &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">DateTime</span>(json.getAsJsonPrimitive().getAsString());<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Gson calls <code>deserialize</code> when it needs to deserialize a JSON string fragment into a DateTime object</p><p>Gson<code>deserialize</code>在需要将 JSON 字符串片段反序列化为 DateTime 对象时调用</p><p><strong>Finer points with Serializers and Deserializers</strong>序列化器和反序列化器的精髓****</p><p>Often you want to register a single handler for all generic types corresponding to a raw type</p><p>通常，您希望为与原始类型对应的所有泛型类型注册单个处理程序</p><ul><li>For example, suppose you have an <code>Id</code> class for id representation/translation (i.e. an internal vs. external representation).例如，假设您有一个<code>Id</code>用于 id 表示/翻译的类（即内部与外部表示）。</li></ul><ul><li>Id<T>type that has same serialization for all generic types 翻译：<code>Id&lt;T&gt;</code> 对所有泛型类型具有相同序列化的类型<ul><li>Essentially write out the id value本质上写出id值</li></ul></li></ul><ul><li>Deserialization is very similar but not exactly the same反序列化非常相似但不完全相同<ul><li>Need to call <code>new Id(Class&lt;T&gt;, String)</code> which returns an instance of <code>Id&lt;T&gt;</code> 需要调用<code>new Id(Class&lt;T&gt;, String)</code>它返回一个实例<code>Id&lt;T&gt;</code></li></ul></li></ul><p>Gson supports registering a single handler for this. You can also register a specific handler for a specific generic type (say <code>Id&lt;RequiresSpecialHandling&gt;</code> needed special handling). The <code>Type</code> parameter for the <code>toJson()</code> and <code>fromJson()</code> contains the generic type information to help you write a single handler for all generic types corresponding to the same raw type.</p><p>Gson 支持为此注册单个处理程序。您还可以为特定的泛型类型注册特定的处理程序（比如<code>Id&lt;RequiresSpecialHandling&gt;</code>需要特殊处理）。在<code>Type</code>该参数<code>toJson()</code>和<code>fromJson()</code>包含的通用类型的信息来帮助你编写对应于同一原始类型的所有泛型类型单一的处理程序</p><h3 id="Writing-an-Instance-Creator编写实例创建器"><a href="#Writing-an-Instance-Creator编写实例创建器" class="headerlink" title="Writing an Instance Creator编写实例创建器"></a>Writing an Instance Creator编写实例创建器</h3><p>While deserializing an Object, Gson needs to create a default instance of the class. Well-behaved classes that are meant for serialization and deserialization should have a no-argument constructor.</p><p>在反序列化对象时，Gson 需要创建类的默认实例。用于序列化和反序列化的行为良好的类应该有一个无参数的构造函数。</p><ul><li>Doesn’t matter whether public or private不管是公有私</li></ul><p>Typically, Instance Creators are needed when you are dealing with a library class that does NOT define a no-argument constructor</p><p>通常，当您处理未定义无参数构造函数的库类时，需要 Instance Creators</p><p><strong>Instance Creator Example</strong>实例创建者示例****</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MoneyInstanceCreator</span> <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">InstanceCreator</span></span>&lt;<span class="hljs-title">Money</span>&gt; </span>&#123;<br>  <span class="hljs-keyword">public</span> Money createInstance(Type type) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">Money</span>(<span class="hljs-string">&quot;1000000&quot;</span>, CurrencyCode.USD);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Type could be of a corresponding generic type类型可以是相应的泛型类型</p><ul><li>Very useful to invoke constructors which need specific generic type information调用需要特定泛型类型信息的构造函数非常有用</li><li>例如，如果<code>Id</code>类存储正在为其创建 Id 的类</li><li>For example, if the <code>Id</code> class stores the class for which the Id is being created</li></ul><h4 id="InstanceCreator-for-a-Parameterized-Type参数化类型的-InstanceCreator"><a href="#InstanceCreator-for-a-Parameterized-Type参数化类型的-InstanceCreator" class="headerlink" title="InstanceCreator for a Parameterized Type参数化类型的 InstanceCreator"></a>InstanceCreator for a Parameterized Type参数化类型的 InstanceCreator</h4><p>Sometimes the type that you are trying to instantiate is a parameterized type. Generally, this is not a problem since the actual instance is of raw type. Here is an example:</p><p>有时，您尝试实例化的类型是参数化类型。通常，这不是问题，因为实际实例是原始类型。下面是一个例子：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyList&lt;T&gt;</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ArrayList&lt;T&gt;</span> </span>&#123;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyListInstanceCreator</span> <span class="hljs-title">implements</span> <span class="hljs-title">InstanceCreator&lt;MyList&lt;?&gt;&gt;</span> </span>&#123;<br>    <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">&quot;unchecked&quot;</span>)<br>  public <span class="hljs-type">MyList</span>&lt;?&gt; createInstance(<span class="hljs-type">Type</span> <span class="hljs-class"><span class="hljs-keyword">type</span>) </span>&#123;<br>    <span class="hljs-comment">// No need to use a parameterized list since the actual instance will have the raw type anyway.</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">MyList</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>However, sometimes you do need to create instance based on the actual parameterized type. In this case, you can use the type parameter being passed to the <code>createInstance</code> method. Here is an example:</p><p>但是，有时您确实需要根据实际参数化类型创建实例。在这种情况下，您可以使用传递给<code>createInstance</code>方法的类型参数。下面是一个例子：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> Id&lt;T&gt; &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">Class</span>&lt;T&gt; classOfId;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> long <span class="hljs-keyword">value</span>;<br>  <span class="hljs-keyword">public</span> Id(<span class="hljs-keyword">Class</span>&lt;T&gt; classOfId, long <span class="hljs-keyword">value</span>) &#123;<br>    this.classOfId = classOfId;<br>    this.<span class="hljs-keyword">value</span> = <span class="hljs-keyword">value</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> IdInstanceCreator implements InstanceCreator&lt;Id&lt;?&gt;&gt; &#123;<br>  <span class="hljs-keyword">public</span> Id&lt;?&gt; createInstance(<span class="hljs-keyword">Type</span> <span class="hljs-keyword">type</span>) &#123;<br>    <span class="hljs-keyword">Type</span>[] typeParameters = ((ParameterizedType)<span class="hljs-keyword">type</span>).getActualTypeArguments();<br>    <span class="hljs-keyword">Type</span> idType = typeParameters[<span class="hljs-number">0</span>]; // Id has <span class="hljs-keyword">only</span> one parameterized <span class="hljs-keyword">type</span> T<br>    <span class="hljs-keyword">return</span> new Id((<span class="hljs-keyword">Class</span>)idType, <span class="hljs-number">0</span>L);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>In the above example, an instance of the Id class can not be created without actually passing in the actual type for the parameterized type. We solve this problem by using the passed method parameter, <code>type</code>. The <code>type</code> object in this case is the Java parameterized type representation of <code>Id&lt;Foo&gt;</code> where the actual instance should be bound to <code>Id&lt;Foo&gt;</code>. Since <code>Id</code> class has just one parameterized type parameter, <code>T</code>, we use the zeroth element of the type array returned by <code>getActualTypeArgument()</code> which will hold <code>Foo.class</code> in this case.</p><p>在上面的例子中，如果没有实际传递参数化类型的实际类型，就无法创建 Id 类的实例。我们通过使用传递的方法参数来解决这个问题，<code>type</code>。<code>type</code>在这种情况下，对象是<code>Id&lt;Foo&gt;</code>实际实例应该绑定到的位置的Java 参数化类型表示<code>Id&lt;Foo&gt;</code>。由于<code>Id</code>class 只有一个参数化类型参数 ，<code>T</code>我们使用返回的类型数组的第零个元素，在这种情况下<code>getActualTypeArgument()</code>它将保持不变<code>Foo.class</code>。</p><h3 id="Compact-Vs-Pretty-Printing-for-JSON-Output-Format紧凑型对比-JSON-输出格式的漂亮打印"><a href="#Compact-Vs-Pretty-Printing-for-JSON-Output-Format紧凑型对比-JSON-输出格式的漂亮打印" class="headerlink" title="Compact Vs. Pretty Printing for JSON Output Format紧凑型对比 JSON 输出格式的漂亮打印"></a>Compact Vs. Pretty Printing for JSON Output Format紧凑型对比 JSON 输出格式的漂亮打印</h3><p>The default JSON output that is provided by Gson is a compact JSON format. This means that there will not be any whitespace in the output JSON structure. Therefore, there will be no whitespace between field names and its value, object fields, and objects within arrays in the JSON output. As well, “null” fields will be ignored in the output (NOTE: null values will still be included in collections/arrays of objects). See the <a href="https://github.com/google/gson/blob/master/UserGuide.md#TOC-Null-Object-Support">Null Object Support</a> section for information on configure Gson to output all null values.</p><p>Gson 提供的默认 JSON 输出是紧凑的 JSON 格式。这意味着输出 JSON 结构中不会有任何空格。因此，JSON 输出中的字段名称及其值、对象字段和数组中的对象之间不会有空格。同样，输出中的“空”字段将被忽略（注意：空值仍将包含在对象的集合/数组中）。有关配置 Gson 以输出所有空值的信息，请参阅<a href="https://github.com/google/gson/blob/master/UserGuide.md#TOC-Null-Object-Support">空对象支持</a>部分。If you would like to use the Pretty Print feature, you must configure your <code>Gson</code> instance using the <code>GsonBuilder</code>. The <code>JsonFormatter</code> is not exposed through our public API, so the client is unable to configure the default print settings/margins for the JSON output. For now, we only provide a default <code>JsonPrintFormatter</code> that has default line length of 80 character, 2 character indentation, and 4 character right margin.</p><p>如果您想使用漂亮打印功能，您必须<code>Gson</code>使用<code>GsonBuilder</code>. 在<code>JsonFormatter</code>没有通过我们的公共API公开，所以客户端无法配置默认打印设置/利润率为JSON输出。目前，我们仅提供<code>JsonPrintFormatter</code>默认行长度为 80 个字符、2 个字符缩进和 4 个字符右边距的默认值。</p><p>The following is an example shows how to configure a <code>Gson</code> instance to use the default <code>JsonPrintFormatter</code> instead of the <code>JsonCompactFormatter</code>:</p><p>以下示例显示了如何将<code>Gson</code>实例配置为使用默认值<code>JsonPrintFormatter</code>而不是<code>JsonCompactFormatter</code>：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Gson gson = <span class="hljs-keyword">new</span> <span class="hljs-constructor">GsonBuilder()</span>.set<span class="hljs-constructor">PrettyPrinting()</span>.create<span class="hljs-literal">()</span>;<br>String jsonOutput = gson.<span class="hljs-keyword">to</span><span class="hljs-constructor">Json(<span class="hljs-params">someObject</span>)</span>;<br></code></pre></td></tr></table></figure><h3 id="Null-Object-Support空对象支持"><a href="#Null-Object-Support空对象支持" class="headerlink" title="Null Object Support空对象支持"></a>Null Object Support空对象支持</h3><p>The default behaviour that is implemented in Gson is that <code>null</code> object fields are ignored. This allows for a more compact output format; however, the client must define a default value for these fields as the JSON format is converted back into its Java form.</p><p>Gson 中实现的默认行为<code>null</code>是忽略对象字段。这允许更紧凑的输出格式；但是，客户端必须为这些字段定义默认值，因为 JSON 格式会转换回其 Java 格式。</p><p>Here’s how you would configure a <code>Gson</code> instance to output null:</p><p>以下是将<code>Gson</code>实例配置为输出 null 的方法：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Gson gson = <span class="hljs-keyword">new</span> <span class="hljs-constructor">GsonBuilder()</span>.serialize<span class="hljs-constructor">Nulls()</span>.create<span class="hljs-literal">()</span>;<br></code></pre></td></tr></table></figure><p>NOTE: when serializing <code>null</code>s with Gson, it will add a <code>JsonNull</code> element to the <code>JsonElement</code> structure. Therefore, this object can be used in custom serialization/deserialization.</p><p>注意：当<code>null</code>使用 Gson序列化s 时，它会<code>JsonNull</code>向<code>JsonElement</code>结构中添加一个元素。因此，该对象可用于自定义序列化/反序列化。</p><p>Here’s an example:下面是一个例子：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> Foo &#123;<br>  <span class="hljs-keyword">private</span> final String s;<br>  <span class="hljs-keyword">private</span> final <span class="hljs-built_in">int</span> i;<br><br>  public <span class="hljs-constructor">Foo()</span> &#123;<br>    this(null, <span class="hljs-number">5</span>);<br>  &#125;<br><br>  public <span class="hljs-constructor">Foo(String <span class="hljs-params">s</span>, <span class="hljs-params">int</span> <span class="hljs-params">i</span>)</span> &#123;<br>    this.s = s;<br>    this.i = i;<br>  &#125;<br>&#125;<br><br>Gson gson = <span class="hljs-keyword">new</span> <span class="hljs-constructor">GsonBuilder()</span>.serialize<span class="hljs-constructor">Nulls()</span>.create<span class="hljs-literal">()</span>;<br>Foo foo = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Foo()</span>;<br>String json = gson.<span class="hljs-keyword">to</span><span class="hljs-constructor">Json(<span class="hljs-params">foo</span>)</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(json);<br><br>json = gson.<span class="hljs-keyword">to</span><span class="hljs-constructor">Json(<span class="hljs-params">null</span>)</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(json);<br></code></pre></td></tr></table></figure><p>The output is:</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">&#123;<span class="hljs-string">&quot;s&quot;</span>:<span class="hljs-literal">null</span>,<span class="hljs-string">&quot;i&quot;</span>:<span class="hljs-number">5</span>&#125;<br><span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><h3 id="Versioning-Support版本支持"><a href="#Versioning-Support版本支持" class="headerlink" title="Versioning Support版本支持"></a>Versioning Support版本支持</h3><p>Multiple versions of the same object can be maintained by using <a href="https://github.com/google/gson/blob/master/gson/src/main/java/com/google/gson/annotations/Since.java">@Since</a> annotation. This annotation can be used on Classes, Fields and, in a future release, Methods. In order to leverage this feature, you must configure your <code>Gson</code> instance to ignore any field/object that is greater than some version number. If no version is set on the <code>Gson</code> instance then it will serialize and deserialize all fields and classes regardless of the version.</p><p>可以使用<a href="https://github.com/google/gson/blob/master/gson/src/main/java/com/google/gson/annotations/Since.java">@Since</a>注解维护同一对象的多个版本。该注解可用于类、字段以及未来版本中的方法。为了利用此功能，您必须将<code>Gson</code>实例配置为忽略大于某个版本号的任何字段/对象。如果没有在<code>Gson</code>实例上设置版本，那么无论版本如何，它都会序列化和反序列化所有字段和类。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VersionedClass</span> </span>&#123;<br>  @Since(<span class="hljs-number">1.1</span>) <span class="hljs-keyword">private</span> final <span class="hljs-keyword">String</span> <span class="hljs-keyword">new</span><span class="hljs-type">erField</span>;<br>  @Since(<span class="hljs-number">1.0</span>) <span class="hljs-keyword">private</span> final <span class="hljs-keyword">String</span> <span class="hljs-keyword">new</span><span class="hljs-type">Field</span>;<br>  <span class="hljs-keyword">private</span> final <span class="hljs-keyword">String</span> field;<br><br>  <span class="hljs-keyword">public</span> VersionedClass() &#123;<br>    <span class="hljs-built_in">this</span>.<span class="hljs-keyword">new</span><span class="hljs-type">erField</span> = <span class="hljs-string">&quot;newer&quot;</span>;<br>    <span class="hljs-built_in">this</span>.<span class="hljs-keyword">new</span><span class="hljs-type">Field</span> = <span class="hljs-string">&quot;new&quot;</span>;<br>    <span class="hljs-built_in">this</span>.field = <span class="hljs-string">&quot;old&quot;</span>;<br>  &#125;<br>&#125;<br><br>VersionedClass versionedObject = <span class="hljs-keyword">new</span> <span class="hljs-type">VersionedClass</span>();<br>Gson gson = <span class="hljs-keyword">new</span> <span class="hljs-type">GsonBuilder</span>().setVersion(<span class="hljs-number">1.0</span>).create();<br><span class="hljs-keyword">String</span> jsonOutput = gson.toJson(versionedObject);<br>System.out.println(jsonOutput);<br>System.out.println();<br><br>gson = <span class="hljs-keyword">new</span> <span class="hljs-type">Gson</span>();<br>jsonOutput = gson.toJson(versionedObject);<br>System.out.println(jsonOutput);<br></code></pre></td></tr></table></figure><p>The output is:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<span class="hljs-attr">&quot;newField&quot;</span>:<span class="hljs-string">&quot;new&quot;</span>,<span class="hljs-attr">&quot;field&quot;</span>:<span class="hljs-string">&quot;old&quot;</span>&#125;<br><br>&#123;<span class="hljs-attr">&quot;newerField&quot;</span>:<span class="hljs-string">&quot;newer&quot;</span>,<span class="hljs-attr">&quot;newField&quot;</span>:<span class="hljs-string">&quot;new&quot;</span>,<span class="hljs-attr">&quot;field&quot;</span>:<span class="hljs-string">&quot;old&quot;</span>&#125;<br></code></pre></td></tr></table></figure><h3 id="Excluding-Fields-From-Serialization-and-Deserialization从序列化和反序列化中排除字段"><a href="#Excluding-Fields-From-Serialization-and-Deserialization从序列化和反序列化中排除字段" class="headerlink" title="Excluding Fields From Serialization and Deserialization从序列化和反序列化中排除字段"></a>Excluding Fields From Serialization and Deserialization从序列化和反序列化中排除字段</h3><p>Gson supports numerous mechanisms for excluding top-level classes, fields and field types. Below are pluggable mechanisms that allow field and class exclusion. If none of the below mechanisms satisfy your needs then you can always use <a href="https://github.com/google/gson/blob/master/UserGuide.md#TOC-Custom-Serialization-and-Deserialization">custom serializers and deserializers</a>.</p><p>Gson 支持多种机制来排除顶级类、字段和字段类型。下面是允许字段和类排除的可插入机制。如果以下机制都不能满足您的需求，那么您始终可以使用<a href="https://github.com/google/gson/blob/master/UserGuide.md#TOC-Custom-Serialization-and-Deserialization">自定义序列化器和反序列化器</a>。</p><h4 id="Java-Modifier-ExclusionJava-修饰符排除"><a href="#Java-Modifier-ExclusionJava-修饰符排除" class="headerlink" title="Java Modifier ExclusionJava 修饰符排除"></a>Java Modifier ExclusionJava 修饰符排除</h4><p>By default, if you mark a field as <code>transient</code>, it will be excluded. As well, if a field is marked as <code>static</code> then by default it will be excluded. If you want to include some transient fields then you can do the following:</p><p>默认情况下，如果您将字段标记为<code>transient</code>，它将被排除在外。同样，如果一个字段被标记为<code>static</code>then 默认情况下它将被排除。如果要包含一些临时字段，则可以执行以下操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.Modifier;<br>Gson gson = <span class="hljs-keyword">new</span> GsonBuilder()<br>    .excludeFieldsWithModifiers(Modifier.STATIC)<br>    .create();<br></code></pre></td></tr></table></figure><p>NOTE: you can give any number of the <code>Modifier</code> constants to the <code>excludeFieldsWithModifiers</code> method. For example:</p><p>注意：您可以<code>Modifier</code>为该<code>excludeFieldsWithModifiers</code>方法提供任意数量的常量。例如：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle">Gson gson = <span class="hljs-keyword">new</span> GsonBuilder()<br>    .excludeFieldsWithModifiers(Modifier.<span class="hljs-keyword">STATIC</span>, Modifier.<span class="hljs-keyword">TRANSIENT</span>, Modifier.<span class="hljs-keyword">VOLATILE</span>)<br>    .create();<br></code></pre></td></tr></table></figure><h4 id="Gson’s-Expose"><a href="#Gson’s-Expose" class="headerlink" title="Gson’s @Expose"></a>Gson’s <code>@Expose</code></h4><p>This feature provides a way where you can mark certain fields of your objects to be excluded for consideration for serialization and deserialization to JSON. To use this annotation, you must create Gson by using <code>new GsonBuilder().excludeFieldsWithoutExposeAnnotation().create()</code>. The Gson instance created will exclude all fields in a class that are not marked with <code>@Expose</code> annotation.</p><p>此功能提供了一种方法，您可以将对象的某些字段标记为要排除以考虑序列化和反序列化为 JSON。要使用此注解，您必须使用<code>new GsonBuilder().excludeFieldsWithoutExposeAnnotation().create()</code>. 创建的 Gson 实例将排除类中所有没有标注的字段<code>@Expose</code>。</p><h4 id="User-Defined-Exclusion-Strategies用户定义的排除策略"><a href="#User-Defined-Exclusion-Strategies用户定义的排除策略" class="headerlink" title="User Defined Exclusion Strategies用户定义的排除策略"></a>User Defined Exclusion Strategies用户定义的排除策略</h4><p>If the above mechanisms for excluding fields and class type do not work for you then you can always write your own exclusion strategy and plug it into Gson. See the <a href="https://static.javadoc.io/com.google.code.gson/gson/2.8.5/com/google/gson/ExclusionStrategy.html"><code>ExclusionStrategy</code></a> JavaDoc for more information.</p><p>如果上述排除字段和类类型的机制对您不起作用，那么您可以随时编写自己的排除策略并将其插入 Gson。有关<a href="https://static.javadoc.io/com.google.code.gson/gson/2.8.5/com/google/gson/ExclusionStrategy.html"><code>ExclusionStrategy</code></a>更多信息，请参阅JavaDoc。</p><p>The following example shows how to exclude fields marked with a specific <code>@Foo</code> annotation and excludes top-level types (or declared field type) of class <code>String</code>.</p><p>以下示例显示了如何排除标有特定<code>@Foo</code>注释的字段并排除 class 的顶级类型（或声明的字段类型）<code>String</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(&#123;ElementType.FIELD&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Foo &#123;<br>  <span class="hljs-comment">// Field tag only annotation</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SampleObjectForTest</span> </span>&#123;<br>  <span class="hljs-meta">@Foo</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> annotatedField;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String stringField;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> longField;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Class&lt;?&gt; clazzField;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SampleObjectForTest</span><span class="hljs-params">()</span> </span>&#123;<br>    annotatedField = <span class="hljs-number">5</span>;<br>    stringField = <span class="hljs-string">&quot;someDefaultValue&quot;</span>;<br>    longField = <span class="hljs-number">1234</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyExclusionStrategy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ExclusionStrategy</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Class&lt;?&gt; typeToSkip;<br><br>  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">MyExclusionStrategy</span><span class="hljs-params">(Class&lt;?&gt; typeToSkip)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.typeToSkip = typeToSkip;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldSkipClass</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (clazz == typeToSkip);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldSkipField</span><span class="hljs-params">(FieldAttributes f)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> f.getAnnotation(Foo.class) != <span class="hljs-keyword">null</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>  Gson gson = <span class="hljs-keyword">new</span> GsonBuilder()<br>      .setExclusionStrategies(<span class="hljs-keyword">new</span> MyExclusionStrategy(String.class))<br>      .serializeNulls()<br>      .create();<br>  SampleObjectForTest src = <span class="hljs-keyword">new</span> SampleObjectForTest();<br>  String json = gson.toJson(src);<br>  System.out.println(json);<br>&#125;<br></code></pre></td></tr></table></figure><p>The output is:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<span class="hljs-attr">&quot;longField&quot;</span>:<span class="hljs-number">1234</span>&#125;<br></code></pre></td></tr></table></figure><h3 id="JSON-Field-Naming-SupportJSON-字段命名支持"><a href="#JSON-Field-Naming-SupportJSON-字段命名支持" class="headerlink" title="JSON Field Naming SupportJSON 字段命名支持"></a>JSON Field Naming SupportJSON 字段命名支持</h3><p>Gson supports some pre-defined field naming policies to convert the standard Java field names (i.e., camel cased names starting with lower case — <code>sampleFieldNameInJava</code>) to a Json field name (i.e., <code>sample_field_name_in_java</code> or <code>SampleFieldNameInJava</code>). See the <a href="https://static.javadoc.io/com.google.code.gson/gson/2.8.5/com/google/gson/FieldNamingPolicy.html">FieldNamingPolicy</a> class for information on the pre-defined naming policies.</p><p>Gson 支持一些预定义的字段命名策略来将标准的 Java 字段名称（即以小写 — 开头的驼峰命名法<code>sampleFieldNameInJava</code>）转换为 Json 字段名称（即，<code>sample_field_name_in_java</code>or <code>SampleFieldNameInJava</code>）。有关预定义命名策略的信息，请参阅<a href="https://static.javadoc.io/com.google.code.gson/gson/2.8.5/com/google/gson/FieldNamingPolicy.html">FieldNamingPolicy</a>类。</p><p>It also has an annotation based strategy to allows clients to define custom names on a per field basis. Note, that the annotation based strategy has field name validation which will raise “Runtime” exceptions if an invalid field name is provided as the annotation value.</p><p>它还具有基于注释的策略，允许客户在每个字段的基础上定义自定义名称。请注意，基于注释的策略具有字段名称验证，如果提供无效的字段名称作为注释值，则会引发“运行时”异常。</p><p>The following is an example of how to use both Gson naming policy features:</p><p>以下是如何使用 Gson 命名策略功能的示例：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SomeObject</span> &#123;</span><br>  @<span class="hljs-built_in">SerializedName</span>(<span class="hljs-string">&quot;custom_naming&quot;</span>) <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">String</span> someField;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">String</span> someOtherField;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SomeObject</span><span class="hljs-params">(<span class="hljs-keyword">String</span> a, <span class="hljs-keyword">String</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.someField = a;<br>    <span class="hljs-keyword">this</span>.someOtherField = b;<br>  &#125;<br>&#125;<br><br>SomeObject someObject = <span class="hljs-keyword">new</span> <span class="hljs-built_in">SomeObject</span>(<span class="hljs-string">&quot;first&quot;</span>, <span class="hljs-string">&quot;second&quot;</span>);<br>Gson gson = <span class="hljs-keyword">new</span> <span class="hljs-built_in">GsonBuilder</span>().<span class="hljs-built_in">setFieldNamingPolicy</span>(FieldNamingPolicy.UPPER_CAMEL_CASE).<span class="hljs-built_in">create</span>();<br><span class="hljs-keyword">String</span> jsonRepresentation = gson.<span class="hljs-built_in">toJson</span>(someObject);<br>System.out.<span class="hljs-built_in">println</span>(jsonRepresentation);<br></code></pre></td></tr></table></figure><p>The output is:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<span class="hljs-attr">&quot;custom_naming&quot;</span>:<span class="hljs-string">&quot;first&quot;</span>,<span class="hljs-attr">&quot;SomeOtherField&quot;</span>:<span class="hljs-string">&quot;second&quot;</span>&#125;<br></code></pre></td></tr></table></figure><p>If you have a need for custom naming policy (<a href="https://groups.google.com/group/google-gson/browse_thread/thread/cb441a2d717f6892">see this discussion</a>), you can use the <a href="https://static.javadoc.io/com.google.code.gson/gson/2.8.5/com/google/gson/annotations/SerializedName.html">@SerializedName</a> annotation.</p><p>如果您需要自定义命名策略（<a href="https://groups.google.com/group/google-gson/browse_thread/thread/cb441a2d717f6892">请参阅此讨论</a>），您可以使用<a href="https://static.javadoc.io/com.google.code.gson/gson/2.8.5/com/google/gson/annotations/SerializedName.html">@SerializedName</a>注释。</p><h3 id="Sharing-State-Across-Custom-Serializers-and-Deserializers在自定义序列化器和反序列化器之间共享状态"><a href="#Sharing-State-Across-Custom-Serializers-and-Deserializers在自定义序列化器和反序列化器之间共享状态" class="headerlink" title="Sharing State Across Custom Serializers and Deserializers在自定义序列化器和反序列化器之间共享状态"></a>Sharing State Across Custom Serializers and Deserializers在自定义序列化器和反序列化器之间共享状态</h3><p>Sometimes you need to share state across custom serializers/deserializers (<a href="https://groups.google.com/group/google-gson/browse_thread/thread/2850010691ea09fb">see this discussion</a>). You can use the following three strategies to accomplish this:</p><p>有时您需要在自定义序列化器/反序列化器之间共享状态（<a href="https://groups.google.com/group/google-gson/browse_thread/thread/2850010691ea09fb">请参阅此讨论</a>）。您可以使用以下三种策略来完成此操作：</p><ol><li>Store shared state in static fields  -在静态字段中存储共享状态</li><li>Declare the serializer/deserializer as inner classes of a parent type, and use the instance fields of parent type to store shared state  -将序列化器/反序列化器声明为父类型的内部类，并使用父类型的实例字段来存储共享状态</li><li>Use Java <code>ThreadLocal</code>  -使用 Java <code>ThreadLocal</code></li></ol><p>1 and 2 are not thread-safe options, but 3 is.</p><p>1 和 2 不是线程安全选项，但 3 是。</p><h3 id="Streaming"><a href="#Streaming" class="headerlink" title="Streaming"></a>Streaming</h3><p>In addition Gson’s object model and data binding, you can use Gson to read from and write to a <a href="https://sites.google.com/site/gson/streaming">stream</a>. You can also combine streaming and object model access to get the best of both approaches.</p><p>除了 Gson 的对象模型和数据绑定之外，您还可以使用 Gson 读取和写入<a href="https://sites.google.com/site/gson/streaming">流</a>。您还可以结合流和对象模型访问来充分利用这两种方法。</p><h2 id="Issues-in-Designing-Gson"><a href="#Issues-in-Designing-Gson" class="headerlink" title="Issues in Designing Gson"></a>Issues in Designing Gson</h2><p>See the <a href="https://github.com/google/gson/blob/master/GsonDesignDocument.md">Gson design document</a> for a discussion of issues we faced while designing Gson. It also include a comparison of Gson with other Java libraries that can be used for Json conversion.</p><h2 id="Future-Enhancements-to-Gson"><a href="#Future-Enhancements-to-Gson" class="headerlink" title="Future Enhancements to Gson"></a>Future Enhancements to Gson</h2><p>For the latest list of proposed enhancements or if you’d like to suggest new ones, see the <a href="https://github.com/google/gson/issues">Issues section</a> under the project website.</p>]]></content>
    
    
    
    <tags>
      
      <tag>gson</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 容器</title>
    <link href="/posts/f431e3b/"/>
    <url>/posts/f431e3b/</url>
    
    <content type="html"><![CDATA[<p> Java 容器</p><pre><code>单列集合顶层接口  Iterable 定义了用于迭代器循环的接口  Collection 定义的一套统一单列集合的接口。其中有isEmpty、add、remove、size等常用方法   List 接口 继承重写了Collection接口的一些函数，同时增加了一些如 sort、indexOf等函数。 其允许重复元素的一种有序的集合。   Set 接口 继承Collection，重写部分函数。 该集合不包含重复元素，不保证插入顺序的访问。   Queue 接口 定义队列一种先进先出的数据结构的接口，继承Collection 接口，增加了 poll、peek、element等方法。List 实现类顺序存储，线性结构的单列集合    ArrayList    非线程安全的，内部基于数组实现。    扩容操作：默认空数组，第一次添加单条数据时，初始化大小为10的数组，一次扩容1.5倍。若用addAll 添加数据，超出1.5倍按实际大小扩容，不足按1.5倍扩。    其中 插入扩容移除操作时，涉及到对数组的拷贝，较影响性能。    LinkedList    非线程安全的，内部基于双向链表实现。    链式存储结构，将不连续的内存连续起来，方便允许插入和删除，只需要改变指针指向的位置。不允许随意存取。    Vector    方法前用synchronized关键字保证线程安全，内部基于数组实现。    扩容操作：默认初始化一个大小为10，扩容容量为0的数组。    若扩容容量小于等于0，一次扩容2倍，否则按扩容容量扩容。        Stack 栈        继承自Vector，增加入栈（向数组尾部加入数据），出栈（取出最后一条数据，并移除）操作。Set 实现类    HashSet    内部用HashMap实现，添加的元素作为key，value为固定的Object。    LinkedHashSet    继承自HashSet，内部用LinkedHashMap实现。保证有序访问。    TreeSet    内部用TreeMap实现，添加的元素作为key，value为固定的Object。Queue 实现类    AbstractQueue        PriorityQueue 非阻塞队列        根据比较器排序的优先级队列，内部用数组实现。        扩容机制：默认初始化一个大小为11的数组，若队列大小小于64，一次扩容+2，否则1.5倍扩。        入队时，保证队首数据是最小的，根据siftUp方法向上筛选。出队时，取出队首数据，根据siftDown方法向下筛选，选出新的队首数据。        ConcurrentLinkedQueue 非阻塞队列        基于单链表实现，链表用volatile修饰。CAS机制保证线程安全。        CAS: compare and swap 比较再交换。当预期值相同时，再修改为新值。原子操作。    BlockingQueue 阻塞队列        ArrayBlockingQueue        有界阻塞队列，内部用数组实现，必须指定数组大小。通过ReentrantLock实现线程安全访问，Condition实现等待阻塞机制。        LinkedBlockingQueue        内部基于单链表实现，默认容量为Integer.MAX_VALUE。        PriorityBlockingQueue        内部基于数组实现，有优先级的无界阻塞队列。内部实现与扩容机制跟PriorityQueue差不多。        SynchronousQueue        内部只有一个元素的队列。        DelayQueue        内部基于PriorityQueue实现，根据时间排序的队列。take取数据时，若未到出队时间，则阻塞。    Deque    定义双端队列接口 既能从头部添加又能从尾部添加，也可以从两端取。        LinkedList        非线程安全的非阻塞式双端队列        LinkedBlockingDeque        阻塞式双端队列键值对集合顶层接口 Map 定义了一套键值对存储集合的接口。包含size、put、get、remvoe等常用方法实现类:HashMap内部用数组+链表的方式实现。指定的数组大小会计算为接近的2的幂次方大小，默认大小为16，阈值为0.75倍。添加数据超过阈值一次扩容2倍，同时阈值*2.hash算法：key的hash值高16位与低16位异或，以保留全部位的特性，减少hash冲突。扩容后，重新计算链表所在下标位置，重新赋值。（原链表下标+(cap&amp;hash)）当一个链表长度超过8时，会生成一个红黑树（根据key值比较排序），加速查找和插入。当结点因为移除分裂操作少于6个时，消除树结构。红黑树：一种自平衡的二叉树。每个节点都带有红色或黑色属性的二叉查找树。当对红黑树进行插入和删除操作时，为了保证树的性质，会对树进行旋转(左旋，右旋);LinkedHashMap继承自HashMap，用LinkedHashMapEntry作为链表的节点，这是一个双向链表。同时内部维护head以及tail节点，以保证顺序访问。默认以插入顺序。accessOrder 设置为true，最近最少访问顺序，再get方法时，将得到的元素移动至尾节点。TreeMap内部用红黑树实现，以保证key值的排序方式。HashTable数组+链表实现，通过锁关键字保证线程安全。注 保证线程安全的集合 可以通过Collections.synchronized 方法达到，其返回一个线程安全的集合。 </code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>-java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jitpack打包</title>
    <link href="/posts/dc8ff4bf/"/>
    <url>/posts/dc8ff4bf/</url>
    
    <content type="html"><![CDATA[<h1 id="1-添加依赖"><a href="#1-添加依赖" class="headerlink" title="1.添加依赖"></a>1.添加依赖</h1><p>在gradle.build文件中，应用插件：<code>maven</code>或者<code>maven-publish</code></p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-title">apply plugin:</span> `maven`<br>或者<br><span class="hljs-title">apply plugin:</span> `maven-publish`<br></code></pre></td></tr></table></figure><p>如果是新版<code>gradle</code>,应用插件可以使用<code>plugins&#123;&#125;</code>取代<code>apply plugin</code>写法。例如：</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gml">plugins&#123;<br><span class="hljs-symbol">id</span> <span class="hljs-string">&#x27;java&#x27;</span><br>    <span class="hljs-symbol">id</span> <span class="hljs-string">&#x27;maven-publish&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果应用的<code>maven</code>插件，可以使用下面命令在本地测试打包情况</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">./gradlew <span class="hljs-keyword">install</span><br></code></pre></td></tr></table></figure><p>如果使用的<code>maven-publish</code>插件，可以使用下面命令在本地测试打包情况</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">./gradlew</span> build publishToMavenLocal <span class="hljs-params">--stacktrace</span> <span class="hljs-string">//</span>本地打包发布，<span class="hljs-params">--stacktrace</span>参数查看更详细内容<br></code></pre></td></tr></table></figure><h1 id="2-更改build-gradle"><a href="#2-更改build-gradle" class="headerlink" title="2.更改build.gradle"></a>2.更改build.gradle</h1><h2 id="示例代码-来自jitpack官方"><a href="#示例代码-来自jitpack官方" class="headerlink" title="示例代码:来自jitpack官方"></a>示例代码:来自jitpack官方</h2><h3 id="Simple-https-github-com-jitpack-gradle-simple"><a href="#Simple-https-github-com-jitpack-gradle-simple" class="headerlink" title="Simple - https://github.com/jitpack/gradle-simple"></a>Simple - <a href="https://github.com/jitpack/gradle-simple">https://github.com/jitpack/gradle-simple</a></h3><p>Example Gradle project producing a single jar. Uses the <code>maven</code> plugin to publish the jar to the local repository.</p><p><a href="https://jitpack.io/#jitpack/gradle-simple">https://jitpack.io/#jitpack/gradle-simple</a></p><p>To install the library add:</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">repositories</span> &#123; <br>     jcenter()<br>     maven &#123; url <span class="hljs-string">&quot;https://jitpack.io&quot;</span> &#125;<br>&#125;<br><span class="hljs-keyword">dependencies</span> &#123;<br>      implementation <span class="hljs-string">&#x27;com.github.jitpack:gradle-simple:1.1&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>build.gradle文件示例内容</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">apply plugin: <span class="hljs-string">&#x27;java&#x27;</span><br>apply plugin: <span class="hljs-string">&#x27;maven-publish&#x27;</span><br><br><span class="hljs-keyword">group</span> = <span class="hljs-string">&#x27;com.github.jitpack&#x27;</span><br>version = <span class="hljs-string">&#x27;2.0&#x27;</span><br><br>sourceCompatibility = <span class="hljs-number">1.8</span> // java <span class="hljs-number">8</span><br>targetCompatibility = <span class="hljs-number">1.8</span><br><br>repositories &#123;<br>  mavenCentral()<br>&#125;<br><br>dependencies &#123;<br>  implementation <span class="hljs-string">&#x27;com.google.guava:guava:29.0-jre&#x27;</span><br>&#125;<br><br>java &#123;<br>withSourcesJar()<br>withJavadocJar()<br>&#125;<br><br>publishing &#123;<br>    publications &#123;<br>        maven(MavenPublication) &#123;<br><span class="hljs-keyword">from</span> components.java<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">wrapper</span> &#123;<br>    gradleVersion = &quot;7.3.3&quot;<br>    distributionType = <span class="hljs-keyword">Wrapper</span>.DistributionType.<span class="hljs-keyword">ALL</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Multiple-modules-https-github-com-jitpack-gradle-modular"><a href="#Multiple-modules-https-github-com-jitpack-gradle-modular" class="headerlink" title="Multiple modules - https://github.com/jitpack/gradle-modular"></a>Multiple modules - <a href="https://github.com/jitpack/gradle-modular">https://github.com/jitpack/gradle-modular</a></h3><p>Example gradle project with two modules:</p><ul><li>client</li><li>server</li></ul><p>To install each module individually use <code>com.github.User.Repo</code> for groupId and module name as artifact id:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">compile</span> &#x27;com.github.jitpack.gradle-modular:client:<span class="hljs-number">1</span>.<span class="hljs-number">1</span>&#x27;<br><span class="hljs-attribute">compile</span> &#x27;com.github.jitpack.gradle-modular:server:<span class="hljs-number">1</span>.<span class="hljs-number">1</span>&#x27;<br></code></pre></td></tr></table></figure><p><strong>build.gradle文件示例内容</strong></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">allprojects</span> &#123;<br>version = <span class="hljs-string">&quot;1.4&quot;</span><br><span class="hljs-keyword">group</span> = <span class="hljs-string">&#x27;io.jitpack.gradle-modular&#x27;</span><br>&#125;<br><br><span class="hljs-keyword">subprojects</span> &#123;<br>apply plugin: <span class="hljs-string">&#x27;java&#x27;</span><br>apply plugin: <span class="hljs-string">&#x27;maven-publish&#x27;</span><br><br><span class="hljs-keyword">sourceCompatibility</span> = <span class="hljs-number">1.8</span> <span class="hljs-comment">// java 8</span><br><span class="hljs-keyword">targetCompatibility</span> = <span class="hljs-number">1.8</span><br><br>java &#123;<br>withSourcesJar()<br>withJavadocJar()<br>&#125;<br><br>publishing &#123;<br>publications &#123;<br>maven(MavenPublication) &#123;<br>groupId <span class="hljs-keyword">project</span>.<span class="hljs-keyword">group</span><br>artifactId <span class="hljs-keyword">project</span>.name<br>version <span class="hljs-keyword">project</span>.version<br><span class="hljs-keyword">from</span> components.java<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Project-with-multiple-artifacts-https-github-com-jitpack-gradle-multiple-jars"><a href="#Project-with-multiple-artifacts-https-github-com-jitpack-gradle-multiple-jars" class="headerlink" title="Project with multiple artifacts - https://github.com/jitpack/gradle-multiple-jars"></a>Project with multiple artifacts - <a href="https://github.com/jitpack/gradle-multiple-jars">https://github.com/jitpack/gradle-multiple-jars</a></h3><p>Example Gradle project producing two jars from single source directory:</p><ul><li><em>API</em> from src/api</li><li><em>Impl</em> from src/impl</li></ul><p>Both jars are installed to local maven reactor with:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">gradle <span class="hljs-keyword">install</span><br></code></pre></td></tr></table></figure><p>To add them to build.gradle use the following syntax:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">compile</span> &#x27;com.github.jitpack.gradle-multiple-jars:api:<span class="hljs-number">1</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>&#x27;<br><span class="hljs-attribute">compile</span> &#x27;com.github.jitpack.gradle-multiple-jars:impl:<span class="hljs-number">1</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>&#x27;<br></code></pre></td></tr></table></figure><p>Or to add them both together:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">compile</span> &#x27;com.github.jitpack:gradle-multiple-jars:<span class="hljs-number">1</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>&#x27;<br></code></pre></td></tr></table></figure><p><strong>build.gradle文件示例内容</strong></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs gradle">apply plugin: <span class="hljs-string">&quot;java&quot;</span><br>apply plugin: <span class="hljs-string">&quot;maven&quot;</span><br><br><span class="hljs-keyword">group</span> = <span class="hljs-string">&quot;com.github.jitpack&quot;</span><br>version = <span class="hljs-number">1.0</span><br><span class="hljs-keyword">sourceCompatibility</span> = <span class="hljs-number">1.8</span> <span class="hljs-comment">// java 8</span><br><span class="hljs-keyword">targetCompatibility</span> = <span class="hljs-number">1.8</span><br><br><span class="hljs-keyword">repositories</span> &#123;<br>    mavenCentral()<br>&#125;<br><br><span class="hljs-keyword">sourceSets</span> &#123;<br>    api<br>    impl<br>&#125;<br><br><span class="hljs-keyword">sourceSets</span>.all &#123; set -&gt;<br>    <span class="hljs-keyword">def</span> jarTask = <span class="hljs-keyword">task</span>(<span class="hljs-string">&quot;$&#123;set.name&#125;Jar&quot;</span>, type: Jar) &#123;<br>        baseName = <span class="hljs-string">&quot;$set.name&quot;</span><br>        <span class="hljs-keyword">from</span> set.output<br>    &#125;<br><br>    <span class="hljs-keyword">artifacts</span> &#123;<br>        archives jarTask<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">dependencies</span> &#123;<br>    apiCompile <span class="hljs-string">&#x27;commons-codec:commons-codec:1.5&#x27;</span><br><br>    implCompile <span class="hljs-keyword">sourceSets</span>.api.output<br>    implCompile <span class="hljs-string">&#x27;commons-lang:commons-lang:2.6&#x27;</span><br><br>    testCompile <span class="hljs-string">&#x27;junit:junit:4.9&#x27;</span><br>    testCompile <span class="hljs-keyword">sourceSets</span>.api.output<br>    testCompile <span class="hljs-keyword">sourceSets</span>.impl.output<br>    <br>    <span class="hljs-keyword">runtime</span> <span class="hljs-keyword">configurations</span>.apiRuntime<br>    <span class="hljs-keyword">runtime</span> <span class="hljs-keyword">configurations</span>.implRuntime<br>&#125;<br><br>jar &#123;<br>    <span class="hljs-keyword">from</span> <span class="hljs-keyword">sourceSets</span>.api.output<br>    <span class="hljs-keyword">from</span> <span class="hljs-keyword">sourceSets</span>.impl.output<br>&#125;<br><br><span class="hljs-comment">// this step is necessary when installing both jars in the local maven repository</span><br>install &#123;<br>    <span class="hljs-keyword">repositories</span>.mavenInstaller &#123;<br>addFilter(<span class="hljs-string">&#x27;api&#x27;</span>) &#123; artifact, <span class="hljs-keyword">file</span> -&gt; artifact.name.endsWith(<span class="hljs-string">&#x27;api&#x27;</span>) &#125;<br>addFilter(<span class="hljs-string">&#x27;impl&#x27;</span>) &#123; artifact, <span class="hljs-keyword">file</span> -&gt; artifact.name.endsWith(<span class="hljs-string">&#x27;impl&#x27;</span>) &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="3-打包和发布"><a href="#3-打包和发布" class="headerlink" title="3.打包和发布"></a>3.打包和发布</h1><h2 id="3-1公开库"><a href="#3-1公开库" class="headerlink" title="3.1公开库"></a>3.1公开库</h2><h2 id="3-2私有库"><a href="#3-2私有库" class="headerlink" title="3.2私有库"></a>3.2私有库</h2><h3 id="3-2-1-总览-以私有库为例"><a href="#3-2-1-总览-以私有库为例" class="headerlink" title="3.2.1 总览-以私有库为例"></a>3.2.1 总览-以私有库为例</h3><ol><li><p>使用github账号登录Jitpack，点击settings</p></li><li><p>输入自己的私有库地址，点击<code>Generate</code>生成SSH keys</p></li><li><p>把jitpack.io生成的ssh-key粘贴到自己的私有工程中，配置访问权限。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">私有库的设置页面，在<span class="hljs-string">&quot;deploy keys&quot;</span>下面点击 “<span class="hljs-built_in">add</span> deploy <span class="hljs-built_in">keys</span>”<br>点击 “<span class="hljs-built_in">add</span> deploy <span class="hljs-built_in">keys</span>”之后，添加key，配置访问权限。<br>不用勾选页面下方的“Allow <span class="hljs-built_in">write</span> access”<br></code></pre></td></tr></table></figure></li><li><p>在github上生成relase,之后在jitpack.io中，查找自己的库，点击Look up出现我们的release版本</p></li></ol><h3 id="3-2-2-setup"><a href="#3-2-2-setup" class="headerlink" title="3.2.2 setup"></a>3.2.2 setup</h3><p>要开始使用私有存储库，您首先需要授予 JitPack 访问权限。打开<a href="https://jitpack.io/private#auth">https://jitpack.io/private</a>并按照以下步骤操作：</p><ol><li><p>单击授权以获取您的个人身份验证令牌。您团队的每个成员都应该获得自己的令牌。</p></li><li><p>将令牌添加到 $HOME/.gradle/gradle.properties：</p><p><code>authToken=AUTHENTICATION_TOKEN</code></p></li><li><p>然后在 build.gradle 中使用 authToken 作为用户名：</p></li></ol><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">repositories</span> &#123;<br>       maven &#123;<br>           url <span class="hljs-string">&quot;https://jitpack.io&quot;</span><br>           credentials &#123; username authToken &#125;<br>       &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>做完这一步，自己就可以不用公开存储库，而是可以直接使用了。</p><p>如果要让其他人可以使用，参考下面的两种分享方法</p><h4 id="问题：按照官网的写法但是使用的时候jitpack-从服务器收到状态代码521-401-403"><a href="#问题：按照官网的写法但是使用的时候jitpack-从服务器收到状态代码521-401-403" class="headerlink" title="问题：按照官网的写法但是使用的时候jitpack -从服务器收到状态代码521/401/403"></a><del><strong>问题</strong>：按照官网的写法但是使用的时候<strong>jitpack -从服务器收到状态代码521/401/403</strong></del></h4><p>因为您在 gradle.properties 中定义了 jitpack 令牌，但您没有将其指向那里，只需复制并粘贴下面在 gradle 属性中使用 jitpack 令牌的代码和应该能正常工作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript">allprojects &#123;<br>repositories &#123;<br>    google()<br>    jcenter()<br>    mavenCentral()<br>    maven &#123; <br>      url <span class="hljs-string">&quot;https://jitpack.io&quot;</span> <br>        credentials &#123; username = project.properties[<span class="hljs-string">&#x27;jitpackToken&#x27;</span>] &#125;<br>    &#125;<br>    maven &#123; url <span class="hljs-string">&#x27;https://maven.microblink.com&#x27;</span> &#125;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-3-公开分享"><a href="#3-2-3-公开分享" class="headerlink" title="3.2.3 公开分享"></a>3.2.3 公开分享</h3><p>在某些情况下，您希望公开发布您的项目，同时保持源代码的私密性。在这种情况下：</p><ol><li>使用具有推送权限的用户登录</li><li>查找您的私人存储库</li><li>点击设置图标</li><li>单击 Lock 图标以公开此库</li></ol><h3 id="3-2-4-私有分享"><a href="#3-2-4-私有分享" class="headerlink" title="3.2.4 私有分享"></a>3.2.4 私有分享</h3><p>任何对您的 Git 存储库具有读取权限的人都可以下载构建工件。您还可以在 JitPack.io 上添加对构建工件具有读取权限的其他协作者。他们将无权访问源代码。</p><p>添加协作者：</p><ol><li>使用具有推送权限的用户登录</li><li>查找您的私人存储库</li><li>点击设置</li><li>添加合作者 GitHub 用户名</li></ol><p>合作者需要登录 JitPack.io 以获得他们自己的身份验证令牌。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="说没有gradle-wrapper"><a href="#说没有gradle-wrapper" class="headerlink" title="说没有gradle-wrapper"></a>说没有gradle-wrapper</h2><p>这个文件是gradle的包装，在不同的环境下不同的gradle版本中确保编译顺利，所以，版本库里不能把他忽略。</p><p>如果git的忽略文件中的规则把他忽略了（比如忽略文件中的规则 ：  *.jar），可以使用<code>git add -f gradle-wrapper.jar </code>强制添加</p><h2 id="Entry-META-INF-DownloadEngine-kotlin-module-is-a-duplicate-but-no-duplicate-handling-strategy-has-been-set"><a href="#Entry-META-INF-DownloadEngine-kotlin-module-is-a-duplicate-but-no-duplicate-handling-strategy-has-been-set" class="headerlink" title="Entry META-INF/DownloadEngine.kotlin_module is a duplicate but no duplicate handling strategy has been set."></a>Entry META-INF/DownloadEngine.kotlin_module is a duplicate but no duplicate handling strategy has been set.</h2><ul><li>Try adding this to your build.gradle . in packagingOptions:</li></ul><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs puppet"><span class="hljs-keyword">packagingOptions</span> &#123;<br>    ...<br>    <span class="hljs-literal">exclude</span> <span class="hljs-string">&#x27;META-INF/rxkotlin.properties&#x27;</span><br>    <span class="hljs-literal">exclude</span> <span class="hljs-string">&#x27;META-INF/rxkotlin_main.kotlin_module&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>Looks like a cache error (with kotlin) to me. Running <code>gradle clean</code> or <code>gradle clear</code> (not sure which is the right spelling, sorry, one of these should exist as a gradle task) and rebuilding should fix the error, because all files in cache will be deleted by the task and regenerated by the project build.</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">./gradlew <span class="hljs-built_in">clean</span><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>gradle</tag>
      
      <tag>打包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kotlin by 关键字</title>
    <link href="/posts/554224d6/"/>
    <url>/posts/554224d6/</url>
    
    <content type="html"><![CDATA[<p>本篇文章来自willwaywang6的投稿，文章详细分析了Kotlin中by关键字，相信会对大家有所帮助！同时也感谢作者贡献的精彩文章。</p><p>willwaywang6的博客地址：</p><blockquote><p><a href="https://blog.csdn.net/willway_wang">https://blog.csdn.net/willway_wang</a></p></blockquote><p>/  前言  /</p><p>Kotlin 中的 by 关键字在 Java 中是没有的，这使我对它感到非常陌生。</p><p>Kotlin 中为什么要新增 by 关键字呢？by 关键字在 Kotlin 中是如何使用的？</p><p>本文会介绍 by 关键字的使用分类，具体的示例，Kotlin 内置的 by 使用，希望能够帮助到大家。</p><p>by 关键字的使用分为两种：<strong>类委托</strong>和<strong>委托属性</strong>。</p><p>/  类委托  /</p><p>现在有一个需求，统计向一个 HashSet 尝试添加元素的尝试次数，该怎么实现？</p><h3 id="使用继承方式实现"><a href="#使用继承方式实现" class="headerlink" title="使用继承方式实现"></a><strong>使用继承方式实现</strong></h3><p>简单，<strong>继承</strong>一个 HashSet，创建一个变量，负责统计尝试添加元素的个数，代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CountingSet1</span>&lt;<span class="hljs-type">T</span>&gt;: <span class="hljs-type">HashSet</span>&lt;<span class="hljs-type">T</span>&gt;</span>() &#123;<br><br>    <span class="hljs-keyword">var</span> objectAdded = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">add</span><span class="hljs-params">(element: <span class="hljs-type">T</span>)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>        objectAdded++<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.add(element)<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">addAll</span><span class="hljs-params">(elements: <span class="hljs-type">Collection</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>        <span class="hljs-comment">// 因为 super.addAll 内部调用了 add 方法，所以这里不必统计添加个数了。</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.addAll(elements)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> cset = CountingSet1&lt;<span class="hljs-built_in">Int</span>&gt;()<br>    cset.add(<span class="hljs-number">1</span>)<br>    cset.addAll(listOf(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>))<br>    println(<span class="hljs-string">&quot;<span class="hljs-subst">$&#123;cset.objectAdded&#125;</span> objects were added, <span class="hljs-subst">$&#123;cset.size&#125;</span> remain&quot;</span>)<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">打印如下：</span><br><span class="hljs-comment">4 objects were added, 3 remain</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>需求是满足了。</p><p>但是这样的实现，CountingSet1 和 HashSet 的具体实现是高度耦合的，也就是说，CountingSet1 严重依赖于 HashSet 类的实现细节。</p><p><strong>这有什么问题吗？</strong></p><p>当基类的实现被修改或者新的方法被添加进去时，可能改变之前进行继承时的类行为，从而导致子类的行为不符合预期。</p><p>当某个类是 final 类时，它是不可以被继承的，这时就不能采用继承的方式来复用它的代码了。</p><p><strong>那我们该怎么办呢？</strong></p><p>想一下，我们新建的类无非是想复用 HashSet的功能，前面我们是采用继承的方式，除了采用继承的方式之外，我们还可以采用组合的方式。</p><p>实际上，在 《Java编程思想》中有写道：</p><blockquote><p>由于继承在面向对象程序设计中如此重要，所以它经常被高度强调，于是程序员新手就会有这样的印象：处处都应该使用继承。这会导致难以使用并过分复杂的设计。<strong>实际上，在建立新类时，应该优先考虑组合，因为它更加简单灵活。</strong>如果采用这种方式，设计会变得更加清晰。</p></blockquote><h3 id="使用组合方式实现"><a href="#使用组合方式实现" class="headerlink" title="使用组合方式实现"></a><strong>使用组合方式实现</strong></h3><p>使用<strong>组合</strong>方式实现如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CountingSet2</span>&lt;<span class="hljs-type">T</span>&gt; : <span class="hljs-type">MutableSet</span>&lt;<span class="hljs-type">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> innerSet = HashSet&lt;T&gt;()<br>    <span class="hljs-keyword">var</span> objectAdded = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">add</span><span class="hljs-params">(element: <span class="hljs-type">T</span>)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>        objectAdded++<br>        <span class="hljs-keyword">return</span> innerSet.add(element)<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">addAll</span><span class="hljs-params">(elements: <span class="hljs-type">Collection</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>        objectAdded += elements.size<br>        <span class="hljs-keyword">return</span> innerSet.addAll(elements)<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span> &#123;<br>        innerSet.clear()<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">iterator</span><span class="hljs-params">()</span></span>: MutableIterator&lt;T&gt; &#123;<br>        <span class="hljs-keyword">return</span> innerSet.iterator()<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">remove</span><span class="hljs-params">(element: <span class="hljs-type">T</span>)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>        <span class="hljs-keyword">return</span> innerSet.remove(element)<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">removeAll</span><span class="hljs-params">(elements: <span class="hljs-type">Collection</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>        <span class="hljs-keyword">return</span> innerSet.removeAll(elements)<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">retainAll</span><span class="hljs-params">(elements: <span class="hljs-type">Collection</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>        <span class="hljs-keyword">return</span> innerSet.retainAll(elements)<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> size: <span class="hljs-built_in">Int</span><br>        <span class="hljs-keyword">get</span>() = innerSet.size<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">contains</span><span class="hljs-params">(element: <span class="hljs-type">T</span>)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>        <span class="hljs-keyword">return</span> innerSet.contains(element)<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">containsAll</span><span class="hljs-params">(elements: <span class="hljs-type">Collection</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>        <span class="hljs-keyword">return</span> innerSet.containsAll(elements)<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>        <span class="hljs-keyword">return</span> innerSet.isEmpty()<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> cset = CountingSet2&lt;<span class="hljs-built_in">Int</span>&gt;()<br>    cset.add(<span class="hljs-number">1</span>)<br>    cset.addAll(listOf(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>))<br>    println(<span class="hljs-string">&quot;<span class="hljs-subst">$&#123;cset.objectAdded&#125;</span> objects were added, <span class="hljs-subst">$&#123;cset.size&#125;</span> remain&quot;</span>)<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">打印如下：</span><br><span class="hljs-comment">4 objects were added, 3 remain</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>同样实现了需求。</p><p>可以看到，CountingSet2 实现了 MutableSet 接口，具体的实现是委托给了 innerSet 来完成的。</p><p><strong>这有什么好处呢？</strong></p><p>CountingSet2 与 HashSet 不再耦合了，它们都实现了 MutableSet 接口。</p><p>这种方式从代码设计上看确实好，但是却需要非常多的模板代码，这点很烦人啊。</p><h3 id="使用类委托实现"><a href="#使用类委托实现" class="headerlink" title="使用类委托实现"></a><strong>使用类委托实现</strong></h3><p>现在就该 Kotlin 的类委托出场了，它可以解决需要写非常多的模板代码的问题。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CountingSet3</span>&lt;<span class="hljs-type">T</span>&gt;</span>(<br>    <span class="hljs-keyword">val</span> innerSet: MutableSet&lt;T&gt; = HashSet&lt;T&gt;()<br>) : MutableSet&lt;T&gt; <span class="hljs-keyword">by</span> innerSet &#123;<br>    <span class="hljs-keyword">var</span> objectAdded = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">add</span><span class="hljs-params">(element: <span class="hljs-type">T</span>)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>        objectAdded++<br>        <span class="hljs-keyword">return</span> innerSet.add(element)<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">addAll</span><span class="hljs-params">(elements: <span class="hljs-type">Collection</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>        objectAdded += elements.size<br>        <span class="hljs-keyword">return</span> innerSet.addAll(elements)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> cset = CountingSet3&lt;<span class="hljs-built_in">Int</span>&gt;()<br>    cset.add(<span class="hljs-number">1</span>)<br>    cset.addAll(listOf(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>))<br>    println(<span class="hljs-string">&quot;<span class="hljs-subst">$&#123;cset.objectAdded&#125;</span> objects were added, <span class="hljs-subst">$&#123;cset.size&#125;</span> remain&quot;</span>)<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">打印如下：</span><br><span class="hljs-comment">4 objects were added, 3 remain</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>完美实现了需求。</p><p>Kotlin 是如何帮我们减少了模板代码了呢？</p><p>使用 Android Studio 的 Tools -&gt; Kotlin -&gt; Show Kotlin Bytecode，再点击 Decompile 按钮，查看对应的 Java 代码：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> final <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CountingSet3</span> <span class="hljs-title">implements</span> <span class="hljs-title">Set</span>, <span class="hljs-title">KMutableSet</span> </span>&#123;<br>   <span class="hljs-keyword">private</span> int objectAdded;<br>   <span class="hljs-meta">@NotNull</span><br>   <span class="hljs-keyword">private</span> final <span class="hljs-built_in">Set</span> innerSet;<br><br>   <span class="hljs-keyword">public</span> final int <span class="hljs-function"><span class="hljs-title">getObjectAdded</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.objectAdded;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> final <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">setObjectAdded</span>(<span class="hljs-params">int var1</span>)</span> &#123;<br>      <span class="hljs-built_in">this</span>.objectAdded = var1;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-function"><span class="hljs-title">add</span>(<span class="hljs-params"><span class="hljs-built_in">Object</span> element</span>)</span> &#123;<br>      int var10001 = <span class="hljs-built_in">this</span>.objectAdded++;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.innerSet.add(element);<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-function"><span class="hljs-title">addAll</span>(<span class="hljs-params"><span class="hljs-meta">@NotNull</span> Collection elements</span>)</span> &#123;<br>      Intrinsics.checkNotNullParameter(elements, <span class="hljs-string">&quot;elements&quot;</span>);<br>      <span class="hljs-built_in">this</span>.objectAdded += elements.size();<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.innerSet.addAll(elements);<br>   &#125;<br><br>   <span class="hljs-meta">@NotNull</span><br>   <span class="hljs-keyword">public</span> final <span class="hljs-built_in">Set</span> <span class="hljs-function"><span class="hljs-title">getInnerSet</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.innerSet;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">CountingSet3</span>(<span class="hljs-params"><span class="hljs-meta">@NotNull</span> <span class="hljs-built_in">Set</span> innerSet</span>)</span> &#123;<br>      Intrinsics.checkNotNullParameter(innerSet, <span class="hljs-string">&quot;innerSet&quot;</span>);<br>      <span class="hljs-built_in">super</span>();<br>      <span class="hljs-built_in">this</span>.innerSet = innerSet;<br>   &#125;<br><br>   <span class="hljs-comment">// $FF: synthetic method</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">CountingSet3</span>(<span class="hljs-params"><span class="hljs-built_in">Set</span> var1, int var2, DefaultConstructorMarker var3</span>)</span> &#123;<br>      <span class="hljs-keyword">if</span> ((var2 &amp; <span class="hljs-number">1</span>) != <span class="hljs-number">0</span>) &#123;<br>         var1 = (<span class="hljs-built_in">Set</span>)(<span class="hljs-keyword">new</span> HashSet());<br>      &#125;<br><br>      <span class="hljs-built_in">this</span>(var1);<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">CountingSet3</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-built_in">this</span>((<span class="hljs-built_in">Set</span>)<span class="hljs-literal">null</span>, <span class="hljs-number">1</span>, (DefaultConstructorMarker)<span class="hljs-literal">null</span>);<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> int <span class="hljs-function"><span class="hljs-title">getSize</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.innerSet.size();<br>   &#125;<br><br>   <span class="hljs-comment">// $FF: bridge method</span><br>   <span class="hljs-keyword">public</span> final int <span class="hljs-function"><span class="hljs-title">size</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.getSize();<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">clear</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-built_in">this</span>.innerSet.clear();<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-function"><span class="hljs-title">contains</span>(<span class="hljs-params"><span class="hljs-built_in">Object</span> element</span>)</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.innerSet.contains(element);<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-function"><span class="hljs-title">containsAll</span>(<span class="hljs-params"><span class="hljs-meta">@NotNull</span> Collection elements</span>)</span> &#123;<br>      Intrinsics.checkNotNullParameter(elements, <span class="hljs-string">&quot;elements&quot;</span>);<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.innerSet.containsAll(elements);<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-function"><span class="hljs-title">isEmpty</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.innerSet.isEmpty();<br>   &#125;<br><br>   <span class="hljs-meta">@NotNull</span><br>   <span class="hljs-keyword">public</span> Iterator <span class="hljs-function"><span class="hljs-title">iterator</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.innerSet.iterator();<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-function"><span class="hljs-title">remove</span>(<span class="hljs-params"><span class="hljs-built_in">Object</span> element</span>)</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.innerSet.remove(element);<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-function"><span class="hljs-title">removeAll</span>(<span class="hljs-params"><span class="hljs-meta">@NotNull</span> Collection elements</span>)</span> &#123;<br>      Intrinsics.checkNotNullParameter(elements, <span class="hljs-string">&quot;elements&quot;</span>);<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.innerSet.removeAll(elements);<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-function"><span class="hljs-title">retainAll</span>(<span class="hljs-params"><span class="hljs-meta">@NotNull</span> Collection elements</span>)</span> &#123;<br>      Intrinsics.checkNotNullParameter(elements, <span class="hljs-string">&quot;elements&quot;</span>);<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.innerSet.retainAll(elements);<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">Object</span>[] <span class="hljs-function"><span class="hljs-title">toArray</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-keyword">return</span> CollectionToArray.toArray(<span class="hljs-built_in">this</span>);<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">Object</span>[] <span class="hljs-function"><span class="hljs-title">toArray</span>(<span class="hljs-params"><span class="hljs-built_in">Object</span>[] var1</span>)</span> &#123;<br>      <span class="hljs-keyword">return</span> CollectionToArray.toArray(<span class="hljs-built_in">this</span>, var1);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这不就是 CountingSet2 的代码吗？</p><p>原来 Kotlin 的编译器默默地帮我们生成了这些模板代码，而仅仅要求我们通过声明并初始化一个 HashSet 类型的成员变量，并在类声明后添加 by innerSet：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">CountingSet3</span>&lt;<span class="hljs-symbol">T</span>&gt;(<br>    <span class="hljs-symbol">val</span> <span class="hljs-symbol">innerSet: <span class="hljs-symbol">MutableSet</span></span>&lt;<span class="hljs-symbol">T</span>&gt; = <span class="hljs-symbol">HashSet</span>&lt;<span class="hljs-symbol">T</span>&gt;()<br>) : <span class="hljs-symbol">MutableSet</span>&lt;<span class="hljs-symbol">T</span>&gt; <span class="hljs-symbol">by</span> <span class="hljs-symbol">innerSet</span> &#123;<br></code></pre></td></tr></table></figure><p>需要注意的是：</p><ul><li>CountingSet3 必须实现一个接口，而不能继承于一个类；</li><li>innerSet 的类型必须是 CountingSet3 所实现接口的子类型；</li><li>可以直接在 by 创建委托对象，如下所示：</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">CountingSet4</span>&lt;<span class="hljs-symbol">T</span>&gt;(<br>) : <span class="hljs-symbol">MutableSet</span>&lt;<span class="hljs-symbol">T</span>&gt; <span class="hljs-symbol">by</span> <span class="hljs-symbol">HashSet</span>&lt;<span class="hljs-symbol">T</span>&gt;() &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是，这样的话，在 CountingSet4 类中无法获取到委托对象的引用了。</p><p>Kotlin 的类委托虽然看起来很简洁，但是它自身又有一些限制：类必须实现一个接口，委托类必须是类所实现接口的子类型。这是需要注意的。</p><p>同时，我们在实际开发中，<strong>要尽力去使用这种委托的思想，来使代码解耦，使代码更加清晰</strong>。这一点，比掌握 Kotlin 的类委托更加重要。</p><p>/  委托属性  /</p><p>委托属性是一个依赖于约定的功能，也是Kotlin 中最独特和最强大的功能之一。</p><p>本部分我们仍然是从一个小例子开始，展示一下委托属性的使用，作用；然后，会说明委托属性的一些特点以及其他使用。</p><p>需求：现在有一个简单的 Person 类：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person2</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> name: <span class="hljs-built_in">String</span> = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">var</span> lastname: <span class="hljs-built_in">String</span> = <span class="hljs-string">&quot;&quot;</span>  <br>&#125;<br></code></pre></td></tr></table></figure><p>需要对 name 和 lastname 赋值时，做一些格式化工作：首字母大写其余字母小写，并统计格式化操作的次数，再获取 name 和 lastname 值的时候，把它们的值的长度拼接在值得后面返回。</p><h3 id="仅仅完成需求的代码"><a href="#仅仅完成需求的代码" class="headerlink" title="仅仅完成需求的代码"></a><strong>仅仅完成需求的代码</strong></h3><p>这不难，代码实现如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person2</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> name: String = <span class="hljs-string">&quot;&quot;</span><br>        <span class="hljs-keyword">set</span>(value) &#123;<br>            field = value.lowercase().replaceFirstChar &#123; it.uppercase() &#125;<br>            updateCount++<br>        &#125;<br>        <span class="hljs-keyword">get</span>() &#123;<br>            <span class="hljs-keyword">return</span> field + <span class="hljs-string">&quot;-&quot;</span> + field.length<br>        &#125;<br><br>    <span class="hljs-keyword">var</span> lastname: String = <span class="hljs-string">&quot;&quot;</span><br>        <span class="hljs-keyword">set</span>(value) &#123;<br>            field = value.lowercase().replaceFirstChar &#123; it.uppercase() &#125;<br>            updateCount++<br>        &#125;<br>        <span class="hljs-keyword">get</span>() &#123;<br>            <span class="hljs-keyword">return</span> field + <span class="hljs-string">&quot;-&quot;</span> + field.length<br>        &#125;<br>    <span class="hljs-keyword">var</span> updateCount = <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> person2 = Person2()<br>    person2.name = <span class="hljs-string">&quot;peter&quot;</span><br>    person2.lastname = <span class="hljs-string">&quot;wang&quot;</span><br>    println(<span class="hljs-string">&quot;name=<span class="hljs-subst">$&#123;person2.name&#125;</span>&quot;</span>)<br>    println(<span class="hljs-string">&quot;lastname=<span class="hljs-subst">$&#123;person2.lastname&#125;</span>&quot;</span>)<br>    println(<span class="hljs-string">&quot;updateCount=<span class="hljs-subst">$&#123;person2.updateCount&#125;</span>&quot;</span>)<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">打印日志：</span><br><span class="hljs-comment">name=Peter-5</span><br><span class="hljs-comment">lastname=Wang-4</span><br><span class="hljs-comment">updateCount=2</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>ps：这里面使用 Kotlin 中的支持字段 field ，需要学习可以查看笔者的这篇文章：<strong>Kotlin 的 Backing Fields 和 Backing Properties</strong>（<a href="https://blog.csdn.net/willway_wang/article/details/100184784%EF%BC%89%E3%80%82">https://blog.csdn.net/willway_wang/article/details/100184784）。</a></p><p>OK，查看日志，可以看到需求实现了。</p><h3 id="抽取重复代码为方法"><a href="#抽取重复代码为方法" class="headerlink" title="抽取重复代码为方法"></a><strong>抽取重复代码为方法</strong></h3><p>但是，这里面有着重复的代码，并且如果其他类也需要这样的格式化操作，这些代码也不可以复用。</p><p>为了提供代码复用性，我们可以把代码抽取出来，放在一个方法里面。代码实现如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person3</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> name: String = <span class="hljs-string">&quot;&quot;</span><br>        <span class="hljs-keyword">set</span>(value) &#123;<br>            field = format(value)<br>        &#125;<br>        <span class="hljs-keyword">get</span>() &#123;<br>            <span class="hljs-keyword">return</span> getter(field)<br>        &#125;<br><br>    <span class="hljs-keyword">var</span> lastname: String = <span class="hljs-string">&quot;&quot;</span><br>        <span class="hljs-keyword">set</span>(value) &#123;<br>            field = format(value)<br>        &#125;<br>        <span class="hljs-keyword">get</span>() &#123;<br>            <span class="hljs-keyword">return</span> getter(field)<br>        &#125;<br>    <span class="hljs-keyword">var</span> updateCount = <span class="hljs-number">0</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">format</span><span class="hljs-params">(value: <span class="hljs-type">String</span>)</span></span>: String &#123;<br>        updateCount++<br>        <span class="hljs-keyword">return</span> value.lowercase().replaceFirstChar &#123; it.uppercase() &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getter</span><span class="hljs-params">(value: <span class="hljs-type">String</span>)</span></span>: String &#123;<br>        <span class="hljs-keyword">return</span> value + <span class="hljs-string">&quot;-&quot;</span> + value.length<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> person = Person3()<br>    person.name = <span class="hljs-string">&quot;peter&quot;</span><br>    person.lastname = <span class="hljs-string">&quot;wang&quot;</span><br>    println(<span class="hljs-string">&quot;name=<span class="hljs-subst">$&#123;person.name&#125;</span>&quot;</span>)<br>    println(<span class="hljs-string">&quot;lastname=<span class="hljs-subst">$&#123;person.lastname&#125;</span>&quot;</span>)<br>    println(<span class="hljs-string">&quot;updateCount=<span class="hljs-subst">$&#123;person.updateCount&#125;</span>&quot;</span>)<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">name=Peter-5</span><br><span class="hljs-comment">lastname=Wang-4</span><br><span class="hljs-comment">updateCount=2</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>查看日志打印，这样做可以实现需求。</p><h3 id="使用类来封装重复代码"><a href="#使用类来封装重复代码" class="headerlink" title="使用类来封装重复代码"></a><strong>使用类来封装重复代码</strong></h3><p>现在需求又来了，有一个 Student 类：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> name: <span class="hljs-built_in">String</span> = <span class="hljs-string">&quot;&quot;</span><br><br>    <span class="hljs-keyword">var</span> address: <span class="hljs-built_in">String</span> = <span class="hljs-string">&quot;&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>也需要对属性做同样的格式化操作并统计进行格式化操作的次数，在获取值的时候把长度拼接在后面。</p><p>这时，我们可以使用面向对象的思想来解决，把 format 方法和 getter 方法封装在一个类里面：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Delegate</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">format</span><span class="hljs-params">(thisRef: <span class="hljs-type">Any</span>, value: <span class="hljs-type">String</span>)</span></span>: String &#123;<br>        <span class="hljs-keyword">if</span> (thisRef <span class="hljs-keyword">is</span> Person4) &#123;<br>            thisRef.updateCount++<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (thisRef <span class="hljs-keyword">is</span> Student2) &#123;<br>            thisRef.updateCount++<br>        &#125;<br>        <span class="hljs-keyword">return</span> value.lowercase().replaceFirstChar &#123; it.uppercase() &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getter</span><span class="hljs-params">(value: <span class="hljs-type">String</span>)</span></span>: String &#123;<br>        <span class="hljs-keyword">return</span> value + <span class="hljs-string">&quot;-&quot;</span> + value.length<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Person 类修改如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person4</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> val delegate = Delegate()<br><br>    <span class="hljs-keyword">var</span> name: <span class="hljs-built_in">String</span> = <span class="hljs-string">&quot;&quot;</span><br>        <span class="hljs-function"><span class="hljs-title">set</span>(<span class="hljs-params">value</span>)</span> &#123;<br>            field = delegate.format(<span class="hljs-built_in">this</span>, value)<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params"></span>)</span> &#123;<br>            <span class="hljs-keyword">return</span> delegate.getter(field)<br>        &#125;<br><br>    <span class="hljs-keyword">var</span> lastname: <span class="hljs-built_in">String</span> = <span class="hljs-string">&quot;&quot;</span><br>        <span class="hljs-function"><span class="hljs-title">set</span>(<span class="hljs-params">value</span>)</span> &#123;<br>            field = delegate.format(<span class="hljs-built_in">this</span>, value)<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params"></span>)</span> &#123;<br>            <span class="hljs-keyword">return</span> delegate.getter(field)<br>        &#125;<br><br>    <span class="hljs-keyword">var</span> updateCount = <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Student 类修改如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student2</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> val delegate = Delegate()<br><br>    <span class="hljs-keyword">var</span> name: <span class="hljs-built_in">String</span> = <span class="hljs-string">&quot;&quot;</span><br>        <span class="hljs-function"><span class="hljs-title">set</span>(<span class="hljs-params">value</span>)</span> &#123;<br>            field = delegate.format(<span class="hljs-built_in">this</span>, value)<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params"></span>)</span> &#123;<br>            <span class="hljs-keyword">return</span> delegate.getter(field)<br>        &#125;<br>    <span class="hljs-keyword">var</span> address: <span class="hljs-built_in">String</span> = <span class="hljs-string">&quot;&quot;</span><br>        <span class="hljs-function"><span class="hljs-title">set</span>(<span class="hljs-params">value</span>)</span> &#123;<br>            field = delegate.format(<span class="hljs-built_in">this</span>, value)<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params"></span>)</span> &#123;<br>            <span class="hljs-keyword">return</span> delegate.getter(field)<br>        &#125;<br>    <span class="hljs-keyword">var</span> updateCount = <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="把值的存储委托给委托类处理"><a href="#把值的存储委托给委托类处理" class="headerlink" title="把值的存储委托给委托类处理"></a><strong>把值的存储委托给委托类处理</strong></h3><p>既然 getter 和 setter 方法都委托给 Delegate 类来实现，我们何不把值也交给 Delegate 类来存储呢？</p><p>如果把 name 和 lastname 的值存在 Delegate 里面的话，它们就不可以共用一个 Delegate 对象了。</p><p>然后，Delegate 类两个方法的作用就是设置和获取值，所以方法也需要改一下。对吧？</p><p>修改 Delegate 类为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Delegate2</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> formattedString: String = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setValue</span><span class="hljs-params">(thisRef: <span class="hljs-type">Any</span>, value: <span class="hljs-type">String</span>)</span></span> &#123;<br>        <span class="hljs-keyword">if</span> (thisRef <span class="hljs-keyword">is</span> Person5) &#123;<br>            thisRef.updateCount++<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (thisRef <span class="hljs-keyword">is</span> Student2) &#123;<br>            thisRef.updateCount++<br>        &#125;<br>        formattedString = value.lowercase().replaceFirstChar &#123; it.uppercase() &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span></span>: String &#123;<br>        <span class="hljs-keyword">return</span> formattedString + <span class="hljs-string">&quot;-&quot;</span> + formattedString.length<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>修改 Person 类为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person5</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> nameDelegate = Delegate2()<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> lastnameDelegate = Delegate2()<br>    <span class="hljs-keyword">var</span> name: String<br>        <span class="hljs-keyword">set</span>(value) &#123;<br>            nameDelegate.setValue(<span class="hljs-keyword">this</span>, value)<br>        &#125;<br>        <span class="hljs-keyword">get</span>() &#123;<br>            <span class="hljs-keyword">return</span> nameDelegate.getValue()<br>        &#125;<br><br>    <span class="hljs-keyword">var</span> lastname: String<br>        <span class="hljs-keyword">set</span>(value) &#123;<br>            lastnameDelegate.setValue(<span class="hljs-keyword">this</span>, value)<br>        &#125;<br>        <span class="hljs-keyword">get</span>() &#123;<br>            <span class="hljs-keyword">return</span> lastnameDelegate.getValue()<br>        &#125;<br>    <span class="hljs-keyword">var</span> updateCount = <span class="hljs-number">0</span><br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">打印日志：</span><br><span class="hljs-comment">name=Peter-5</span><br><span class="hljs-comment">lastname=Wang-4</span><br><span class="hljs-comment">updateCount=2</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>到这里，需要强调的是，Person5 里的 name 和 lastname 不具有存储值的功能了，它们是自定义了 setter 和 getter 的属性。</p><h3 id="使用-Kotlin-的委托属性来简化代码"><a href="#使用-Kotlin-的委托属性来简化代码" class="headerlink" title="使用 Kotlin 的委托属性来简化代码"></a><strong>使用 Kotlin 的委托属性来简化代码</strong></h3><p>对于上面的代码实现，我们仍然感到有些累赘，不简洁。</p><p>Kotlin 的委托属性可以帮我们解决这些烦恼。</p><p>委托属性的基本语法是这样的：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">class Foo &#123;<br>    <span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">p</span>: Type by <span class="hljs-built_in">Delegate</span>()<br>&#125;<br></code></pre></td></tr></table></figure><p>等价于</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> &#123;<br>    <span class="hljs-keyword">private</span> val <span class="hljs-built_in">delegate</span> = Delegate()<br>    <span class="hljs-keyword">var</span> p: <span class="hljs-function">Type</span><br><span class="hljs-function">        <span class="hljs-title">set</span>(<span class="hljs-params"><span class="hljs-keyword">value</span>: Type</span>)</span> = <span class="hljs-built_in">delegate</span>.setValue(<span class="hljs-keyword">this</span>, ..., <span class="hljs-keyword">value</span>)<br>        <span class="hljs-keyword">get</span>() = <span class="hljs-built_in">delegate</span>.getValue(<span class="hljs-keyword">this</span>, ...)<br>&#125;<br></code></pre></td></tr></table></figure><p>属性 p 将它的访问器逻辑委托给 Delegate 这个辅助对象来处理。</p><p>by 关键字的作用是对它后面的表达式求值来获取这个对象，在这里就是获取到了 Delegate 对象。</p><p>编译器会创建一个隐藏的辅助属性，并使用委托对象的实例对它进行初始化，在这里就是把 Delegate 对象赋值给了 delegate 属性。</p><p>那么，Kotlin 是如何知道把属性 p 的 setter 逻辑委托给辅助对象 delegate 的哪个方法，把属性 p 的 getter 逻辑委托给辅助对象 delegate 的哪个方法呢？</p><p>这里就要说到<strong>约定</strong>的概念了，委托类必须具有 getValue 和 setValue 方法（如果是可变属性的话），定义在 ReadWriteProperty 接口里：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-keyword">interface</span> ReadOnlyProperty<span class="hljs-type">&lt;in T, out V&gt;</span> &#123;</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getValue</span><span class="hljs-params">(thisRef: <span class="hljs-type">T</span>, property: <span class="hljs-type">KProperty</span>&lt;*&gt;)</span></span>: V<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ReadWriteProperty</span>&lt;<span class="hljs-type">in T, V</span>&gt; : <span class="hljs-type">ReadOnlyProperty</span>&lt;<span class="hljs-type">T, V</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getValue</span><span class="hljs-params">(thisRef: <span class="hljs-type">T</span>, property: <span class="hljs-type">KProperty</span>&lt;*&gt;)</span></span>: V<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setValue</span><span class="hljs-params">(thisRef: <span class="hljs-type">T</span>, property: <span class="hljs-type">KProperty</span>&lt;*&gt;, value: <span class="hljs-type">V</span>)</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>当对 Foo 对象的 p 属性赋值时，会调用 Delegate 对象的 setValue 方法，设置对应的值；</p><p>当获取 Foo 对象的 p 的值时，会调用 Delegate 对象的 getValue 方法，获取对应的值。</p><p>修改委托类为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Delegate3</span> : <span class="hljs-type">ReadWriteProperty</span>&lt;<span class="hljs-type">Any, String</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">var</span> formattedString = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getValue</span><span class="hljs-params">(thisRef: <span class="hljs-type">Any</span>, property: <span class="hljs-type">KProperty</span>&lt;*&gt;)</span></span>: String &#123;<br>        <span class="hljs-keyword">return</span> formattedString + <span class="hljs-string">&quot;-&quot;</span> + formattedString.length<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setValue</span><span class="hljs-params">(thisRef: <span class="hljs-type">Any</span>, property: <span class="hljs-type">KProperty</span>&lt;*&gt;, value: <span class="hljs-type">String</span>)</span></span> &#123;<br>        <span class="hljs-keyword">if</span> (thisRef <span class="hljs-keyword">is</span> Person6) &#123;<br>            thisRef.updateCount++<br>        &#125;<br>        formattedString = value.lowercase().replaceFirstChar &#123; it.uppercase() &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>修改 Person 类为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person6</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> name: String <span class="hljs-keyword">by</span> Delegate3()<br>    <span class="hljs-keyword">var</span> lastname: String <span class="hljs-keyword">by</span> Delegate3()<br>    <span class="hljs-keyword">var</span> updateCount = <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> person = Person6()<br>    person.name = <span class="hljs-string">&quot;peter&quot;</span><br>    person.lastname = <span class="hljs-string">&quot;wang&quot;</span><br>    println(<span class="hljs-string">&quot;name=<span class="hljs-subst">$&#123;person.name&#125;</span>&quot;</span>)<br>    println(<span class="hljs-string">&quot;lastname=<span class="hljs-subst">$&#123;person.lastname&#125;</span>&quot;</span>)<br>    println(<span class="hljs-string">&quot;updateCount=<span class="hljs-subst">$&#123;person.updateCount&#125;</span>&quot;</span>)<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">打印如下：</span><br><span class="hljs-comment">name=Peter-5</span><br><span class="hljs-comment">lastname=Wang-4</span><br><span class="hljs-comment">updateCount=2</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>OK，完美符合需求。</p><p>使用 Android Studio 的 Tools -&gt; Kotlin -&gt; Show Kotlin Bytecode，再点击 Decompile 按钮，查看 Delegate3 和 Person6 对应的 Java 代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Delegate3</span> <span class="hljs-title">implements</span> <span class="hljs-title">ReadWriteProperty</span> </span>&#123;<br>   <span class="hljs-meta">@NotNull</span><br>   <span class="hljs-keyword">private</span> String formattedString = <span class="hljs-string">&quot;&quot;</span>;<br><br>   <span class="hljs-meta">@NotNull</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String getFormattedString() &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.formattedString;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> void setFormattedString(<span class="hljs-meta">@NotNull</span> String var1) &#123;<br>      <span class="hljs-keyword">this</span>.formattedString = var1;<br>   &#125;<br><br>   <span class="hljs-meta">@NotNull</span><br>   <span class="hljs-keyword">public</span> String getValue(<span class="hljs-meta">@NotNull</span> Object thisRef, <span class="hljs-meta">@NotNull</span> KProperty property) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.formattedString + <span class="hljs-string">&quot;-&quot;</span> + <span class="hljs-keyword">this</span>.formattedString.length();<br>   &#125;<br><br>   <span class="hljs-comment">// $FF: synthetic method</span><br>   <span class="hljs-comment">// $FF: bridge method</span><br>   <span class="hljs-keyword">public</span> Object getValue(Object var1, KProperty var2) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getValue(var1, var2);<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> void setValue(<span class="hljs-meta">@NotNull</span> Object thisRef, <span class="hljs-meta">@NotNull</span> KProperty property, <span class="hljs-meta">@NotNull</span> String value) &#123;<br>      <span class="hljs-keyword">if</span> (thisRef instanceof Person6) &#123;<br>         ((Person6)thisRef).setUpdateCount(((Person6)thisRef).getUpdateCount() + <span class="hljs-number">1</span>);<br>      &#125;<br><br>      Delegate3 var10000 = <span class="hljs-keyword">this</span>;<br>      boolean var5 = <span class="hljs-literal">false</span>;<br>      String var10001 = value.toLowerCase(Locale.ROOT);<br>      Intrinsics.checkNotNullExpressionValue(var10001, <span class="hljs-string">&quot;(this as java.lang.Strin….toLowerCase(Locale.ROOT)&quot;</span>);<br>      String var4 = var10001;<br>      var5 = <span class="hljs-literal">false</span>;<br>      CharSequence var6 = (CharSequence)var4;<br>      boolean var7 = <span class="hljs-literal">false</span>;<br>      <span class="hljs-keyword">if</span> (var6.length() &gt; <span class="hljs-number">0</span>) &#123;<br>         StringBuilder var20 = new StringBuilder();<br>         char it = var4.charAt(<span class="hljs-number">0</span>);<br>         StringBuilder var15 = var20;<br>         int var9 = <span class="hljs-literal">false</span>;<br>         boolean var11 = <span class="hljs-literal">false</span>;<br>         String var12 = String.valueOf(it);<br>         boolean var13 = <span class="hljs-literal">false</span>;<br>         <span class="hljs-keyword">if</span> (var12 == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> new NullPointerException(<span class="hljs-string">&quot;null cannot be cast to non-null type java.lang.String&quot;</span>);<br>         &#125;<br><br>         String var19 = var12.toUpperCase(Locale.ROOT);<br>         Intrinsics.checkNotNullExpressionValue(var19, <span class="hljs-string">&quot;(this as java.lang.Strin….toUpperCase(Locale.ROOT)&quot;</span>);<br>         String var16 = var19;<br>         var10000 = <span class="hljs-keyword">this</span>;<br>         var20 = var15.append(var16.toString());<br>         byte var17 = <span class="hljs-number">1</span>;<br>         boolean var18 = <span class="hljs-literal">false</span>;<br>         <span class="hljs-keyword">if</span> (var4 == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> new NullPointerException(<span class="hljs-string">&quot;null cannot be cast to non-null type java.lang.String&quot;</span>);<br>         &#125;<br><br>         String var10002 = var4.substring(var17);<br>         Intrinsics.checkNotNullExpressionValue(var10002, <span class="hljs-string">&quot;(this as java.lang.String).substring(startIndex)&quot;</span>);<br>         var10001 = var20.append(var10002).toString();<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>         var10001 = var4;<br>      &#125;<br><br>      var10000.formattedString = var10001;<br>   &#125;<br><br>   <span class="hljs-comment">// $FF: synthetic method</span><br>   <span class="hljs-comment">// $FF: bridge method</span><br>   <span class="hljs-keyword">public</span> void setValue(Object var1, KProperty var2, Object var3) &#123;<br>      <span class="hljs-keyword">this</span>.setValue(var1, var2, (String)var3);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person6</span> </span>&#123;<br>   <span class="hljs-comment">// $FF: synthetic field</span><br>   static <span class="hljs-keyword">final</span> KProperty[] $$delegatedProperties = new KProperty[]&#123;<br>   (KProperty)Reflection.mutableProperty1(new MutablePropertyReference1Impl(Person6.<span class="hljs-keyword">class</span>, <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;getName()Ljava/lang/String;&quot;</span>, <span class="hljs-number">0</span>)), <br>   (KProperty)Reflection.mutableProperty1(new MutablePropertyReference1Impl(Person6.<span class="hljs-keyword">class</span>, <span class="hljs-string">&quot;lastname&quot;</span>, <span class="hljs-string">&quot;getLastname()Ljava/lang/String;&quot;</span>, <span class="hljs-number">0</span>))&#125;;<br>   <span class="hljs-meta">@NotNull</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Delegate3 name$delegate = new Delegate3();<br>   <span class="hljs-meta">@NotNull</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Delegate3 lastname$delegate = new Delegate3();<br>   <span class="hljs-keyword">private</span> int updateCount;<br><br>   <span class="hljs-meta">@NotNull</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String getName() &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name$delegate.getValue(<span class="hljs-keyword">this</span>, $$delegatedProperties[<span class="hljs-number">0</span>]);<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> void setName(<span class="hljs-meta">@NotNull</span> String var1) &#123;<br>      <span class="hljs-keyword">this</span>.name$delegate.setValue(<span class="hljs-keyword">this</span>, $$delegatedProperties[<span class="hljs-number">0</span>], var1);<br>   &#125;<br><br>   <span class="hljs-meta">@NotNull</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String getLastname() &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.lastname$delegate.getValue(<span class="hljs-keyword">this</span>, $$delegatedProperties[<span class="hljs-number">1</span>]);<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> void setLastname(<span class="hljs-meta">@NotNull</span> String var1) &#123;<br>      <span class="hljs-keyword">this</span>.lastname$delegate.setValue(<span class="hljs-keyword">this</span>, $$delegatedProperties[<span class="hljs-number">1</span>], var1);<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> int getUpdateCount() &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.updateCount;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> void setUpdateCount(int var1) &#123;<br>      <span class="hljs-keyword">this</span>.updateCount = var1;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，这和我们在上一节中写的大致是一样的。</p><p>thisRef 就是发起委托的对象。</p><p>值得注意的是，在 Person6.java 中创建了一个 $$delegatedProperties 对象，它是一个 KProperty 类型的数组，它的元素封装了类，属性名，getter 方法签名等信息，也会传递给委托类，这是用来做什么的？</p><p>本例子中我们确实用不到这些信息。KProperty 主要是用来封装属性的元信息，提供给委托类使用，比如在委托类的 setValue 方法中通知属性发生变化时，就会用到 KProperty 里的属性名信息了。</p><h3 id="对委托属性约定的再认识"><a href="#对委托属性约定的再认识" class="headerlink" title="对委托属性约定的再认识"></a><strong>对委托属性约定的再认识</strong></h3><p>**<br>**</p><p>虽然 Kotlin 提供了 ReadWriteProperty 和 ReadOnlyProperty 封装了约定的方法给我们使用，但是当我们定义委托类时并不是一定要实现 Kotlin 提供的接口。</p><p>实际上，只要保持委托类里的 setValue 和 getValue 方法与约定的 setValue 方法和 getValue 方法一致就可以了。</p><p>修改委托类为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Delegate4</span>  </span>&#123;<br>    <span class="hljs-keyword">var</span> formattedString = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-comment">// 注意这里的 operator 不可以省略</span><br>    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getValue</span><span class="hljs-params">(thisRef: <span class="hljs-type">Any</span>, property: <span class="hljs-type">KProperty</span>&lt;*&gt;)</span></span>: String &#123;<br>        <span class="hljs-keyword">return</span> formattedString + <span class="hljs-string">&quot;-&quot;</span> + formattedString.length<br>    &#125;<br>    <span class="hljs-comment">// 注意这里的 operator 不可以省略</span><br>    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setValue</span><span class="hljs-params">(thisRef: <span class="hljs-type">Any</span>, property: <span class="hljs-type">KProperty</span>&lt;*&gt;, value: <span class="hljs-type">String</span>)</span></span> &#123;<br>        <span class="hljs-keyword">if</span> (thisRef <span class="hljs-keyword">is</span> Person7) &#123;<br>            thisRef.updateCount++<br>        &#125;<br>        formattedString = value.lowercase().replaceFirstChar &#123; it.uppercase() &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>修改 Person 类为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person7</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> name: String <span class="hljs-keyword">by</span> Delegate4()<br>    <span class="hljs-keyword">var</span> lastname: String <span class="hljs-keyword">by</span> Delegate4()<br>    <span class="hljs-keyword">var</span> updateCount = <span class="hljs-number">0</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> person = Person7()<br>    person.name = <span class="hljs-string">&quot;peter&quot;</span><br>    person.lastname = <span class="hljs-string">&quot;wang&quot;</span><br>    println(<span class="hljs-string">&quot;name=<span class="hljs-subst">$&#123;person.name&#125;</span>&quot;</span>)<br>    println(<span class="hljs-string">&quot;lastname=<span class="hljs-subst">$&#123;person.lastname&#125;</span>&quot;</span>)<br>    println(<span class="hljs-string">&quot;updateCount=<span class="hljs-subst">$&#123;person.updateCount&#125;</span>&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>约定方法可以使用扩展函数来实现：</p><p>比如，Delegate 类不符合委托属性的约定方法，代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Delegate5</span>  </span>&#123;<br>    <span class="hljs-keyword">var</span> formattedString = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">get</span><span class="hljs-params">()</span></span>: String &#123;<br>        <span class="hljs-keyword">return</span> formattedString + <span class="hljs-string">&quot;-&quot;</span> + formattedString.length<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">set</span><span class="hljs-params">(thisRef: <span class="hljs-type">Any</span>, value: <span class="hljs-type">String</span>)</span></span> &#123;<br>        <span class="hljs-keyword">if</span> (thisRef <span class="hljs-keyword">is</span> Person8) &#123;<br>            thisRef.updateCount++<br>        &#125;<br>        formattedString = value.lowercase().replaceFirstChar &#123; it.uppercase() &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这时可以使用扩展函数来实现约定方法，新建 Delegate5Extension.kt：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> Delegate5.<span class="hljs-title">setValue</span><span class="hljs-params">(thisRef: <span class="hljs-type">Any</span>, property: <span class="hljs-type">KProperty</span>&lt;*&gt;, value: <span class="hljs-type">String</span>)</span></span> =<br>    <span class="hljs-keyword">set</span>(thisRef, value)<br><br><span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> Delegate5.<span class="hljs-title">getValue</span><span class="hljs-params">(thisRef: <span class="hljs-type">Any</span>, property: <span class="hljs-type">KProperty</span>&lt;*&gt;)</span></span> = <span class="hljs-keyword">get</span>()<br></code></pre></td></tr></table></figure><p>修改 Person 类为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person8</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> name: String <span class="hljs-keyword">by</span> Delegate5()<br>    <span class="hljs-keyword">var</span> lastname: String <span class="hljs-keyword">by</span> Delegate5()<br>    <span class="hljs-keyword">var</span> updateCount = <span class="hljs-number">0</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> person = Person8()<br>    person.name = <span class="hljs-string">&quot;peter&quot;</span><br>    person.lastname = <span class="hljs-string">&quot;wang&quot;</span><br>    println(<span class="hljs-string">&quot;name=<span class="hljs-subst">$&#123;person.name&#125;</span>&quot;</span>)<br>    println(<span class="hljs-string">&quot;lastname=<span class="hljs-subst">$&#123;person.lastname&#125;</span>&quot;</span>)<br>    println(<span class="hljs-string">&quot;updateCount=<span class="hljs-subst">$&#123;person.updateCount&#125;</span>&quot;</span>)<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">打印日志：</span><br><span class="hljs-comment">name=Peter-5</span><br><span class="hljs-comment">lastname=Wang-4</span><br><span class="hljs-comment">updateCount=2</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>/  Kotlin内置委托  /</p><h3 id="lazy-函数"><a href="#lazy-函数" class="headerlink" title="lazy() 函数"></a><strong>lazy() 函数</strong></h3><p>lazy() 函数用于实现属性的惰性初始化，即只有在第一次访问属性时，才对它进行初始化。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>(name: String) &#123;<br>    <span class="hljs-keyword">val</span> emails: List&lt;String&gt; <span class="hljs-keyword">by</span> lazy &#123; loadEmailsByName(name) &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">loadEmailsByName</span><span class="hljs-params">(name: <span class="hljs-type">String</span>)</span></span>: List&lt;String&gt; &#123;<br>        println(<span class="hljs-string">&quot;loadEmailsByName called&quot;</span>)<br>        <span class="hljs-keyword">return</span> listOf(<span class="hljs-string">&quot;Email1&quot;</span>, <span class="hljs-string">&quot;Email2&quot;</span>, <span class="hljs-string">&quot;Email3&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> p = Person(<span class="hljs-string">&quot;Peter&quot;</span>)<br>    println(p.emails)<br>    println(p.emails)<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">打印日志：</span><br><span class="hljs-comment">loadEmailsByName called</span><br><span class="hljs-comment">[Email1, Email2, Email3]</span><br><span class="hljs-comment">[Email1, Email2, Email3]</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>可以看到，两次访问 emails 属性，只有第一次调用了 loadEmailsByName 方法。</p><p>如果把访问 emails 属性的代码注释掉，会看到没有任何打印，说明 emails 属性确实是惰性初始化的。</p><p>为什么 lazy() 函数可以放在 by 后面用于获取委托对象呢？</p><p>这是因为 Lazy.kt 中定义了符合约定的扩展函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> Lazy<span class="hljs-type">&lt;T&gt;</span>.<span class="hljs-title">getValue</span><span class="hljs-params">(thisRef: <span class="hljs-type">Any</span>?, property: <span class="hljs-type">KProperty</span>&lt;*&gt;)</span></span>: T = value<br></code></pre></td></tr></table></figure><h3 id="Delegates-notNull"><a href="#Delegates-notNull" class="headerlink" title="Delegates.notNull()"></a><strong>Delegates.notNull()</strong></h3><p>Delegates.notNull() 用于实现属性的延迟初始化，和 lateinit 类似。</p><p>它们的区别是：</p><ul><li>notNull 会给每个属性额外创建一个对象，而 lateinit 不会；</li><li>notNull 可以用于基本数据类型的延迟初始化，而 lateinit 不可以。</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person4</span> </span>&#123;<br>    <span class="hljs-keyword">val</span> fullname: String <span class="hljs-keyword">by</span> Delegates.notNull&lt;String&gt;()<br>    <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> fullname2: String<br>    <span class="hljs-comment">// lateinit var age: Int</span><br><br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> &#123;<br>        <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> list: MutableList&lt;String&gt;<br>        <span class="hljs-keyword">val</span> l : List&lt;String&gt; <span class="hljs-keyword">by</span> Delegates.notNull&lt;List&lt;String&gt;&gt;()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>/  最后  /</p><p>本文比较详细地介绍了 Kotlin 为什么要出现 by 关键字，以及它的两种用法。通过小的例子一步一步引出 by 关键字的使用。</p><p>需要说明的是，本文对于 by 关键字的委托属性的用法的实际应用并没有一一说明，这部分需要查看 <strong>Delegated properties-Kotlin官方文档</strong>(<a href="https://kotlinlang.org/docs/delegated-properties.html)%E3%80%82">https://kotlinlang.org/docs/delegated-properties.html)。</a></p><p>另外，本文没有把委托属性在属性值变化监听的应用例子写在文章里，主要考虑到大家对 PropertyChangeSupport 这个接口比较陌生，不太适合做基本实例说明。不过，这个例子在本文提供的代码中是包含的。需要说明的是，Kotlin 的内置的 Delegates.observable 和 Delegates.vetoable 就是对属性值变化监听或者否决的代码封装。</p><p>代码在这里（<a href="https://github.com/jhwsx/BlogCodes/tree/master/KotlinByStudy%EF%BC%89%E3%80%82">https://github.com/jhwsx/BlogCodes/tree/master/KotlinByStudy）。</a></p><p>文章的参考部分是不可多得的学习资料。大家也可以看看。</p><p>/  参考  /</p><p><strong>Delegation-Kotlin官方文档</strong></p><blockquote><p><a href="https://kotlinlang.org/docs/delegation.html">https://kotlinlang.org/docs/delegation.html</a></p></blockquote><p><strong>Delegated properties-Kotlin官方文档</strong></p><blockquote><p><a href="https://kotlinlang.org/docs/delegated-properties.html">https://kotlinlang.org/docs/delegated-properties.html</a></p></blockquote><p><strong>Delegating Delegates to Kotlin-AndroidDevelopersBlog（出自谷歌技术推广工程师，使用的例子比较贴切）</strong></p><blockquote><p><a href="https://medium.com/androiddevelopers/delegating-delegates-to-kotlin-ee0a0b21c52b">https://medium.com/androiddevelopers/delegating-delegates-to-kotlin-ee0a0b21c52b</a></p></blockquote><p><strong>Built-in Delegates-AndroidDevelopersBlog*<em>（出自谷歌技术推广工程师，使用的例子比较贴切）*</em></strong></p><blockquote><p><a href="https://medium.com/androiddevelopers/built-in-delegates-4811947e781f">https://medium.com/androiddevelopers/built-in-delegates-4811947e781f</a></p></blockquote><p><strong>Built-in Delegates-MAD Skills*<em>（出自谷歌技术推广工程师，这个是视频）*</em></strong></p><blockquote><p><a href="https://www.youtube.com/watch?v=s5qn5QhFntY&amp;list=PLWz5rJ2EKKc_T0fSZc9obnmnWcjvmJdw_&amp;index=3">https://www.youtube.com/watch?v=s5qn5QhFntY&amp;list=PLWz5rJ2EKKc_T0fSZc9obnmnWcjvmJdw_&amp;index=3</a></p></blockquote><p><strong>[译]带你揭开Kotlin中属性代理和懒加载语法糖衣（对 lazy 进行的详细地说明）</strong></p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/65914552">https://zhuanlan.zhihu.com/p/65914552</a></p></blockquote><p><strong>Kotlin “By” Class Delegation: Favor Composition Over Inheritance（作者详细地说明了类委托，介绍了组合优于继承，并举出 Android 中的 AppCompatDelegate 的例子，Guava 开源库中集合中使用组合代替继承的例子。）</strong></p><blockquote><p><a href="https://medium.com/rocket-fuel/kotlin-by-class-delegation-favor-composition-over-inheritance-a1b97fecd839">https://medium.com/rocket-fuel/kotlin-by-class-delegation-favor-composition-over-inheritance-a1b97fecd839</a></p></blockquote><p><strong>Kotlin ‘By’ Property Delegation: Create Reusable Code</strong></p><blockquote><p><a href="https://medium.com/rocket-fuel/kotlin-by-property-delegation-create-reusable-code-f2bc2253e227">https://medium.com/rocket-fuel/kotlin-by-property-delegation-create-reusable-code-f2bc2253e227</a> </p></blockquote><hr><h2 id="1-类委托"><a href="#1-类委托" class="headerlink" title="1.类委托"></a>1.类委托</h2><h3 id="（1）概念"><a href="#（1）概念" class="headerlink" title="（1）概念"></a>（1）概念</h3><p> 本类需要实现的<strong>方法/属性</strong>，借用其他已实现该<strong>方法/属性</strong>的对象作为自己的实现；</p><p> 一旦使用了某类作为委托类，该类就能借用该委托类实现的方法/属性。</p><h3 id="（2）定义"><a href="#（2）定义" class="headerlink" title="（2）定义"></a>（2）定义</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 定义一个生物接口，有一个run抽象方法和一个抽象属性</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Creature</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span><br>    <span class="hljs-keyword">val</span> type: String<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 定义一个委托类，实现了Creature接口</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DelegateClass</span> : <span class="hljs-type">Creature &#123;</span></span><br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> type: String<br>        <span class="hljs-keyword">get</span>() = <span class="hljs-string">&quot;委托类该属性&quot;</span><br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span> &#123;<br>        println(<span class="hljs-string">&quot;代理类执行run方法&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="①委托类作为构造器形参传入（常用）"><a href="#①委托类作为构造器形参传入（常用）" class="headerlink" title="①委托类作为构造器形参传入（常用）"></a>①委托类作为构造器形参传入（常用）</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 定义一个Human类，实现了Creature接口，委托类作为形参传入，由形参委托类对象作为委托对象</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Human</span></span>(delegateClass: DelegateClass) : Creature <span class="hljs-keyword">by</span> delegateClass<br></code></pre></td></tr></table></figure><h4 id="②新建委托类对象"><a href="#②新建委托类对象" class="headerlink" title="②新建委托类对象"></a>②新建委托类对象</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 定义一个Dog类，实现了Creature接口，新建一个委托类作为委托对象</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> : <span class="hljs-type">Creature by DelegateClass</span></span>()<br></code></pre></td></tr></table></figure><h4 id="③新建委托类对象，并自己实现方法-属性"><a href="#③新建委托类对象，并自己实现方法-属性" class="headerlink" title="③新建委托类对象，并自己实现方法/属性"></a>③新建委托类对象，并自己实现方法/属性</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 定义一个pig类，实现了Creature接口，新建一个委托类作为委托对象，并自己实现了抽象方法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pig</span> : <span class="hljs-type">Creature by DelegateClass</span></span>() &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span> &#123;<br>        println(<span class="hljs-string">&quot;自己执行实现的run方法&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> type: String<br>        <span class="hljs-keyword">get</span>() = <span class="hljs-string">&quot;自己实现的type属性&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>调用示例：</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>    <span class="hljs-comment">//作为形参（委托对象可复用）</span><br>    <span class="hljs-keyword">val</span> delegateClass = DelegateClass()<br>    <span class="hljs-keyword">val</span> human = Human(delegateClass)<br>    human.run()<span class="hljs-comment">//结果：代理类执行run方法</span><br>    println(human.type)<span class="hljs-comment">//结果：委托类该属性</span><br>    <span class="hljs-keyword">val</span> human2 = Human(delegateClass)<br>    human2.run()<span class="hljs-comment">//结果：代理类执行run方法</span><br>    println(human2.type)<span class="hljs-comment">//结果：委托类该属性</span><br><br>    <span class="hljs-comment">//新建对象</span><br>    <span class="hljs-keyword">val</span> dog = Dog()<br>    dog.run()<span class="hljs-comment">//结果：代理类执行run方法</span><br>    println(dog.type)<span class="hljs-comment">//结果：委托类该属性</span><br><br>    <span class="hljs-comment">//新建对象并自己实现方法/属性</span><br>    <span class="hljs-keyword">val</span> pig = Pig()<br>    pig.run()<span class="hljs-comment">//结果：自己执行实现的run方法</span><br>    println(pig.type)<span class="hljs-comment">//结果：自己实现的type属性</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-属性委托"><a href="#2-属性委托" class="headerlink" title="2.属性委托"></a>2.属性委托</h2><h3 id="（1）概念-1"><a href="#（1）概念-1" class="headerlink" title="（1）概念"></a>（1）概念</h3><p> 多个类的类似属性交给委托类统一实现，避免每个类都要单独重复实现一次。</p><h3 id="（2）定义-1"><a href="#（2）定义-1" class="headerlink" title="（2）定义"></a>（2）定义</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 定义一个委托类Jobs，</span><br><span class="hljs-comment"> * 为属性name创建了operator修饰的getValue和setValue方法</span><br><span class="hljs-comment"> * 该属性可被其他了委托该类共享</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Jobs</span> </span>&#123;<br>    <span class="hljs-keyword">var</span> name: String = <span class="hljs-string">&quot;工作名&quot;</span><br>    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setValue</span><span class="hljs-params">(thisRef: <span class="hljs-type">SoftWareDev</span>, property: <span class="hljs-type">KProperty</span>&lt;*&gt;, value: <span class="hljs-type">String</span>)</span></span> &#123;<br>        <span class="hljs-keyword">this</span>.name = value<br>    &#125;<br><br>    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getValue</span><span class="hljs-params">(thisRef: <span class="hljs-type">SoftWareDev</span>, property: <span class="hljs-type">KProperty</span>&lt;*&gt;)</span></span>: String &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 定义一个接口</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SoftWareDev</span></span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 定义一个AndroidDev类，实现SoftWareDev接口</span><br><span class="hljs-comment"> * 属性name委托Jobs类实现</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AndroidDev</span> : <span class="hljs-type">SoftWareDev &#123;</span></span><br>    <span class="hljs-keyword">var</span> name: String <span class="hljs-keyword">by</span> Jobs()<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 定义一个PhpDev类，实现了SoftWareDev接口</span><br><span class="hljs-comment"> * 属性name委托Jobs类实现</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PhpDev</span> : <span class="hljs-type">SoftWareDev &#123;</span></span><br>    <span class="hljs-keyword">var</span> name: String <span class="hljs-keyword">by</span> Jobs()<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 定义一个类实现了SoftWareDev接口</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExtensionClass</span> : <span class="hljs-type">SoftWareDev</span></span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 为ExtensionClass扩展属性，该属性由委托类Jobs实现</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">val</span> ExtensionClass.name <span class="hljs-keyword">by</span> Jobs()<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> androidDev = AndroidDev()<br>    androidDev.name = <span class="hljs-string">&quot;android开发&quot;</span><br>    println(androidDev.name)<span class="hljs-comment">//结果：android开发</span><br>    <span class="hljs-keyword">val</span> phpDev = PhpDev()<br>    println(phpDev.name)<span class="hljs-comment">//结果：工作名</span><br>    println(ExtensionClass().name)<span class="hljs-comment">//结果：工作名</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="（3）关于委托类的委托属性的getValue、setValue形参说明"><a href="#（3）关于委托类的委托属性的getValue、setValue形参说明" class="headerlink" title="（3）关于委托类的委托属性的getValue、setValue形参说明"></a>（3）关于委托类的委托属性的getValue、setValue形参说明</h3><h4 id="①getValue-thisRef-property"><a href="#①getValue-thisRef-property" class="headerlink" title="①getValue(thisRef, property)"></a>①getValue(thisRef, property)</h4><ul><li>thisRef：代表委托属性所属对象，因此thisDef类型需要与委托属性所属对象<strong>类型一致</strong>，或者是其<strong>父类</strong>，如上面代码thisRef类型为SoftWareDev，是AndroidDev和PhpDev两个类的<strong>父类类型</strong>；</li><li>property：代表目标属性，该属性必须是<strong>KProperty&lt;*&gt;类型</strong>或其<strong>父类类型</strong>；</li><li>返回值：返回目标属性<strong>相同的类型</strong>，或者其<strong>子类类型</strong>。</li></ul><h4 id="②setValue-thisRef-property-value"><a href="#②setValue-thisRef-property-value" class="headerlink" title="②setValue(thisRef, property, value)"></a>②setValue(thisRef, property, value)</h4><ul><li>thisRef：同上；</li><li>property：同上；</li><li>value：为目标属性设置的新的值，因此该值类型必须与目标属性<strong>类型一致</strong>，或者是其<strong>父类</strong>。</li></ul><p>总结：传入形参类型需与目标类型一致或者是其父类类型，返回值类型需与目标类型一致或者是其子类类型。</p><h3 id="（4）关于ReadOnlyProperty和ReadWriteProperty接口"><a href="#（4）关于ReadOnlyProperty和ReadWriteProperty接口" class="headerlink" title="（4）关于ReadOnlyProperty和ReadWriteProperty接口"></a>（4）关于ReadOnlyProperty和ReadWriteProperty接口</h3><ul><li>ReadOnlyProperty接口定义了getValue方法；</li><li>ReadWriteProperty接口定义了getValue、setValue方法。</li></ul><p>因此，委托类可以实现ReadOnlyProperty（val声明待委托属性时）或者ReadWriteProperty（var声明待委托属性时）接口来进行委托属性的定义。</p><p>上面Jobs类完全可以这么实现：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 定义一个委托类Jobs，</span><br><span class="hljs-comment"> * 实现了ReadWriteProperty接口，重写setValue、getValue方法</span><br><span class="hljs-comment"> * 该属性可被其他了委托该类共享</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Jobs</span> : <span class="hljs-type">ReadWriteProperty</span>&lt;<span class="hljs-type">SoftWareDev,String</span>&gt;</span>&#123;<br>    <span class="hljs-keyword">var</span> name: String = <span class="hljs-string">&quot;工作名&quot;</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setValue</span><span class="hljs-params">(thisRef: <span class="hljs-type">SoftWareDev</span>, property: <span class="hljs-type">KProperty</span>&lt;*&gt;, value: <span class="hljs-type">String</span>)</span></span> &#123;<br>        <span class="hljs-keyword">this</span>.name = value<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getValue</span><span class="hljs-params">(thisRef: <span class="hljs-type">SoftWareDev</span>, property: <span class="hljs-type">KProperty</span>&lt;*&gt;)</span></span>: String &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name<br>    &#125;<br>&#125;<br> 复制 全<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>kotlin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>idea配置java注解处理器</title>
    <link href="/posts/9097d82a/"/>
    <url>/posts/9097d82a/</url>
    
    <content type="html"><![CDATA[<h1 id="IntelliJ-IDEA-和-Gradle：为什么每个子模块有-3-个模块？"><a href="#IntelliJ-IDEA-和-Gradle：为什么每个子模块有-3-个模块？" class="headerlink" title="IntelliJ IDEA 和 Gradle：为什么每个子模块有 3 个模块？"></a><a href="https://stackoverflow.com/questions/36372571/intellij-idea-and-gradle-why-there-are-3-modules-per-sub-module">IntelliJ IDEA 和 Gradle：为什么每个子模块有 3 个模块？</a></h1><p>如果您只想为之前导入的项目禁用此选项，您可以通过编辑位于**.idea/gradle.xml 中的** idea gradle 配置文件来实现 。</p><p>添加将<strong>resolveModulePerSourceSet</strong>设置为<strong>false 的</strong>这一行：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;4&quot;</span>&gt;</span><br>  ...<br>  <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;GradleSettings&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;linkedExternalProjectsSettings&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">GradleProjectSettings</span>&gt;</span><br>        ...<br>        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;resolveModulePerSourceSet&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span> /&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">GradleProjectSettings</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后刷新gradle项目。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>在idea+gradle的环境中使用annotation processor生成代码，但是代码生成在了build文件夹下的classes里，且程序无法引用生成的类，若强行使用则报错找不到类。</p><h2 id="第一步-配置idea"><a href="#第一步-配置idea" class="headerlink" title="第一步 配置idea"></a>第一步 配置idea</h2><p>file -&gt; settting -&gt; Build,Execution,Deployment -&gt; compiler -&gt; annotation processor 进入此界面，然后：</p><ol><li>勾上<code>启用注解处理器</code></li><li>选中<code>从项目类路径获取处理器</code></li><li>选中<code>模块项目根</code></li><li><code>生产源目录</code>输入<code>../main/src/generated/java</code></li></ol><h2 id="第二步-配置gradle"><a href="#第二步-配置gradle" class="headerlink" title="第二步 配置gradle"></a>第二步 配置gradle</h2><p>这个项目有三个module：</p><p>一个是main 测试ProcessorLib库</p><p>一个是ProcessorLib 处理注解</p><p>一个是AnnotationsLib 定义注解</p><ul><li>ProcessorLib 的gradle</li></ul><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">//使编译时将文件生成到指定目录</span><br>compileJava &#123;<br><span class="hljs-comment">//配置编译时生成代码的目录</span><br>        <span class="hljs-keyword">options</span>.compilerArgs &lt;&lt; <span class="hljs-string">&quot;-s&quot;</span><br>        <span class="hljs-keyword">options</span>.compilerArgs &lt;&lt; <span class="hljs-string">&quot;$projectDir/src/main/generated/java&quot;</span><br><span class="hljs-comment">//确保文件夹存在</span><br>        <span class="hljs-keyword">doFirst</span> &#123;<br>            <span class="hljs-keyword">file</span>(<span class="hljs-keyword">new</span> <span class="hljs-keyword">File</span>(projectDir, <span class="hljs-string">&quot;/src/main/generated/java&quot;</span>)).mkdirs()<br>        &#125;<br>    &#125;<br><span class="hljs-comment">//在clean时删除编译生成的代码</span><br>    clean.<span class="hljs-keyword">doLast</span> &#123;<br>        <span class="hljs-comment">// clean-up directory when necessary</span><br>        <span class="hljs-keyword">file</span>(<span class="hljs-keyword">new</span> <span class="hljs-keyword">File</span>(projectDir, <span class="hljs-string">&quot;/src/main/generated&quot;</span>)).deleteDir()<br>    &#125;<br><span class="hljs-comment">//依赖  </span><br><span class="hljs-keyword">dependencies</span> &#123;<br>    implementation <span class="hljs-keyword">project</span>(path: <span class="hljs-string">&#x27;:AnnotationsLib&#x27;</span>)<span class="hljs-comment">//自己的注解定义module</span><br>    implementation <span class="hljs-string">&#x27;com.google.auto.service:auto-service-annotations:1.0.1&#x27;</span><span class="hljs-comment">//autoservice</span><br>    annotationProcessor <span class="hljs-string">&#x27;com.google.auto.service:auto-service:1.0.1&#x27;</span><span class="hljs-comment">//autoservice</span><br>    implementation <span class="hljs-string">&#x27;com.squareup:javapoet:1.13.0&#x27;</span><br>    testImplementation <span class="hljs-string">&#x27;org.junit.jupiter:junit-jupiter-api:5.7.2&#x27;</span><br>    testRuntimeOnly <span class="hljs-string">&#x27;org.junit.jupiter:junit-jupiter-engine:5.7.2&#x27;</span><br>&#125;<br><br><span class="hljs-comment">//详细日志打印，没有调用处理器，可能是跳过了，直接进行编译了</span><br><span class="hljs-comment">// 参数可选，重点是 -verbose -XprintRounds -XprintProcessorInfo</span><br><span class="hljs-keyword">allprojects</span> &#123;<br>    gradle.projectsEvaluated &#123;<br>        tasks.withType(JavaCompile) &#123;<br>            <span class="hljs-keyword">options</span>.compilerArgs &lt;&lt; <span class="hljs-string">&quot;-Xlint&quot;</span> &lt;&lt; <span class="hljs-string">&quot;-verbose&quot;</span> &lt;&lt; <span class="hljs-string">&quot;-XprintRounds&quot;</span> &lt;&lt; <span class="hljs-string">&quot;-XprintProcessorInfo&quot;</span> &lt;&lt; <span class="hljs-string">&quot;-Xmaxerrs&quot;</span> &lt;&lt; <span class="hljs-string">&quot;100000&quot;</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在main module的gradle中</li></ul><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs puppet"><span class="hljs-keyword">dependencies</span> &#123;<br>    implementation <span class="hljs-literal">project</span>(<span class="hljs-built_in">path</span>: <span class="hljs-string">&#x27;:ProcessorLib&#x27;</span>)<br>    annotationProcessor <span class="hljs-literal">project</span>(<span class="hljs-built_in">path</span>: <span class="hljs-string">&#x27;:ProcessorLib&#x27;</span>)<br>    implementation <span class="hljs-literal">project</span>(<span class="hljs-built_in">path</span>: <span class="hljs-string">&#x27;:AnnotationsLib&#x27;</span>)<br>    testImplementation <span class="hljs-string">&#x27;org.junit.jupiter:junit-jupiter-api:5.7.2&#x27;</span><br>    testRuntimeOnly <span class="hljs-string">&#x27;org.junit.jupiter:junit-jupiter-engine:5.7.2&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第三步-配置文件夹类型"><a href="#第三步-配置文件夹类型" class="headerlink" title="第三步 配置文件夹类型"></a>第三步 配置文件夹类型</h2><p>在执行gradle的build任务后，会在src/main下生成指定目录以及代码，但是在我们的源文件中依然没有提示，那么我们需要指定其文件夹类型。</p><p>前面用gradle生成的目录：<code>src/main/generated/java</code></p><p>把这个目录右键，将目录标记为<code>“生成文件夹的根目录”</code>。</p><h1 id="需要注意的细节"><a href="#需要注意的细节" class="headerlink" title="需要注意的细节"></a>需要注意的细节</h1><ul><li>在编写自定义Processor可能会出现处理器不起作用的情况<br>答:其很有可能是你将Processor.class写成了Process.class</li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">//正确的写法</span><br><span class="hljs-variable">@AutoService</span>(Processor.class)<br><span class="hljs-comment">//错误的写法</span><br><span class="hljs-variable">@AutoService</span>(Process.class)<br></code></pre></td></tr></table></figure><p>即使是按照上面的步骤配置，但仍然无法引用生成的代码(删除线即当时认知错误，在第4点会讲原因)<br>答:可能是由于你生成代码的文件夹与你的源文件不在一个module中，由于idea中使用gradle创建一个module，他会识别为三个module。</p><p>两种解决方式：</p><p>1.开头部分。</p><p>2.在创建项目时取消 <code>create separate per source set</code> 。</p><ul><li>annotation processor 生成类时报异常:错误: <strong>类重复: com.cxyz.test.Test</strong><br>答:其实annotation processor只能生成额外的类，而不能在原先类的基础上做改动</li></ul><hr><p>写过自定义注解处理器的老司机们乍一看这个问题觉得挺简单，是的，因为网上基本通篇都在教你怎么打日志，但是你有没有想过如果连日志都打印不出来的时候你怎么定位呢？譬如如下代码：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 确认 META-INF/services/javax.annotation.processing.Processor 没问题</span><br><span class="hljs-comment">// 确认构建脚本没问题，确认注解 Bridge 有被使用且有参与构建</span><br><span class="hljs-meta">@AutoService</span>(Processor.class)<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestAnnotationProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractProcessor</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">TestAnnotationProcessor</span>(<span class="hljs-params"></span>)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;TestAnnotationProcessor constrator&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> synchronized <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">init</span>(<span class="hljs-params">ProcessingEnvironment processingEnvironment</span>)</span> &#123;<br>        <span class="hljs-built_in">super</span>.init(processingEnvironment);<br>        System.out.println(<span class="hljs-string">&quot;TestAnnotationProcessor init&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">Set</span>&lt;<span class="hljs-built_in">String</span>&gt; <span class="hljs-function"><span class="hljs-title">getSupportedAnnotationTypes</span>(<span class="hljs-params"></span>)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;TestAnnotationProcessor getSupportedAnnotationTypes&quot;</span>);<br>        <span class="hljs-built_in">Set</span>&lt;<span class="hljs-built_in">String</span>&gt; supported = <span class="hljs-keyword">new</span> HashSet&lt;<span class="hljs-built_in">String</span>&gt;();<br>        supported.add(Bridge.class.getCanonicalName());<br>        <span class="hljs-keyword">return</span> supported;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-function"><span class="hljs-title">process</span>(<span class="hljs-params"><span class="hljs-built_in">Set</span>&lt;? <span class="hljs-keyword">extends</span> TypeElement&gt; set, RoundEnvironment roundEnvironment</span>)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;TestAnnotationProcessor process&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行构建后compileReleaseJavaWithJavac过程中没有先吐我 Annotation Processor 的任意一行日志，直接报错找不到我注解处理器产物类引用（即直接进行了 compile class 环节）。</p><p>你懵逼吗？反正我懵逼了！打印日志不好使了，哈哈，环境确认没问题，什么鬼，直接越过 Annotation Processor 进行 compile 了。</p><p>这时候就需要你稍微深入定位分析（撸javac源码的巨佬请自行飘过），前提就是你需要熟悉下 Annotation Processor 基本原理，然后我们通过一些额外的javac详细日志进行举例分析。</p><p>Annotation Processor 机制<br>注解和注解处理器是 JDK5 引入的机制，主要用来为类、方法、字段和参数等 Java 结构提供额外的信息。譬如常见的@Override就是仅仅对 Java 编译器生效的一个注解。Java 允许我们自定义注解，自定义的注解处理器就是用来处理这些自定义注解的（废话），注解处理器触发时机是由javac来处理的，所以整个javac过程的简要步骤如下图：</p><p>![在这里插入图片描述](TyporaRaw/idea 注解处理器.assets/20210111193442602.png)</p><p>可以看到，javac编译概要图主要分为如下几步：</p><p>把源文件解析为抽象语法树。<br>调用已注册的注解处理器。<br>如果注解处理器处理过程中生成了新的源文件，编译器重复第 1、2 步，当注解处理器不再生成新的源文件则进入最后一轮。<br>进入真正的 compile 字节码环节生成字节码。<br>如上就是注解处理器的核心机制，有了这个核心机制的认识我们就继续往下探索。</p><p>构建工具下 Annotation Processor 的本质<br>我们日常开发中（无论是 Java 后端还是 Android 移动端）总是多多少少会用到 JDK 提供的annotation processor能力，无论是什么构建工具（Gradle 或者 Maven 等）本质都是通过javac -processorpath命令参数显式指定哪些 Processer，或者显式声明META-INF/services/javax.annotation.processing.Processor来被javac发现并调用的（参见 google 的 AutoService 框架）。</p><p>正常情况下我们开发中使用及构建 Annotation Processor 技术都是上面几步走的方案，而且大多数照着网络上抄的都能正常工作，每次只用自己处理 process 就挺香的，因为只要按照规则声明放置，其他的 javac都能自己完美调用。</p><p>增强 javac 过程打印暴露问题<br>要解决一开始说的 Annotation Processor 中自己加的日志都不打印场景问题，我们需要获取一些额外的信息辅助定位。由于直接使用命令行javac的方式是最原始的操作，我们构建一般采用 Gradle，而 Gradle 的本质还是调用javac，所以下面我们以 Gradle 为例来分析如何定位 Annotation Processor 问题。</p><p>下面简单粗暴点就是直接在根目录的build.gradle中给所有模块添加参数：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><br><span class="hljs-comment">// 参数可选，重点是 -verbose -XprintRounds -XprintProcessorInfo</span><br>allprojects &#123;<br>    gradle<span class="hljs-selector-class">.projectsEvaluated</span> &#123;<br>        tasks<span class="hljs-selector-class">.withType</span>(JavaCompile) &#123;<br>            options<span class="hljs-selector-class">.compilerArgs</span> &lt;&lt; <span class="hljs-string">&quot;-Xlint&quot;</span> &lt;&lt; <span class="hljs-string">&quot;-verbose&quot;</span> &lt;&lt; <span class="hljs-string">&quot;-XprintRounds&quot;</span> &lt;&lt; <span class="hljs-string">&quot;-XprintProcessorInfo&quot;</span> &lt;&lt; <span class="hljs-string">&quot;-Xmaxerrs&quot;</span> &lt;&lt; <span class="hljs-string">&quot;100000&quot;</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>你也可以仅仅在自己有注解处理器的模块中添加，与上面一样，只要加给JavaCompile的参数就行。这里的参数其实就是我们平时命令行javac是否的参数，不懂的可以去命令行执行下javac -help观摩下含义吧，如下（JDK8，不同版本 JDK 略有差异）：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">yan@yanDeMackbookPro:~$ javac -help<br>用法: javac &lt;options&gt; &lt;source files&gt;<br>其中, 可能的选项包括:<br>-g                         生成所有调试信息<br><span class="hljs-code">......</span><br><span class="hljs-code">-verbose                   输出有关编译器正在执行的操作的消息</span><br><span class="hljs-code">......</span><br>-processor &lt;class1&gt;[,&lt;class2&gt;,&lt;class3&gt;...] 要运行的注释处理程序的名称; 绕过默认的搜索进程<br>-processorpath &lt;路径&gt;        指定查找注释处理程序的位置<br>......<br></code></pre></td></tr></table></figure><p>至于脚本中其他几个在javac -help中没有的参数可以看下官方文档<a href="https://docs.oracle.com/en/java/javase/11/tools/javac.html">https://docs.oracle.com/en/java/javase/11/tools/javac.html</a> ，里面详细解释了参数含义。</p><p>添加上面参数后一定要将你的构建日志追加到一个磁盘文件中，因为日志会变得非常庞大，同时也变得很容易定位问题。</p><p>通过构建日志分析定位问题<br>执行你的构建任务，完毕后分析定位主要分为如下几个步骤，每一步都是一种场景的定位，循序渐进定位分析即可。</p><p>在你的日志中搜索你的 Processor 类名，譬如TestAnnotationProcessor.class，看到的日志会是如下。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 如果你的注解处理器在项目中是源码形式的日志<br>[loading RegularFileObject[<span class="hljs-regexp">/home/u</span>ser<span class="hljs-regexp">/yan/</span>test<span class="hljs-regexp">/target/</span>classes<span class="hljs-regexp">/cn/y</span>an<span class="hljs-regexp">/test/</span>TestAnnotationProcessor.class]]<br><br><span class="hljs-regexp">//</span> 如果你的注解处理器在项目中是依赖 jar 形式的日志<br>[loading ZipFileIndexFileObject[......<span class="hljs-regexp">/test.jar(cn/y</span>an<span class="hljs-regexp">/test/</span>TestAnnotationProcessor.class)]]<br></code></pre></td></tr></table></figure><p>分析： 如果你的日志中搜不到上面信息，说明你的注解处理器没有被添加到javac的 classpath 中。一般问题就是你的META-INF/services/javax.annotation.processing.Processor声明有问题，javac无法找到你的注解处理器。有些同学可能是通过 google 的 AutoService 来生成META-INF/services/javax.annotation.processing.Processor的，这种情况下也要自己检查是否 OK（譬如之前安卓中 AGP 有一段时间的中间过渡版本就修改了 classpath，需要手动将 compile 改成 annotationProcessor 才行）。</p><p>在你的日志中搜索Round关键字，建议直接搜Round 1:这样的格式容易点，看到的日志会是如下。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vim">Round <span class="hljs-number">1</span>:<br>        <span class="hljs-built_in">input</span> <span class="hljs-keyword">file</span><span class="hljs-variable">s:</span> &#123;<span class="hljs-keyword">cn</span>.yan.test.Application, ......, <span class="hljs-keyword">cn</span>.yan.test.UseMarkedAnnotation&#125;<br>                annotation<span class="hljs-variable">s:</span> [java.lang.Override, <span class="hljs-keyword">cn</span>.yan.annotation.Bridge]<br>                <span class="hljs-keyword">last</span> <span class="hljs-built_in">round</span>: false<br></code></pre></td></tr></table></figure><p>上面日志中的input files:部分是扫到的你的源码，annotations:部分就是扫到你代码中使用了哪些注解，如果你注解处理器声明了要处理这种注解（譬如@cn.yan.annotation.Bridge），则日志如上才是正常的。</p><p>分析： 如果你日志中没搜到上面的Round，则说明javac没有触发调用任何注解处理器（无论是你写的还是依赖三方框架的），最大的可疑点就是检查下自己有没有禁用javac注解处理器，也就是确认javac执行时没有-proc:none参数。如果你的日志中有Round，但是input files:和annotations:没有你的注解类和使用类，则说明你没有在代码中使用你注解处理器要处理的注解。</p><p>在你的日志中搜索Loaded cn.yan.test.TestAnnotationProcessor关键字，看到的日志会是如下。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">[Loaded cn.yan.test.TestAnnotationProcessor <span class="hljs-keyword">from</span> <span class="hljs-keyword">file</span>:<span class="hljs-regexp">/home/u</span>ser<span class="hljs-regexp">/yan/</span>test<span class="hljs-regexp">/target/</span>classes<span class="hljs-regexp">/cn/y</span>an<span class="hljs-regexp">/test/</span>TestAnnotationProcessor.<span class="hljs-keyword">class</span>]<br></code></pre></td></tr></table></figure><p>分析： 如果你看不到上面这行日志，说明你的注解处理器类自己没有被加载成功，为什么没有我也不知道怎么分析了，但是至少说明没加载成功，你可能需要仔细核对哪里不规范或者不合法导致的了。</p><p>上面都排查完了，如果还是找不到问题原因，不妨换个思路，去仔细检查下你参与构建的普通 java 文件，是否存在语法错误或者什么问题（譬如常量没声明等）；如果有，解决完了再试试，别问我为什么，我也没有深入研究javac这块源码，只是我遇到过，且也没有异常堆栈信息，最终发现是合并解决冲突后代码少了一个变量声明，就是单纯的越过了 Annotation Processor 过程直接进行 compile to class 流程了）。<br>这个技能有什么鸟用？<br>不瞒你说，我也算是老司机了，好些年前 Annotation Processor 就玩的很 6 了，但是最近项目升级构建和 Java8 及 androidX 支持后 merge 了下代码，然后项目中的注解处理器、dataBinding 全部都不工作了，更可气的是，这个不工作是真的很吝啬，什么错误堆栈都没有，大致如下奇葩构建日志：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">FAILURE: Build failed <span class="hljs-keyword">with</span> an <span class="hljs-keyword">exception</span>.<span class="hljs-operator"></span><br><span class="hljs-operator"></span><br><span class="hljs-operator">* </span>What went wrong:<br>Execution failed <span class="hljs-keyword">for</span> task &#x27;:test:compileReleaseJavaWithJavac&#x27;.<br><span class="hljs-comment">// 本来这里该先吐我注解处理器内部的日志，然后才继续 javac 编译，实际什么都没吐</span><br>&gt; Compilation failed; see the compiler error output <span class="hljs-keyword">for</span> details.<span class="hljs-operator"></span><br><span class="hljs-operator">* </span>Exception is:<br>org.gradle.api.tasks.TaskExecutionException: Execution failed <span class="hljs-keyword">for</span> task &#x27;:moffice:compileReleaseJavaWithJavac&#x27;.<br>at org.gradle.api.internal.tasks.execution.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ExecuteActionsTaskExecuter</span>.</span></span>lambda<span class="hljs-constructor">$executeIfValid$1(ExecuteActionsTaskExecuter.<span class="hljs-params">java</span>:200)</span><br>......<br>Caused by: org.gradle.api.internal.tasks.compile.CompilationFailedException: Compilation failed; see the compiler error output <span class="hljs-keyword">for</span> details.<br>at org.gradle.api.internal.tasks.compile.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JdkJavaCompiler</span>.</span></span>execute(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JdkJavaCompiler</span>.</span></span>java:<span class="hljs-number">57</span>)<br><br></code></pre></td></tr></table></figure><p>Gradle 构建命令已经添加了各种详细参数供查看堆栈和详细日志，但奇妙的事情就是他走到compileReleaseJavaWithJavac就直接出错了，前后没有任何错误提示（有的只是一坨 Gradle 自己的 task 调用链）。我特么大意了，我就同步了下代码，编不过就编不过啊，你倒是提示下问题啊！啥也不提示直接干到 compile class 环节了，跳过了 Annotation Processor 流程，这就很恼火了。好在按照上面方式定位修复了，哈哈。</p><hr><p><a href="https://blog.csdn.net/qq_40985294/article/details/90041296#t4">引用</a></p><p><a href="https://blog.csdn.net/yanbober/article/details/112487959">引用</a></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>注解</tag>
      
      <tag>idea</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>配置 AndroidStudio</title>
    <link href="/posts/9dcd67b4/"/>
    <url>/posts/9dcd67b4/</url>
    
    <content type="html"><![CDATA[<h1 id="androidstudio4-2之后配置文件位置"><a href="#androidstudio4-2之后配置文件位置" class="headerlink" title="androidstudio4.2之后配置文件位置"></a>androidstudio4.2之后配置文件位置</h1><ul><li>System directory﻿</li></ul><p>现在位置在：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">C:<span class="hljs-symbol">\U</span>sers<span class="hljs-symbol">\1</span>23<span class="hljs-symbol">\A</span>ppData<span class="hljs-symbol">\L</span>ocal<span class="hljs-symbol">\G</span>oogle<br></code></pre></td></tr></table></figure><p>自定义位置；</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">D:<span class="hljs-symbol">\P</span>rogramData<span class="hljs-symbol">\a</span>ndroidStudioData<span class="hljs-symbol">\1</span>23<span class="hljs-symbol">\A</span>ppData<span class="hljs-symbol">\L</span>ocal<span class="hljs-symbol">\G</span>oogle<br>指定为idea.system.path<br></code></pre></td></tr></table></figure><ul><li>Configuration directory</li></ul><p>现在位置在：﻿</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">C:<span class="hljs-symbol">\U</span>sers<span class="hljs-symbol">\1</span>23<span class="hljs-symbol">\A</span>ppData<span class="hljs-symbol">\R</span>oaming<span class="hljs-symbol">\G</span>oogle<br></code></pre></td></tr></table></figure><p>自定义位置；</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">D:<span class="hljs-symbol">\P</span>rogramData<span class="hljs-symbol">\a</span>ndroidStudioData<span class="hljs-symbol">\1</span>23<span class="hljs-symbol">\A</span>ppData<span class="hljs-symbol">\R</span>oaming<span class="hljs-symbol">\G</span>oogle<br>指定为idea.config.path<br></code></pre></td></tr></table></figure><ul><li>Plugins directory﻿</li></ul><p>位置在：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">Roaming<span class="hljs-symbol">\J</span>etBrains<span class="hljs-symbol">\I</span>ntelliJIdea2020.2<span class="hljs-symbol">\p</span>lugins<br>指定为idea.plugins.path<br></code></pre></td></tr></table></figure><ul><li>Logs directory﻿</li></ul><p>现在位置在：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Local</span>\JetBrains\IntelliJIdea2020<span class="hljs-number">.2</span>\<span class="hljs-keyword">log</span><br>指定为idea.<span class="hljs-keyword">log</span>.path<br></code></pre></td></tr></table></figure><h1 id="修改配置文件位置"><a href="#修改配置文件位置" class="headerlink" title="修改配置文件位置"></a>修改配置文件位置</h1><p>在<code>C:\Users\123\AppData\Roaming\Google</code>的androidstudio目录下新建文件<code>idea.properties</code>填写下面内容</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gradle"># custom Android Studio propertiesidea.config.path= D:<span class="hljs-regexp">/ProgramData/</span>androidStudioData<span class="hljs-regexp">/123/</span>AppData<span class="hljs-regexp">/Roaming/G</span>oogle/AndroidStudioPreview2020.<span class="hljs-number">3</span><br>idea.config.path= D:<span class="hljs-regexp">/ProgramData/</span>androidStudioData<span class="hljs-regexp">/123/</span>AppData<span class="hljs-regexp">/Roaming/G</span>oogle/AndroidStudioPreview2020.<span class="hljs-number">3</span><br>idea.system.path=D:<span class="hljs-regexp">/ProgramData/</span>androidStudioData<span class="hljs-regexp">/123/</span>AppData<span class="hljs-regexp">/Local/G</span>oogle/AndroidStudioPreview2020.<span class="hljs-number">3</span><br>idea.plugins.path=D:<span class="hljs-regexp">/ProgramData/</span>androidStudioData<span class="hljs-regexp">/123/</span>AppData<span class="hljs-regexp">/Roaming/G</span>oogle<span class="hljs-regexp">/AndroidStudioPreview2020.3/</span>plugins<br>idea.log.path=D:<span class="hljs-regexp">/ProgramData/</span>androidStudioData<span class="hljs-regexp">/123/</span>AppData<span class="hljs-regexp">/Local/G</span>oogle<span class="hljs-regexp">/AndroidStudioPreview2020.3/</span>log<br></code></pre></td></tr></table></figure><h1 id="乱码"><a href="#乱码" class="headerlink" title="乱码"></a>乱码</h1><p>在Android Studio中双击Shift或者点击顶部全局搜索<code>&quot;Edit Custom VM Options&quot;</code><br>或者点击<code>Help—&gt;Edit Custom VM Option</code><br>(其实文件就在androidstudio的安装目录的bin文件夹下)<br>然后在打开的文件中添加一句</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">-Dfile.encoding</span>=UTF-<span class="hljs-number">8</span>s<br></code></pre></td></tr></table></figure><p>然后重启Android Studio</p><p>添加全局环境变量</p><p><code>名称:LC_ALL</code><br><code>值:C.UTF-8</code></p>]]></content>
    
    
    <categories>
      
      <category>android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Manjaro文档</title>
    <link href="/posts/e1aff6f4/"/>
    <url>/posts/e1aff6f4/</url>
    
    <content type="html"><![CDATA[<h1 id="更换国内源（可以在软件商店设置里修改）"><a href="#更换国内源（可以在软件商店设置里修改）" class="headerlink" title="更换国内源（可以在软件商店设置里修改）"></a>更换国内源（可以在软件商店设置里修改）</h1><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">sudo pacman-mirrors -<span class="hljs-selector-tag">i</span> -c China -m rank<br></code></pre></td></tr></table></figure><h1 id="fcitx5"><a href="#fcitx5" class="headerlink" title="fcitx5"></a>fcitx5</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> pacman -S fcitx<span class="hljs-number">5</span>-im fcitx<span class="hljs-number">5</span>-chinese-addons<br></code></pre></td></tr></table></figure><ul><li><p>其他一些软件包</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">fcitx5:</span> <span class="hljs-string">输入法基础框架主程序</span><br>   <span class="hljs-attr">fcitx5-chinese-addons:</span> <span class="hljs-string">简体中文输入的支持，云拼音</span><br>   <span class="hljs-attr">fcitx5-gtk:</span> <span class="hljs-string">GTK程序的支持</span><br>   <span class="hljs-attr">fcitx5-qt:</span> <span class="hljs-string">QT5程序的支持</span><br>   <span class="hljs-attr">fcitx5-pinyin-zhwiki:</span> <span class="hljs-string">肥猫制作的维基百万词库，没有版权风险,</span> <span class="hljs-string">放心使用</span><br>   <span class="hljs-attr">fcitx5-configtool:</span> <span class="hljs-string">图形化配置工具</span><br>   <span class="hljs-attr">kcm-fcitx5:</span> <span class="hljs-string">KDE桌面环境的支持</span><br></code></pre></td></tr></table></figure></li></ul><p>打开系统设置在 设置–区域设置—输入法—添加输入法—拼音—配置—-在程序中显示与编辑文本——启用云拼音 返回 配置附加组件 Classic User Interface 选择主题</p><p>配置fcitx5的环境变量：</p><p> <strong>不要在 fcitx 运行时修改, 因为进程退出后会覆写所有配置文件 (大字才能醒目)</strong></p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">nano ~<span class="hljs-string">/.pam_environment</span><br></code></pre></td></tr></table></figure><p>写入以下内容（内容来自manjaro的wiki）</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">GTK_IM_MODULE <span class="hljs-attribute">DEFAULT</span>=fcitx<br>QT_IM_MODULE  <span class="hljs-attribute">DEFAULT</span>=fcitx<br>XMODIFIERS    <span class="hljs-attribute">DEFAULT</span>=\@im=fcitx<br>SDL_IM_MODULE <span class="hljs-attribute">DEFAULT</span>=fcitx<br>最后那行 SDL_IM_MODULE 是为了让一些使用特定版本 SDL2 库的游戏，比如 Dota2 能正常使用输入法。 <br></code></pre></td></tr></table></figure><p>使用wps的用户还需要编辑~/.xprofile添加以下内容（在新版中bug被修复了，但是如果有问题的话，可以尝试此方法）</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">QT_IM_MODULE</span>=fcitx5<br></code></pre></td></tr></table></figure><p>自启动<br>在设置的开机里设置fcitx5自启动</p><p>输入法的默认设置：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dos">Ctrl + Space 激活输入法<br>左<span class="hljs-built_in">Shift</span> 临时切换到英文<br>Ctrl + <span class="hljs-built_in">Shift</span> 输入法间切换<br>-/= 向前/向后翻页<br><span class="hljs-built_in">Shift</span> + Space 全角、半角切换<br></code></pre></td></tr></table></figure><h2 id="全自动配置"><a href="#全自动配置" class="headerlink" title="全自动配置"></a>全自动配置</h2><p>manjaro的源里的<code>manjaro-asian-input-support</code></p><h2 id="fcitx5主题文件"><a href="#fcitx5主题文件" class="headerlink" title="fcitx5主题文件"></a>fcitx5主题文件</h2><p>主题文件位置：<code>~/.local/share/fcitx5/themes/</code></p><p>将下载的主题放进去，在设置面板里更改就可以了</p><h3 id="deepin论坛里的一个主题"><a href="#deepin论坛里的一个主题" class="headerlink" title="deepin论坛里的一个主题"></a>deepin论坛里的一个主题</h3><p><a href="https://bbs.deepin.org/zh/post/223743">地址</a></p><p>百度网盘：<code>链接: https://pan.baidu.com/s/13mn46NhmWRwQ4-Qmiufztg 提取码: 7yai 复制这段内容后打开百度网盘手机App，操作更方便哦</code></p><h3 id="fcitx5-material-color-主题"><a href="#fcitx5-material-color-主题" class="headerlink" title="fcitx5-material-color 主题"></a>fcitx5-material-color 主题</h3><ul><li>安装</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">yay</span> -S fcitx<span class="hljs-number">5</span>-material-color<br></code></pre></td></tr></table></figure><p>然后修改配置文件 ~/.config/fcitx5/conf/classicui.conf</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 横向候选列表</span><br>Vertical Candidate <span class="hljs-attribute">List</span>=<span class="hljs-literal">False</span><br><br><span class="hljs-comment"># 禁止字体随着DPI缩放，避免界面太大</span><br><span class="hljs-attribute">PerScreenDPI</span>=<span class="hljs-literal">False</span><br><br><span class="hljs-comment"># 字体和大小，可以用 fc-list 命令来查看使用</span><br><span class="hljs-attribute">Font</span>=<span class="hljs-string">&quot;Noto Sans Mono 13&quot;</span><br><br><span class="hljs-comment"># 默认蓝色主题</span><br><span class="hljs-attribute">Theme</span>=Material-Color-Blue<br></code></pre></td></tr></table></figure><h1 id="pacman常用命令"><a href="#pacman常用命令" class="headerlink" title="pacman常用命令"></a>pacman常用命令</h1><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs applescript">pacman -Ss <span class="hljs-built_in">string</span>             <span class="hljs-comment"># 在包数据库中查询软件</span><br>pacman -S package_name        <span class="hljs-comment"># 安装软件</span><br><br>pacman -S extra/package_name  <span class="hljs-comment"># 安装不同仓库中的版本</span><br>pacman -Syu                   <span class="hljs-comment"># 升级整个系统，y是更新数据库，yy是强制更新，u是升级软件</span><br>pacman -Si package_name       <span class="hljs-comment"># 显示软件的详细信息</span><br>pacman -Sc                    <span class="hljs-comment"># 清除软件缓存，即/var/cache/pacman/pkg目录下的文件</span><br>pacman -R package_name        <span class="hljs-comment"># 删除单个软件</span><br>pacman -Rs package_name       <span class="hljs-comment"># 删除指定软件及其没有被其他已安装软件使用的依赖关系</span><br>pacman -Qs <span class="hljs-built_in">string</span>             <span class="hljs-comment"># 查询已安装的软件包</span><br>pacman -Qi package_name       <span class="hljs-comment"># 查询本地安装包的详细信息</span><br>pacman -Ql package_name       <span class="hljs-comment"># 获取已安装软件所包含的文件的列表</span><br>pacman -U package.tar.zx      <span class="hljs-comment"># 从本地文件安装</span><br>pactree package_name          <span class="hljs-comment"># 显示软件的依赖树</span><br></code></pre></td></tr></table></figure><h1 id="manjaro的pamac命令"><a href="#manjaro的pamac命令" class="headerlink" title="manjaro的pamac命令"></a>manjaro的pamac命令</h1><p>他是软件商店的命令版本，也是manjaro自己的包管理命令。类似于ubuntu的apt命令。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs applescript">pamac search <span class="hljs-built_in">name</span> <span class="hljs-comment">#搜索</span><br>pamac info <span class="hljs-built_in">name</span>  <span class="hljs-comment">#详细信息</span><br>pamac install <span class="hljs-built_in">name</span> <span class="hljs-comment">#安装软件</span><br>pamac remove <span class="hljs-built_in">name</span> <span class="hljs-comment">#卸载软件</span><br>pamac checkupdates <span class="hljs-comment">#检查更新</span><br>pamac upgrade <span class="hljs-comment">#安装更新</span><br></code></pre></td></tr></table></figure><h1 id="改善火狐或chrome滚动"><a href="#改善火狐或chrome滚动" class="headerlink" title="改善火狐或chrome滚动"></a>改善火狐或chrome滚动</h1><ul><li>在火狐中搜索<code> Yet Another Smooth Scrolling WE</code>扩展</li><li>chrome中搜索<code>Chromium Wheel Smooth Scroller</code>扩展</li></ul><p>或者</p><ul><li><p>输入在火狐浏览器地址栏输入</p><p>about:config<br>搜索mousewheel<br>其中<code> mousewheel.defalut.delta_multiplier_y</code>越大，每次滚动一下<br>滚轮，屏幕就滑动地越大。<br>除此之外，推测<code>durationMaxMs和durationMinMs</code>参数是<br>完成滚动的时间间隔，以毫秒计算，数值越小，单次滚动越快。factor<br>和鼠标滚轮滚动时，屏幕滚动的加速度有关。</p></li></ul><h1 id="设置界面缩放"><a href="#设置界面缩放" class="headerlink" title="设置界面缩放"></a>设置界面缩放</h1><pre><code>高分屏缩放，比如netease-cloud-music软件：可以通过 env QT_SCREEN_SCALE_FACTORS=1.25 netease-cloud-music 启动来解决,也就是在启动文件里添加。</code></pre><h1 id="设置快捷键启动的方式："><a href="#设置快捷键启动的方式：" class="headerlink" title="设置快捷键启动的方式："></a>设置快捷键启动的方式：</h1><p>设置 -&gt; 快捷键 -&gt; 自定义快捷键 -&gt; 编辑 -&gt; 新建 -&gt; 全局快捷键 -&gt; 命令/URL</p><p>设置触发器：设置为你习惯的快捷键 -&gt; 动作：命令/URL这填：/usr/bin/flameshot gui</p><h1 id="网络启停"><a href="#网络启停" class="headerlink" title="网络启停"></a>网络启停</h1><p>开机后显示wifi不可用，鼠标放在网络图标上显示<code>Networkmanager未运行</code>，解决方法是在终端执行以下命令</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">systemctl restart <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">NetworkManager</span>.</span></span>service<br>systemctl enable <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">NetworkManager</span>.</span></span>service<br></code></pre></td></tr></table></figure><hr><h1 id="ZSH"><a href="#ZSH" class="headerlink" title="ZSH"></a>ZSH</h1><ul><li><strong>替换shell</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">yay -Sy zsh  #安装zsh  manjaro现在默认就已经安装了zsh<br>chsh -l  #列出现在安装的shell<br>chsh -s /bin/zsh # 设置zsh为默认  重启生效<br></code></pre></td></tr></table></figure><ul><li><strong>备注</strong>： <strong>manjaro已经内置zsh,直接在kde设置里修改即可，ohmyzsh在manjaro也内置了，所以如果自己想折腾，可以直接去github把ohmyzsh克隆到任意位置使用。</strong></li></ul><h2 id="PART-1-→-oh-my-zsh"><a href="#PART-1-→-oh-my-zsh" class="headerlink" title="PART 1 → oh-my-zsh"></a>PART 1 → oh-my-zsh</h2><p>默认的 Zsh 配置有点麻烦。因此一个叫 robbyrussel 的用户在 GitHub 上制作了一个配置文件 oh-my-zsh，这是目前为止最流行的 Zsh 配置：</p><p><a href="https://link.zhihu.com/?target=https://github.com/robbyrussell/oh-my-zsh">oh-my-zsh 项目地址（不要吝啬你的 Star）</a></p><p>如果你不想看官方的安装说明，请看这里：</p><p><strong>第一步 → 把 oh-my-zsh 项目 Clone 下来：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh<br></code></pre></td></tr></table></figure><p><strong>第二步 → 复制 .zshrc</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc<br></code></pre></td></tr></table></figure><p><strong>第三步 → 更改你的默认 Shell</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">chsh -s /bin/zsh<br></code></pre></td></tr></table></figure><p>现在，你会看到你的命令提示符变了。</p><p>zsh的配置文件存在当前用户目录中的.zshrc文件，如果你发现切换了shell之后，以前的配置的环境变量不生效了，可以打开 .zshrc文件，找到：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># User configuration</span><br><span class="hljs-built_in">source</span> ~/.bash_profile<br></code></pre></td></tr></table></figure><p>指定配置的环境变量文件，之后运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> .zshrc<br></code></pre></td></tr></table></figure><p>前往 <a href="https://link.zhihu.com/?target=https://github.com/robbyrussell/oh-my-zsh/wiki/Themes">oh-my-zsh 的 Wiki</a> 就可以看到大多数 oh-my-zsh 的内置主题以及它们的截图。如果你看中的其中的一款，可以重复上面的步骤，编辑~/.zshrc，并更改ZSH_THEME=”xxx”。</p><p>比如你看中了 ys 主题（我的最爱），你可以把 ZSH_THEME 改成 “ys”，然后回到终端，执行 source ~/.zshrc 命令。</p><p>P.S. 这些主题都保存在 “~/.oh-my-zsh/themes” 目录中</p><ul><li><h1 id="powerlevel10k主题"><a href="#powerlevel10k主题" class="headerlink" title="powerlevel10k主题"></a>powerlevel10k主题</h1><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-number">1</span>. 安装 <br>git clone --depth=<span class="hljs-number">1</span> https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/romkatv/</span>powerlevel10k.git <span class="hljs-variable">$&#123;ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom&#125;</span><span class="hljs-regexp">/themes/</span>powerlevel10k<br><span class="hljs-number">2</span>. 傻瓜式配置 终端中输入 p10k configure<br></code></pre></td></tr></table></figure><ul><li>安装完 powerlevel10k 后你可能会发现有乱码，这是因为你终端字体不支持那么多的字符，这就需要使用扩展字体了。</li></ul></li></ul><h2 id="PART-3-→-插件"><a href="#PART-3-→-插件" class="headerlink" title="PART 3 → 插件"></a>PART 3 → 插件</h2><pre><code>oh-my-zsh 的自带插件都储存在 &quot;~/.oh-my-zsh/plugins&quot; 目录中，如果你希望安装一个插件，可以在 &quot;~/.zshrc&quot; 的 plugins=(xxx, xxx, ...) 这一行里加入插件名称如果你需要安装第三方插件和主题，你可以在 &quot;~/.zshrc&quot; 的某一行（比如末尾）加入 source /path/to/plugin比如你希望添加一个 zsh-syntax-highlighting 插件 ↓</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> ~/.zsh-syntax-highlighting/zsh-syntax-highlighting.zsh<br><span class="hljs-comment"># 这里要根据你自己的输入目录，而不是抄我的，否则然并卵</span><br></code></pre></td></tr></table></figure><p>​    kde主题文件位置</p><p>要么在根目录的usr目录下，要么就在home的.config目录下。</p><p>要删除主题，先把当前使用的主题换成默认的主题，然后根据下面的目录删除即可。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs awk">  AURORAE_DIR=<span class="hljs-string">&quot;/usr/share/aurorae/themes&quot;</span><br>  SCHEMES_DIR=<span class="hljs-string">&quot;/usr/share/color-schemes&quot;</span><br>  PLASMA_DIR=<span class="hljs-string">&quot;/usr/share/plasma/desktoptheme&quot;</span><br>  LOOKFEEL_DIR=<span class="hljs-string">&quot;/usr/share/plasma/look-and-feel&quot;</span><br>  KVANTUM_DIR=<span class="hljs-string">&quot;/usr/share/Kvantum&quot;</span><br>  WALLPAPER_DIR=<span class="hljs-string">&quot;/usr/share/wallpapers&quot;</span><br>或者<br>  AURORAE_DIR=<span class="hljs-string">&quot;$HOME/.local/share/aurorae/themes&quot;</span><br>  SCHEMES_DIR=<span class="hljs-string">&quot;$HOME/.local/share/color-schemes&quot;</span><br>  PLASMA_DIR=<span class="hljs-string">&quot;$HOME/.local/share/plasma/desktoptheme&quot;</span><br>  LOOKFEEL_DIR=<span class="hljs-string">&quot;$HOME/.local/share/plasma/look-and-feel&quot;</span><br>  KVANTUM_DIR=<span class="hljs-string">&quot;$HOME/.config/Kvantum&quot;</span><br>  WALLPAPER_DIR=<span class="hljs-string">&quot;$HOME/.local/share/wallpapers&quot;</span> <br><br>注：<br><span class="hljs-regexp">/home/</span>hzt<span class="hljs-regexp">/.local/</span>share<span class="hljs-regexp">/plasma/</span>desktoptheme 这是存放plasma主题<br><span class="hljs-regexp">/home/</span>hzt<span class="hljs-regexp">/.local/</span>share<span class="hljs-regexp">/plasma/</span>look-and-feel/ 存放全局主题<br><span class="hljs-regexp">/home/</span>hzt<span class="hljs-regexp">/.local/</span>share<span class="hljs-regexp">/plasma/</span>plasmoids/ 存放插件<br><span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/sddm/</span> sddm主题位置<br></code></pre></td></tr></table></figure><hr><h2 id="重启桌面"><a href="#重启桌面" class="headerlink" title="重启桌面"></a>重启桌面</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">kquitapp5 plasmashell    <span class="hljs-comment"># 退出kde桌面</span><br>kstart5 plasmashell<br></code></pre></td></tr></table></figure><h1 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h1><h2 id="ctrl-f2进入tty，中文显示为方块"><a href="#ctrl-f2进入tty，中文显示为方块" class="headerlink" title="ctrl+f2进入tty，中文显示为方块"></a>ctrl+f2进入tty，中文显示为方块</h2><p>解决方法：安装fbterm</p><h2 id="错误：-Cannot-find-the-fakeroot-binary-gt-错误：-Cannot-find-the-strip-binary"><a href="#错误：-Cannot-find-the-fakeroot-binary-gt-错误：-Cannot-find-the-strip-binary" class="headerlink" title="错误： Cannot find the fakeroot binary. ==&gt; 错误： Cannot find the strip binary"></a>错误： Cannot find the fakeroot binary. ==&gt; 错误： Cannot find the strip binary</h2><p>解决方法：因为没安装 fakeroot、binutils 等打包基本工具，所以<code>sudo pacman -S --needed base-devel</code> 装一下。</p><hr><h2 id="使用数位板"><a href="#使用数位板" class="headerlink" title="使用数位板"></a>使用数位板</h2><p>1.查看系统信息中的内核版本，根据内核版本安装linux-header</p><p>2.安装aur源中的驱动：yay -S digimend-drivers-git-dkms  </p><hr><h2 id="蓝牙"><a href="#蓝牙" class="headerlink" title="蓝牙"></a>蓝牙</h2><p>安装<code>manjaro-bluetooth</code></p><p>如果不能接收文件，</p><p>更改kde设置-蓝牙-配置-接收文件选项 为接受信任设备或总是接受</p><h2 id="关闭watchdog"><a href="#关闭watchdog" class="headerlink" title="关闭watchdog"></a>关闭watchdog</h2><p>根据 <a href="https://en.wikipedia.org/wiki/Watchdog_timer">维基百科：看门狗定时器 </a>： </p><p>由于系统的关键任务（即服务器）或缺少电源重置（即嵌入式设备），许多用户需要此功能。  因此，在某些情况下，此功能是良好操作所必需的。  另一方面，普通用户（例如台式机和笔记本电脑）不需要此功能，可以将其禁用。 </p><p>要禁用看门狗定时器（包括软件和硬件），请附加  <code>nowatchdog</code> 到您的启动参数。 </p><p>要检查新配置，请执行以下操作： </p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"># cat <span class="hljs-regexp">/proc/</span>sys<span class="hljs-regexp">/kernel/</span>watchdog<br></code></pre></td></tr></table></figure><p>或使用： </p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># wdctl</span><br></code></pre></td></tr></table></figure><ul><li><p>附加启动参数到grub</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs gradle">如果要禁用watchdog，需要在内核启动选项里面添加一个参数：<br><br>nowatchdog<br><br>添加的方法是修改 <span class="hljs-regexp">/etc/</span><span class="hljs-keyword">default</span>/grub 文件加上这个参数（用什么编辑器都可以，只要有root权限修改）<br><br>sudo nano <span class="hljs-regexp">/etc/</span><span class="hljs-keyword">default</span>/grub<br><br>找到其中包含 GRUB_CMDLINE_LINUX_DEFAULT 的一行，等号后面的字符串里面加个空格，加上nowatchdog就行了，比如：<br><br>本来是<br><br>GRUB_CMDLINE_LINUX_DEFAULT=<span class="hljs-string">&quot;quiet splash foo=bar&quot;</span><br><br>改成<br><br>GRUB_CMDLINE_LINUX_DEFAULT=<span class="hljs-string">&quot;quiet splash foo=bar nowatchdog&quot;</span><br><br>修改完毕之后<br>在终端中调用 update-grub<br><br></code></pre></td></tr></table></figure></li></ul><p>禁用看门狗后，您也可以 <em>选择</em> 避免加载负责硬件看门狗的模块。 通过 <a href="https://wiki.archlinux.org/index.php/Blacklisting">列入黑名单 </a>将相关模块 ，例如 <code>iTCO_wdt</code>. </p><p><strong>注意：</strong> 一些用户 <a href="https://bbs.archlinux.org/viewtopic.php?id=221239">报告 </a>了 <code>nowatchdog</code> 参数不能按预期工作，但是他们已通过将上述模块列入黑名单而成功禁用了看门狗（至少是硬件之一）。 </p><p>这两种操作都会加快启动和关闭的速度，因为只加载了一个模块。 另外，禁用看门狗定时器可以提高性能并 <a href="https://wiki.archlinux.org/index.php/Power_management#Disabling_NMI_watchdog">降低功耗 </a>。 </p><p>有关 请参见 [<a href="https://bbs.archlinux.org/viewtopic.php?id=163768">3] </a>， ， [<a href="https://bbs.archlinux.org/viewtopic.php?id=165834">4] </a>， [<a href="http://0pointer.de/blog/projects/watchdog.html">5] </a>和 [<a href="https://www.kernel.org/doc/html/latest/watchdog/watchdog-parameters.html">6] </a>更多信息 。 </p><h3 id="将硬件列入黑名单"><a href="#将硬件列入黑名单" class="headerlink" title="将硬件列入黑名单"></a>将硬件列入黑名单</h3><p>在内核模块的上下文中，黑名单是一种防止内核模块加载的机制。  例如，如果不需要关联的硬件，或者如果加载该模块会导致问题，这可能会很有用：例如，可能有两个内核模块试图控制同一硬件，然后将它们一起加载会导致冲突。 </p><p>有些模块作为 <a href="https://wiki.archlinux.org/index.php/Initramfs">initramfs</a> 的一部分装入。</p><p><code>mkinitcpio -M</code> 会显示所有自动检测到到模块：要阻止 initramfs 装入某些模块，可以在 <code>/etc/modprobe.d</code>中将它们加入黑名单。并应在映像生成过程中通过<code>modconf</code>挂钩将其添加。 </p><p>运行 <code>mkinitcpio -v</code> 会显示各种钩子(例如 filesystem 钩子, SCSI 钩子等)装入的模块。如果您的<code>HOOKS</code> 数组中没有 <code>modconf</code> 钩子（例如，和默认配置不同）则请将该”.conf”文件添加到<code>/etc/mkinitcpio.conf</code>中的FILES数组中。一旦您将其列入黑名单，请重新生成 <a href="https://wiki.archlinux.org/index.php/Initramfs">initramfs</a>，然后重新启动。 </p><h4 id="使用-etc-modprobe-d-中的文件"><a href="#使用-etc-modprobe-d-中的文件" class="headerlink" title="使用/etc/modprobe.d/中的文件"></a>使用/etc/modprobe.d/中的文件</h4><p>在 <code>/etc/modprobe.d/</code> 中创建 <code>.conf</code> 文件，使用 <code>blacklist</code> 关键字屏蔽不需要的模块，例如如果不想装入 <code>pcspkr</code> 模块：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/etc/m</span>odprobe.d/nobeep.conf<br><span class="hljs-comment"># Do not load the &#x27;pcspkr&#x27; module on boot.</span><br>blacklist pcspkr<br></code></pre></td></tr></table></figure><p><strong>注：</strong> 该 <code>blacklist</code> 该命令会将一个模块列入黑名单，因此不会自动加载该模块，但是如果另一个未列入黑名单的模块依赖该模块或手动加载该模块，则可能会加载该模块。 </p><p>要避免这个行为，可以让 modprobe 使用自定义的 <code>install</code> 命令，而不是像往常一样将模块插入内核，因此您可以通过以下方式强制模块始终无法加载：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-regexp">/etc/m</span>odprobe.d/blacklist.conf<br>...<br>install MODULE <span class="hljs-regexp">/bin/</span><span class="hljs-keyword">true</span><br>...<br></code></pre></td></tr></table></figure><p>这样就可以 “屏蔽” 模块及所有依赖它的模块。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">也就是在<span class="hljs-regexp">/etc/m</span>odprobe.d我创建watchdog.conf文件，写入下面两行<br>blacklist iTCO_wdt <br>blacklist iTCO_vendor_support<br></code></pre></td></tr></table></figure><h2 id="停用-watchdog"><a href="#停用-watchdog" class="headerlink" title="停用 watchdog"></a>停用 watchdog</h2><p>关机时提示：watchdog: watchdog0: watchdog did not stop! 在台式机和笔记本上安装 Manjaro 时可以停用 watchdog 模块<br><a href="https://wiki.archlinux.org/index.php/Improving_performance#Watchdogs">提高性能#Watchdogs </a></p><blockquote><p>许多用户由于其系统的关键任务角色（即服务器）或缺乏电源重置（即嵌入式设备）而需要此功能。  因此，在某些情况下，良好的操作需要此功能。  另一方面，普通用户（即台式机和笔记本电脑）不需要此功能，可以禁用它。 </p></blockquote><p>按照 archlinux wiki 上的方法，在启动参数中添加  <code>nowatchdog</code> 不能停用 watchdog </p><blockquote><p>注意：一些用户报告 nowatchdog 参数没有按预期工作，但他们通过将上述模块列入黑名单，成功禁用了看门狗（至少是硬件）。 </p></blockquote><p>另一种方法是在内核启动参数中添加  <code>modprobe.blacklist=iTCO_wdt</code> 来禁用  <code>watchdog</code> 模块。<br>编辑  <code>/etc/default/grub</code> 在  <code>GRUB_CMDLINE_LINUX_DEFAULT</code> 后添加  <code>modprobe.blacklist=iTCO_wdt</code> 保存退出后执行  <code>sudo update-grub</code> 来应用配置。   </p><blockquote><p>编辑 <code>/etc/default/grub</code>并附加 <code>modprobe.blacklist=iTCO_wdt</code>到 <code>GRUB_CMDLINE_LINUX_DEFAULT</code>线 </p></blockquote><p><a href="https://wiki.archlinux.org/index.php/Kernel_parameters#GRUB">内核参数#GRUB </a><br><a href="https://bbs.archlinux.org/viewtopic.php?id=221239">静音关机。  看门狗：看门狗0：看门狗没有停止！ </a></p><h2 id="开关机显示-dev-nvme0n1p5-clean-…-files-…blocks"><a href="#开关机显示-dev-nvme0n1p5-clean-…-files-…blocks" class="headerlink" title="开关机显示/dev/nvme0n1p5: clean, … files, …blocks"></a>开关机显示/dev/nvme0n1p5: clean, … files, …blocks</h2><p>1.在论坛里有提及这个问题</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">这两条命令显示一些日志信息<br><span class="hljs-keyword">journalctl </span>-<span class="hljs-keyword">b </span>-g nvme0n1p <br><span class="hljs-keyword">journalctl </span>-<span class="hljs-keyword">b </span>-u <span class="hljs-string">&#x27;systemd-fsck*&#x27;</span><br></code></pre></td></tr></table></figure><p>2.实际上根据</p><p>得到结论：系统在检查硬盘有没有问题，显示<code>/dev/nvme0n1p5: clean</code>就表示没有问题，所以没必要理会这条信息</p><h2 id="调整swap分区使用率"><a href="#调整swap分区使用率" class="headerlink" title="调整swap分区使用率"></a>调整swap分区使用率</h2><p>在内核版本为5.8之前，swappiness范围在0-100，内核大于5.8，范围是0-200。</p><p>总的说来，swappiness值越小，越尽可能的使用内存而不是交换分区。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sysctl</span> -q vm.swappiness 显示当前设置<br><span class="hljs-attribute">sudo</span> sysctl -w vm.swappiness=<span class="hljs-number">10</span> 临时设置为<span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>To set the swappiness value permanently, create a <a href="https://man.archlinux.org/man/sysctl.d.5">sysctl.d(5)</a> configuration file. For example:</p><p>永久的调整该设置，创建下面的配置文件</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/etc/</span>sysctl.d/<span class="hljs-number">99</span>-swappiness.conf<br>vm.swappiness=<span class="hljs-number">10</span>                              <br></code></pre></td></tr></table></figure><h2 id="failed-to-start-pkgfile-database-update"><a href="#failed-to-start-pkgfile-database-update" class="headerlink" title="failed to start pkgfile database update"></a>failed to start pkgfile database update</h2><p>查看<code>pkgfile-update.service</code>和<code>pkgfile-update.timer</code>，我猜测这个任务会每天相隔6小时执行，开机和关机时会因为错过任务而补偿执行，但是开机和关机时没有网络，所以执行失败。在系统设置面板的systemed里找到并修改<code>pkgfile-update.timer</code>，修改为开机后15分钟执行，相隔1天重复执行，就不会看到错误信息了。<br> 这是修改后的<code>pkgfile-update.timer</code>文件。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Unit]</span><br><span class="hljs-attr">Description</span>=pkgfile database update timer<br><br><span class="hljs-section">[Timer]</span><br><span class="hljs-attr">OnBootSec</span>=<span class="hljs-number">15</span>min<br><span class="hljs-attr">OnUnitActiveSec</span>=<span class="hljs-number">1</span>d<br><span class="hljs-attr">Persistent</span>=<span class="hljs-literal">no</span><br><br><span class="hljs-section">[Install]</span><br><span class="hljs-attr">WantedBy</span>=multi-user.target<br></code></pre></td></tr></table></figure><h2 id="软件源里没有grub-customer"><a href="#软件源里没有grub-customer" class="headerlink" title="软件源里没有grub-customer"></a>软件源里没有grub-customer</h2><p>去官网下载</p><h1 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h1><h2 id="检测-SSD-是否支持-TRIM"><a href="#检测-SSD-是否支持-TRIM" class="headerlink" title="检测 SSD 是否支持 TRIM"></a>检测 SSD 是否支持 TRIM</h2><p>可以通过 /sys/block 下的信息来判断 SSD 支持 TRIM, discard_granularity 非 0 表示支持。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># cat /sys/block/sda/queue/discard_granularity</span><br>0<br><span class="hljs-comment"># cat /sys/block/nvme0n1/queue/discard_granularity</span><br>512<br></code></pre></td></tr></table></figure><p>也可以直接使用 lsblk 来检测，DISC-GRAN (discard granularity) 和 DISC-MAX (discard max bytes) 列非 0 表示该 SSD 支持 TRIM 功能。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># lsblk --discard</span><br>NAME    DISC-ALN DISC-GRAN DISC-MAX DISC-ZERO<br>sda            0        0B       0B         0<br>├─sda1         0        0B       0B         0<br>├─sda2         0        0B       0B         0<br>└─sda3         0        0B       0B         0<br>sr0            0        0B       0B         0<br>nvme0n1      512      512B       2T         1<br>nvme1n1      512      512B       2T         1<br></code></pre></td></tr></table></figure><p>网上也有文章介绍通过 hdparm 来检测，不过我在 Intel P4500 SSD 测试没有返回该信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># hdparm -I /dev/sda | grep TRIM</span><br>        *    Data Set Management TRIM supported (<span class="hljs-built_in">limit</span> 1 block)<br></code></pre></td></tr></table></figure><h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><p>虽然<a href="https://wiki.archlinux.org/title/Solid_State_Drives#Continuous_TRIM">连续 TRIM</a>是 SSD 的一个选项（尽管不推荐），但不应向<strong>NVMe 设备发出Discards</strong>。</p><p>在使用<a href="https://wiki.archlinux.org/title/Ext4">ext4</a>和<a href="https://wiki.archlinux.org/title/LVM">LVM 的</a>典型设置中，默认情况下禁用Discards，但其他<a href="https://wiki.archlinux.org/title/File_systems">文件系统</a>可能需要明确禁用Discards。</p><p>英特尔作为一家设备制造商，建议不要在文件系统级别启用Discards，而是建议<a href="https://wiki.archlinux.org/title/Solid_State_Drives#Periodic_TRIM">定期 TRIM</a>方法，或者<code>fstrim</code>手动应用。<a href="https://communities.intel.com/thread/75161?start=0&tstart=0">[3]</a></p><ul><li>Intel Optane SSD 不同于 NAND, 使用了 write-in-place 技术, 没有垃圾回收，没有 trim。而 Intel P4500、P4600 系列的 NVMe SSD 都是 NAND 产品，主动 trim 可以优化性能并延长寿命，特别是写频繁场景：</li></ul><blockquote><p>For NAND SSD:<br>mount -t xfs -o noatime,nodiratime,discard,nobarrier /dev/nvme0n1 /data/nandssd<br>The noatime/nodiratime parameters reduces the updates to the access time structures on disk.<br>The “discard” parameter tells the SSD to use the NVMe “TRIM” transaction to inform the SSD on “free space”.<br>The “nobarrier” parameter informs the OS that the drive supports a power-protected write buffer…and the OS can relax ordered writes on filesystem updates.<br>There have been some very recent changes in the XFS filesystem code that are now ignoring this option.<br>That appears to change some of the performance results…I need to go back and measure what the impacts are.<br>For Optane SSD:<br>mount -t xfs -o noatime,nodiratime,nodiscard,nobarrier /dev/nvme${i}n1 /data/optssd${i}<br>We changed “discard” to “nodiscard”. That is because “discard” does not provide any performance benefit on Optane.<br>Because Intel supports a “zeros” discard policy…(reads to unallocated data items returns zeros rather than random data)…the Optane drives were doing an extra erase of the memory when it handled a NVME TRIM transaction. Not good.</p></blockquote><h2 id="Continuous-TRIM-连续修剪"><a href="#Continuous-TRIM-连续修剪" class="headerlink" title="Continuous TRIM(连续修剪)"></a>Continuous TRIM(连续修剪)</h2><p><strong>Note:</strong> There is no need to enable continuous TRIM if you run <code>fstrim</code> periodically. If you want to use TRIM, use either periodic TRIM or continuous TRIM.</p><ul><li>如果您<code>fstrim</code>定期运行，则无需启用连续 TRIM 。如果要使用 TRIM，请使用周期性 TRIM 或连续 TRIM。</li></ul><p>Instead of issuing TRIM commands once in a while (by default once a week if using <code>fstrim.timer</code>), it is also possible to issue TRIM commands each time files are deleted instead. The latter is known as the continuous TRIM.</p><ul><li>除了偶尔发出 TRIM 命令（如果使用<code>fstrim.timer</code>，则默认为每周一次），也可以在每次删除文件时发出 TRIM 命令。后者被称为连续TRIM。</li></ul><p><strong>Warning:</strong> Before <a href="https://en.wikipedia.org/wiki/Serial_ATA#SATA_revision_3.1">SATA 3.1</a> all TRIM commands were non-queued, so continuous trimming would produce frequent system freezes. In this case, applying <a href="https://wiki.archlinux.org/title/Solid_state_drive#Periodic_TRIM">#Periodic TRIM</a> less often is better alternative. Similar issue holds also for a number of devices, see <code>ata_device_blacklist</code> in <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/ata/libata-core.c">Linux source code</a>, for which queued TRIM command execution was blacklisted due to serious data corruption. In such case, depending on the device, the system may be forced to send non-queued TRIM commands the SSD instead of queued TRIM. See <a href="https://en.wikipedia.org/wiki/Trim_(computing)#Disadvantages">Wikipedia:Trim_(computing)#Disadvantages</a> for details.</p><ul><li>在<a href="https://en.wikipedia.org/wiki/Serial_ATA#SATA_revision_3.1">SATA 3.1</a>之前，所有 TRIM 命令都是非排队的，因此连续修剪会产生频繁的系统冻结。在这种情况下，较少应用<a href="https://wiki.archlinux.org/title/Solid_state_drive#Periodic_TRIM">#Periodic TRIM</a>是更好的选择。类似的问题也适用于大量的设备，见<code>ata_device_blacklist</code>在<a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/ata/libata-core.c">Linux的源代码</a>，为此排队TRIM指令的执行被列入黑名单，由于严重的数据损坏。在这种情况下，根据设备，系统可能会被迫向 SSD 发送非排队的 TRIM 命令，而不是排队的 TRIM。有关详细信息，请参阅<a href="https://en.wikipedia.org/wiki/Trim_(computing)#Disadvantages">Wikipedia:Trim_(computing)#Disadvantages</a>。</li></ul><p><strong>Note:</strong> Continuous TRIM is not the most preferred way to issue TRIM commands among the Linux community. For example, Ubuntu enables periodic TRIM by default [<a href="https://askubuntu.com/questions/1034169/is-trim-enabled-on-my-ubuntu-18-04-installation">7]</a>, Debian does not recommend using <a href="https://wiki.debian.org/SSDOptimization#Mounting_SSD_filesystems">continuous TRIM</a> and Red Hat recommends using periodic TRIM over using continuous TRIM if feasible [<a href="https://web.archive.org/web/20160917183831/https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Storage_Administration_Guide/ch02s04.html">8]</a>.</p><ul><li>在 Linux 社区中，连续 TRIM 并不是发布 TRIM 命令的首选方式。例如，Ubuntu 默认启用周期性 TRIM [<a href="https://askubuntu.com/questions/1034169/is-trim-enabled-on-my-ubuntu-18-04-installation">7]</a>，Debian 不建议使用<a href="https://wiki.debian.org/SSDOptimization#Mounting_SSD_filesystems">连续 TRIM</a>，Red Hat 建议在可行的情况下使用周期性 TRIM 而不是使用连续 TRIM [<a href="https://web.archive.org/web/20160917183831/https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Storage_Administration_Guide/ch02s04.html">8]</a>。</li></ul><p>Using the <code>discard</code> option for a mount in <code>/etc/fstab</code> enables continuous TRIM in device operations:</p><ul><li>在 /etc/fstab 中使用挂载的<code>discord</code>选项可在设备操作中启用连续 TRIM：</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/dev/</span>sda1  /           ext4  defaults,discard   <span class="hljs-number">0</span>  <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>Note:</strong> Specifying the discard mount option in <code>/etc/fstab</code> does not work with an XFS <code>/</code> partition. According to <a href="https://bbs.archlinux.org/viewtopic.php?id=143254">this thread</a>, it has to be set using the <code>rootflags=discard</code> <a href="https://wiki.archlinux.org/title/Kernel_parameter">kernel parameter</a>.</p><ul><li>在 /etc/fstab 中指定丢弃挂载选项不适用于 XFS / 分区。 根据这个线程，它必须使用 rootflags=discard 内核参数进行设置。</li></ul><p>On the ext4 filesystem, the <code>discard</code> flag can also be set as a <a href="https://wiki.archlinux.org/title/Access_Control_Lists#Enable_ACL">default mount option</a> using <em>tune2fs</em>:</p><ul><li>在 ext4 文件系统上，<code>discard</code>也可以使用<em>tune2fs</em>将该标志设置为<a href="https://wiki.archlinux.org/title/Access_Control_Lists#Enable_ACL">默认挂载选项</a>：</li></ul><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"># tune2fs -o discard <span class="hljs-regexp">/dev/</span>sdXY<br></code></pre></td></tr></table></figure><p>Using the default mount options instead of an entry in <code>/etc/fstab</code> is particularly useful for external drives, because such partition will be mounted with the default options also on other machines. This way, there is no need to edit <code>/etc/fstab</code> on every machine.</p><ul><li>使用默认挂载选项而不是 <code>/etc/fstab</code> 中的条目对于外部驱动器特别有用，因为这样的分区也将使用默认选项挂载到其他机器上。 这样，无需在每台机器上编辑 <code>/etc/fstab</code>。</li></ul><p><strong>Note:</strong> The default mount options are not listed in <code>/proc/mounts</code>.</p><h2 id="Periodic-TRIM-定期修剪"><a href="#Periodic-TRIM-定期修剪" class="headerlink" title="Periodic TRIM(定期修剪)"></a>Periodic TRIM(定期修剪)</h2><p>The <a href="https://archlinux.org/packages/?name=util-linux">util-linux</a> package provides <code>fstrim.service</code> and <code>fstrim.timer</code> <a href="https://wiki.archlinux.org/title/Systemd">systemd</a> unit files. <a href="https://wiki.archlinux.org/title/Enabling">Enabling</a> the timer will activate the service weekly. The service executes <a href="https://man.archlinux.org/man/fstrim.8">fstrim(8)</a> on all mounted filesystems on devices that support the <em>discard</em> operation.</p><ul><li>所述<a href="https://archlinux.org/packages/?name=util-linux">UTIL Linux的</a>包提供<code>fstrim.service</code>和<code>fstrim.timer</code> <a href="https://wiki.archlinux.org/title/Systemd">systemd</a>单元文件。<a href="https://wiki.archlinux.org/title/Enabling">启用</a>计时器将每周激活服务。该服务在支持<em>丢弃</em>操作的设备上的所有已安装文件系统上执行<a href="https://man.archlinux.org/man/fstrim.8">fstrim(8)</a>。</li></ul><p>The timer relies on the timestamp of <code>/var/lib/systemd/timers/stamp-fstrim.timer</code> (which it will create upon first invocation) to know whether a week has elapsed since it last ran. Therefore there is no need to worry about too frequent invocations, in an <em>anacron</em>-like fashion.</p><ul><li>计时器依赖于<code>/var/lib/systemd/timers/stamp-fstrim.timer</code>（它将在第一次调用时创建）的时间戳来了解自上次运行以来是否已经过去了一周。因此，无需担心以<em>类似 anacron</em>的方式调用过于频繁。</li></ul><p>To query the units activity and status, see <a href="https://wiki.archlinux.org/title/Journalctl">journalctl</a>. To change the periodicity of the timer or the command run, <a href="https://wiki.archlinux.org/title/Edit">edit</a> the provided unit files.</p><ul><li>要查询单位活动和状态，请参阅<a href="https://wiki.archlinux.org/title/Journalctl">journalctl</a>。要更改计时器或命令运行的周期，请<a href="https://wiki.archlinux.org/title/Edit">编辑</a>提供的单元文件。</li></ul><h3 id="fstrim"><a href="#fstrim" class="headerlink" title="fstrim"></a>fstrim</h3><p>util-linux 中自带了 fstrim 工具（Discard unused blocks on a mounted filesystem.），平常用 -a 选项（-a, –all trim all mounted filesystems that are supported）比较多，可以自动检测硬盘是否支持 trim 功能，并在已挂载文件系统上执行 trim。</p><p>使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># sudo fstrim -a -v  </span><br>/:    18.2 GiB (19515346944 bytes) trimmed on /dev/nvme0n1p5<br>/boot/efi: 224.7 MiB (235589632 bytes)  trimmed on /dev/nvme0n1p1<br></code></pre></td></tr></table></figure><p>更多用法查看manpage</p><h2 id="启用-TRIM（fstrim）"><a href="#启用-TRIM（fstrim）" class="headerlink" title="启用 TRIM（fstrim）"></a><strong>启用 TRIM（fstrim）</strong></h2><p>要在 有systemd的系统中启用 TRIM，请在终端中输入以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo systemctl enable fstrim.timer<br></code></pre></td></tr></table></figure><h1 id="释放内存"><a href="#释放内存" class="headerlink" title="释放内存"></a>释放内存</h1><p>Kernels 2.6.16  and newer provide a mechanism to have the kernel drop the page cache  and/or inode and dentry caches on command, which can help free up a lot  of memory.  Now you can throw away that script that allocated a ton of  memory just to get rid of the cache… </p><p>To use <code>/proc/sys/vm/drop_caches</code>, just echo a number to it. </p><p>To free pagecache: </p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"># echo <span class="hljs-number">1</span> &gt; <span class="hljs-regexp">/proc/</span>sys<span class="hljs-regexp">/vm/</span>drop_caches<br></code></pre></td></tr></table></figure><p>To free dentries and inodes: </p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"># echo <span class="hljs-number">2</span> &gt; <span class="hljs-regexp">/proc/</span>sys<span class="hljs-regexp">/vm/</span>drop_caches<br></code></pre></td></tr></table></figure><p>To free pagecache, dentries and inodes: </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">echo <span class="hljs-number">3</span> &gt; <span class="hljs-regexp">/proc/</span>sys<span class="hljs-regexp">/vm/</span>drop_caches<br>echo <span class="hljs-number">3</span> | sudo tee <span class="hljs-regexp">/proc/</span>sys<span class="hljs-regexp">/vm/</span>drop_caches <span class="hljs-regexp">//</span>与上面一个作用<br></code></pre></td></tr></table></figure><p>This is a non-destructive operation and will only free things that are  completely unused.  Dirty objects will continue to be in use until  written out to disk and are not freeable.  If you run “sync” first to  flush them out to disk, these drop operations will tend to free more  memory. </p><h1 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a>日志管理</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo journalctl --disk-usage                #查看日志大小<br>sudo journalctl --vacuum-time=5d                  #超过5天的自动删除<br>sudo journalctl --vacuum-size=500M                #超过500M的自动删除<br>sudo rm /var/lib/systemd/coredump/*             #崩溃日志，文件不多，也不大，删不删随你<br></code></pre></td></tr></table></figure><h2 id="清空-var-log-journal-文件的方法"><a href="#清空-var-log-journal-文件的方法" class="headerlink" title="清空 /var/log/journal 文件的方法"></a>清空 /var/log/journal 文件的方法</h2><p>1、用echo命令，将空字符串内容重定向到指定文件中</p><p>echo “” &gt; system.journal</p><p>说明：此方法只会清空一次，一段时间后还要再次手动清空很麻烦，这里可以用以下命令让journalctl 自动维护空间</p><p>2、journalctl 命令自动维护文件大小</p><p>1）只保留近一周的日志</p><p>journalctl –vacuum-time=1w</p><p>2）只保留500MB的日志</p><p>journalctl –vacuum-size=500M</p><p>3）直接删除 <strong>/var/log/journal/</strong> 目录下的日志文件</p><p>rm -rf /var/log/journal/f9d400c5e1e8c3a8209e990d887d4ac1</p><h2 id="问题与分析解决"><a href="#问题与分析解决" class="headerlink" title="问题与分析解决"></a>问题与分析解决</h2><p>执行 journalctl 命令时报错：Error was encountered while opening journal files: Input/output error</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># journalctl --vacuum-time=1w<br><span class="hljs-built_in">Error</span> was encountered <span class="hljs-keyword">while</span> opening journal files: Input/output error<br></code></pre></td></tr></table></figure><p>问题分析：日志文件损坏</p><p>解决方法：删除之前的日志，并重启 journalctl 服务</p><p>mv journal/f9d400c5e1e8c3a8209e990d887d4ac1 journal/f9d400c5e1e8c3a8209e990d887d4ac1_bk_20190122</p><p>systemctl restart systemd-journald.service</p><p>查看 /var/log/journal/ 日志目录如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">#ll /<span class="hljs-keyword">var</span>/log/journal/<br>drwxr-sr-x  <span class="hljs-number">2</span> root systemd-journal  <span class="hljs-number">4096</span> Jan <span class="hljs-number">22</span> <span class="hljs-number">11</span>:<span class="hljs-number">26</span> f9d400c5e1e8c3a8209e990d887d4ac1<br>drwxr-sr-x+ <span class="hljs-number">2</span> root systemd-journal <span class="hljs-number">12288</span> Jan <span class="hljs-number">14</span> <span class="hljs-number">15</span>:<span class="hljs-number">37</span> f9d400c5e1e8c3a8209e990d887d4ac1_bk_20190122<br></code></pre></td></tr></table></figure><p>然后，再执行 journalctl 限制日志的命令：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># journalctl --vacuum-time=1w<br>Vacuuming done, freed 0B <span class="hljs-keyword">of</span> archived journals on disk.<br># journalctl --vacuum-size=500M<br>Vacuuming done, freed 0B <span class="hljs-keyword">of</span> archived journals on disk.<br></code></pre></td></tr></table></figure><h1 id="pgp密钥管理"><a href="#pgp密钥管理" class="headerlink" title="pgp密钥管理"></a>pgp密钥管理</h1><h2 id="删除密钥"><a href="#删除密钥" class="headerlink" title="删除密钥"></a>删除密钥</h2><p>删除密钥有三个选项：–delete-keys、–delete-secret-keys和–delete-secret-and-public-key。<br>–delete-keys表示从公钥钥匙圈上删除密钥，也就是一同删除公钥和对应的私钥。在分批模式（batch mode）下，密钥必须使用指纹表示，或者使用–yes选项。<br>–delete-secret-keys表示从私钥钥匙圈上删除密钥。<br>–delete-secret-and-public-key和–delete-keys一样，但是如果私钥存在的话，会先移除私钥。在分批模式下，密钥必须使用指纹表示。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs livescript">❯ gpg --<span class="hljs-keyword">list</span>-keys <span class="hljs-comment">#列出自己添加的密钥</span><br><span class="hljs-regexp">/home/kiylx/</span>.gnupg/pubring.kbx<br>------------------------------<br>pub   rsa4096 <span class="hljs-number">2009</span>-<span class="hljs-number">07</span>-<span class="hljs-number">05</span> [SC]<br>      <span class="hljs-number">8</span>C470B2A0B31568E110D432516281F2E007C98D1<br>uid             [ 未知 ] Francois Marier &lt;fmarier@gmail.com&gt;<br>uid             [ 未知 ] Francois Marier &lt;francois@fmarier.org&gt;<br>uid             [ 未知 ] Francois Marier &lt;fmarier@alumni.uwaterloo.ca&gt;<br>uid             [ 未知 ] Francois Marier &lt;francois@debian.org&gt;<br>sub   rsa4096 <span class="hljs-number">2009</span>-<span class="hljs-number">07</span>-<span class="hljs-number">05</span> [E]<br><br>❯ gpg --<span class="hljs-keyword">delete</span>-keys <span class="hljs-number">8</span>C470B2A0B31568E110D432516281F2E007C98D1  <span class="hljs-comment">#删除密钥的公钥和私钥</span><br>gpg (GnuPG) <span class="hljs-number">2.2</span>.<span class="hljs-number">32</span>; Copyright (C) <span class="hljs-number">2021</span> Free Software Foundation, Inc.<br>This <span class="hljs-keyword">is</span> free software: you are free <span class="hljs-keyword">to</span> change <span class="hljs-keyword">and</span> redistribute <span class="hljs-literal">it</span>.<br>There <span class="hljs-keyword">is</span> NO WARRANTY, <span class="hljs-keyword">to</span> the extent permitted <span class="hljs-keyword">by</span> law.<br><br><br>pub  rsa4096/<span class="hljs-number">16281</span>F2E007C98D1 <span class="hljs-number">2009</span>-<span class="hljs-number">07</span>-<span class="hljs-number">05</span> Francois Marier &lt;fmarier@gmail.com&gt;<br><br>要从钥匙环里删除这个密钥吗？(y/N) y<br><br></code></pre></td></tr></table></figure><h1 id="plasmashell"><a href="#plasmashell" class="headerlink" title="plasmashell"></a>plasmashell</h1><p><strong>可以直接在<code>krunner</code>中运行按 <code>alt+F2 </code>打开<code> krunner</code>。</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># kde4</span><br>killall plasmashell &amp;&amp; kstart plasmashell<br>kquitapp5 plasmashell &amp;&amp; kstart plasmashell<br><span class="hljs-comment"># kde5</span><br>killall plasmashell &amp;&amp; kstart5 plasmashell<br>kquitapp5 plasmashell &amp;&amp; kstart5 plasmashell<br></code></pre></td></tr></table></figure><h2 id="重启plasmashell脚本"><a href="#重启plasmashell脚本" class="headerlink" title="重启plasmashell脚本"></a>重启plasmashell脚本</h2><h3 id="脚本文件内容"><a href="#脚本文件内容" class="headerlink" title="脚本文件内容"></a>脚本文件内容</h3><p>具体内容：</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs d">#bash<br><br><span class="hljs-meta">#! /bin/bash</span><br>kquitapp5 plasmashell &amp;&amp; kstart5 plasmashell<br></code></pre></td></tr></table></figure><ul><li>命名：restart_kde，注意，没有后缀名</li></ul><hr><h1 id="脚本放进环境变量（以上面kde-restart为例）"><a href="#脚本放进环境变量（以上面kde-restart为例）" class="headerlink" title="脚本放进环境变量（以上面kde_restart为例）"></a>脚本放进环境变量（以上面kde_restart为例）</h1><h2 id="赋权"><a href="#赋权" class="headerlink" title="赋权"></a>赋权</h2><p>使用文本工具或者<code>vim</code>进行编写，编写完成后对其进行运行权限的赋权：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">sudo chmod +<span class="hljs-keyword">x</span> restart_kde<br></code></pre></td></tr></table></figure><h2 id="复制至bin文件夹"><a href="#复制至bin文件夹" class="headerlink" title="复制至bin文件夹"></a>复制至bin文件夹</h2><p>将脚本文件移至<code>path</code>中指定的系统变量路径，可放至<code>/usr/local/sbin</code>、<code>/usr/local/bin</code>，<code>/usr/bin</code>中。</p><p>移动命令：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo cp restart_kde <span class="hljs-regexp">/usr/</span>bin<br></code></pre></td></tr></table></figure><h2 id="除了系统目录，也可以自己创建存放脚本的目录"><a href="#除了系统目录，也可以自己创建存放脚本的目录" class="headerlink" title="除了系统目录，也可以自己创建存放脚本的目录"></a><strong>除了系统目录，也可以自己创建存放脚本的目录</strong></h2><h3 id="复制至自定义目录"><a href="#复制至自定义目录" class="headerlink" title="复制至自定义目录"></a>复制至自定义目录</h3><p>1.在任意位置创建任意目录：比如<code>~/存档/Linux/bin </code></p><p>2.然后修改环境变量<code>export PATH=$PATH:路径</code></p><ul><li><p>bash</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#m打开.bashrc文件</span><br>nano ~/.bashrc<br>添加下面一行<br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">PATH</span>=<span class="hljs-variable">$PATH</span>:~/存档/Linux/bin<br></code></pre></td></tr></table></figure></li><li><p>zsh</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#打开.zshrc文件</span><br>nano ~/.zshrc<br>添加下面一行<br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">PATH</span>=<span class="hljs-variable">$PATH</span>:~/存档/Linux/bin<br></code></pre></td></tr></table></figure></li></ul><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><ul><li>用<code>KRunner</code>，<code>Alt</code>+<code>Space</code>唤醒，确保<code>KRunner</code>拥有执行命令的功能</li><li>输入<code>restart_kde</code>即可</li></ul><h1 id="安装多个JDK时"><a href="#安装多个JDK时" class="headerlink" title="安装多个JDK时"></a>安装多个<code>JDK</code>时</h1><p>我这里先安装的 <code>jdk8-openjdk</code>，后安装 <code>jdk16</code></p><p><code>sudo pacman -S jdk-openjdk </code>默认就是16版本</p><p>安装 <code>jdk16</code>时提示：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Default</span> Java environment <span class="hljs-keyword">is</span> already <span class="hljs-keyword">set</span> <span class="hljs-keyword">to</span> <span class="hljs-string">&#x27;java-8-openjdk&#x27;</span><br>See <span class="hljs-string">&#x27;archlinux-java help&#x27;</span> <span class="hljs-keyword">to</span> change it<br><span class="hljs-keyword">when</span> you use a non-reparenting <span class="hljs-keyword">window</span> manager,<br><span class="hljs-keyword">set</span> _JAVA_AWT_WM_NONREPARENTING=<span class="hljs-number">1</span> <span class="hljs-keyword">in</span> /etc/profile.d/jre.sh<br></code></pre></td></tr></table></figure><h2 id="切换-JDK-版本"><a href="#切换-JDK-版本" class="headerlink" title="切换 JDK 版本"></a>切换 <code>JDK</code> 版本</h2><h2 id="使用archlinux-java命令切换JDK-版本"><a href="#使用archlinux-java命令切换JDK-版本" class="headerlink" title="使用archlinux-java命令切换JDK 版本"></a>使用<code>archlinux-java</code>命令切换<code>JDK</code> 版本</h2><p><code>archlinux-java help</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">archlinux-java &lt;COMMAND&gt;<br><br>COMMAND:<br>    status      List installed Java environments and enabled one<br>    get     Return the short name of the Java environment <span class="hljs-built_in">set</span> as default<br>    <span class="hljs-built_in">set</span> &lt;JAVA_ENV&gt;  Force &lt;JAVA_ENV&gt; as default<br>    <span class="hljs-built_in">unset</span>       Unset current default Java environment<br>    fix     Fix an invalid/broken default Java environment configuration<br></code></pre></td></tr></table></figure><h3 id="set-lt-JAVA-ENV-gt-就是设置默认环境的方法"><a href="#set-lt-JAVA-ENV-gt-就是设置默认环境的方法" class="headerlink" title="set &lt;JAVA_ENV&gt; 就是设置默认环境的方法"></a><code>set &lt;JAVA_ENV&gt;</code> 就是设置默认环境的方法</h3><ul><li>set 之前</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -version                                                                            1 ↵ ──(六,10月09)─┘<br>openjdk version <span class="hljs-string">&quot;1.8.0_292&quot;</span><br>OpenJDK Runtime Environment (build 1.8.0_292-b10)<br>OpenJDK 64-Bit Server VM (build 25.292-b10, mixed mode)<br></code></pre></td></tr></table></figure><ul><li>set之后</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -version                                                                                ──(六,10月09)─┘<br>openjdk version <span class="hljs-string">&quot;16.0.2&quot;</span> 2021-07-20<br>OpenJDK Runtime Environment (build 16.0.2+7)<br>OpenJDK 64-Bit Server VM (build 16.0.2+7, mixed mode)<br></code></pre></td></tr></table></figure><h1 id="ranger"><a href="#ranger" class="headerlink" title="ranger"></a>ranger</h1><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ol><li><p>配置文件</p><p>首先复制配置文件到主目录:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs none">ranger --copy-config=all<br></code></pre></td></tr></table></figure></li></ol><p>然后自己到~/.config/ranger中配置各种选项即可</p><ol start="2"><li><p>配置ranger<br>在～/.config/ranger中有ranger的配置文件.<br>找到文件<code>scope.sh</code>中, 在externsions部分注释掉不想预览的文件类型, 在那行上面添加”#”注释掉即可. ranger在预览rar等压缩包时会运行得比较慢.<br><code>rc.conf</code>保存着快捷键的说明</p></li><li><p>自动挂载U盘等外部存储位置,需要安装usbmount:</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs none">sudo apt-get install usbmount<br>sudo vim /etc/usbmount/usbmount.conf<br></code></pre></td></tr></table></figure><p>在<code>MOUNTOPTIONS</code>那行添加<code>user</code>即可使普通用户也对挂载的U盘拥有写权限, 如下:<br><code>MOUNTOPTIOS=&quot;rw,user,noatime,nodiratime&quot; </code></p><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p>下面列出常用操作的快捷键</p><p>?  查看帮助</p><h3 id="浏览"><a href="#浏览" class="headerlink" title="浏览:"></a>浏览:</h3><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs maxima">H   后退<br>L   前进<br>gg  跳到顶端<br>G   跳到底端<br>gh  <span class="hljs-built_in">go</span> home<br><span class="hljs-built_in">gn</span>  新建标签<br>f   查找<br>/   搜素<br>g   快速进入目录<br></code></pre></td></tr></table></figure><h3 id="编辑"><a href="#编辑" class="headerlink" title="编辑:"></a>编辑:</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css">space   选择<br>uv      取消选择<br><br>yy      复制<br><span class="hljs-selector-tag">dd</span>      剪切<br>pp      粘贴<br>delete  删除<br>cw      重命名<br><span class="hljs-selector-tag">A</span>       在当前名称基础上重命名<br><span class="hljs-selector-tag">I</span>       类似<span class="hljs-selector-tag">A</span>, 但是光标会跳到起始位置<br>Ctrl-f  向下翻页<br>Ctrl-<span class="hljs-selector-tag">b</span>  向上翻页<br></code></pre></td></tr></table></figure><h3 id="书签"><a href="#书签" class="headerlink" title="书签:"></a>书签:</h3><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">m       新建书签<br>`       打开书签<br>um      删除书签<br></code></pre></td></tr></table></figure><h3 id="标签"><a href="#标签" class="headerlink" title="标签:"></a>标签:</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">gn / C-n        新建标签<br>TAB / S-TAB     切换标签<br><span class="hljs-selector-tag">A</span>-<span class="hljs-attribute">Right</span>, <span class="hljs-selector-tag">A</span>-<span class="hljs-attribute">Left</span> 切换标签<br>gc / C-w        关闭标签<br></code></pre></td></tr></table></figure><h3 id="排序"><a href="#排序" class="headerlink" title="排序:"></a>排序:</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">on</span>/ob   根据文件名进行排序(<span class="hljs-keyword">natural</span>/basename)<br>oc      根据改变时间进行排序 (Change <span class="hljs-type">Time</span> 文件的权限组别和文件自身数据被修改的时间)<br>os      根据文件大小进行排序(Size)<br>ot      根据后缀名进行排序 (<span class="hljs-keyword">Type</span>)<br><br>oa      根据访问时间进行排序 (<span class="hljs-keyword">Access</span> <span class="hljs-type">Time</span> 访问文件自身数据的时间)<br>om      根据修改进行排序 (Modify <span class="hljs-type">time</span> 文件自身内容被修改的时间)<br></code></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他:"></a>其他:</h3><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-built_in">zh</span>      显示隐藏文件<br><br>zp      打开/关闭文件预览功能<br>zP      打开目录预览功能<br></code></pre></td></tr></table></figure><h3 id="链接-Link"><a href="#链接-Link" class="headerlink" title="链接(Link):"></a>链接(Link):</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">pl</span>      粘贴绝对路径的链接<br><span class="hljs-keyword">pL</span>      粘贴相对路径的链接<br>phl     硬链接<br></code></pre></td></tr></table></figure><h3 id="批量改名"><a href="#批量改名" class="headerlink" title="批量改名:"></a>批量改名:</h3><p>批量选择文件后, 键入命令:bulkname, 会打开编辑器, 其中的文件名编辑后保存退出, 再次打开操作确认编辑, 然后就批量改名了, 如果想取消批量改名, 在确认时把文件内容删除即可.</p><h3 id="任务管理"><a href="#任务管理" class="headerlink" title="任务管理:"></a>任务管理:</h3><p>在执行某些操作(比如复制一个大文件)时不能立即完成, 这在 ranger 中就是一个任务. 你可以停止, 启动某个任务, 也可以对某个任务设置优先级.</p><p>w: 打开/关闭任务视图. 在w打开的任务视图中:<br>    dd: 终止一个任务<br>    J: 降低当前任务的优先级<br>    K: 提升当前任务的优先级</p><h3 id="其他-1"><a href="#其他-1" class="headerlink" title="其他:"></a>其他:</h3><ul><li><p>zf      过滤器(如过滤pdf文件, zf+pdf,回车) S       在当前目录打开终端 z(*)    改变设置, <em>表示在弹出选项中的选择 o(</em>)    改变排序方式 ! / s   使用shell命令(！shell -w ls -hl %s,%s代表当前被选中的文件)</p><p>使用ranger命令(3? 查看可用命令) :set colorscheme snow 设置颜色模式</p></li></ul><h2 id="快速预览"><a href="#快速预览" class="headerlink" title="快速预览"></a>快速预览</h2><p>安装以下程序可以实现快速预览:</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-built_in">elinks,</span> html<br><span class="hljs-built_in">highlight,</span>text/code<br><span class="hljs-built_in">img2txt,</span>image<br><span class="hljs-built_in">atool,</span>压缩包<br><span class="hljs-built_in">pdf2text,</span>pdf<br><span class="hljs-built_in">medinfo,</span>audio/video<br></code></pre></td></tr></table></figure><hr><h1 id="字体调整"><a href="#字体调整" class="headerlink" title="字体调整"></a>字体调整</h1><p><strong>提示：</strong> 中文用户在安装思源cjk全集或者noto-cjk全集后，部分文字显示为日文异形字体，可参看<a href="https://wiki.archlinux.org/title/Arch_Linux_Localization_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E4%BF%AE%E6%AD%A3%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%E6%98%BE%E7%A4%BA%E4%B8%BA%E5%BC%82%E4%BD%93%EF%BC%88%E6%97%A5%E6%96%87%EF%BC%89%E5%AD%97%E5%BD%A2">Arch Linux Localization (简体中文)#修正简体中文显示为异体（日文）字形</a> 进行解决。</p><h2 id="字体安装和配置"><a href="#字体安装和配置" class="headerlink" title="字体安装和配置"></a>字体安装和配置</h2><p><code>noto-fonts-cjk</code>-Google Noto CJK 字体， 提供简体中文、繁体中文、日文、韩文一致的设计和外观。它是基于是<code>adobe-source-han-sans-otc-fonts</code>重贴的商标。所以选择一个安装。</p><h2 id="安装的字体"><a href="#安装的字体" class="headerlink" title="安装的字体"></a>安装的字体</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vim">例如<br>sudo pacman -S ttf-roboto noto-fonts ttf-dejavu<br>文泉驿<br>sudo pacman -S wqy-bitmapfont wqy-microhei wqy-microhei-lite wqy-zenhei <br>思源字体<br>sudo pacman -S adobe-<span class="hljs-keyword">source</span>-han-sans-<span class="hljs-keyword">cn</span>-fonts adobe-<span class="hljs-keyword">source</span>-han-serif-<span class="hljs-keyword">cn</span>-fonts<br></code></pre></td></tr></table></figure><ul><li><p>思源字体（不安装cjk版本，仅安装cn版本，避免火狐异体字问题）：</p><ul><li><code>adobe-source-han-serif-cn-fonts</code></li><li><code>adobe-source-han-sans-cn-fonts</code></li></ul></li><li><p>文泉驿正黑</p><ul><li><a href="https://archlinux.org/packages/?name=wqy-zenhei">wqy-zenhei</a> - 文泉驿正黑体，黑体 (无衬线) 的中文轮廓字体，附带文泉驿点阵宋体 (也支持部分日韩字符)。</li><li><a href="https://archlinux.org/packages/?name=wqy-bitmapfont">wqy-bitmapfont</a> - 文泉驿点阵宋体 (衬线) 中文字体。</li></ul></li><li><p>文泉驿微米黑</p><ul><li><a href="https://archlinux.org/packages/?name=wqy-microhei">wqy-microhei</a> - 文泉驿微米黑，无衬线形式字体。</li><li><a href="https://archlinux.org/packages/?name=wqy-microhei-lite">wqy-microhei-lite</a> - 文泉驿微米黑light版（笔画更细）。</li></ul></li><li><p>windows字体</p></li></ul><p>​        把windows的字体复制到<code>~/.local/share/fonts/WindowsFonts</code>目录下</p><h2 id="配置font"><a href="#配置font" class="headerlink" title="配置font"></a>配置font</h2><ul><li>修改<code>~/.config/fontconfig/fonts.conf</code>配置文件</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><code class="hljs xml">原理就是把某些符合条件的字体请求映射到我们定义的字体<br><span class="hljs-meta">&lt;?xml version=&#x27;1.0&#x27;?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">fontconfig</span> <span class="hljs-meta-keyword">SYSTEM</span> <span class="hljs-meta-string">&#x27;urn:fontconfig:fonts.dtd&#x27;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">fontconfig</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">dir</span>&gt;</span>~/.fonts<span class="hljs-tag">&lt;/<span class="hljs-name">dir</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">dir</span>&gt;</span>~/.local/share/fonts/<span class="hljs-tag">&lt;/<span class="hljs-name">dir</span>&gt;</span><br> <span class="hljs-comment">&lt;!-- </span><br><span class="hljs-comment"> Artificial oblique for fonts without an italic or oblique version</span><br><span class="hljs-comment"> --&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">match</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;font&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- check to see if the font is roman --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">test</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;slant&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">const</span>&gt;</span>roman<span class="hljs-tag">&lt;/<span class="hljs-name">const</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">test</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- check to see if the pattern requested non-roman --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">test</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;pattern&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;slant&quot;</span> <span class="hljs-attr">compare</span>=<span class="hljs-string">&quot;not_eq&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">const</span>&gt;</span>roman<span class="hljs-tag">&lt;/<span class="hljs-name">const</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">test</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- multiply the matrix to slant the font --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">edit</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;matrix&quot;</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">&quot;assign&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">times</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>matrix<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">matrix</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">double</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">double</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">double</span>&gt;</span>0.2<span class="hljs-tag">&lt;/<span class="hljs-name">double</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">double</span>&gt;</span>0<span class="hljs-tag">&lt;/<span class="hljs-name">double</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">double</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">double</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">matrix</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">times</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">edit</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- pretend the font is oblique now --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">edit</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;slant&quot;</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">&quot;assign&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">const</span>&gt;</span>oblique<span class="hljs-tag">&lt;/<span class="hljs-name">const</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">edit</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- and disable embedded bitmaps for artificial oblique --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">edit</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;embeddedbitmap&quot;</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">&quot;assign&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">bool</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">bool</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">edit</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">match</span>&gt;</span><br> <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment"> Synthetic emboldening for fonts that do not have bold face available</span><br><span class="hljs-comment"> --&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">match</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;font&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- check to see if the weight in the font is less than medium which possibly need emboldening --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">test</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;weight&quot;</span> <span class="hljs-attr">compare</span>=<span class="hljs-string">&quot;less_eq&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">const</span>&gt;</span>medium<span class="hljs-tag">&lt;/<span class="hljs-name">const</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">test</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- check to see if the pattern requests bold --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">test</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;pattern&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;weight&quot;</span> <span class="hljs-attr">compare</span>=<span class="hljs-string">&quot;more_eq&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">const</span>&gt;</span>bold<span class="hljs-tag">&lt;/<span class="hljs-name">const</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">test</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">  set the embolden flag</span><br><span class="hljs-comment">  needed for applications using cairo, e.g. gucharmap, gedit, ...</span><br><span class="hljs-comment">--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">edit</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;embolden&quot;</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">&quot;assign&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">bool</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">bool</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">edit</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment"> set weight to bold</span><br><span class="hljs-comment"> needed for applications using Xft directly, e.g. Firefox, ...</span><br><span class="hljs-comment">--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">edit</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;weight&quot;</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">&quot;assign&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">const</span>&gt;</span>bold<span class="hljs-tag">&lt;/<span class="hljs-name">const</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">edit</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">match</span>&gt;</span><br> <span class="hljs-comment">&lt;!--   自定义开始--&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">match</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;font&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">edit</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;embeddedbitmap&quot;</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">&quot;assign&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">bool</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">bool</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">edit</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">match</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">match</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">test</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;family&quot;</span> <span class="hljs-attr">qual</span>=<span class="hljs-string">&quot;any&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>serif<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">test</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">edit</span> <span class="hljs-attr">binding</span>=<span class="hljs-string">&quot;strong&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;family&quot;</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">&quot;prepend&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>Noto Serif<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">edit</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">match</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">match</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;pattern&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">test</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;family&quot;</span> <span class="hljs-attr">qual</span>=<span class="hljs-string">&quot;any&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>sans-serif<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">test</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">edit</span> <span class="hljs-attr">binding</span>=<span class="hljs-string">&quot;strong&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;family&quot;</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">&quot;prepend&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>Roboto<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">edit</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">match</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">match</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;pattern&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">test</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;family&quot;</span> <span class="hljs-attr">qual</span>=<span class="hljs-string">&quot;any&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>monospace<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">test</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">edit</span> <span class="hljs-attr">binding</span>=<span class="hljs-string">&quot;strong&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;family&quot;</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">&quot;prepend&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>DejaVu Sans Mono<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">edit</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">match</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">match</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">test</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lang&quot;</span> <span class="hljs-attr">compare</span>=<span class="hljs-string">&quot;contains&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>zh<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">test</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">test</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;family&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>serif<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">test</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">edit</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;family&quot;</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">&quot;prepend&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>Source Han Serif CN<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">edit</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">match</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">match</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">test</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lang&quot;</span> <span class="hljs-attr">compare</span>=<span class="hljs-string">&quot;contains&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>zh<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">test</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">test</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;family&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>sans-serif<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">test</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">edit</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;family&quot;</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">&quot;prepend&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>Source Han Sans CN<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">edit</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">match</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">match</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">test</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lang&quot;</span> <span class="hljs-attr">compare</span>=<span class="hljs-string">&quot;contains&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>zh<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">test</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">test</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;family&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>monospace<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">test</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">edit</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;family&quot;</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">&quot;prepend&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>WenQuanYi Micro Hei Mono<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">edit</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">match</span>&gt;</span><br> <span class="hljs-comment">&lt;!--WenQuanYi Zen Hei -&gt; WenQuanYi Micro Hei --&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">match</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;pattern&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">test</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;family&quot;</span> <span class="hljs-attr">qual</span>=<span class="hljs-string">&quot;any&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>WenQuanYi Zen Hei<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">test</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">edit</span> <span class="hljs-attr">binding</span>=<span class="hljs-string">&quot;same&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;family&quot;</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">&quot;assign&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>WenQuanYi Micro Hei<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">edit</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">match</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">match</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;pattern&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">test</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;family&quot;</span> <span class="hljs-attr">qual</span>=<span class="hljs-string">&quot;any&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>WenQuanYi Zen Hei Lite<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">test</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">edit</span> <span class="hljs-attr">binding</span>=<span class="hljs-string">&quot;same&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;family&quot;</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">&quot;assign&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>WenQuanYi Micro Hei Lite<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">edit</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">match</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">match</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;pattern&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">test</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;family&quot;</span> <span class="hljs-attr">qual</span>=<span class="hljs-string">&quot;any&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>WenQuanYi Zen Hei Mono<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">test</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">edit</span> <span class="hljs-attr">binding</span>=<span class="hljs-string">&quot;same&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;family&quot;</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">&quot;assign&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>WenQuanYi Micro Hei Mono<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">edit</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">match</span>&gt;</span><br> <span class="hljs-comment">&lt;!--   自定义结束--&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">match</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;font&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">edit</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hinting&quot;</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">&quot;assign&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">bool</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">bool</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">edit</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">match</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">match</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;font&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">edit</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hintstyle&quot;</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">&quot;assign&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">const</span>&gt;</span>hintslight<span class="hljs-tag">&lt;/<span class="hljs-name">const</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">edit</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">match</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">fontconfig</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h2 id="修正简体中文显示为异体（日文）字形"><a href="#修正简体中文显示为异体（日文）字形" class="headerlink" title="修正简体中文显示为异体（日文）字形"></a>修正简体中文显示为异体（日文）字形</h2><ul><li><p>上面安装了windows字体，要禁用或删除windows字体中的<code>Candara</code>字体，因为它会显示异体字。</p><hr></li></ul><p>安装的 Noto Sans CJK 或 <a href="https://archlinux.org/packages/?name=adobe-source-han-sans-otc-fonts">adobe-source-han-sans-otc-fonts</a>（思源黑体）或 <a href="https://archlinux.org/packages/?name=adobe-source-han-serif-otc-fonts">adobe-source-han-serif-otc-fonts</a>（思源宋体）后，在某些情况下（框架未定义地区）汉字字形与标准形态不符，例如门、关、复等字字形与规范中文不符。</p><p>这是因为每个程序中可以设置不同的默认字体，比如 Arial 或者 Tohamo，而这些字体的属性由 <a href="https://wiki.archlinux.org/title/Fontconfig_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">fontconfig</a> 控制，其使用顺序是据地区代码以 A-Z 字母表顺序成默认排序，由于 <code>ja-JP</code> 在 <code>zh_&#123;CN,HK,SG,TW&#125;</code> 之前，故优先显示日文字形。</p><p><strong>提示：</strong> Chromium/Chrome/Firefox 浏览器的设置中可单独设置字体，例如将字体选项调成 Noto xxx CJK SC。</p><p>可选用以下方法解决（以简体中文为例）：</p><ul><li><p>只安装 cjk 中的简体中文字体，例如思源黑体简体中文包 <a href="https://archlinux.org/packages/?name=adobe-source-han-sans-cn-fonts">adobe-source-han-sans-cn-fonts</a>、<a href="https://archlinux.org/packages/?name=adobe-source-han-serif-cn-fonts">adobe-source-han-serif-cn-fonts</a> 或者 <a href="https://aur.archlinux.org/packages/noto-fonts-sc/">noto-fonts-sc</a>AUR。</p></li><li><p>在 <code>locale.conf</code> 中添加 <code>LANG=zh_CN.UTF-8</code>，以将简体中文设置为默认语言。由于对 <a href="https://wiki.archlinux.org/title/Locale_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">Locale</a> 定义了框架内地区（即 CJK 优先度），使得默认的优先级被忽略。</p></li><li><p>手动调整优先级，将中文字形调整到日文字形之前。[<a href="https://tieba.baidu.com/p/4879946717">3]</a>在 <code>/etc/fonts/conf.d/</code> 或 <code>/etc/fonts/conf.avail/</code> 下创建文件，例如 <code>64-language-selector-prefer.conf</code>，也可以修改或创建 <code>~/.fonts.conf</code>或在<code>~/.config/fontconfig/conf.d/</code>创建后缀为.conf的文件（仅对该用户生效）。例如针对<a href="https://archlinux.org/packages/?name=noto-fonts-cjk">noto-fonts-cjk</a>的规则，写入：</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">fontconfig</span> <span class="hljs-meta-keyword">SYSTEM</span> <span class="hljs-meta-string">&quot;fonts.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">fontconfig</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">alias</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">family</span>&gt;</span>sans-serif<span class="hljs-tag">&lt;/<span class="hljs-name">family</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">prefer</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">family</span>&gt;</span>Noto Sans CJK SC<span class="hljs-tag">&lt;/<span class="hljs-name">family</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">family</span>&gt;</span>Noto Sans CJK TC<span class="hljs-tag">&lt;/<span class="hljs-name">family</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">family</span>&gt;</span>Noto Sans CJK JP<span class="hljs-tag">&lt;/<span class="hljs-name">family</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">prefer</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">alias</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">alias</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">family</span>&gt;</span>monospace<span class="hljs-tag">&lt;/<span class="hljs-name">family</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">prefer</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">family</span>&gt;</span>Noto Sans Mono CJK SC<span class="hljs-tag">&lt;/<span class="hljs-name">family</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">family</span>&gt;</span>Noto Sans Mono CJK TC<span class="hljs-tag">&lt;/<span class="hljs-name">family</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">family</span>&gt;</span>Noto Sans Mono CJK JP<span class="hljs-tag">&lt;/<span class="hljs-name">family</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">prefer</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">alias</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">fontconfig</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果安装的是 <a href="https://archlinux.org/packages/?name=adobe-source-han-sans-otc-fonts">adobe-source-han-sans-otc-fonts</a>，写入：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">fontconfig</span> <span class="hljs-meta-keyword">SYSTEM</span> <span class="hljs-meta-string">&quot;fonts.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">fontconfig</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">alias</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">family</span>&gt;</span>sans-serif<span class="hljs-tag">&lt;/<span class="hljs-name">family</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">prefer</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">family</span>&gt;</span>Source Han Sans SC<span class="hljs-tag">&lt;/<span class="hljs-name">family</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">family</span>&gt;</span>Source Han Sans TC<span class="hljs-tag">&lt;/<span class="hljs-name">family</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">family</span>&gt;</span>Source Han Sans HW<span class="hljs-tag">&lt;/<span class="hljs-name">family</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">family</span>&gt;</span>Source Han Sans K<span class="hljs-tag">&lt;/<span class="hljs-name">family</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">prefer</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">alias</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">alias</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">family</span>&gt;</span>monospace<span class="hljs-tag">&lt;/<span class="hljs-name">family</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">prefer</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">family</span>&gt;</span>Source Han Sans SC<span class="hljs-tag">&lt;/<span class="hljs-name">family</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">family</span>&gt;</span>Source Han Sans TC<span class="hljs-tag">&lt;/<span class="hljs-name">family</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">family</span>&gt;</span>Source Han Sans HW<span class="hljs-tag">&lt;/<span class="hljs-name">family</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">family</span>&gt;</span>Source Han Sans K<span class="hljs-tag">&lt;/<span class="hljs-name">family</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">prefer</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">alias</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">fontconfig</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注意，如果你是在 <code>/etc/fonts/conf.avail</code> 目录下创建的 xml 文件，则将该 xml 文件软链接到 <code>/etc/fonts/conf.d</code> 下，例如：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"># ln -s <span class="hljs-regexp">/etc/</span>fonts<span class="hljs-regexp">/conf.avail/</span><span class="hljs-number">64</span>-language-selector-prefer.conf <span class="hljs-regexp">/etc/</span>fonts<span class="hljs-regexp">/conf.d/</span><span class="hljs-number">64</span>-language-selector-prefer.conf<br></code></pre></td></tr></table></figure><p>然后更新字体缓存即可生效：</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># fc-cache -fv</span><br></code></pre></td></tr></table></figure><p>执行以下命令检查，如果出现 <code>NotoSansCJK-Regular.ttc: &quot;Noto Sans CJK SC&quot; &quot;Regular&quot;</code> 则表示设置成功：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"># fc-<span class="hljs-keyword">match</span> -s | <span class="hljs-keyword">grep</span> <span class="hljs-string">&#x27;Noto Sans CJK&#x27;</span><br></code></pre></td></tr></table></figure><h1 id="kde-美化"><a href="#kde-美化" class="headerlink" title="kde 美化"></a>kde 美化</h1><h2 id="安装kde的一些小工具"><a href="#安装kde的一些小工具" class="headerlink" title="安装kde的一些小工具"></a>安装kde的一些小工具</h2><ul><li>kdialog 某些shell脚本会用他显示一些提示信息</li><li>kmousetool 自动点击，解放你的鼠标</li><li>kipi-plugins  是gwenview的插件集合</li></ul><h2 id="安装主题管理"><a href="#安装主题管理" class="headerlink" title="安装主题管理"></a>安装主题管理</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> pacman -S kvantum-qt<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h2 id="主题位置"><a href="#主题位置" class="headerlink" title="主题位置"></a>主题位置</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs awk">AURORAE_DIR=<span class="hljs-string">&quot;$HOME/.local/share/aurorae/themes&quot;</span><span class="hljs-regexp">//</span>窗口装饰元素<br>PLASMA_DIR=<span class="hljs-string">&quot;$HOME/.local/share/plasma/desktoptheme&quot;</span><span class="hljs-regexp">//</span>plasma样式<br>LAYOUT_DIR=<span class="hljs-string">&quot;$HOME/.local/share/plasma/layout-templates&quot;</span><span class="hljs-regexp">//</span>无<br>LOOKFEEL_DIR=<span class="hljs-string">&quot;$HOME/.local/share/plasma/look-and-feel&quot;</span>总体的预览/全局主题<br>SCHEMES_DIR=<span class="hljs-string">&quot;$HOME/.local/share/color-schemes&quot;</span><span class="hljs-regexp">//</span>颜色<br>KVANTUM_DIR=<span class="hljs-string">&quot;$HOME/.config/Kvantum&quot;</span><br>WALLPAPER_DIR=<span class="hljs-string">&quot;$HOME/.local/share/wallpapers&quot;</span><br>   <span class="hljs-variable">$HOME</span><span class="hljs-regexp">/.local/</span>share<span class="hljs-regexp">/icons/</span> <span class="hljs-regexp">//</span>存放鼠标或图标<br><span class="hljs-variable">$HOME</span><span class="hljs-regexp">/.local/</span>share<span class="hljs-regexp">/plasma/</span>plasmoids/ 存放插件<br><span class="hljs-variable">$HOME</span><span class="hljs-regexp">/.local/</span>share<span class="hljs-regexp">/kwin/</span>scripts/  kwin插件<br>以上目录如果没有就自行创建。<br><br>壁纸位置在<span class="hljs-regexp">/home/</span>kiylx<span class="hljs-regexp">/.local/</span>share/wallpapers 更改为此文件夹下的文件就可以改壁纸<br><span class="hljs-number">1</span>.更换登录壁纸 :菜单-系统设置-工作区-工作空间行为-锁屏-外观-接下来选取你喜欢的图片即可<br><span class="hljs-number">2</span>.更换锁屏壁纸 :菜单-系统设置-工作区-工作空间行为-锁屏-外观-接下来选取你喜欢的图片即可<br><span class="hljs-number">3</span>.更换登录屏幕的壁纸：菜单-系统设置-工作区-开机和关机-登录屏幕-接下来选取你喜欢的动画即可<br><span class="hljs-number">4</span>.更换开机动画：菜单-系统设置-工作区-开机和关机-欢迎屏幕<br><span class="hljs-number">5</span>.设置双击打开文件夹，单击选择：菜单-系统设置-工作区-工作空间行为-常规行为-点击行为<br></code></pre></td></tr></table></figure><h2 id="重启plasmashell"><a href="#重启plasmashell" class="headerlink" title="重启plasmashell"></a>重启plasmashell</h2><h3 id="直接杀死并重启"><a href="#直接杀死并重启" class="headerlink" title="直接杀死并重启"></a>直接杀死并重启</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">killall plasmashell    <span class="hljs-comment"># 杀死 kde plasma 的进程</span><br><span class="hljs-comment"># kde4</span><br>kstart plasmashell    <span class="hljs-comment"># 重新启动 plasma 桌面会话</span><br><span class="hljs-comment"># kde5</span><br>kstart5 plasmashell    <span class="hljs-comment"># 重新启动 plasma 桌面会话</span><br></code></pre></td></tr></table></figure><h3 id="退出并重启"><a href="#退出并重启" class="headerlink" title="退出并重启"></a>退出并重启</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">kquitapp5 plasmashell    <span class="hljs-comment"># 退出kde桌面</span><br><span class="hljs-comment"># kde4</span><br>kstart plasmashell    <span class="hljs-comment"># 重新启动 plasma 桌面会话</span><br><span class="hljs-comment"># kde5</span><br>kstart5 plasmashell    <span class="hljs-comment"># 重新启动 plasma 桌面会话</span><br></code></pre></td></tr></table></figure><hr><h2 id="主题推荐"><a href="#主题推荐" class="headerlink" title="主题推荐"></a>主题推荐</h2><h2 id="图标"><a href="#图标" class="headerlink" title="图标"></a>图标</h2><p><a href="https://github.com/PapirusDevelopmentTeam/papirus-icon-theme">papirus-icon</a><br><a href="https://github.com/vinceliuice/Tela-icon-theme">Tela-icon</a><br><a href="https://github.com/Bonandry/adwaita-plus#home-directory-for-kde">adwaita-plus</a><br><a href="https://gitlab.gnome.org/GNOME/adwaita-icon-theme">adwaita</a></p><h2 id="鼠标指针："><a href="#鼠标指针：" class="headerlink" title="鼠标指针："></a>鼠标指针：</h2><p><a href="https://github.com/vinceliuice/McMojave-cursors">mac样式</a></p><h2 id="整体样式"><a href="#整体样式" class="headerlink" title="整体样式"></a>整体样式</h2><ul><li><p>应用商店搜索：materia-kde</p><p><a href="https://github.com/PapirusDevelopmentTeam/materia-kde">materia-kde地址</a></p></li><li><p>gtk样式：orchis</p><p><a href="https://github.com/vinceliuice/Orchis-theme">orchis地址</a></p></li></ul><h2 id="应用程序样式"><a href="#应用程序样式" class="headerlink" title="应用程序样式"></a>应用程序样式</h2><ul><li>更现代化的样式 <a href="https://github.com/Luwx/Lightly">lightly-qt</a></li><li>gnome的样式 <a href="https://github.com/FedoraQt/adwaita-qt">adwaita-qt</a></li></ul><h2 id="dock栏"><a href="#dock栏" class="headerlink" title="dock栏"></a>dock栏</h2><ul><li>latte dock</li></ul><h2 id="顶栏"><a href="#顶栏" class="headerlink" title="顶栏"></a>顶栏</h2><ul><li><p>applet-window-appmenu</p><p>提供了顶栏的全局菜单，比自带的好用</p><p>应用商店搜索<code>plasma5-applets-window-appmenu-git</code></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs subunit">github： https://github.com/psifidotos/applet-window-appmenu<br>调用 sh install.sh安装，安装之前应该查看INSTALLATION.md安装编译环境，但是可以在<br>应用商店查找plasma5-applets-window-appmenu-git，安装别人做好的。<br>构建依赖：<br>[2021<span class="hljs-string">-08</span><span class="hljs-string">-14</span>T22:20:17<span class="hljs-string">+0800</span>] [ALPM] installed plasma5-applets-window-appmenu-git (0.7.1.r0.gcdbc943<span class="hljs-string">-1</span>)<br>[2021<span class="hljs-string">-08</span><span class="hljs-string">-14</span>T22:19:48<span class="hljs-string">+0800</span>] [ALPM] installed extra-cmake-modules (5.84.0<span class="hljs-string">-1</span>)<br>[2021<span class="hljs-string">-08</span><span class="hljs-string">-14</span>T22:19:48<span class="hljs-string">+0800</span>] [ALPM] installed cmake (3.21.1<span class="hljs-string">-1</span>)<br>[2021<span class="hljs-string">-08</span><span class="hljs-string">-14</span>T22:19:47<span class="hljs-string">+0800</span>] [ALPM] installed libuv (1.42.0<span class="hljs-string">-1</span>)<br>[2021<span class="hljs-string">-08</span><span class="hljs-string">-14</span>T22:19:47<span class="hljs-string">+0800</span>] [ALPM] installed jsoncpp (1.9.4<span class="hljs-string">-1</span>)<br>[2021<span class="hljs-string">-08</span><span class="hljs-string">-14</span>T22:19:47<span class="hljs-string">+0800</span>] [ALPM] installed rhash (1.4.2<span class="hljs-string">-1</span>)<br></code></pre></td></tr></table></figure></li><li><p>applet-window-buttons</p><p>提供窗口管理按钮</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">github：https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/psifidotos/</span>applet-window-buttons<br>上面的菜单使用应用商店安装好后，编译环境还没被卸载，可以直接clone这个applet-window-buttons库下来，调用sh install.sh安装这个button插件<br><br></code></pre></td></tr></table></figure></li><li><p><a href="https://github.com/psifidotos/applet-window-title">顶栏显示应用的标题和图标</a></p><p>应用商店自行安装</p><p>或手动安装：</p><p>克隆仓库</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/psifidotos/</span>applet-window-title.git<br></code></pre></td></tr></table></figure><p>由于此插件使用<code>QML</code>编写，所以可以直接使用命令装入插件</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dos"><span class="hljs-built_in">cd</span> applet-window-<span class="hljs-built_in">title</span><br>plasmapkg2 -i .<br></code></pre></td></tr></table></figure></li></ul><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><h3 id="kwin脚本"><a href="#kwin脚本" class="headerlink" title="kwin脚本"></a>kwin脚本</h3><ul><li><p><a href="https://github.com/JoseBahamonde/hide-titles">窗口最大化隐藏窗口顶部</a></p></li><li><p>另一种“神灯”<a href="https://github.com/zzag/kwin-effects-yet-another-magic-lamp/tree/Plasma/5.23">效果</a></p></li></ul><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs vim">git clone http<span class="hljs-variable">s:</span>//github.<span class="hljs-keyword">com</span>/zzag/kwin-effects-yet-another-magic-lamp.git<br><span class="hljs-keyword">cd</span> kwin-effects-yet-another-magic-lamp<br>git branch -<span class="hljs-keyword">a</span> //查看远程分支<br>git checkout Plasma/<span class="hljs-number">5.23</span>    //切换到与kde桌面版本符合的分支<br><span class="hljs-built_in">mkdir</span> build &amp;&amp; <span class="hljs-keyword">cd</span> build<br>cmake .. \<br>    -DCMAKE_BUILD_TYPE=Release \<br>    -DCMAKE_INSTALL_PREFIX=/usr<br><span class="hljs-keyword">make</span><br>sudo <span class="hljs-keyword">make</span> install<br><br><span class="hljs-keyword">ps</span>：卸载<br>查看克隆文件夹里的<br>kwin-effects-yet-another-magic-lamp/build/install_manifest.txt文件，删除文件中记载的位置的文件<br></code></pre></td></tr></table></figure><h3 id="applet"><a href="#applet" class="headerlink" title="applet"></a>applet</h3><ul><li><p>日历插件<code>plasma5-applets-eventcalendar</code>，可直接在应用商店搜索</p><p><a href="https://github.com/Zren/plasma-applet-eventcalendar">github地址</a></p></li></ul><hr><h1 id="ufw防火墙"><a href="#ufw防火墙" class="headerlink" title="ufw防火墙"></a>ufw防火墙</h1><p><a href="https://wiki.archlinux.org/title/Uncomplicated_Firewall#Installation"><strong>archwiki</strong></a></p><h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><ol><li><p>安装<code>gufw</code></p></li><li><p>启动<code>ufw服务</code>，但不要启动<code>iptables服务和ip6tables服务</code>。<code>ufw</code>依赖它，但启动<code>iptables服务和ip6tables服务</code>，会造成冲突。<a href="https://wiki.archlinux.org/title/Uncomplicated_Firewall#Installation">archwiki</a></p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gauss">如果iptables和ip6tables服务是启动的，要禁用并停止他们<br>systemctl <span class="hljs-keyword">disable</span> iptables <span class="hljs-meta">#禁用iptables服务</span><br>systemctl <span class="hljs-keyword">disable</span> ip6tables <span class="hljs-meta">#禁用ip6tables服务</span><br>systemctl <span class="hljs-keyword">stop</span> iptables  <span class="hljs-meta">#停止</span><br>systemctl <span class="hljs-keyword">stop</span> ip6tables <span class="hljs-meta">#他</span><br><br>systemctl start ufw <span class="hljs-meta">#启动ufw服务</span><br>sudo ufw <span class="hljs-keyword">enable</span>     <span class="hljs-meta">#启动ufw</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="额外应用"><a href="#额外应用" class="headerlink" title="额外应用"></a>额外应用</h2><ul><li><p><code>ufw-extras</code></p><p> 添加一些额外的<code>ufw</code>预配置应用程序：</p><p> 预配置文件在<code>/etc/ufw/applications.d</code>文件夹</p></li></ul><p><a href="https://github.com/xyproto/ufw-extras">github地址</a></p>   <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pamac <span class="hljs-keyword">install</span> ufw-extras<br></code></pre></td></tr></table></figure><ul><li><p><code>plasma-firewall</code></p><p> kde设置里查看和管理防火墙</p></li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pamac <span class="hljs-keyword">install</span> plasma-firewall<br></code></pre></td></tr></table></figure><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="1-ERROR-problem-running-ip6tables错误"><a href="#1-ERROR-problem-running-ip6tables错误" class="headerlink" title="1 ERROR: problem running ip6tables错误"></a>1 <code>ERROR: problem running ip6tables</code>错误</h3><ul><li><p>安装<code>iptables-nft</code>替代默认的<code>iptables</code>。链接<a href="https://bbs.archlinux.org/viewtopic.php?id=260168">1</a></p></li><li><p>当然这个问题可以修改配置文件，禁用ipv6解决。 链接<a href="http://tisfeng.com/2017/09/02/%E9%98%B2%E7%81%AB%E5%A2%99%E6%8A%A5%E9%94%99-ERROR-problem-running-ip6tables/">2</a></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo nano /etc/default/ufw<br>把 <span class="hljs-attribute">IPV6</span>=<span class="hljs-literal">yes</span> 改为 <span class="hljs-attribute">IPV6</span>=<span class="hljs-literal">no</span><br></code></pre></td></tr></table></figure></li><li><p>但我觉得可能是启用了ip6tables服务的问题。</p><p>​         因为我遇到这个问题的时候，我还不知道有ip6tables服务，看上面两个博客确实能解决问题。之后看archwiki时提示要禁用iptables服务和ip6tables服务，这时候我才发现我之前只禁用了iptables服务但ip6tables服务一直是启用的。</p></li></ul><h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>   UFW(iptables)规则的匹配基于规则出现的顺序，</p><p>   一旦匹配某个规则，检查便会停止。因此，如果某个规则允许访问TCP端口22(如使用udo ufw allow 22)，<br>   后面另一个规则指示拦截某个IP地址(如使用 ufw deny proto tcp from 202.54.1.1 to any port 22)。<br>   最终，允许访问TCP端口22的规则会被使用，而后一个拦截黑客IP地址 202.54.1.1 却没有被使用。<br>   这都是由于规则的顺序造成的。为避免这类问题，<br>   你需要编辑 /etc/ufw/before.rules文件，<br>   在“# End required lines”之后”Block an IP Address”添加规则。</p>   <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">在/etc/ufw/<span class="hljs-keyword">before</span>.rules文件添加规则之后生效<br><br># <span class="hljs-keyword">End</span> required lines<br><br># Block spammers<br><br>-A ufw-<span class="hljs-keyword">before</span>-<span class="hljs-keyword">input</span> -s <span class="hljs-number">123.125</span><span class="hljs-number">.71</span><span class="hljs-number">.0</span>/<span class="hljs-number">24</span> -j <span class="hljs-keyword">DROP</span><br>-A ufw-<span class="hljs-keyword">before</span>-<span class="hljs-keyword">input</span> -s <span class="hljs-number">220.181</span><span class="hljs-number">.108</span><span class="hljs-number">.0</span>/<span class="hljs-number">24</span> -j <span class="hljs-keyword">DROP</span><br><br>保存并关闭文件。***，让防火墙重新加载配置信息：<br><br>sudo ufw reload<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>manjaro</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Sqlite基本内容</title>
    <link href="/posts/8d2ce9e6/"/>
    <url>/posts/8d2ce9e6/</url>
    
    <content type="html"><![CDATA[<p>本篇文章可以学到以下内容：</p><ul><li>SQLite操作以及SQL基本语法</li><li>Android中的数据库操作（增删改查）</li><li>Android中ContentProvide内容提供者和ContentResolver内容解析者的使用</li></ul><p>项目地址：</p><blockquote><p><a href="https://link.jianshu.com/?t=https://github.com/liaozhoubei/DatabaseContentProvider">https://github.com/liaozhoubei/DatabaseContentProvider</a></p></blockquote><p>学习android的小伙伴们在使用Android的SQLiteDatabase类进行数据库操作的时候总会有一些力不从心，特别是对于初涉数据库的小伙伴来说更是如此。<br>这是因为Android的SQLiteDatabase原本就不是依赖于Android而存在的，而是单独的作为一个个体而存在的，有着自己特有的体系和语言，而这就是SQL语法了。</p><p>关于SQLite数据库的理论知识网上一搜一大片，这里就不多说。SQLite是一个轻量型的数据库，它对于大型数据库来说功能少，因此只需要学习一些通用的SQL语法就能够轻松掌握，而这些SQL语法对于其他的数据库来说也是基本不变化的。</p><p>但SQLite有个缺点，那就是作为轻量级选手的它，如果要保存大量数据会力有不及，因此它在android中适合保存个人设置等没有大量数据的信息。</p><p>好了，下面就是正式学习SQLite了，只有掌握了SQLite，掌握SQL语法，才能对Android中的数据库操作运用自如。</p><h2 id="SQLite的数据类型"><a href="#SQLite的数据类型" class="headerlink" title="SQLite的数据类型"></a>SQLite的数据类型</h2><p>与Java语言一样，SQLite也有其特有的数据类型，当然相比MySQL来说只有5种数据类型算是很少了</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp">NULL：空值相当于Java中的<span class="hljs-literal">null</span><br>INTEGER：带符号的整型，相当于Java中的<span class="hljs-built_in">int</span>型<br>REAL：浮点数字，相当于Java中<span class="hljs-built_in">float</span>/<span class="hljs-built_in">double</span>型<br>TEXT/VARCHAR：字符串文本，相当于Java中String类<br>BLOB：二进制对象，相当于Java中的<span class="hljs-built_in">byte</span>数组，用于存放图片、声音等文件<br></code></pre></td></tr></table></figure><h2 id="Sqlite3中的约束"><a href="#Sqlite3中的约束" class="headerlink" title="Sqlite3中的约束"></a>Sqlite3中的约束</h2><p>SQLite的约束是什么呢？约束就是限定数据库字段的条件，如果有个student数据表，它里面有一个age年龄的属性字段，我们要求数据库保存age这个字段的时候必须有值，不能为空，那么就可以设置为：”age INTEGER NOT NULL”。这句话的意思就是age字段是不能为空的整型</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php">NOT <span class="hljs-literal">NULL</span> ：非空<br>UNIQUE ： 唯一<br>PRIMARY KEY ：主键<br>FOREIGN KEY : 外键<br>CHECK ：条件检查<br><span class="hljs-keyword">DEFAULT</span> : 默认<br></code></pre></td></tr></table></figure><p>创建表，此时可对表里的结构和字段进行约束限定，将约束条件放在需要约束的字段之后</p><h2 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h2><p>数据库是数据库，数据表是存放在数据库中存放信息的容器，这点大家要区分。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css">语法：<br>  create <span class="hljs-selector-tag">table</span> tabname(col1 type1 <span class="hljs-selector-attr">[not null]</span><span class="hljs-selector-attr">[primary key]</span>, col2 type2<span class="hljs-selector-attr">[not null]</span>, ··· )<br>注：<br>    tabname为表名<br>    col1、col2为字段名字<br>    type1、type2为字段类型<br>    在<span class="hljs-selector-attr">[]</span>中的约束条件是可以选的<br></code></pre></td></tr></table></figure><p>例：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">  字段名       类型            长度           约束            说明<br>  <span class="hljs-keyword">id</span>        INTEGER                       主键，自增长       编号<br>  name      VARCHAR           <span class="hljs-number">20</span>            非空            姓名<br>  cid       INTEGER                                        所在班级<br>  age       INTEGER                      大于<span class="hljs-number">18</span>且小于<span class="hljs-number">60</span>     年龄<br>  gender    BIT                          默认为<span class="hljs-number">1</span>，表示男     性别<br>  score     REAL                                           成绩<br><br>create table student(<br>    <span class="hljs-keyword">id</span> INTEGER PRIMARY KEY AUTOINCREMENT,<br>    name VARCHAR(<span class="hljs-number">20</span>) NOT <span class="hljs-literal">NULL</span>,<br>    cid INTEGER,<br>    age INTEGER CHECK(age&gt;<span class="hljs-number">18</span> and age&lt;<span class="hljs-number">60</span>),<br>    gender BIT DEFAULT(<span class="hljs-number">1</span>),<br>    score REAL);<br><br>注：SQL中不区分大小写<br></code></pre></td></tr></table></figure><h2 id="insert插入语句"><a href="#insert插入语句" class="headerlink" title="insert插入语句"></a>insert插入语句</h2><p>数据库的操作无非四大类，增删改查这几种，因此必须要掌握这几种语句，insert增加也就是在数据表中添加信息</p><p>语法</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function">insert <span class="hljs-keyword">into</span> <span class="hljs-title">table1</span>(<span class="hljs-params">field1, field2</span>) <span class="hljs-title">values</span>(<span class="hljs-params">value1, value2</span>)</span>;<br>语法详解，在表名为table1的表的field1和field2字段分别插入value1和value2的值<br></code></pre></td></tr></table></figure><p>例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">给student表中的各个字段插入值<br><span class="hljs-function">insert <span class="hljs-keyword">into</span> <span class="hljs-title">student</span> (<span class="hljs-params">name, cid, age, gender, score</span>) <span class="hljs-title">values</span> (<span class="hljs-params"><span class="hljs-string">&#x27;tom&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">20</span>, <span class="hljs-number">1</span>, <span class="hljs-number">80.0</span></span>)</span>;<br></code></pre></td></tr></table></figure><p>注：其实可以在student后面不带有字段名，即name，cid···等，但如果不携带字段信息但看insert语句就无法直接明了的知道插入的value是给哪个字段赋值</p><h2 id="update更新语句"><a href="#update更新语句" class="headerlink" title="update更新语句"></a>update更新语句</h2><p>语法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp">update table1 <span class="hljs-keyword">set</span> field1=value1 <span class="hljs-keyword">where</span> 范围<br>语法详解：<span class="hljs-keyword">set</span>后面是某个字段要更改的值，<span class="hljs-keyword">where</span>表示限定field1字段<span class="hljs-keyword">value</span>值在某个范围内才需要修改<br><span class="hljs-keyword">set</span>表示要修改哪个字段的值<br><span class="hljs-keyword">where</span>表示修改字段值的范围<br></code></pre></td></tr></table></figure><p>例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">update student <span class="hljs-keyword">set</span> name=<span class="hljs-string">&#x27;jack&#x27;</span> <span class="hljs-keyword">where</span> name=<span class="hljs-string">&#x27;tom&#x27;</span>;<br>将student表中name字段中<span class="hljs-keyword">value</span>为tom的值修改为jack<br></code></pre></td></tr></table></figure><h2 id="select查询语句"><a href="#select查询语句" class="headerlink" title="select查询语句"></a>select查询语句</h2><p>select查询方法可以说是在数据库操作中使用最频繁的操作了，无论是想获取数据还是得知数据库中的信息都必须使用select语句，同时select语句也算得上在SQL语法中最复杂的语句了。</p><p>语法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp">基础查询：<br>    <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> table1 <span class="hljs-keyword">where</span> 范围<br>    语法详解：* 代表通配符，即所有的字段<br>    <span class="hljs-keyword">select</span> col1, col2, col3 <span class="hljs-keyword">from</span> table1 <span class="hljs-keyword">where</span> 范围;<br>    查看col1, col2, col3字段的信息<br><br>    例：<br><br>        <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> name=<span class="hljs-string">&quot;jack&quot;</span><br>        查询student表中名字叫jack的所有字段的信息<br><br>        <span class="hljs-keyword">select</span> id, name, score <span class="hljs-keyword">from</span> student;<br>        查询student表中所有学生的编号、名字、分数<br></code></pre></td></tr></table></figure><p>限制查询：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp">LIMIT关键字<br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> table1 LIMIT <span class="hljs-number">5</span>;<br>查询table1中前<span class="hljs-number">5</span>行中的数据，LIMIT关键字后面加数字可限定返回多少条数据<br>OFFSET关键字<br> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> table1 limit <span class="hljs-number">5</span> offset <span class="hljs-number">5</span>;<br> 查询table1中从第<span class="hljs-number">5</span>行起的<span class="hljs-number">5</span>行数据，OFFSET前面必须有LIMIT限定<br><br>例子：<br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> student limit <span class="hljs-number">5</span>;<br>查询table1中前<span class="hljs-number">5</span>行中的数据<br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> limit <span class="hljs-number">5</span> offset <span class="hljs-number">5</span>;<br>查询table1中从第<span class="hljs-number">5</span>行起的<span class="hljs-number">5</span>行数据<br></code></pre></td></tr></table></figure><p>排序查询：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs csharp">ORDER BY关键字<br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> table1 order <span class="hljs-keyword">by</span> col1;<br>查询table1中所有数据，然后按照col1字段的升序排列（A-Z, <span class="hljs-number">0</span><span class="hljs-number">-9</span>)<br> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> table1 order <span class="hljs-keyword">by</span> col1, col2;<br> 查询table1中所有数据，然后先按照col1字段的排列，然后按照col2字段排序<br><br> 例子：<br>     <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> student order <span class="hljs-keyword">by</span> score;<br>     查询student中所有数据，然后按照score字段的升序排列<br>     <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> student order <span class="hljs-keyword">by</span> name, score;<br>     查询student中所有数据，然后先按照name字段的排列，然后按照score字段排序<br><br> DESC关键字<br> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> student order <span class="hljs-keyword">by</span> name, score DESC;<br> 查询student中所有数据，然后先按照name字段的排列，然后按照name字段降序排序<br> 注：DESC为降序排序，即（Z-A,<span class="hljs-number">9</span><span class="hljs-number">-0</span>)，DESC是DESCENDING缩写。<br>     DESC必须跟着ORDER BY关键字后面；<br>     DESC关键字只应用在直接位于其前面的列名；<br>     与DESC相反的是ASC(即ASCENDING)，在升序排序时可指定ASC，但这一关键字并没什么用处，因为升序是默认的<br></code></pre></td></tr></table></figure><h2 id="where过滤语句"><a href="#where过滤语句" class="headerlink" title="where过滤语句"></a>where过滤语句</h2><p>where是过滤语句，数据会根据where自居的搜索条件进行过滤，一般情况下where跟在insert、delete、update、select后面。这是一个需要值得注意的语句，使用它能够极大的提高查询数据库的效率，而使用delete语句如果不带上过滤语句，则会把数据表中的所有信息删除！</p><p>注：当ORDER BY关键字和where一起使用的时候，ORDER BY应该位于where后面，否则会报错。</p><p>where子句后面跟着的是过滤条件，过滤条件可使用逻辑符号，即&gt;、&lt;、=、!=等等逻辑符号，与计算机通用的逻辑符合并没有什么不同</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs csharp">例子：<br>    <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> score&gt;<span class="hljs-number">70.0</span> ORDER BY name;<br>    查询student表中成绩大于<span class="hljs-number">70</span>分的数据，同时按照名字升序排列<br><br>高级过滤：<br>    AND关键字：必须满足前后两个条件的数据<br>    <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> score&gt;<span class="hljs-number">60</span> <span class="hljs-keyword">and</span> score&lt; <span class="hljs-number">100</span>;<br>    查询student表中成绩大于<span class="hljs-number">60</span>分并且小于<span class="hljs-number">100</span>分的数据<br>    OR关键字：只要满足前后任意一个条件即可<br>    <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> score&gt;<span class="hljs-number">90</span> <span class="hljs-keyword">or</span> score&lt;<span class="hljs-number">70</span>;<br>    查询student表中成绩大于<span class="hljs-number">90</span>分并且或者小于<span class="hljs-number">70</span>分的数据<br><br>    AND和OR连用（<span class="hljs-keyword">and</span>的优先级比<span class="hljs-keyword">or</span>要高，两者连用的时候最后在各自的条件中添加圆括号（）进行分组）<br>    <span class="hljs-keyword">select</span> * <span class="hljs-function"><span class="hljs-keyword">from</span> student <span class="hljs-title">where</span> (<span class="hljs-params">score&gt;<span class="hljs-number">90</span> <span class="hljs-keyword">or</span> score&lt;<span class="hljs-number">70</span></span>) <span class="hljs-title">and</span> (<span class="hljs-params">age&gt;<span class="hljs-number">19</span></span>)</span>;<br><br>    BETWEEN关键字：<br>     <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> score between <span class="hljs-number">70</span> <span class="hljs-keyword">and</span> <span class="hljs-number">80</span>;<br>     查询student表中分数在<span class="hljs-number">70</span>至<span class="hljs-number">80</span>分之间的数据<br><br>    IN关键字：用于指定范围，范围中的每个条件都进行匹配，IN由一组逗号分隔、括在圆括号中的合法值<br>    <span class="hljs-keyword">select</span> * <span class="hljs-function"><span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> name <span class="hljs-title">in</span>(<span class="hljs-params"><span class="hljs-string">&#x27;tom&#x27;</span>, <span class="hljs-string">&#x27;Denesy&#x27;</span></span>)</span>;<br>    查询student表中名字为tom和Denesy的数据<br><br>    注：在指定要匹配值得清单的关键字中，IN和OR功能相当<br>    IN可与<span class="hljs-keyword">and</span>和<span class="hljs-keyword">or</span>等其他操作符使用<br>    IN操作符比一组OR操作符执行快<br>    可以包含其他的SELECT语句<br><br>    NOT关键字：否定其后条件的关键字<br>    <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> <span class="hljs-keyword">not</span> name=<span class="hljs-string">&#x27;tom&#x27;</span>;<br>    获取不包含名字为tom的信息<br>    <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> <span class="hljs-keyword">not</span> score&gt;<span class="hljs-number">80</span>;<br>    获取分数不是大于<span class="hljs-number">80</span>分的信息<br><br>    空值检查：<br>    <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> score <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">null</span>;<br>    查询student表中score字段不为空的信息<br></code></pre></td></tr></table></figure><h2 id="delete删除语句"><a href="#delete删除语句" class="headerlink" title="delete删除语句"></a>delete删除语句</h2><p>语法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp">delete <span class="hljs-keyword">from</span> table1 <span class="hljs-keyword">where</span> 范围<br>语法详解：从table中删除某一范围内的数据（只能一条一条的删除，不能删除某个字段中的值）<br>注：不要漏掉<span class="hljs-keyword">where</span>，否则会清空整个表中的信息<br></code></pre></td></tr></table></figure><p>例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp">delete <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> name=<span class="hljs-string">&#x27;tom&#x27;</span>;<br>从student表中删除名字为tom的信息<br><br>delete <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> score&lt; <span class="hljs-number">90</span>;<br>从student表中删除分数小于<span class="hljs-number">90</span>分的信息<br></code></pre></td></tr></table></figure><h2 id="Android中的数据库操作"><a href="#Android中的数据库操作" class="headerlink" title="Android中的数据库操作"></a>Android中的数据库操作</h2><p>Android中的数据库操作其实只要掌握了上面的SQLite的基本知识，那么就很简单了。<br>首先我们要创建一个类继承自SQLiteOpenHelper，这个类的作用在于创建数据库和数据表。在Android中已经帮我们封装好了创建数据库的方法，因此只要写好创建数据表的语句就好了，而创建数据表的方法是使用原生的SQL语法，仅仅如此就让你不得不学习SQL语法了。</p><p>MyDatabaseHelper代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyDatabaseHelper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SQLiteOpenHelper</span> </span>&#123;<br>    <span class="hljs-comment">// 创建Book数据表语法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String CREATE_BOOK = <span class="hljs-string">&quot;create table Book (&quot;</span><br>            + <span class="hljs-string">&quot;id integer primary key autoincrement, &quot;</span> <br>            + <span class="hljs-string">&quot;author text, &quot;</span><br>            + <span class="hljs-string">&quot;price real, &quot;</span> <br>            + <span class="hljs-string">&quot;pages integer, &quot;</span> <br>            + <span class="hljs-string">&quot;bookname text)&quot;</span>;<br>    <br>    <span class="hljs-comment">// 通过构造方法创建数据库，其中name为数据库名称</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyDatabaseHelper</span><span class="hljs-params">(Context context, String name)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(context, name, <span class="hljs-keyword">null</span>, <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(SQLiteDatabase db)</span> </span>&#123;<br>        <span class="hljs-comment">// 执行创建数据表的语法</span><br>        db.execSQL(CREATE_BOOK);<br>    &#125;<br>···<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数据库操作类"><a href="#数据库操作类" class="headerlink" title="数据库操作类"></a>数据库操作类</h3><p>为了方便大家阅读，这里将数据库操作都封装到一个类中，同时，将原本需要从外部传入的数据也直接在类中写入。<br>代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BookDao</span> &#123;<br>    <span class="hljs-keyword">private</span> MyDatabaseHelper helper;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BookDao</span>(<span class="hljs-params">Context context</span>)</span> &#123;<br>        helper = <span class="hljs-keyword">new</span> MyDatabaseHelper(context, <span class="hljs-string">&quot;BookStore.db&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 添加数据到Book表中        </span><br><span class="hljs-comment">     * @return    返回新插入的行号，如果插入失败返回-1</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">long</span> <span class="hljs-title">addData</span>(<span class="hljs-params"></span>)</span> &#123;<br>        SQLiteDatabase database = helper.getReadableDatabase();<br>        <span class="hljs-comment">// 使用anddroid封装的SQL语法</span><br>        ContentValues values = <span class="hljs-keyword">new</span> ContentValues();<br>        values.put(<span class="hljs-string">&quot;bookname&quot;</span>, <span class="hljs-string">&quot;The Da Vinci Code&quot;</span>);<br>        values.put(<span class="hljs-string">&quot;author&quot;</span>, <span class="hljs-string">&quot;Dan Brown&quot;</span>);<br>        values.put(<span class="hljs-string">&quot;pages&quot;</span>, <span class="hljs-number">454</span>);<br>        values.put(<span class="hljs-string">&quot;price&quot;</span>, <span class="hljs-number">16.96</span>);<br>        <span class="hljs-built_in">long</span> insert = database.insert(<span class="hljs-string">&quot;Book&quot;</span>, <span class="hljs-literal">null</span>, values);<br>        values.clear();<br>        values.put(<span class="hljs-string">&quot;bookname&quot;</span>, <span class="hljs-string">&quot;The Lost Symbol&quot;</span>);<br>        values.put(<span class="hljs-string">&quot;author&quot;</span>, <span class="hljs-string">&quot;Dan Brown&quot;</span>);<br>        values.put(<span class="hljs-string">&quot;pages&quot;</span>, <span class="hljs-number">510</span>);<br>        values.put(<span class="hljs-string">&quot;price&quot;</span>, <span class="hljs-number">19.95</span>);<br>        <span class="hljs-built_in">long</span> insert1 = database.insert(<span class="hljs-string">&quot;Book&quot;</span>, <span class="hljs-literal">null</span>, values);<br><br>        <span class="hljs-keyword">return</span> insert;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 更新Book表中的数据</span><br><span class="hljs-comment">     * @return    返回受影响的行</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">updateData</span>(<span class="hljs-params"></span>)</span> &#123;<br>        SQLiteDatabase database = helper.getReadableDatabase();<br>        <span class="hljs-comment">// 使用anddroid封装的SQL语法</span><br>        ContentValues values = <span class="hljs-keyword">new</span> ContentValues();<br>        values.put(<span class="hljs-string">&quot;price&quot;</span>, <span class="hljs-number">10.99</span>);<br>        <span class="hljs-built_in">int</span> update = database.update(<span class="hljs-string">&quot;Book&quot;</span>, values,  <span class="hljs-string">&quot;bookname = ?&quot;</span>, <span class="hljs-keyword">new</span> String[] &#123; <span class="hljs-string">&quot;The Da Vinci Code&quot;</span> &#125;);<br><br>        <span class="hljs-keyword">return</span> update;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除Book中的数据     </span><br><span class="hljs-comment">     * @return    返回受影响的行</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">delete</span>(<span class="hljs-params"></span>)</span> &#123;<br>        SQLiteDatabase database = helper.getReadableDatabase();<br>        <span class="hljs-comment">// 使用anddroid封装的SQL语法</span><br>        <span class="hljs-built_in">int</span> delete = database.delete(<span class="hljs-string">&quot;Book&quot;</span>, <span class="hljs-string">&quot;pages &gt; ?&quot;</span>, <span class="hljs-keyword">new</span> String[] &#123; <span class="hljs-string">&quot;500&quot;</span> &#125;);<br><br>        <span class="hljs-keyword">return</span> delete;    <br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 查询Book表中的数据</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">query</span>(<span class="hljs-params"></span>)</span> &#123;<br>        SQLiteDatabase database = helper.getReadableDatabase();<br>        <span class="hljs-comment">// 使用原生SQL语法</span><br>        Cursor cursor = database.query(<span class="hljs-string">&quot;Book&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;price=?&quot;</span>, <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;10.99&quot;</span>&#125;, <span class="hljs-string">&quot;bookname&quot;</span>, <span class="hljs-string">&quot;author=&#x27;Baby lin&#x27;&quot;</span>, <span class="hljs-string">&quot;author&quot;</span>);<br><br>        <span class="hljs-keyword">if</span> (cursor.moveToFirst()) &#123;<br>            <span class="hljs-keyword">do</span> &#123;<br>                String bookname = cursor.getString(cursor.getColumnIndex(<span class="hljs-string">&quot;bookname&quot;</span>));<br>                String author = cursor.getString(cursor.getColumnIndex(<span class="hljs-string">&quot;author&quot;</span>));<br>                <span class="hljs-built_in">int</span> pages = cursor.getInt(cursor.getColumnIndex(<span class="hljs-string">&quot;pages&quot;</span>));<br>                <span class="hljs-built_in">double</span> price = cursor.getDouble(cursor.getColumnIndex(<span class="hljs-string">&quot;price&quot;</span>));<br>                System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;书名：&quot;</span> + bookname + <span class="hljs-string">&quot;  作者：&quot;</span> + author + <span class="hljs-string">&quot;  页数&quot;</span> + pages + <span class="hljs-string">&quot;   价格&quot;</span> + price);<br>            &#125; <span class="hljs-keyword">while</span> (cursor.moveToNext());<br>        &#125;<br>        cursor.close();    <br>    &#125;    <br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码虽然有些长，但其功能却很简单，也就是实现了数据库的增删查改这是个方法。</p><p>首先我们看到每个方法都有这么一行代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">SQLiteDatabase database = helper.getReadableDatabase();<br></code></pre></td></tr></table></figure><p>这一行代码是通过MyDatabaseHelper使用父类SQLiteOpenHelper 中有两个非常重要的实例方法，getReadableDatabase() 和getWritableDatabase()。这两个方法都可以创建或打开一个现有的数据库（如果数据库已存在则直接打开，否则创建一个新的数据库），并返回一个可对数据库进行读写操作的对象。不同的是，当数据库不可写入的时候（如磁盘空间已满）getReadableDatabase()方法返回的对象将以只读的方式去打开数据库，而getWritableDatabase()方法则将出现异常。</p><h4 id="详解addData-方法"><a href="#详解addData-方法" class="headerlink" title="详解addData()方法"></a>详解addData()方法</h4><p>其次，在addData()插入数据中有ContentValue这个类，这个类是用来存储要插入数据表中的数据的。<br>举个比较熟悉的例子，如ArrayList数据列表，我们可以在它里面存储String或者HashMap&lt;key, value&gt;，而ContentValue就是类似ArrayList这样的容器。<br>实际上ContentValue里面存储的也是HashMap&lt;key, value&gt;。<br>通过ContentValue存储数据，然后再使用Android封装的insert方法，能够解析其中的数据，然后保存到数据表中。<br>其实深入Android中的insert方法，可以看到Android只是将insert方法中的参数取出还原为SQL原生语句，然后保存到数据表中。那么怎么在Android使用原生的SQL方法呢？android在SQLiteDatabase对象中封装了execSQL()方法，可直接使用，当然，execSQL()方法又有完全使用SQL语句，一半使用SQL语句一半使用Android参数的方法。下面是使用原生的SQL语句的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">addData</span><span class="hljs-params">()</span> </span>&#123;<br>    SQLiteDatabase database = helper.<span class="hljs-built_in">getReadableDatabase</span>();<br>    <br>    <span class="hljs-comment">// 使用原生SQL语法</span><br>    database.<span class="hljs-built_in">execSQL</span>(<span class="hljs-string">&quot;insert into Book(bookname, author, pages, price) values(&#x27;The Da Vinci Code&#x27;, &#x27;Dan Brown&#x27;, 454, 16.96)&quot;</span>);<br>    <br>    <span class="hljs-comment">// 使用原生与android封装方法，在values(?,?,?,?)有4个问号，</span><br>    <span class="hljs-comment">// 代表的是占位符，分别对应后面的String数组中的四个值。</span><br>    database.<span class="hljs-built_in">execSQL</span>(<span class="hljs-string">&quot;insert into Book(bookname, author, pages, price) values(?, ?, ?, ?)&quot;</span>, <br>            <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;The Lost Symbol&quot;</span>, <span class="hljs-string">&quot;Dan Brown&quot;</span>, <span class="hljs-string">&quot;510&quot;</span>, <span class="hljs-string">&quot;19.95&quot;</span>&#125;);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们看到如果使用原生的SQL语句来保存数据库，代码量减少了很多。但是android为什么推荐我们使用它封装的方法呢？这是因为使用原生SQL语法不能获取返回值，因此一但出现问题，会造成App崩溃；同时使用SQL语句的时候不能拼错单词或出现其他问题，否则也会崩溃。</p><p>同时我们看到使用SQL语句中保持的数字都是String，与数据表中的限定的值不同，这是因为在保存过程中只要数据类型正确，会自动将”510”还原为整数型。</p><h4 id="详解query-方法"><a href="#详解query-方法" class="headerlink" title="详解query()方法"></a>详解query()方法</h4><p>除此之外，需要特别注意的便是查询数据库的query()方法</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart">query(<span class="hljs-built_in">String</span> table, <span class="hljs-built_in">String</span>[] columns, <span class="hljs-built_in">String</span> selection,<br>        <span class="hljs-built_in">String</span>[] selectionArgs, <span class="hljs-built_in">String</span> groupBy, <span class="hljs-built_in">String</span> having,<br>        <span class="hljs-built_in">String</span> orderBy) ；<br></code></pre></td></tr></table></figure><p>这几个参数的意思是：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp">table：指定查询的表名，对应：<span class="hljs-keyword">from</span> table_name<br>columns：指定查询的列名，对应<span class="hljs-keyword">select</span> column1, column2<br>selection：指定<span class="hljs-keyword">where</span> 的约束条件，对应：<span class="hljs-keyword">where</span> column = <span class="hljs-keyword">value</span><br>selectionArgs：为<span class="hljs-keyword">where</span> 中的占位符提供具体的值<br>groupBy：指定需要<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> 的列，对应：<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> column<br>having：<span class="hljs-keyword">value</span> 对<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> 后的结果进一步约束，对应：having column = <span class="hljs-keyword">value</span><br>orderBy：指定查询结果的排序方式，对应：order <span class="hljs-keyword">by</span> column1, column2<br></code></pre></td></tr></table></figure><p>这些参数中在SQL语法中都是有的，其后面对应的是相应的SQL语句。<br>group By这个关键字是归组的意思，用于与 SELECT 语句一起使用，来对相同的数据进行分组。在 SELECT 语句中，GROUP BY 子句放在 WHERE 子句之后，放在 ORDER BY 子句之前。<br>也就是说如果使用GROUP BY子句，那么会见所有相同的字段的值合并为一条信息返回。<br>HAVING 子句允许指定条件来过滤将出现在最终结果中的分组结果。WHERE 子句在所选列上设置条件，而 HAVING 子句则在由 GROUP BY 子句创建的分组上设置条件。</p><p>为了获取查询结构，首先插入这些数据：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">database.execSQL(<br>        <span class="hljs-string">&quot;insert into Book(bookname, author, pages, price) values(&#x27;The Da Vinci Code&#x27;, &#x27;Dan Brown&#x27;, 454, 16.96)&quot;</span>);<br>database.execSQL(<br>        <span class="hljs-string">&quot;insert into Book(bookname, author, pages, price) values(&#x27;The Lost Symbol&#x27;, &#x27;Dan Brown&#x27;, 510, 19.95)&quot;</span>);<br>database.execSQL(<br>        <span class="hljs-string">&quot;insert into Book(bookname, author, pages, price) values(&#x27;piao liu chuan shuo&#x27;, &#x27;Baby lin&#x27;, 189, 12.99)&quot;</span>);<br>database.execSQL(<br>        <span class="hljs-string">&quot;insert into Book(bookname, author, pages, price) values(&#x27;lv bing xun chuan qi&#x27;, &#x27;Baby lin&#x27;, 470, 10.99)&quot;</span>);<br>database.execSQL(<br>        <span class="hljs-string">&quot;insert into Book(bookname, author, pages, price) values(&#x27;bing yu huo zhi ge&#x27;, &#x27;Dan Brown&#x27;, 624, 10.99)&quot;</span>);<br>database.execSQL(<br>        <span class="hljs-string">&quot;insert into Book(bookname, author, pages, price) values(&#x27;bing yu huo zhi ge&#x27;, &#x27;Dan Brown&#x27;, 624, 10.99)&quot;</span>);<br>database.execSQL(<br>        <span class="hljs-string">&quot;insert into Book(bookname, author, pages, price) values(&#x27;wo yao du shu&#x27;, &#x27;Dan Brown&#x27;, 510, 10.99)&quot;</span>);<br></code></pre></td></tr></table></figure><p>他们只有些许的区别，现在我们想查询价格是10.99元，然后按照bookname进行归组，找出组里作者是Baby lin的那条信息，最后按照author排序（实质只有一条信息，没必要排序）。<br>这条信息由两种写法，一种是上面代码演示的，一种用原生SQL，如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Cursor cursor = database.rawQuery(<br>            <span class="hljs-string">&quot;select * from Book where price=10.99 group by bookname having author=&#x27;Baby lin&#x27; order by author&quot;</span>, <span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure><p>这两种写法都可以的到Cursor这个对象，然后通过Cursor获得数据库中的数据。<br>Cursor的用法相对固定，通过while遍历，每次使用cursor.moveToNext()将游标移到下一行数据，如果能移动下一行数据则返回True，否则为false。<br>cursor.getString(int index)或者cursor.getInt(int index)传入相应字段在数据表中的排序便能获得在当前行的字段的值。</p><h4 id="修改和删除"><a href="#修改和删除" class="headerlink" title="修改和删除"></a>修改和删除</h4><p>修改和删除就比前面两种方法简单多了。<br>修改update数据表的三种方法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// 使用anddroid封装的SQL语法</span><br>ContentValues values = <span class="hljs-keyword">new</span> ContentValues();<br>values.put(<span class="hljs-string">&quot;price&quot;</span>, <span class="hljs-number">10.99</span>);<br><span class="hljs-built_in">int</span> update = database.update(<span class="hljs-string">&quot;Book&quot;</span>, values, <span class="hljs-string">&quot;bookname = ?&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>[] &#123; <span class="hljs-string">&quot;The Da Vinci Code&quot;</span> &#125;);<br><span class="hljs-comment">// 使用原生SQL语法</span><br><span class="hljs-comment">// database.execSQL(&quot;update Book SET price=10.99 where bookname=&#x27;The Da</span><br><span class="hljs-comment">// Vinci Code&#x27; &quot;);</span><br><span class="hljs-comment">// 使用原生与android封装方法</span><br><span class="hljs-comment">// database.execSQL(&quot;update Book SET price=? where bookname=? &quot;, new String[] &#123; &quot;10.99&quot;, &quot;The Da Vinci Code&quot; &#125;);</span><br></code></pre></td></tr></table></figure><p>删除delete数据表的三种方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> <span class="hljs-keyword">delete</span> = database.<span class="hljs-built_in"><span class="hljs-keyword">delete</span></span>(<span class="hljs-string">&quot;Book&quot;</span>, <span class="hljs-string">&quot;pages &gt; ?&quot;</span>, <span class="hljs-keyword">new</span> String[] &#123; <span class="hljs-string">&quot;500&quot;</span> &#125;);<br><span class="hljs-comment">// 使用原生SQL语法</span><br><span class="hljs-comment">// database.execSQL(&quot;delete from Book where pages &gt; 500&quot;);</span><br><span class="hljs-comment">// 使用原生与android封装方法</span><br><span class="hljs-comment">// database.execSQL(&quot;delete from Book where pages &gt; ?&quot;, new String[] &#123; &quot;500&quot; &#125;);</span><br></code></pre></td></tr></table></figure><p>以上就是android中对于数据库操作的全部内容了！</p><h2 id="内容提供者"><a href="#内容提供者" class="headerlink" title="内容提供者"></a>内容提供者</h2><p>研究完数据库，那么与数据库密切相关的内容提供者就不得不说说的，因为内容提供者也是依赖于数据库的实现的。<br>内容提供者也就是将当前应用的数据提供出去给其他的app使用，这是一个很好的功能，可惜一般情况下没有人会使用你的应用的信息，因为不知道是不是有陷阱。当然啦，支付宝、微博这些肯定会有人用的。<br>言归正传，我们来说说如何构建一个内容提供者,在这里以上一个项目的数据库作为内容提供者。</p><h3 id="创建一个类继承自ContentProvider"><a href="#创建一个类继承自ContentProvider" class="headerlink" title="创建一个类继承自ContentProvider"></a>创建一个类继承自ContentProvider</h3><p>ContentProvider有六个方法必须实现，他们是onCreate()和getType()以及数据库的增删查改四个方法，其中他们每个方法都会使用的Uri参数，这个参数是调用ContentResolver内容解析者的增删改查方法时传递过来的。</p><p>我们首先创建MyContentProvider继承ContentProvider。<br>然后在AndroidManifest.xml的application中添加内容提供者的注册清单：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">provider</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;com.example.databasecontentprovider.MyContentProvider&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:authorities</span>=<span class="hljs-string">&quot;com.example.databasecontentprovider.provider&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:exported</span>=<span class="hljs-string">&quot;true&quot;</span> &gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">provider</span>&gt;</span><br></code></pre></td></tr></table></figure><p>其中android:name是ContentProvider的全类名，android:authorities 属性中指定了该内容提供器的权限，android:exported表示该应用是否可供外部访问。</p><p>然后回到MyContentProvider中，我们写下以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyContentProvider</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ContentProvider</span></span>&#123;<br>    <span class="hljs-comment">//定一个一个uri路径匹配器</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> UriMatcher sUrimatcher = <span class="hljs-keyword">new</span> UriMatcher(UriMatcher.NO_MATCH);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> QUERYSUCESS = <span class="hljs-number">0</span>;  <span class="hljs-comment">//ctrl+shift+X  变大写   小写加y</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> INSERTSUCESS = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> UPDATESUCESS = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DELETESUCESS = <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">private</span> MyDatabaseHelper databaseHelper;<br>    <br>    <span class="hljs-keyword">static</span> &#123;<br>        sUrimatcher.addURI(<span class="hljs-string">&quot;com.example.databasecontentprovider.provider&quot;</span>, <span class="hljs-string">&quot;query&quot;</span>, QUERYSUCESS);<br>        sUrimatcher.addURI(<span class="hljs-string">&quot;com.example.databasecontentprovider.provider&quot;</span>, <span class="hljs-string">&quot;insert&quot;</span>, INSERTSUCESS);<br>        sUrimatcher.addURI(<span class="hljs-string">&quot;com.example.databasecontentprovider.provider&quot;</span>, <span class="hljs-string">&quot;update&quot;</span>, UPDATESUCESS);<br>        sUrimatcher.addURI(<span class="hljs-string">&quot;com.example.databasecontentprovider.provider&quot;</span>, <span class="hljs-string">&quot;delete&quot;</span>, DELETESUCESS);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onCreate</span><span class="hljs-params">()</span> </span>&#123;<br>        databaseHelper = <span class="hljs-keyword">new</span> MyDatabaseHelper(getContext(), <span class="hljs-string">&quot;BookStore.db&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Cursor <span class="hljs-title">query</span><span class="hljs-params">(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> code = sUrimatcher.match(uri);<br>        <span class="hljs-keyword">if</span> (code == QUERYSUCESS) &#123;<br>            SQLiteDatabase readableDatabase = databaseHelper.getReadableDatabase();<br>            Cursor cursor = readableDatabase.query(<span class="hljs-string">&quot;Book&quot;</span>, projection, selection, selectionArgs, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, sortOrder);<br>            <span class="hljs-keyword">return</span> cursor;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getType</span><span class="hljs-params">(Uri uri)</span> </span>&#123;<br>        <span class="hljs-comment">// TODO Auto-generated method stub</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Uri <span class="hljs-title">insert</span><span class="hljs-params">(Uri uri, ContentValues values)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> code = sUrimatcher.match(uri);<br>        <span class="hljs-keyword">if</span> (code == INSERTSUCESS)&#123;<br>            SQLiteDatabase readableDatabase = databaseHelper.getReadableDatabase();<br>            <span class="hljs-keyword">long</span> insert = readableDatabase.insert(<span class="hljs-string">&quot;Book&quot;</span>, <span class="hljs-keyword">null</span>, values);<br>            Uri myUri = Uri.parse(<span class="hljs-string">&quot;com.youCanDoIt/&quot;</span> + insert);<br>            <span class="hljs-keyword">return</span> myUri;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">delete</span><span class="hljs-params">(Uri uri, String selection, String[] selectionArgs)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> code = sUrimatcher.match(uri);<br>        <span class="hljs-keyword">if</span> (code == DELETESUCESS) &#123;<br>            SQLiteDatabase readableDatabase = databaseHelper.getReadableDatabase();<br>            <span class="hljs-keyword">int</span> delete = readableDatabase.delete(<span class="hljs-string">&quot;Book&quot;</span>, selection, selectionArgs);<br>            <span class="hljs-keyword">return</span> delete;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">update</span><span class="hljs-params">(Uri uri, ContentValues values, String selection, String[] selectionArgs)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> code = sUrimatcher.match(uri);<br>        <span class="hljs-keyword">if</span> (code == UPDATESUCESS)&#123;<br>            SQLiteDatabase readableDatabase = databaseHelper.getReadableDatabase();<br>            <span class="hljs-keyword">int</span> update = readableDatabase.update(<span class="hljs-string">&quot;Book&quot;</span>, values, selection, selectionArgs);<br>            <span class="hljs-keyword">return</span> update;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>其中UriMatcher这个实用类，我们可以当作是路径匹配器，它添加访问需要的路径名。<br>在UriMatcher构造方法中有UriMatcher.NO_MATCH这个参数，表示的是Uri不匹配时返回的code<br>其中</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">sUrimatcher<span class="hljs-selector-class">.addURI</span>(&quot;com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.databasecontentprovider</span><span class="hljs-selector-class">.provider</span>&quot;, &quot;query&quot;, QUERYSUCESS);<br></code></pre></td></tr></table></figure><p>这个方法，第一个参数这是在AndroidManifest.xml中内容提供者注册清单中的authorities，第二个参数需要匹配的路径名，第三个参数这是路径匹配时所返回的值。<br>那么query这个路径该怎么访问呢？<br>这时使用</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">Uri</span> url = <span class="hljs-built_in">Uri</span>.parse(<span class="hljs-string">&quot;content://com.example.databasecontentprovider.provider/query&quot;</span>);<br></code></pre></td></tr></table></figure><p>就能够解析这个路径，其中content://是协议，跟http://差不多。</p><p>设置好匹配器，也设置了访问路径，接下来就是提供给外部的权限方法了，现在我们先让其他的app有对数据库增删查改的方法，那么就要重新MyContentProvider中增删查改是个方法。<br>首先判断sUrimatcher.match(uri)是否能够匹配传过来的uri，如果返回的值刚好就与定义好的值相等，那么就返回这里增删查改方法中要返回的数据类型。<br>如public Cursor query(···）中要返回一个Cursor游标，那么就返回一个Cursor对象。<br>而public Uri insert( ···)最特殊，它要返回一个Uri，事实上这个Uri可以自定义，只需要符合相应规则就行，即com.xxxx即可，它最大的功能是让外部应用得到是否成功执行插入数据的操作。</p><p>这样一来，一个内容提供者就完成了。<br>总结一下，有以下几个步骤：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">1、定义内容提供者 定义一个类继承contentProvider  <br>2、在清单文件里面配置一下 内容提供者<br>3、定义一个Urimatcher <br>4、写一个静态代码块 ，添加匹配规则 <br>5、按照我们添加的匹配规则，暴露想暴露的方法 <br></code></pre></td></tr></table></figure><h2 id="内容访问者"><a href="#内容访问者" class="headerlink" title="内容访问者"></a>内容访问者</h2><p>内容提供者设置好之后，便要有访问者，内容访问者很简单，只要得到Uri路径，然后使用ContentResolver内容访问者就好了。<br>我们新建一个MyContentResolver应用，添加增删查改四个按钮，然后在MainActivity中添加以下代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs dart">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Activity</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    protected <span class="hljs-keyword">void</span> onCreate(Bundle savedInstanceState) &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_main);<br>        Button addData = (Button) findViewById(R.id.add_data);<br>        Button queryData = (Button) findViewById(R.id.query_data);<br>        Button updateData = (Button) findViewById(R.id.update_data);<br>        Button deleteData = (Button) findViewById(R.id.delete_data);<br>        <br>        addData.setOnClickListener(<span class="hljs-keyword">new</span> OnClickListener() &#123;<br>            <br>            <span class="hljs-meta">@Override</span><br>            public <span class="hljs-keyword">void</span> onClick(View v) &#123;<br>                <span class="hljs-built_in">Uri</span> url = <span class="hljs-built_in">Uri</span>.parse(<span class="hljs-string">&quot;content://com.example.databasecontentprovider.provider/insert&quot;</span>);<br>                ContentValues values = <span class="hljs-keyword">new</span> ContentValues();<br>                values.put(<span class="hljs-string">&quot;bookname&quot;</span>, <span class="hljs-string">&quot;A Clash of Kings&quot;</span>);<br>                values.put(<span class="hljs-string">&quot;author&quot;</span>, <span class="hljs-string">&quot;George Martin&quot;</span>);<br>                values.put(<span class="hljs-string">&quot;pages&quot;</span>, <span class="hljs-number">1040</span>);<br>                values.put(<span class="hljs-string">&quot;price&quot;</span>, <span class="hljs-number">55.55</span>);<br>                ContentResolver contentResolver = getContentResolver();<br>                <span class="hljs-built_in">Uri</span> insert = contentResolver.insert(url, values);<br>                System.out.println(insert);<br>            &#125;<br>        &#125;);<br>        <br>        queryData.setOnClickListener(<span class="hljs-keyword">new</span> OnClickListener() &#123;<br>            <br>            <span class="hljs-meta">@Override</span><br>            public <span class="hljs-keyword">void</span> onClick(View v) &#123;<br>                <span class="hljs-built_in">Uri</span> url = <span class="hljs-built_in">Uri</span>.parse(<span class="hljs-string">&quot;content://com.example.databasecontentprovider.provider/query&quot;</span>);    <br>                ContentResolver contentResolver = getContentResolver();<br>                Cursor query = contentResolver.query(url, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<br>                <span class="hljs-keyword">if</span> (query != <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-keyword">while</span> (query.moveToNext())&#123;<br>                        <span class="hljs-built_in">String</span> autor = query.getString(<span class="hljs-number">1</span>);<br>                        <span class="hljs-built_in">String</span> prices = query.getString(<span class="hljs-number">2</span>);<br>                        <span class="hljs-built_in">String</span> pages = query.getString(<span class="hljs-number">3</span>);<br>                        <span class="hljs-built_in">String</span> bookname = query.getString(<span class="hljs-number">4</span>);<br>                        System.out.println(autor + <span class="hljs-string">&quot;   &quot;</span> + prices + <span class="hljs-string">&quot;   &quot;</span> + pages +<span class="hljs-string">&quot;   &quot;</span> + bookname);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;);<br>        <br>        updateData.setOnClickListener(<span class="hljs-keyword">new</span> OnClickListener() &#123;<br>            <br>            <span class="hljs-meta">@Override</span><br>            public <span class="hljs-keyword">void</span> onClick(View v) &#123;<br>                <span class="hljs-built_in">Uri</span> url = <span class="hljs-built_in">Uri</span>.parse(<span class="hljs-string">&quot;content://com.example.databasecontentprovider.provider/update&quot;</span>);<br>                ContentValues values = <span class="hljs-keyword">new</span> ContentValues();<br>                values.put(<span class="hljs-string">&quot;bookname&quot;</span>, <span class="hljs-string">&quot;A Storm of Swords&quot;</span>);<br>                values.put(<span class="hljs-string">&quot;pages&quot;</span>, <span class="hljs-number">1216</span>);<br>                values.put(<span class="hljs-string">&quot;price&quot;</span>, <span class="hljs-number">24.05</span>);    <br>                ContentResolver contentResolver = getContentResolver();<br>                <span class="hljs-built_in">int</span> update = contentResolver.update(url, values, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<br>                System.out.println(<span class="hljs-string">&quot;更新了&quot;</span> + update + <span class="hljs-string">&quot;条数据&quot;</span>);<br>            &#125;<br>        &#125;);<br>        <br>        deleteData.setOnClickListener(<span class="hljs-keyword">new</span> OnClickListener() &#123;<br>            <br>            <span class="hljs-meta">@Override</span><br>            public <span class="hljs-keyword">void</span> onClick(View v) &#123;<br>                <span class="hljs-built_in">Uri</span> url = <span class="hljs-built_in">Uri</span>.parse(<span class="hljs-string">&quot;content://com.example.databasecontentprovider.provider/delete&quot;</span>);<br>                ContentResolver contentResolver = getContentResolver();<br>                <span class="hljs-built_in">int</span> delete = contentResolver.delete(url, <span class="hljs-string">&quot;bookname = ?&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>[]&#123;<span class="hljs-string">&quot;A Storm of Swords&quot;</span>&#125;);<br>                System.out.println(<span class="hljs-string">&quot;删除了&quot;</span> + delete + <span class="hljs-string">&quot;条数据&quot;</span>);<br>            &#125;<br>        &#125;);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>在这里，我们通过Activity中的getContentResolver()得到ContentResolver()，然后通过ContentResolver对象传出想要修改或查询的数据。当然在这里就不能够写SQL原生的语句了，只能够按照Android的封装的方法来走。<br>内容解析者的操作简略为以下几步：<br>1、通过Uri地址获取Uri对象<br>2、通过getContentResolver()得到ContentResolver对象<br>3、通过ContentResolver对象进行增删改查等动作，方法与数据库操作基本相同。</p><p>好了，这篇文章就到此结束，写的还停长的，但实质上就只有这三方面的内容：<br>SQLite操作以及SQL基本语法；<br>Android中的数据库操作；<br>Android中的内容提供者和内容解析者；</p><h2 id="补充小知识"><a href="#补充小知识" class="headerlink" title="补充小知识"></a>补充小知识</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs css">使用adb进入模拟器：当有多个模拟器开启式使用以下方式<br>    adb -s emulator-<span class="hljs-number">5554</span> shell<br>其中emulator-<span class="hljs-number">5554</span>是你的设备代号，在dos窗口下使用adb devices列出当前所有的设备<br><br>-：普通文件<br>d：目录<br>r：可读<br>w：可写<br>x：可读可写可执行<br><br>直接更改数据库权限为可读可写可执行（在dos窗口中更改数据库全新）：chmod <span class="hljs-number">777</span> xxx<span class="hljs-selector-class">.db</span><br><br>创建或打开D盘中的数据库，在dos窗口：sqlite3<span class="hljs-selector-class">.exe</span> d:\test.db<br><br>然后创建表<br><br>此时如果在D盘中原本没有test.db这个数据库，那么在你创建表的时候会直接创建数据库和表<br><br>.table  展示数据库中已经拥有的表名<br><br>.schema 展示表的创建语句<br></code></pre></td></tr></table></figure><p>项目地址：</p><blockquote><p><a href="https://link.jianshu.com/?t=https://github.com/liaozhoubei/DatabaseContentProvider">https://github.com/liaozhoubei/DatabaseContentProvider</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>android10新存储方案</title>
    <link href="/posts/398acbb1/"/>
    <url>/posts/398acbb1/</url>
    
    <content type="html"><![CDATA[<h1 id="android10新存储方案"><a href="#android10新存储方案" class="headerlink" title="android10新存储方案"></a>android10新存储方案</h1><p>早期的Android开发，对文件操作缺少限制，只要申请个读写内存权限就可以对整个文件目录随便操作，绝大多数应用都会在根目录建一个自己的文件夹用来存储数据，甚至把应用数据库(SQLite)移到外部文件夹中以防止应用卸载后数据被删除。那么这么做有什么好处吗？我想了一下，大概有两点吧。第一，存储在SD卡的文件不会计入到应用程序的占用空间当中，也就是说即使你在SD卡存放了1G的文件，你的应用程序在设置中显示的占用空间仍然可能只有几十K。第二，存储在SD卡的文件，即使应用程序被卸载了，这些文件仍然会被保留下来，这有助于实现一些需要数据被永久保留的功能。</p><p>然而，这些“好处”真的是好处吗？或许对于开发者而言这算是好处吧，但对于用户而言，上述好处无异于一些流氓行为。因为这会将用户的SD卡空间搞得乱糟糟的，而且即使我卸载了一个完全不再使用的程序，它所产生的垃圾文件却可能会一直保留在我的手机上。</p><p>另外，存储在SD卡上的文件属于公有文件，所有的应用程序都有权随意访问，这也对数据的安全性带来了很大的挑战。</p><p>其实Android并不是没有做这方面的API，Android早就提供了getCacheDir()、getFilesDir()、getExternalFilesDir()、getExternalCacheDir()等API供开发者使用，奈何开发者不听话，不论是为了应用方便统一管理文件，亦或者想让文件不会因为应用的卸载而被移除，多数开发者都会选择在外部建立自己的专有文件夹来保存文件。</p><p>为了解决文件混乱的问题，以及让用户能够更好地控制自己的文件和更好的保护用户隐私，Google从Android Q版本开始修改了外部存储权限。这种外部存储的新特性被称为分区存储（Scoped Storage）。官方翻译称为“分区存储“，我们一般称为“沙盒模式”，当然也有称为“作用域存储”。</p><p>Android Q仍然使用READ_EXTERNAL_STORAGE和WRITE_EXTERNAL_STORAGE作为面向用户的存储相关运行时权限，但现在即使获取了这些权限，访问外部存储也受到了限制。APP需要这些运行时权限的情景发生了变化，且各种情况下外部存储对APP的可见性也发生了变化。</p><h2 id="迁移"><a href="#迁移" class="headerlink" title="迁移"></a>迁移</h2><p>从Android Q正式发布，官方就开始推行新特性的适配工作，当时官方的说法是从Android Q开始(targetSdkVersion &gt;= 29)将不再允许应用无限制的操作或访问公共目录，强制使用分区存储，但是Android Q版本可以通过在Manifest中声android:requestLegacyExternalStorage=”true”  来继续使用以前的存储方式（当然你也可以选择不升级应用的targetSdkVersion），但是从AndroidR(11)开始,requestLegacyExternalStorage也会失效。</p><p>但是官方又新增了preserveLegacyExternalStorage属性，开启该属性可以使原本未开启分区存储的应用在覆盖安装后仍然可以继续使用旧的存储方式，但是新安装的应用将没有任何办法使用旧的存储方式。关于requestLegacyExternalStorage和preserveLegacyExternalStorage在不同版本的表现，总结如下：</p><p><img src="TyporaRaw/android%E5%AD%98%E5%82%A8%E4%BD%BF%E7%94%A8.assets/640-16467496347888.png" alt="图片"></p><p><strong>AndroidP/Q</strong></p><p><img src="TyporaRaw/android%E5%AD%98%E5%82%A8%E4%BD%BF%E7%94%A8.assets/640-16467496347899.png" alt="图片"></p><p><strong>AndroidR</strong></p><p>关于targetSdkVersion，Google Play的规定是从今年8月开始，所有新上线的应用的目标API，即targetSdkVersion必须升级到30以上，对现有应用更新新的版本，这个政策的要求将自 11 月开始生效。抛开Google Play的规定不谈，关于Gradle中的minSdkVersion、compileSdkVersion以及targetSdkVersion的具体作用，参考此篇博客：</p><blockquote><p><a href="https://blog.csdn.net/qq_23062979/article/details/81294550">https://blog.csdn.net/qq_23062979/article/details/81294550</a></p></blockquote><hr><p>目前Android 10系统对于作用域存储适配的要求还不是那么严格，毕竟之前传统外置存储空间的用法实在是太广泛了。如果你的项目指定的targetSdkVersion低于29，那么即使不做任何作用域存储方面的适配，你的项目也可以成功运行到Android 10手机上。</p><p>而如果你的targetSdkVersion已经指定成了29，也没有关系，假如你还不想进行作用域存储的适配，只需要在AndroidManifest.xml中加入如下配置即可：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">&lt;manifest <span class="hljs-string">...</span> &gt;<br>  &lt;application android<span class="hljs-function">:requestLegacyExternalStorage</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-string">...</span>&gt;<br>    <span class="hljs-string">...</span><br>  &lt;<span class="hljs-string">/application</span>&gt;<br>&lt;<span class="hljs-string">/manifest</span>&gt;<br></code></pre></td></tr></table></figure><p>这段配置表示，即使在Android 10系统上，仍然允许使用之前遗留的外置存储空间的用法来运行程序，这样就不用对代码进行任何修改了。当然，这只是一种权宜之计，在未来的Android系统版本中，这段配置随时都可能会失效（目前Android 11预览版已经确认，这段配置至少在Android 11上不会失效）。因此，我们还是非常有必要现在就来学习一下，到底该如何对作用域存储进行适配。</p><p>另外，本篇文章中演示的所有示例，都可以到ScopedStorageDemo这个开源库中找到其对应的源码。</p><p>开源库地址是：</p><blockquote><p><a href="https://github.com/guolindev/ScopedStorageDemo">https://github.com/guolindev/ScopedStorageDemo</a></p></blockquote><h2 id="这么做的好处"><a href="#这么做的好处" class="headerlink" title="这么做的好处"></a>这么做的好处</h2><p>对用户而言，当开发者适配完成后，用户的文件目录将不再像以前那么混乱，能够让用户更好的管理自己的文件。</p><p>应用的数据全部存储在沙盒内，卸载应用时所有的文件也随之移除，解决了卸载应用仍然占用存储空间的问题。</p><p>保护用户隐私，应用将不能随便访问公共文件，存储媒体文件等需要通过操作媒体数据库的方式存储在特定的媒体文件夹中，对用户来说，所有的媒体文件都存储在特定的文件夹下，也方便管理。</p><p>对于开发者而言，这样做也能更好的保护自己的应用，应用不能访问其他应用的沙盒目录，应用的沙盒目录存储在 /Android/data/包名 文件夹下，而且在AndroidR版本的手机上，Android/data文件夹也向用户隐藏，通过系统文件管理器或者是连接电脑都无法访问data文件夹（可以通过SAF向用户申请权限来访问，仅用于文件管理类应用，或者获取Root权限）。</p><h2 id="那么到底什么是作用域存储-分区存储呢？"><a href="#那么到底什么是作用域存储-分区存储呢？" class="headerlink" title="那么到底什么是作用域存储/分区存储呢？"></a>那么到底什么是作用域存储/分区存储呢？</h2><p>简单来讲，就是Android系统对SD卡的使用做了很大的限制。从Android 10开始，每个应用程序只能有权在自己的外置存储空间关联目录下读取和创建文件，获取该关联目录的代码是：context.getExternalFilesDir()。关联目录对应的路径大致如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/storage/</span>emulated<span class="hljs-regexp">/0/</span>Android<span class="hljs-regexp">/data/</span>&lt;包名&gt;/files<br></code></pre></td></tr></table></figure><p>将数据存放到这个目录下，你将可以完全使用之前的写法来对文件进行读写，不需要做任何变更和适配。但同时，刚才提到的那两个“好处”也就不存在了。这个目录中的文件会被计入到应用程序的占用空间当中，同时也会随着应用程序的卸载而被删除。</p><p>那么有些朋友可能会问了，我就是需要访问其他目录该怎么办呢？比如读取手机相册中的图片，或者向手机相册中添加一张图片。为此，Android系统针对文件类型进行了分类，图片、音频、视频这三类文件将可以通过MediaStore API来进行访问，而其他类型的文件则需要使用系统的文件选择器来进行访问。</p><p>另外，我们的应用程序向媒体库贡献的图片、音频或视频，将会自动拥有其读写权限，不需要额外申请READ_EXTERNAL_STORAGE和WRITE_EXTERNAL_STORAGE权限。而如果你要读取其他应用程序向媒体库贡献的图片、音频或视频，则必须要申请READ_EXTERNAL_STORAGE权限才行。WRITE_EXTERNAL_STORAGE权限将会在未来的Android版本中废弃。</p><h2 id="分区存储带来了哪些变化"><a href="#分区存储带来了哪些变化" class="headerlink" title="分区存储带来了哪些变化"></a>分区存储带来了哪些变化</h2><p>分区存储将外部存储分成两部分：</p><ol><li><strong>App-specific directory （沙盒目录）</strong></li></ol><p>APP只能在Context.getExternalFilesDir()目录下通过File的方式创建文件，APP卸载的时候，这个目录下的文件会被删除；无法通过File的方式在其他路径创建文件。</p><ol start="2"><li><strong>Public Directory 公共目录</strong> </li></ol><p>公共目录包括：多媒体公共目录（Photos, Images, Videos, Audio）和下载文件目录（Downloads）。</p><p>APP可以通过MediaStore或者SAF（System Access Framework）的方式访问其中的文件。APP卸载后，文件不会被删除。</p><p>Android Q以上移除了WRITE_EXTERNAL_STORAGE权限，应用不需要这个权限就可以向沙盒内存储文件，也可以通过媒体数据库的方式保存媒体数据至特定位置。</p><p>公共目录的媒体文件（Photos, Images, Videos, Audio）通过MediaStore来访问，另外，MediaStore的DATA字段从Android Q开始被标记为deprecated，通过该字段获取的文件路径不再可靠，Android Q以上新增字段RELATIVE_PATH，代表文件的相对路径，在使用MediaStore保存媒体文件时，可以通过设置该字段来设置媒体文件保存的文件夹。</p><p>如：我们要保存一个图片文件，设置RELATIVE_PATH字段为Environment.DIRECTORY_DCIM时，图片会保存到DCIM文件夹下，如果我们想保存图片到DCIM/CustomDir 文件夹下时，可以设置RELATIVE_PATH的值为：Environment.DIRECTORY_DCIM+“/CustomDir”，当然，你也可以改成Environment.DIRECTORY_PICTURES来将图片保存在Pictures文件夹下。</p><p>应用可以通过MediaStore访问其他App创建的多媒体文件，但需要申请READ_EXTERNAL_STORAGE权限。同时，如果用户要修改或者删除其他App创建的多媒体文件，需要用户单独授权。</p><p>App卸载后，对应的沙盒目录也会被删除，如果APP想要在卸载时保留沙盒目录下的数据，要在AndroidManifest.xml中声明android:hasFragileUserData=”true”，这样在 APP卸载时就会有弹出框提示用户是否保留应用数据。</p><h2 id="适配Android-Q"><a href="#适配Android-Q" class="headerlink" title="/  适配Android Q  /"></a>/  适配Android Q  /</h2><p><strong>保存文件至App-specific directory （沙盒目录）</strong></p><p><img src="TyporaRaw/android%E5%AD%98%E5%82%A8%E4%BD%BF%E7%94%A8.assets/640-164674972928412.png" alt="图片"></p><p>沙盒内的文件可以直接使用File的Api进行操作，且不需要申请读写内存权限，代码示例：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">val</span> appFilePath = get<span class="hljs-constructor">ExternalFilesDir(<span class="hljs-params">null</span>)</span>?.path?:<span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">val</span> appImagePath = get<span class="hljs-constructor">ExternalFilesDir(Environment.DIRECTORY_DCIM)</span>?.path?:<span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">val</span> appCustomPath = get<span class="hljs-constructor">ExternalFilesDir(<span class="hljs-string">&quot;Demo&quot;</span>)</span>?.path?:<span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">val</span> appCachePath = get<span class="hljs-constructor">ExternalCacheDir()</span>?.path?:<span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure><p><strong>访问公共目录（MediaStore）</strong></p><p>MediaStore提供下列Uri，可以用MediaProvider查询对应的Uri数据</p><p><img src="TyporaRaw/android%E5%AD%98%E5%82%A8%E4%BD%BF%E7%94%A8.assets/640-164674972928513.png" alt="图片"></p><p>代码示例如下，使用MediaStore查询手机上的图片。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">val</span> <span class="hljs-keyword">external</span> = MediaStore.Images.Media.EXTERNAL_CONTENT_URI<br><span class="hljs-keyword">val</span> projection = <span class="hljs-built_in">array</span><span class="hljs-constructor">Of(MediaStore.Images.Media.<span class="hljs-params">_ID</span>)</span><br><span class="hljs-keyword">val</span> cursor = contentResolver.query(<span class="hljs-keyword">external</span>, projection, null, null, null)<br><span class="hljs-keyword">if</span> (cursor != null<span class="hljs-operator"> &amp;&amp; </span>cursor.move<span class="hljs-constructor">ToFirst()</span>) &#123;<br>    queryUri = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ContentUris</span>.</span></span><span class="hljs-keyword">with</span><span class="hljs-constructor">AppendedId(<span class="hljs-params">external</span>, <span class="hljs-params">cursor</span>.<span class="hljs-params">getLong</span>(0)</span>)<br>    <span class="hljs-comment">// queryUri即上图中对应的uri</span><br>    cursor.close<span class="hljs-literal">()</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在Android Q以下版本，使用该方法可以拿到媒体文件的绝对路径（比如external/DCIM/xxx.png），即DATA字段，但是在Android Q及以上版本，DATA字段被弃用且不再可靠，新增了RELATIVE_PATH字段表示相对地址，通过该字段可以设置媒体文件保存的位置（具体见下文）。</p><p>Android Q以下版本可以通过DATA字段拿到绝对路径并转换成File类型，对文件进行操作，Android Q之后不再可行。要访问这个uri，通用的方法是通过文件描述符FileDescriptor来实现，示例代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> pfd: ParcelFileDescriptor? = <span class="hljs-literal">null</span><br><span class="hljs-keyword">try</span> &#123;<br>    pfd = contentResolver.openFileDescriptor(queryUri!!, <span class="hljs-string">&quot;r&quot;</span>)<br>    <span class="hljs-keyword">if</span> (pfd != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">val</span> bitmap = BitmapFactory.decodeFileDescriptor(pfd.fileDescriptor)<br>        imageIv.setImageBitmap(bitmap)<br>    &#125;<br>&#125; <span class="hljs-keyword">catch</span> (e: IOException) &#123;<br>    e.printStackTrace()<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    pfd?.close()<br>&#125;<br></code></pre></td></tr></table></figure><p>读取MedisStore文件时，如果未申请READ_EXTERNAL_STORAGE权限，那么读取到的图片只有自己应用保存的图片，换句话说，应用读取和操作自己保存的媒体文件不需要申请READ_EXTERNAL_STORAGE权限，但是要访问其他应用创建的媒体文件，需要申请权限。</p><p>在Android Q以下只使用DATA字段，Android Q及以上不使用DATA字段，改为使用RELATEIVE_PATH字段。</p><p><strong>保存文件至公共目录 （MediaStore）</strong></p><p>最常见的一个操作：保存图片/视频到媒体目录。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">val</span> imageMediaPath = <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.Q) &#123;<br>        <span class="hljs-constructor">File(Environment.<span class="hljs-params">getExternalStoragePublicDirectory</span>(Environment.DIRECTORY_DCIM)</span>, <span class="hljs-string">&quot;Demo&quot;</span>).path<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    Environment.DIRECTORY_PICTURES + <span class="hljs-string">&quot;/Demo&quot;</span><br>&#125;<br><br><span class="hljs-keyword">if</span>(Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.Q) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">val</span> bitmap = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Bitmap</span>.</span></span>create<span class="hljs-constructor">Bitmap(400, 400, Bitmap.Config.ARGB_8888)</span><br>        <span class="hljs-comment">//创建了一个红色的图片</span><br>        <span class="hljs-keyword">val</span> canvas = <span class="hljs-constructor">Canvas(<span class="hljs-params">bitmap</span>)</span><br>        canvas.draw<span class="hljs-constructor">Color(Color.RED)</span><br>        <span class="hljs-keyword">val</span> outputFile = <span class="hljs-constructor">File(<span class="hljs-params">path</span>)</span><br>        <span class="hljs-keyword">val</span> fos = <span class="hljs-constructor">FileOutputStream(<span class="hljs-params">outputFile</span>)</span><br>        bitmap.compress(Bitmap.CompressFormat.PNG, <span class="hljs-number">90</span>, fos)<br>        fos.close<span class="hljs-literal">()</span><br>    &#125; catch (e : FileNotFoundException) &#123;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>d(TAG, <span class="hljs-string">&quot;创建失败：$&#123;e.message&#125;&quot;</span>)<br>    &#125; catch (e : IOException) &#123;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>d(TAG, <span class="hljs-string">&quot;创建失败：$&#123;e.message&#125;&quot;</span>)<br>    &#125;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-keyword">val</span> values = <span class="hljs-constructor">ContentValues()</span><br>    values.put(MediaStore.Images.Media.DISPLAY_NAME, <span class="hljs-string">&quot;red_image.png&quot;</span>)<br>    values.put(MediaStore.Images.Media.DESCRIPTION, <span class="hljs-string">&quot;This is an image&quot;</span>)<br>    values.put(MediaStore.Images.Media.MIME_TYPE, <span class="hljs-string">&quot;image/png&quot;</span>)<br>    values.put(MediaStore.Images.Media.RELATIVE_PATH, imageMediaPath)<br>    <span class="hljs-keyword">val</span> <span class="hljs-keyword">external</span> = MediaStore.Images.Media.EXTERNAL_CONTENT_URI<br>    <span class="hljs-keyword">val</span> insertUri = contentResolver.insert(<span class="hljs-keyword">external</span>, values)<br>    var os: OutputStream? = null<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (insertUri != null) &#123;<br>            os = contentResolver.<span class="hljs-keyword">open</span><span class="hljs-constructor">OutputStream(<span class="hljs-params">insertUri</span>)</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (os != null) &#123;<br>            <span class="hljs-keyword">val</span> bitmap = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Bitmap</span>.</span></span>create<span class="hljs-constructor">Bitmap(400, 400, Bitmap.Config.ARGB_8888)</span><br>            <span class="hljs-comment">//创建了一个红色的图片</span><br>            <span class="hljs-keyword">val</span> canvas = <span class="hljs-constructor">Canvas(<span class="hljs-params">bitmap</span>)</span><br>            canvas.draw<span class="hljs-constructor">Color(Color.RED)</span><br>            <span class="hljs-comment">// 向os流写入数据</span><br>            bitmap.compress(Bitmap.CompressFormat.PNG, <span class="hljs-number">90</span>, os)<br>        &#125;<br>    &#125; catch (e: IOException) &#123;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>d(TAG, <span class="hljs-string">&quot;创建失败：$&#123;e.message&#125;&quot;</span>)<br>    &#125; finally &#123;<br>        os?.close<span class="hljs-literal">()</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：使用MediaStore保存媒体文件，不保证在Android Q以下的手机上也能成功，所以最稳妥的办法就是Android Q以下申请WRITE_EXTERNAL权限，直接使用File的Api保存文件并通知系统扫描媒体数据库，Android Q及以上版本才使用MediaStore方式存储。其他媒体文件（如视频，音频，文件等）同上。另外，使用MediaStore存储的方式不需要通知系统扫描媒体数据库。</p><p><strong>删除公共目录文件（MediaStore）</strong></p><p>Android Q以下版本，删除文件需要申请WRITE_EXTERNAL_STORAGE权限，通过MediaStore的DATA字段获得媒体文件的绝对路径，然后使用File相关API删除，在Android Q及以上版本，DATA字段被弃用，应用也无法通过路径访问公共目录，此时需要用getContentProvider.delete()方法来删除，应用删除自己创建的媒体文件不需要READ_EXTERNAL_STORAGE权限，也不需要用户授权就可以直接删除。</p><p>但是如果应用卸载后又重新安装，删除卸载之前保存的文件就无法直接删除，或者删除其他应用创建的媒体文件也不能直接删除，此时需要申请READ_EXTERNAL_STORAGE权限。Android Q以后，删除时还会抛出RecoverableSecurityException异常，在操作或删除公共目录的文件时，需要Catch该异常，由MediaProvider弹出弹框给用户选择是否允许应用修改或删除图片/视频/音频文件。用户操作的结果，将通过onActivityResult回调返回到APP。如果用户允许，APP将获得该Uri的修改权限，直到设备重启。</p><p>示例代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//这里的imgUri是使用上述代码获取的</span><br><span class="hljs-keyword">val</span> queryUri = imgUri<br><span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.Q) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">val</span> projection = arrayOf(MediaStore.Images.Media.DATA)<br>        <span class="hljs-keyword">val</span> cursor = contentResolver.query(queryUri, projection,<br>                    <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>)<br>        cursor?.let&#123;<br>            <span class="hljs-keyword">val</span> columnIndex = it.getColumnIndex(MediaStore.Images.Media.DATA)<br>            <span class="hljs-keyword">if</span> (columnIndex &gt; -<span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">val</span> file = File(it.getString(columnIndex))<br>                file.delete()<br>            &#125;<br>        &#125;<br>        cursor?.close()<br>    &#125; <span class="hljs-keyword">catch</span> (e: IOException) &#123;<br>        Log.e(TAG, <span class="hljs-string">&quot;delete failed :<span class="hljs-subst">$&#123;e.message&#125;</span>&quot;</span>)<br>    &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        contentResolver.delete(queryUri, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>)<br>    &#125; <span class="hljs-keyword">catch</span> (e: IOException) &#123;<br>        Log.e(TAG, <span class="hljs-string">&quot;delete failed :<span class="hljs-subst">$&#123;e.message&#125;</span>&quot;</span>)<br>    &#125; <span class="hljs-keyword">catch</span> (e1: RecoverableSecurityException) &#123;<br>        <span class="hljs-comment">//捕获 RecoverableSecurityException异常，发起请求</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            startIntentSenderForResult(e1.userAction.actionIntent.intentSender,<br>                        REQUEST_CODE, <span class="hljs-literal">null</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br>        &#125; <span class="hljs-keyword">catch</span> (e2: IntentSender.SendIntentException) &#123;<br>            e2.printStackTrace()<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>无法访问图片的地理位置数据</strong></p><p>Android Q及以上版本，因为隐私问题，默认不再提供图片的地理位置信息，要获取该信息需要向用户申请ACCESS_MEDIA_LOCATION权限，并使用MediaStore.setRequireOriginal()接口更新文件Uri。</p><p><strong>分享文件的处理（AndroidN）</strong></p><p>在Android N以前，分享文件没有任何限制，拿到文件后通过Uri.fromFile()转换成uri，即可分享文件到其他应用，这样转换出来的uri是file://开头的，在Android N（Android7.0）以后，继续以这种方式分享会抛出FileUriExposedException的异常并崩溃，此时需要用FileProvider来实现文件的分享，具体就不展开讲了，自行百度即可。</p><p><strong>使用SAF访问指定文件目录</strong></p><p>SAF，即Storage Access Framework。根据当前系统中存在的DocumentsProvider，让用户选择特定的文件或文件夹，使调用SAF的APP获取它们的读写权限。APP通过SAF获得文件或目录的读写权限，无需申请任何存储相关的运行时权限。</p><p>/  总结  /</p><p>现在的手机系统，Android Q系统已逐渐成为主流，Android12也马上要发布，所以适配Android Q是十分必要的工作，个人建议是，在开发过程中，不管什么版本，如果文件只有自己应用需要，都保存在沙盒目录（App-special）内，根据文件类型做好文件夹区分，如File，Cache，Pictures等。</p><p>如果需要保存图片或者视频到相册时，Android Q以下系统依旧使用旧的方式，直接使用文件方式保存，Android Q以上使用MediaStore方式存储，读取媒体文件时（最常见的比如读取用户的图片并显示），Android Q以下使用DATA字段，Android Q以上使用RELATIVE_PATH字段，验证媒体文件是否存在时，均使用openFileDescriptor的方式。保存文档等文件同上，这样的意义在于文件不会随着应用的卸载而被删除。</p><p>Android Q以下版本保存图片等媒体文件时不要使用MediaStore的方式，因为Android Q以下并不能保证MediaStore方式的可靠性，有可能手机厂商更改了某些行为，所以这种方式只在Android Q及以上版本使用，Android Q以下版本，申请WRITE_EXTERNAL_STORAGE权限并使用文件操作即可。</p><p>如果有特殊需求需要访问公共目录的文件，使用SAF向用户申请权限，一般是文件管理类应用才有这类需求。</p><p>Android Q之后，无论是向沙盒内保存文件，还是使用MediaStore保存媒体文件，又或者是使用SAF访问特定文件目录，均不需要WRITE_EXTERNAL_STORAGE权限，适配工作做好以后，动态申请的时候根据版本去掉即可。在需要访问用户图片或者其他媒体文件时，再申请READ_EXTERNAL_STORAGE权限，删除其他应用的媒体文件时还需要额外向用户申请读写操作权限。</p><hr><h1 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h1><h2 id="获取相册中的图片"><a href="#获取相册中的图片" class="headerlink" title="/  获取相册中的图片  /"></a>/  获取相册中的图片  /</h2><p>首先来学习一下如何在作用域存储当中获取手机相册里的图片。注意，虽然本篇文章中我是以图片来举例的，但是获取音频、视频的用法也是基本相同的。</p><p>不同于过去可以直接获取到相册中图片的绝对路径，在作用域存储当中，我们只能借助MediaStore API获取到图片的Uri，示例代码如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">val</span> cursor = contentResolver.query(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, null, null, null, <span class="hljs-string">&quot;$&#123;MediaStore.MediaColumns.DATE_ADDED&#125; desc&quot;</span>)<br><span class="hljs-keyword">if</span> (cursor != null) &#123;<br>    <span class="hljs-keyword">while</span> (cursor.move<span class="hljs-constructor">ToNext()</span>) &#123;<br>        <span class="hljs-keyword">val</span> id = cursor.get<span class="hljs-constructor">Long(<span class="hljs-params">cursor</span>.<span class="hljs-params">getColumnIndexOrThrow</span>(MediaStore.MediaColumns.<span class="hljs-params">_ID</span>)</span>)<br>        <span class="hljs-keyword">val</span> uri = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ContentUris</span>.</span></span><span class="hljs-keyword">with</span><span class="hljs-constructor">AppendedId(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, <span class="hljs-params">id</span>)</span><br>        println(<span class="hljs-string">&quot;image uri is $uri&quot;</span>)<br>    &#125;<br>    cursor.close<span class="hljs-literal">()</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中，我们先是通过ContentResolver获取到了相册中所有图片的id，然后再借助ContentUris将id拼装成一个完整的Uri对象。一张图片的Uri格式大致如下所示：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">content:<span class="hljs-regexp">//m</span>edia<span class="hljs-regexp">/external/im</span>ages<span class="hljs-regexp">/media/</span><span class="hljs-number">321</span><br></code></pre></td></tr></table></figure><p>那么有些朋友可能会问了，获取到了Uri之后，我又该怎样将这张图片显示出来呢？这就有很多种办法了，比如使用Glide来加载图片，它本身就支持传入Uri对象来作为图片路径：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">Glide</span><span class="hljs-selector-class">.with</span>(context)<span class="hljs-selector-class">.load</span>(uri)<span class="hljs-selector-class">.into</span>(imageView)<br></code></pre></td></tr></table></figure><p>而如果你没有使用Glide或其他图片加载框架，想在不借助第三方库的情况下直接将一个Uri对象解析成图片，可以使用如下代码：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">val</span> fd = contentResolver.<span class="hljs-keyword">open</span><span class="hljs-constructor">FileDescriptor(<span class="hljs-params">uri</span>, <span class="hljs-string">&quot;r&quot;</span>)</span><br><span class="hljs-keyword">if</span> (fd != null) &#123;<br>    <span class="hljs-keyword">val</span> bitmap = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">BitmapFactory</span>.</span></span>decode<span class="hljs-constructor">FileDescriptor(<span class="hljs-params">fd</span>.<span class="hljs-params">fileDescriptor</span>)</span><br>    fd.close<span class="hljs-literal">()</span><br>    imageView.set<span class="hljs-constructor">ImageBitmap(<span class="hljs-params">bitmap</span>)</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码中，我们调用了ContentResolver的openFileDescriptor()方法，并传入Uri对象来打开文件句柄，然后再调用BitmapFactory的decodeFileDescriptor()方法将文件句柄解析成Bitmap对象即可。</p><p>Demo效果：</p><p><img src="TyporaRaw/android%E5%AD%98%E5%82%A8%E4%BD%BF%E7%94%A8.assets/640-16467507662931.gif" alt="图片"></p><p>这样我们就将获取相册中图片的方式掌握了，并且这种方式在所有的Android系统版本中都适用。</p><p>那么接下来，我们开始学习如何将一张图片添加到相册。</p><h2 id="将图片添加到相册"><a href="#将图片添加到相册" class="headerlink" title="/  将图片添加到相册  /"></a>/  将图片添加到相册  /</h2><p>将一张图片添加到手机相册要相对稍微复杂一点，因为不同系统版本之间的处理方式是不太一样的。</p><p>我们还是通过一段代码示例来直观地学习一下，代码如下所示：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs stylus">fun addBitmapToAlbum(bitmap: Bitmap, displayName: String, mimeType: String, compressFormat: Bitmap.CompressFormat) &#123;<br>    val values = ContentValues()<br>    values<span class="hljs-selector-class">.put</span>(MediaStore<span class="hljs-selector-class">.MediaColumns</span><span class="hljs-selector-class">.DISPLAY_NAME</span>, displayName)<br>    values<span class="hljs-selector-class">.put</span>(MediaStore<span class="hljs-selector-class">.MediaColumns</span><span class="hljs-selector-class">.MIME_TYPE</span>, mimeType)<br>    <span class="hljs-keyword">if</span> (Build<span class="hljs-selector-class">.VERSION</span><span class="hljs-selector-class">.SDK_INT</span> &gt;= Build<span class="hljs-selector-class">.VERSION_CODES</span>.Q) &#123;<br>        values<span class="hljs-selector-class">.put</span>(MediaStore<span class="hljs-selector-class">.MediaColumns</span><span class="hljs-selector-class">.RELATIVE_PATH</span>, Environment.DIRECTORY_DCIM)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        values<span class="hljs-selector-class">.put</span>(MediaStore<span class="hljs-selector-class">.MediaColumns</span><span class="hljs-selector-class">.DATA</span>, <span class="hljs-string">&quot;$&#123;Environment.getExternalStorageDirectory().path&#125;/$&#123;Environment.DIRECTORY_DCIM&#125;/$displayName&quot;</span>)<br>    &#125;<br>    val uri = contentResolver<span class="hljs-selector-class">.insert</span>(MediaStore<span class="hljs-selector-class">.Images</span><span class="hljs-selector-class">.Media</span><span class="hljs-selector-class">.EXTERNAL_CONTENT_URI</span>, values)<br>    <span class="hljs-keyword">if</span> (uri != null) &#123;<br>        val outputStream = contentResolver<span class="hljs-selector-class">.openOutputStream</span>(uri)<br>        <span class="hljs-keyword">if</span> (outputStream != null) &#123;<br>            bitmap<span class="hljs-selector-class">.compress</span>(compressFormat, <span class="hljs-number">100</span>, outputStream)<br>            outputStream<span class="hljs-selector-class">.close</span>()<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码演示了如何将一个Bitmap对象添加到手机相册当中，我来简单解释一下。</p><p>想要将一张图片添加到手机相册，我们需要构建一个ContentValues对象，然后向这个对象中添加三个重要的数据。一个是DISPLAY_NAME，也就是图片显示的名称，一个是MIME_TYPE，也就是图片的mime类型。还有一个是图片存储的路径，不过这个值在Android 10和之前的系统版本中的处理方式不一样。Android 10中新增了一个RELATIVE_PATH常量，表示文件存储的相对路径，可选值有DIRECTORY_DCIM、DIRECTORY_PICTURES、DIRECTORY_MOVIES、DIRECTORY_MUSIC等，分别表示相册、图片、电影、音乐等目录。而在之前的系统版本中并没有RELATIVE_PATH，所以我们要使用DATA常量（已在Android 10中废弃），并拼装出一个文件存储的绝对路径才行。</p><p>有了ContentValues对象之后，接下来调用ContentResolver的insert()方法即可获得插入图片的Uri。但仅仅获得Uri仍然是不够的，我们还需要向该Uri所对应的图片写入数据才行。调用ContentResolver的openOutputStream()方法获得文件的输出流，然后将Bitmap对象写入到该输出流当中即可。</p><p>以上代码即可实现将Bitmap对象存储到手机相册当中，那么有些朋友可能会问了，如果我要存储的图片并不是Bitmap对象，而是一张网络上的图片，或者是当前应用关联目录下的图片该怎么办呢？</p><p>其实方法都是相似的，因为不管是网络上的图片还是关联目录下的图片，我们都能获取到它的输入流，只要不断读取输入流中的数据，然后写入到相册图片所对应的输出流当中就可以了，示例代码如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs stylus">fun writeInputStreamToAlbum(inputStream: InputStream, displayName: String, mimeType: String) &#123;<br>    val values = ContentValues()<br>    values<span class="hljs-selector-class">.put</span>(MediaStore<span class="hljs-selector-class">.MediaColumns</span><span class="hljs-selector-class">.DISPLAY_NAME</span>, displayName)<br>    values<span class="hljs-selector-class">.put</span>(MediaStore<span class="hljs-selector-class">.MediaColumns</span><span class="hljs-selector-class">.MIME_TYPE</span>, mimeType)<br>    <span class="hljs-keyword">if</span> (Build<span class="hljs-selector-class">.VERSION</span><span class="hljs-selector-class">.SDK_INT</span> &gt;= Build<span class="hljs-selector-class">.VERSION_CODES</span>.Q) &#123;<br>        values<span class="hljs-selector-class">.put</span>(MediaStore<span class="hljs-selector-class">.MediaColumns</span><span class="hljs-selector-class">.RELATIVE_PATH</span>, Environment.DIRECTORY_DCIM)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        values<span class="hljs-selector-class">.put</span>(MediaStore<span class="hljs-selector-class">.MediaColumns</span><span class="hljs-selector-class">.DATA</span>, <span class="hljs-string">&quot;$&#123;Environment.getExternalStorageDirectory().path&#125;/$&#123;Environment.DIRECTORY_DCIM&#125;/$displayName&quot;</span>)<br>    &#125;<br>    val bis = BufferedInputStream(inputStream)<br>    val uri = contentResolver<span class="hljs-selector-class">.insert</span>(MediaStore<span class="hljs-selector-class">.Images</span><span class="hljs-selector-class">.Media</span><span class="hljs-selector-class">.EXTERNAL_CONTENT_URI</span>, values)<br>    <span class="hljs-keyword">if</span> (uri != null) &#123;<br>        val outputStream = contentResolver<span class="hljs-selector-class">.openOutputStream</span>(uri)<br>        <span class="hljs-keyword">if</span> (outputStream != null) &#123;<br>            val bos = BufferedOutputStream(outputStream)<br>            val buffer = ByteArray(<span class="hljs-number">1024</span>)<br>            <span class="hljs-selector-tag">var</span> bytes = bis<span class="hljs-selector-class">.read</span>(buffer)<br>            while (bytes &gt;= <span class="hljs-number">0</span>) &#123;<br>                bos<span class="hljs-selector-class">.write</span>(buffer, <span class="hljs-number">0</span> , bytes)<br>                bos<span class="hljs-selector-class">.flush</span>()<br>                bytes = bis<span class="hljs-selector-class">.read</span>(buffer)<br>            &#125;<br>            bos<span class="hljs-selector-class">.close</span>()<br>        &#125;<br>    &#125;<br>    bis<span class="hljs-selector-class">.close</span>()<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码中只是将输入流和输出流的部分重新编写了一下，其他部分和之前存储Bitmap的代码是完全一致的，相信很好理解。</p><p>Demo效果：</p><p><img src="TyporaRaw/android%E5%AD%98%E5%82%A8%E4%BD%BF%E7%94%A8.assets/640-16467495390871-16467507662932.gif" alt="图片"></p><p>好了，这样我们就将相册图片的读取和存储问题都解决了，下面我们来探讨另外一个常见的需求，如何将文件下载到Download目录。</p><h2 id="下载文件到Download目录"><a href="#下载文件到Download目录" class="headerlink" title="/  下载文件到Download目录  /"></a>/  下载文件到Download目录  /</h2><p>执行文件下载操作是一个很常见的场景，比如说下载pdf、doc文件，或者下载APK安装包等等。在过去，这些文件我们通常都会下载到Download目录，这是一个专门用于存放下载文件的目录。而从Android 10开始，我们已经不能以绝对路径的方式访问外置存储空间了，所以文件下载功能也会受到影响。</p><p>那么该如何解决呢？主要有以下两种方式。</p><p>第一种同时也是最简单的一种方式，就是更改文件的下载目录。将文件下载到应用程序的关联目录下，这样不用修改任何代码就可以让程序在Android 10系统上正常工作。但使用这种方式，你需要知道，下载的文件会被计入到应用程序的占用空间当中，同时如果应用程序被卸载了，该文件也会一同被删除。另外，存放在关联目录下的文件只能被当前的应用程序所访问，其他程序是没有读取权限的。</p><p>以上几个限制条件如果不能满足你的需求，那么就只能使用第二种方式，对Android 10系统进行代码适配，仍然将文件下载到Download目录下。</p><p>其实将文件下载到Download目录，和向相册中添加一张图片的过程是差不多的，Android 10在MediaStore中新增了一种Downloads集合，专门用于执行文件下载操作。但由于每个项目下载功能的实现都各不相同，有些项目的下载实现还十分复杂，因此怎么将以下的示例代码融合到你的项目当中是你自己需要思考的问题。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">fun</span> download<span class="hljs-constructor">File(<span class="hljs-params">fileUrl</span>: String, <span class="hljs-params">fileName</span>: String)</span> &#123;<br>    <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.Q) &#123;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Toast</span>.</span></span>make<span class="hljs-constructor">Text(<span class="hljs-params">this</span>, <span class="hljs-string">&quot;You must use device running Android 10 or higher&quot;</span>, Toast.LENGTH_SHORT)</span>.show<span class="hljs-literal">()</span><br>        return<br>    &#125;<br>    thread &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">val</span> url = <span class="hljs-constructor">URL(<span class="hljs-params">fileUrl</span>)</span><br>            <span class="hljs-keyword">val</span> connection = url.<span class="hljs-keyword">open</span><span class="hljs-constructor">Connection()</span> <span class="hljs-keyword">as</span> HttpURLConnection<br>            connection.requestMethod = <span class="hljs-string">&quot;GET&quot;</span><br>            connection.connectTimeout = <span class="hljs-number">8000</span><br>            connection.readTimeout = <span class="hljs-number">8000</span><br>            <span class="hljs-keyword">val</span> inputStream = connection.inputStream<br>            <span class="hljs-keyword">val</span> bis = <span class="hljs-constructor">BufferedInputStream(<span class="hljs-params">inputStream</span>)</span><br>            <span class="hljs-keyword">val</span> values = <span class="hljs-constructor">ContentValues()</span><br>            values.put(MediaStore.MediaColumns.DISPLAY_NAME, fileName)<br>            values.put(MediaStore.MediaColumns.RELATIVE_PATH, Environment.DIRECTORY_DOWNLOADS)<br>            <span class="hljs-keyword">val</span> uri = contentResolver.insert(MediaStore.Downloads.EXTERNAL_CONTENT_URI, values)<br>            <span class="hljs-keyword">if</span> (uri != null) &#123;<br>                <span class="hljs-keyword">val</span> outputStream = contentResolver.<span class="hljs-keyword">open</span><span class="hljs-constructor">OutputStream(<span class="hljs-params">uri</span>)</span><br>                <span class="hljs-keyword">if</span> (outputStream != null) &#123;<br>                    <span class="hljs-keyword">val</span> bos = <span class="hljs-constructor">BufferedOutputStream(<span class="hljs-params">outputStream</span>)</span><br>                    <span class="hljs-keyword">val</span> buffer = <span class="hljs-constructor">ByteArray(1024)</span><br>                    var <span class="hljs-built_in">bytes</span> = bis.read(buffer)<br>                    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">bytes</span> &gt;= <span class="hljs-number">0</span>) &#123;<br>                        bos.write(buffer, <span class="hljs-number">0</span> , <span class="hljs-built_in">bytes</span>)<br>                        bos.flush<span class="hljs-literal">()</span><br>                        <span class="hljs-built_in">bytes</span> = bis.read(buffer)<br>                    &#125;<br>                    bos.close<span class="hljs-literal">()</span><br>                &#125;<br>            &#125;<br>            bis.close<span class="hljs-literal">()</span><br>        &#125; catch(e: Exception) &#123;<br>            e.print<span class="hljs-constructor">StackTrace()</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码总体来讲还是比较好理解的，主要就是添加了一些Http请求的代码，并将MediaStore.Images.Media改成了MediaStore.Downloads，其他部分几乎是没有变化的，我就不再多加解释了。</p><p>注意，上述代码只能在Android 10或更高的系统版本上运行，因为MediaStore.Downloads是Android 10中新增的API。至于Android 9及以下的系统版本，请你仍然使用之前的代码来进行文件下载。</p><p>Demo效果：</p><p><img src="TyporaRaw/android%E5%AD%98%E5%82%A8%E4%BD%BF%E7%94%A8.assets/640-16467495390882-16467507662933.gif" alt="图片"></p><h2 id="使用文件选择器"><a href="#使用文件选择器" class="headerlink" title="/  使用文件选择器  /"></a>/  使用文件选择器  /</h2><p>如果我们要读取SD卡上非图片、音频、视频类的文件，比如说打开一个PDF文件，这个时候就不能再使用MediaStore API了，而是要使用文件选择器。</p><p>但是，我们不能再像之前的写法那样，自己写一个文件浏览器，然后从中选取文件，而是必须要使用手机系统中内置的文件选择器。示例代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">const</span> <span class="hljs-keyword">val</span> PICK_FILE = <span class="hljs-number">1</span><br><br><span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">pickFile</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> intent = Intent(Intent.ACTION_OPEN_DOCUMENT)<br>    intent.addCategory(Intent.CATEGORY_OPENABLE)<br>    intent.type = <span class="hljs-string">&quot;*/*&quot;</span><br>    startActivityForResult(intent, PICK_FILE)<br>&#125;<br><br><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onActivityResult</span><span class="hljs-params">(requestCode: <span class="hljs-type">Int</span>, resultCode: <span class="hljs-type">Int</span>, <span class="hljs-keyword">data</span>: <span class="hljs-type">Intent</span>?)</span></span> &#123;<br>    <span class="hljs-keyword">super</span>.onActivityResult(requestCode, resultCode, <span class="hljs-keyword">data</span>)<br>    <span class="hljs-keyword">when</span> (requestCode) &#123;<br>        PICK_FILE -&gt; &#123;<br>            <span class="hljs-keyword">if</span> (resultCode == Activity.RESULT_OK &amp;&amp; <span class="hljs-keyword">data</span> != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">val</span> uri = <span class="hljs-keyword">data</span>.<span class="hljs-keyword">data</span><br>                <span class="hljs-keyword">if</span> (uri != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">val</span> inputStream = contentResolver.openInputStream(uri)<br>                    <span class="hljs-comment">// 执行文件读取操作</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里在pickFile()方法当中通过Intent去启动系统的文件选择器，注意Intent的action和category都是固定不变的。而type属性可以用于对文件类型进行过滤，比如指定成image/<em>就可以只显示图片类型的文件，这里写成</em>/*表示显示所有类型的文件。注意type属性必须要指定，否则会产生崩溃。</p><p>然后在onActivityResult()方法当中，我们就可以获取到用户选中文件的Uri，之后通过ContentResolver打开文件输入流来进行读取就可以了。</p><p>Demo效果：</p><p><img src="TyporaRaw/android%E5%AD%98%E5%82%A8%E4%BD%BF%E7%94%A8.assets/640-16467495390883-16467507662934.gif" alt="图片"></p><h2 id="第三方SDK不支持怎么办？"><a href="#第三方SDK不支持怎么办？" class="headerlink" title="/  第三方SDK不支持怎么办？  /"></a>/  第三方SDK不支持怎么办？  /</h2><p>阅读完了本篇文章之后，相信你对Android 10作用域存储的用法和适配基本上都已经掌握了。然而我们在实际的开发工作当中还可能会面临一个非常头疼的问题，就是我自己的代码当然可以进行适配，但是项目中使用的第三方SDK还不支持作用域存储该怎么办呢？</p><p>这个情况确实是存在的，比如我之前使用的七牛云SDK，它的文件上传功能要求你传入的就是一个文件的绝对路径，而不支持传入Uri对象，大家应该也会碰到类似的问题。</p><p>由于我们是没有权限修改第三方SDK的，因此最简单直接的办法就是等待第三方SDK的提供者对这部分功能进行更新，在那之前我们先不要将targetSdkVersion指定到29，或者先在AndroidManifest文件中配置一下requestLegacyExternalStorage属性。</p><p>然而如果你不想使用这种权宜之计，其实还有一个非常好的办法来解决此问题，就是我们自己编写一个文件复制功能，将Uri对象所对应的文件复制到应用程序的关联目录下，然后再将关联目录下这个文件的绝对路径传递给第三方SDK，这样就可以完美进行适配了。这个功能的示例代码如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">fun</span> copy<span class="hljs-constructor">UriToExternalFilesDir(<span class="hljs-params">uri</span>: Uri, <span class="hljs-params">fileName</span>: String)</span> &#123;<br>    <span class="hljs-keyword">val</span> inputStream = contentResolver.<span class="hljs-keyword">open</span><span class="hljs-constructor">InputStream(<span class="hljs-params">uri</span>)</span><br>    <span class="hljs-keyword">val</span> tempDir = get<span class="hljs-constructor">ExternalFilesDir(<span class="hljs-string">&quot;temp&quot;</span>)</span><br>    <span class="hljs-keyword">if</span> (inputStream != null<span class="hljs-operator"> &amp;&amp; </span>tempDir != null) &#123;<br>        <span class="hljs-keyword">val</span> file = <span class="hljs-constructor">File(<span class="hljs-string">&quot;$tempDir/$fileName&quot;</span>)</span><br>        <span class="hljs-keyword">val</span> fos = <span class="hljs-constructor">FileOutputStream(<span class="hljs-params">file</span>)</span><br>        <span class="hljs-keyword">val</span> bis = <span class="hljs-constructor">BufferedInputStream(<span class="hljs-params">inputStream</span>)</span><br>        <span class="hljs-keyword">val</span> bos = <span class="hljs-constructor">BufferedOutputStream(<span class="hljs-params">fos</span>)</span><br>        <span class="hljs-keyword">val</span> byteArray = <span class="hljs-constructor">ByteArray(1024)</span><br>        var <span class="hljs-built_in">bytes</span> = bis.read(byteArray)<br>        <span class="hljs-keyword">while</span> (<span class="hljs-built_in">bytes</span> &gt; <span class="hljs-number">0</span>) &#123;<br>            bos.write(byteArray, <span class="hljs-number">0</span>, <span class="hljs-built_in">bytes</span>)<br>            bos.flush<span class="hljs-literal">()</span><br>            <span class="hljs-built_in">bytes</span> = bis.read(byteArray)<br>        &#125;<br>        bos.close<span class="hljs-literal">()</span><br>        fos.close<span class="hljs-literal">()</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>好的，关于Android 10作用域存储的重要知识点就讲到这里，相信你已经可以完全掌握了。下篇文章中我们会继续学习Android 10适配，讲一讲深色主题的功能，敬请期待。</p><p>注：本篇文章中演示的所有示例，都可以到ScopedStorageDemo这个开源库中找到其对应的源码。</p><p>开源库地址是：</p><blockquote><p><a href="https://github.com/guolindev/ScopedStorageDemo">https://github.com/guolindev/ScopedStorageDemo</a></p></blockquote><hr><h1 id="一文带你了解适配Android-11分区存储"><a href="#一文带你了解适配Android-11分区存储" class="headerlink" title="一文带你了解适配Android 11分区存储"></a>一文带你了解适配Android 11分区存储</h1><h2 id="1-分区存储概念"><a href="#1-分区存储概念" class="headerlink" title="1 分区存储概念"></a><em>1</em> 分区存储概念</h2><p>为了让用户更好地控制自己的文件并减少混乱，Android 10针对应用推出的一个新的存储范例，新的存储模型会让以 Android 10（API 级别 29）及更高版本为目标平台的应用在默认情况下被赋予了对外部存储设备的分区访问权限，即分区存储(scoped storage)。分区存储改变了应用在设备的外部存储设备中存储和访问文件的方式。</p><p>从另一个角度来说，分区存储的推出更好的保护用户的隐私。默认情况下，对于以 Android 10 及更高版本为目标平台的应用，其访问权限范围限定为外部存储，即分区存储。此类应用可以查看外部存储设备内以下类型的文件，无需请求任何与存储相关的用户权限：</p><ul><li><p>特定于应用的目录中的文件（使用 getExternalFilesDir() 访问）。</p></li><li><p>应用创建的照片、视频和音频片段（通过媒体库访问）。</p></li></ul><p>意思是说，我们的app在外部存储设备（即SD卡）上存文件的时候，需要先想明白需要存的数据是属于app私有的还是需要分享的，如果是app私有的，存在getExternalFilesDir()返回的文件夹下，也就是Android/data/包名/files/文件夹；如果是需要分享的，需要采用媒体库（MediaStore）的方式来存取，后面会讲怎么存取。需要指出的是在分区存储模型下存取共享媒体文件是不需要存储权限的，而旧的存储模型是需要存储权限的。</p><p>下表总结了分区存储如何影响文件访问：</p><table><thead><tr><th align="left">文件位置</th><th align="left">所需权限</th><th align="left">访问方法 (*)</th><th align="left">卸载应用时是否移除文件？</th></tr></thead><tbody><tr><td align="left">特定于应用的目录</td><td align="left">无</td><td align="left">getExternalFilesDir()</td><td align="left">是</td></tr><tr><td align="left">媒体集合（照片、视频、音频）</td><td align="left">READ_EXTERNAL_STORAGE（仅当访问其他应用的文件时）</td><td align="left">MediaStore</td><td align="left">否</td></tr><tr><td align="left">下载内容（文档和电子书籍）</td><td align="left">无</td><td align="left">存储访问框架（加载系统的文件选择器）</td><td align="left">否</td></tr></tbody></table><h2 id="2-适配分区存储"><a href="#2-适配分区存储" class="headerlink" title="*2 *适配分区存储"></a>*2 *适配分区存储</h2><h3 id="为什么要适配"><a href="#为什么要适配" class="headerlink" title="为什么要适配"></a><strong>为什么要适配</strong></h3><p>在分区存储模型下，外部存储设备的公共区域是不让访问的，如果强行访问，会在创建或读写文件的api上报错，具体看分区存储模型下，访问SD卡公共区域错误举例。那么有没有办法关闭分区存储模型呢？</p><p>有两种办法，第一种是app的targetSdkVersion永远低于29，这个是不现实的；第二种办法是targetSdkVersion 29时覆盖安装和新安装能关闭，targetSdkVersion 30时覆盖安装能关闭，新安装是没有办法关闭的，具体看requestLegacyExternalStorage和preserveLegacyExternalStorage的理解。而且说不定，Android 12出来后，以Android 12为目标平台的app都是强制执行分区存储模型的。所以分区存储是一定需要适配的，而且越早适配越好。</p><h3 id="怎么适配"><a href="#怎么适配" class="headerlink" title="怎么适配"></a><strong>怎么适配</strong></h3><p>适配分为两部分，新数据的存储和老数据的迁移，我们先说新数据的存储。</p><h4 id="新数据的存储"><a href="#新数据的存储" class="headerlink" title="新数据的存储"></a><strong>新数据的存储</strong></h4><p>把app所有需要存的数据梳理一遍，对于私有数据我们存到SD卡app私有目录下，对于需要共享的媒体数据我们通过MediaStore的方式。数据放到私有目录很简单我们不讲，主要讲怎么共享媒体数据，以视频为例，看下面的代码：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 保存共享媒体资源，必须使用先在MediaStore创建表示视频保存信息的Uri，然后通过Uri写入视频数据的方式。</span><br><span class="hljs-comment"> * 在&quot;分区存储&quot;模型中，这是官方推荐的，因为在Android 10禁止通过File的方式访问媒体资源，Android 11又允许了</span><br><span class="hljs-comment"> * 从Android 10开始默认是分区存储模型</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 说明：</span><br><span class="hljs-comment"> * 此方法中MediaStore默认的保存目录是/storage/emulated/0/video</span><br><span class="hljs-comment"> * 而Environment.DIRECTORY_MOVIES的目录是/storage/emulated/0/Movies</span><br><span class="hljs-comment"> * @param context</span><br><span class="hljs-comment"> * @return</span><br><span class="hljs-comment"> */</span><br>static Uri getSaveToGalleryVideoUri(Context <span class="hljs-built_in">context</span>, String videoName, String mineType, String subDir) &#123;<br>    ContentValues <span class="hljs-built_in">values</span> = <span class="hljs-built_in">new</span> ContentValues();<br>    <span class="hljs-built_in">values</span>.<span class="hljs-built_in">put</span>(MediaStore.Video.Media.DISPLAY_NAME,  videoName);<br>    <span class="hljs-built_in">values</span>.<span class="hljs-built_in">put</span>(MediaStore.Video.Media.MIME_TYPE, mineType);<br>    <span class="hljs-built_in">values</span>.<span class="hljs-built_in">put</span>(MediaStore.Video.Media.DATE_MODIFIED, System.currentTimeMillis() / <span class="hljs-number">1000</span>);<br>    <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q) &#123;<br>        <span class="hljs-built_in">values</span>.<span class="hljs-built_in">put</span>(MediaStore.Video.Media.RELATIVE_PATH, Environment.DIRECTORY_MOVIES + subDir);<br>    &#125;<br><br>    Uri uri = <span class="hljs-built_in">context</span>.getContentResolver().insert(MediaStore.Video.Media.EXTERNAL_CONTENT_URI, <span class="hljs-built_in">values</span>);<br>    printMediaInfo(<span class="hljs-built_in">context</span>, uri);<br>    <span class="hljs-built_in">return</span> uri;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>需要保存视频的时候，其实就是先在MediaStore的Video表插入一条记录，获取一个Uri，然后把视频写入这Uri就行了。具体保存位置，我们不用操心，它其实是保存到了Sd卡的Movies文件夹下了，在Android 10以上系统提供RELATIVE_PATH字段用于创建子目录。</p><p>我们会问，高版本可以这样共享视频，那么低版本可以吗？如果可以的话，低版本的也用这种方式，一套方案解决。理论上是可以的，毕竟MediaStore从Android诞生就存在。可实际操作发现了问题，具体看下面代码注释。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 此接口用于获取保存共享视频的输出流，推荐！！！</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 在低于29的系统上采用getSaveToGalleryVideoUri的方式保存共享视频，会有文件名不能定制、视频保存类型是.3gp、视频保存在video文件夹等问题</span><br><span class="hljs-comment"> * 所以在低版本上采用文件路径的方式写入数据。在低于29的系统上采用文件路径的方式是没有问题的，因为在这些系统上没有分区存储的概念</span><br><span class="hljs-comment"> * 以及，getExternalStoragePublicDirectory函数可用</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @param context</span><br><span class="hljs-comment"> * @param videoName</span><br><span class="hljs-comment"> * @param mineType</span><br><span class="hljs-comment"> * @return</span><br><span class="hljs-comment"> * @throws FileNotFoundException</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">public</span> static FileOutputStream getSaveToGalleryVideoOutputStream(@NonNull Context context, @NonNull String videoName, @NonNull String mineType) throws FileNotFoundException &#123;<br>    //先在MediaStore中查询，有的话直接返回<br>    Uri uri = SHScopedStorageManager.querySpecialVideoUri(context, videoName);<br>    <span class="hljs-keyword">if</span> (uri != <span class="hljs-keyword">null</span>) &#123;<br>        ParcelFileDescriptor fileDescriptor = context.getContentResolver().openFileDescriptor(uri, &quot;w&quot;);<br>        FileOutputStream outputStream = <span class="hljs-built_in">new</span> FileOutputStream(fileDescriptor.getFileDescriptor());<br>        <span class="hljs-keyword">return</span> outputStream;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (Build.<span class="hljs-keyword">VERSION</span>.SDK_INT &gt;= Build.VERSION_CODES.Q) &#123;<br>        uri = getSaveToGalleryVideoUri(context, videoName, mineType);<br>        <span class="hljs-keyword">if</span> (uri == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        ParcelFileDescriptor fileDescriptor = context.getContentResolver().openFileDescriptor(uri, &quot;w&quot;);<br>        FileOutputStream outputStream = <span class="hljs-built_in">new</span> FileOutputStream(fileDescriptor.getFileDescriptor());<br>        <span class="hljs-keyword">return</span> outputStream;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (TextUtils.isEmpty(videoName)) &#123;<br>            videoName = String.valueOf(<span class="hljs-keyword">System</span>.currentTimeMillis());<br>        &#125;<br>        //通过显示路径方式共享媒体的时候，是需要指定文件后缀，要不然下载文件会没有后缀名<br>        <span class="hljs-keyword">if</span> (!TextUtils.isEmpty(mineType)) &#123;<br>            String <span class="hljs-keyword">extension</span> = MimeTypeMap.getSingleton().getExtensionFromMimeType(mineType);<br>            <span class="hljs-keyword">if</span> (videoName.contains(&quot;.&quot;)) &#123;<br>                videoName = videoName.substring(<span class="hljs-number">0</span>, videoName.indexOf(&quot;.&quot;)) + &quot;.&quot; + <span class="hljs-keyword">extension</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                videoName += &quot;.&quot; + <span class="hljs-keyword">extension</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 直接路径的方式，组合出的文件路径，路径中的文件夹一定要存在，否则转成FileOutputStream的时候会报FileNotFoundException</span><br><span class="hljs-comment">         * 即便是通过DATA注册到MediaStore中，也是如此</span><br><span class="hljs-comment">         */</span><br>        String rootPath = getSaveToGalleryVideoPath();<br>        String videoPath = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">if</span> (rootPath.endsWith(File.separator)) &#123;<br>            videoPath = rootPath + videoName;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            videoPath = rootPath + File.separator + videoName;<br>        &#125;<br><br>        //通过DATA字段在MediaStore中注册一下<br>        ContentValues <span class="hljs-keyword">values</span> = <span class="hljs-built_in">new</span> ContentValues();<br>        <span class="hljs-keyword">values</span>.put(MediaStore.Video.Media.DISPLAY_NAME, videoName);<br>        <span class="hljs-keyword">values</span>.put(MediaStore.Video.Media.MIME_TYPE, mineType);<br>        <span class="hljs-keyword">values</span>.put(MediaStore.Video.Media.DATA, videoPath);<br>        <span class="hljs-keyword">values</span>.put(MediaStore.Video.Media.DATE_MODIFIED, <span class="hljs-keyword">System</span>.currentTimeMillis() / <span class="hljs-number">1000</span>);<br>        uri = context.getContentResolver().<span class="hljs-keyword">insert</span>(MediaStore.Video.Media.EXTERNAL_CONTENT_URI, <span class="hljs-keyword">values</span>);<br><br>        <span class="hljs-keyword">if</span> (uri == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br><br>        SHScopedStorageManager.printMediaInfo(context, uri);<br>        ParcelFileDescriptor fileDescriptor = context.getContentResolver().openFileDescriptor(uri, &quot;w&quot;);<br>        FileOutputStream outputStream = <span class="hljs-built_in">new</span> FileOutputStream(fileDescriptor.getFileDescriptor());<br><br>        <span class="hljs-keyword">return</span> outputStream;<br>    &#125;<br>&#125;<br><br><span class="hljs-built_in">public</span> static String getSaveToGalleryVideoPath() &#123;<br>    File <span class="hljs-type">path</span> = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_MOVIES);<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-type">path</span>.<span class="hljs-keyword">exists</span>()) &#123;<br>        <span class="hljs-type">path</span>.mkdirs();<br>    &#125;<br>    String pathStr = <span class="hljs-type">path</span>.getAbsolutePath() + VIDEO_DIR;<br>    File file = <span class="hljs-built_in">new</span> File(pathStr);<br>    <span class="hljs-keyword">if</span> (!file.<span class="hljs-keyword">exists</span>()) &#123;<br>        file.mkdirs();<br>    &#125;<br>    <span class="hljs-keyword">return</span> pathStr;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>解决办法，进行了版本区分，对外暴露OutputStream接口，低版本我们采用直接路径的方式，直接把视频保存到Movies目录下，而且还可以有子目录，为了让相册或者别的app能看到保存的视频，我们通过DATA把保存路径注册给了MediaStore，这个在低版本上是可行的，这种方式绝大多数开发者之前都是这么做的，但是，DATA从Android 10开始标记为弃用。</p><p>我们这里会问，我们可不可以在Android 10及以上也用直接路径保存视频到Movies目录下呢？可以，但是会有问题，首先Android 10的分区存储模型下不能使用直接路径，因为使用File api报错，不过我们可以通过requestLegacyExternalStorage禁用分区存储模型；最大的问题是获取Movies目录的接口getExternalStoragePublicDirectory从Android 10开始标记为弃用。而且google还提示了使用直接路径操作媒体文件的性能问题。</p><p>当您使用直接文件路径依序读取媒体文件时，其性能与 MediaStore API 相当。但是，当您使用直接文件路径随机读取和写入媒体文件时，进程的速度可能最多会慢一倍。在此类情况下，我们建议您改为使用 MediaStore API。</p><p>这套适配方案无论是在旧存储模型还是分区存储模型下都能完美运行，把共享视频保存到Medias的指定文件夹下，而且相册和别的app都能扫描的到。共享图片、音频和共享视频思路一样，大家自行编写。</p><h4 id="老数据的迁移"><a href="#老数据的迁移" class="headerlink" title="老数据的迁移"></a><strong>老数据的迁移</strong></h4><p>迁移老数据是为了在分区存储模型下，老数据依旧可以访问，如果不迁移这些散落在SD卡公共区域的数据，一旦开始执行分区存储模型，这些数据app就访问不到了。也就是说，在app还是旧存储模型的时候，需要把数据迁移到能够兼容分区存储要求的文件夹下。这块具体看数据迁移。</p><h2 id="3-数据迁移"><a href="#3-数据迁移" class="headerlink" title="3 数据迁移"></a><em>3</em> 数据迁移</h2><h3 id="理清头绪"><a href="#理清头绪" class="headerlink" title="理清头绪"></a><strong>理清头绪</strong></h3><p>在数据迁移的时候，有个很重要的前提是，app能够访问旧存储模型。我们看看什么情况能访问旧存储模型，得分几种情况讨论：</p><ul><li><ol><li>targetSdkVersion 28的app安装在Android 9（28）的手机上，手机系统升级到Android10或11，app正常访问旧存储模型。这种情况和把targetSDKVersion 28的app安装到Android10或11系统手机上一样的情况。</li></ol></li></ul><ul><li><ol start="2"><li>target 28在Android 9上，app target升级到30，覆盖安装，旧存储模型访问正常；target 28在Android10上，app target升级到30，覆盖安装，旧存储模型访问正常。</li></ol></li></ul><p>requestLegacyExternalStorage设置成true，在Android 10上新安装的target 30 app，也可以正常访问旧存储模型。</p><p>target28在Android11上，app target升级到30，覆盖安装，旧存储模型不能访问了，需要preserveLegacyExternalStorage设置成true。</p><h4 id="怎么进行数据迁移最好呢？"><a href="#怎么进行数据迁移最好呢？" class="headerlink" title="怎么进行数据迁移最好呢？"></a><strong>怎么进行数据迁移最好呢？</strong></h4><p>targetSDKVersion 28的时候，先大规模的升级一次，此app就包含数据迁移功能，同时共享媒体的方式也按照分区存储模型的规范来，这样不论什么版本系统的用户，都能完成数据迁移，同时进行共享媒体的方式也正确。</p><p>但是，有部分用户就是不升级我们的app，可是我们app以后也得发版，而且target也得升级，假如有一部分用户没升级，等升级的时候，我们的app的target已经是30了，这些用户的系统如果是小于29的，可以正常迁移，如果这些用户的系统版本是29或者30，那也得给这些用户迁移数据呀，target30的app在29的系统上正常迁移，target30的app在30系统上，preserveLegacyExternalStorage设置成true，正常迁移。</p><p>所以我们的数据迁移方案就是，做好数据迁移功能和共享媒体功能，requestLegacyExternalStorage和preserveLegacyExternalStorage都设置成true，target升级不升级都没问题。不过前提是compileSdkVersion得是30。</p><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a><strong>实战</strong></h3><p>在8.0及以上的系统，采用Files.move进行数据迁移，8.0以下的系统采用File.rename进行数据迁移。Files的move方法既可以作用于文件也可以作用于文件夹。</p><p>我们项目中需要move的是文件夹，首先看看对move文件夹的定义：</p><p>Empty directories can be moved. If the directory is not empty, the move is allowed when the directory can be moved without moving the contents of that directory. On UNIX systems, moving a directory within the same partition generally consists of renaming the directory. In that situation, this method works even when the directory contains files. </p><p>从定义中，我们知道在UNIX系统（linux源自UNIX）上同一个partition上，即便被move的文件夹中有内容，也是可以move的，实际就是重命名了一下。</p><p><strong>我们的需求：</strong></p><p>在分区存储模型下，SD卡的公共区域是禁止app使用的，为了保证我们app之前下载到SD的视频在分区存储模型下还能被app识别，所以，在app还是采用旧存储模型的时候，我们需要把这些视频迁移到app在SD卡的私有目录下。这两个目录都在SD卡上，属于同一个partition。说明一下，targetSDKVersion 29或30的app在Android 10和Android 11上，也是有办法让app采用旧存储模型的；targetSDKVersion 29以下的app在任何系统上都是执行旧存储模型。</p><p><strong>我们的实际情况：</strong></p><ul><li>共享数据迁移 把之前保存的需要分享的视频从app自建的目录迁移到分区存储模型下app也能访问到Movies目录，这样做的目的是在分区存储模型下，自己和别的app还是访问到这些视频。</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><br>从<span class="hljs-regexp">/storage/</span>emulated<span class="hljs-regexp">/0/</span>shvdownload<span class="hljs-regexp">/video/</span>VideoGallery 迁移到 <span class="hljs-regexp">/storage/</span>emulated<span class="hljs-regexp">/0/</span>Movies/SHVideo<br></code></pre></td></tr></table></figure><p>VideoGallery目录中有文件，SHVideo目录不存在，move可以成功。app在分区存储模型下，在任何版本系统上上述迁移都正常。</p><ul><li>私有数据迁移</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><br>从<span class="hljs-regexp">/storage/</span>emulated<span class="hljs-regexp">/0/</span>xxx<span class="hljs-regexp">/data 迁移到 /</span>storage<span class="hljs-regexp">/emulated/</span><span class="hljs-number">0</span><span class="hljs-regexp">/Android/</span>data<span class="hljs-regexp">/包名/</span>files/data<br></code></pre></td></tr></table></figure><p>xxx/data目录中有文件，files/data目录不存在，==在Android 10及以下的系统上，可以move成功；在Android 11的系统上 ，move失败了，报DirectoryNotEmptyException。== 猜测可能是Android 11对Android/data目录有了限制吧！如果，在Android 11上还需要进行这种迁移的话，可以采用遍历文件夹输入输出流拷贝的方式。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">java<span class="hljs-selector-class">.nio</span><span class="hljs-selector-class">.file</span><span class="hljs-selector-class">.DirectoryNotEmptyException</span>: /storage/emulated/<span class="hljs-number">0</span>/xxx/data<br> at sun<span class="hljs-selector-class">.nio</span><span class="hljs-selector-class">.fs</span><span class="hljs-selector-class">.UnixCopyFile</span><span class="hljs-selector-class">.move</span>(UnixCopyFile<span class="hljs-selector-class">.java</span>:<span class="hljs-number">498</span>)<br> at sun<span class="hljs-selector-class">.nio</span><span class="hljs-selector-class">.fs</span><span class="hljs-selector-class">.UnixFileSystemProvider</span><span class="hljs-selector-class">.move</span>(UnixFileSystemProvider<span class="hljs-selector-class">.java</span>:<span class="hljs-number">262</span>)<br> at java<span class="hljs-selector-class">.nio</span><span class="hljs-selector-class">.file</span><span class="hljs-selector-class">.Files</span><span class="hljs-selector-class">.move</span>(Files<span class="hljs-selector-class">.java</span>:<span class="hljs-number">1395</span>)<br> at com<span class="hljs-selector-class">.xxx</span><span class="hljs-selector-class">.sdk</span><span class="hljs-selector-class">.android</span><span class="hljs-selector-class">.storage</span><span class="hljs-selector-class">.SHDataMigrateUtil</span><span class="hljs-selector-class">.moveData</span>(SHDataMigrateUtil<span class="hljs-selector-class">.java</span>:<span class="hljs-number">257</span>)<br>    ...<br></code></pre></td></tr></table></figure><p>File.move 文件夹的时候，如果目标文件夹存在，那么会报java.nio.file.FileAlreadyExistsException异常。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> boolean move<span class="hljs-constructor">Data(File <span class="hljs-params">source</span>, File <span class="hljs-params">target</span>)</span> &#123;<br>    long start = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>current<span class="hljs-constructor">TimeMillis()</span>;<br>    <span class="hljs-comment">// 只有目标文件夹不存在的时候，move文件夹才能成功</span><br>    <span class="hljs-keyword">if</span> (target.exists<span class="hljs-literal">()</span><span class="hljs-operator"> &amp;&amp; </span>target.is<span class="hljs-constructor">Directory()</span><span class="hljs-operator"> &amp;&amp; </span>(target.<span class="hljs-built_in">list</span><span class="hljs-literal">()</span><span class="hljs-operator"> == </span>null<span class="hljs-operator"> || </span>target.<span class="hljs-built_in">list</span><span class="hljs-literal">()</span>.length<span class="hljs-operator"> == </span><span class="hljs-number">0</span>)) &#123;<br>        target.delete<span class="hljs-literal">()</span>;<br>    &#125;<br>    boolean isSuccess;<br>    <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;<br>        Path sourceP = source.<span class="hljs-keyword">to</span><span class="hljs-constructor">Path()</span>;<br>        Path targetP = target.<span class="hljs-keyword">to</span><span class="hljs-constructor">Path()</span>;<br><br>        <span class="hljs-keyword">if</span> (target.exists<span class="hljs-literal">()</span>) &#123;<br>            isSuccess = copy<span class="hljs-constructor">Dir(<span class="hljs-params">source</span>, <span class="hljs-params">target</span>)</span>;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LogUtils</span>.</span></span>i(TAG, <span class="hljs-string">&quot;moveData copyDir&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Files</span>.</span></span>move(sourceP, targetP);<br>                isSuccess = <span class="hljs-literal">true</span>;<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LogUtils</span>.</span></span>i(TAG, <span class="hljs-string">&quot;moveData Files.move&quot;</span>);<br>            &#125; catch (IOException e) &#123;<br>                e.print<span class="hljs-constructor">StackTrace()</span>;<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LogUtils</span>.</span></span>i(TAG, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>get<span class="hljs-constructor">StackTraceString(<span class="hljs-params">e</span>)</span>);<br>                <span class="hljs-comment">//在Android11上，move ATOMIC_MOVE会报AtomicMoveNotSupportedException异常</span><br>                <span class="hljs-comment">//在Android11上，move REPLACE_EXISTING会报DirectoryNotEmptyException异常</span><br>                isSuccess = copy<span class="hljs-constructor">Dir(<span class="hljs-params">source</span>, <span class="hljs-params">target</span>)</span>;<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LogUtils</span>.</span></span>i(TAG, <span class="hljs-string">&quot;moveData move fail, use copyDir&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (target.exists<span class="hljs-literal">()</span>) &#123;<br>            isSuccess = copy<span class="hljs-constructor">Dir(<span class="hljs-params">source</span>, <span class="hljs-params">target</span>)</span>;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LogUtils</span>.</span></span>i(TAG, <span class="hljs-string">&quot;moveData copyDir&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            isSuccess = source.rename<span class="hljs-constructor">To(<span class="hljs-params">target</span>)</span>;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LogUtils</span>.</span></span>i(TAG, <span class="hljs-string">&quot;moveData renameTo result &quot;</span> + isSuccess);<br>        &#125;<br>    &#125;<br>    long <span class="hljs-keyword">end</span> = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>current<span class="hljs-constructor">TimeMillis()</span>;<br>    long <span class="hljs-keyword">val</span> = <span class="hljs-keyword">end</span> - start;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LogUtils</span>.</span></span>i(TAG, <span class="hljs-string">&quot;moveData migrate data take time &quot;</span> + <span class="hljs-keyword">val</span> +<span class="hljs-string">&quot; from &quot;</span> + source.get<span class="hljs-constructor">AbsolutePath()</span> + <span class="hljs-string">&quot; to &quot;</span> + target.get<span class="hljs-constructor">AbsolutePath()</span>);<br><br>    return isSuccess;<br>&#125; <br><br></code></pre></td></tr></table></figure><h2 id="4-requestLegacyExternalStorage和preserveLegacyExternalStorage的理解"><a href="#4-requestLegacyExternalStorage和preserveLegacyExternalStorage的理解" class="headerlink" title="4 requestLegacyExternalStorage和preserveLegacyExternalStorage的理解"></a><em>4</em> requestLegacyExternalStorage和preserveLegacyExternalStorage的理解</h2><p>requestLegacyExternalStorage是Android10引入的，preserveLegacyExternalStorage 是 Android11 引入的。</p><p>如果你已经适配Android 10，如果应用通过升级安装，那么还会使用以前的储存模式（Legacy View），只有通过首次安装或是卸载重新安装才能启用新模式（Filtered View）。</p><p>经过测试，确实是这样，我们在Android10的手机上安装了一个targetSDKVersion是27的app，旧的存储模型是可以正常使用的，然后覆盖安装了target是29的新包，旧存储模型也是可以访问的，但是，卸载重新安装旧存储模型就不能访问了。</p><p>requestLegacyExternalStorage让targetSDKVersion是29（适配了Android 10）的app新安装在Android 10系统上也继续访问旧的存储模型。</p><p>如果某个应用在安装时启用了传统外部存储，则该应用会保持此模式，直到卸载为止。无论设备后续是否升级为搭载 Android 10 或更高版本，或者应用后续是否更新为以 Android 10 或更高版本为目标平台，此兼容性行为均适用。</p><p>这句话是有些问题的，估计当时说这话的时候，是Android10的时候。在Android11中引入了preserveLegacyExternalStorage，看下面的解释：</p><p>按照文档说targetSDKVersion&lt;29时，requestLegacyExternalStorage默认是true的，也就是说这些app是采用旧的存储模型运行的，targetSDKVersion升级到29后，requestLegacyExternalStorage默认是false的，但是覆盖安装的，还是采用旧的存储模式运行。重新安装的，由于requestLegacyExternalStorage是false，就采用分区存储模式运行了，除非requestLegacyExternalStorage显示设置成true。</p><p>也就是说requestLegacyExternalStorage给了app，在Android 10的系统上，无论是覆盖安装还是重新安装都能使用旧存储模式的机会。</p><p>targetSDKVersion升级到30后，在Android 11设备上，requestLegacyExternalStorage会被忽略掉，在Android 10的系统上requestLegacyExternalStorage依旧有效。</p><p>preserveLegacyExternalStorage只是让覆盖安装的app能继续使用旧的存储模型，如果之前是旧的存储模型的话。如果您使用 preserveLegacyExternalStorage，旧版存储模型只在用户卸载您的应用之前保持有效。如果用户在搭载 Android 11 的设备上安装或重新安装您的应用，那么无论 preserveLegacyExternalStorage 的值是什么，您的应用都无法停用分区存储模型。</p><p>app targetSDKVersion适配到30，在Android 11的系统上首次安装，是没有任何机会，让app能继续使用旧存储模型的。</p><h2 id="5-分区存储模型下，访问SD卡公共区域错误举例"><a href="#5-分区存储模型下，访问SD卡公共区域错误举例" class="headerlink" title="5 分区存储模型下，访问SD卡公共区域错误举例"></a><em>5</em> 分区存储模型下，访问SD卡公共区域错误举例</h2><h3 id="File的api"><a href="#File的api" class="headerlink" title="File的api"></a><strong>File的api</strong></h3><ul><li>createNewFile targetSdkVersion 28的app在Android 10的系统上，运行旧存储模型，targetSdkVersion升级到30后，覆盖安装在Android10系统上，也是运行旧存储模型的。targetSdkVersion 30的app首次安装到Android10系统上，是开启分区存储模型的（没有配置requestLegacyExternalStorage），在SD卡的公共目录上调用File的createNewFile()方法会报java.io.IOException: No such file or directory。在旧存储模型下，没有开启读写权限的时候，在SD卡的公共目录上调用File的createNewFile()方法也会报java.io.IOException: No such file or directory</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><br>java<span class="hljs-selector-class">.io</span><span class="hljs-selector-class">.IOException</span>: No such file or directory<br>    at java<span class="hljs-selector-class">.io</span><span class="hljs-selector-class">.UnixFileSystem</span><span class="hljs-selector-class">.createFileExclusively0</span>(Native Method)<br>    at java<span class="hljs-selector-class">.io</span><span class="hljs-selector-class">.UnixFileSystem</span><span class="hljs-selector-class">.createFileExclusively</span>(UnixFileSystem<span class="hljs-selector-class">.java</span>:<span class="hljs-number">317</span>)<br>    at java<span class="hljs-selector-class">.io</span><span class="hljs-selector-class">.File</span><span class="hljs-selector-class">.createNewFile</span>(File<span class="hljs-selector-class">.java</span>:<span class="hljs-number">1008</span>)<br>    at com<span class="hljs-selector-class">.xxx</span><span class="hljs-selector-class">.sdk</span><span class="hljs-selector-class">.android</span><span class="hljs-selector-class">.storage</span><span class="hljs-selector-class">.SohuStorageManager</span><span class="hljs-selector-class">.tryGetGalleryPathState</span>(SohuStorageManager<span class="hljs-selector-class">.java</span>:<span class="hljs-number">748</span>)<br>    ...<br><br></code></pre></td></tr></table></figure><ul><li>listFiles 分区存储模式下，SD卡的公共目录调用File的listFiles会返回null，即便此文件夹下有文件。</li></ul><h3 id="FileOutputStream｜FileInputStream"><a href="#FileOutputStream｜FileInputStream" class="headerlink" title="FileOutputStream｜FileInputStream"></a><strong>FileOutputStream｜FileInputStream</strong></h3><p>在分区存储模型下，SD卡的公共目录是不让访问的，除了共享媒体的那几个文件夹。所以，用一个公共目录的路径实例化FileOutputStream或者FileInputStream会报FileNotFoundException异常。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs stylus">java<span class="hljs-selector-class">.io</span><span class="hljs-selector-class">.FileNotFoundException</span>: /storage/emulated/<span class="hljs-number">0</span>/xxx/SharePic/<span class="hljs-number">1603277403193</span><span class="hljs-selector-class">.jpg</span>: open failed: ENOENT (No such fileor directory)<br>    at libcore<span class="hljs-selector-class">.io</span><span class="hljs-selector-class">.IoBridge</span><span class="hljs-selector-class">.open</span>(IoBridge<span class="hljs-selector-class">.java</span>:<span class="hljs-number">496</span>)<br>    at java<span class="hljs-selector-class">.io</span><span class="hljs-selector-class">.FileOutputStream</span>.&lt;init&gt;(FileOutputStream<span class="hljs-selector-class">.java</span>:<span class="hljs-number">235</span>)<br>    at com<span class="hljs-selector-class">.xxx</span><span class="hljs-selector-class">.ui</span><span class="hljs-selector-class">.QrCodeActivity</span><span class="hljs-selector-class">.askSDCardSaveImgPermission</span>(QrCodeActivity<span class="hljs-selector-class">.java</span>:<span class="hljs-number">242</span>)<br>    ...<br><br>java<span class="hljs-selector-class">.io</span><span class="hljs-selector-class">.FileNotFoundException</span>: /storage/emulated/<span class="hljs-number">0</span>/xxx/data/testusf: open failed: EACCES (Permission denied)<br>  at libcore<span class="hljs-selector-class">.io</span><span class="hljs-selector-class">.IoBridge</span><span class="hljs-selector-class">.open</span>(IoBridge<span class="hljs-selector-class">.java</span>:<span class="hljs-number">496</span>)<br>  at java<span class="hljs-selector-class">.io</span><span class="hljs-selector-class">.FileInputStream</span>.&lt;init&gt;(FileInputStream<span class="hljs-selector-class">.java</span>:<span class="hljs-number">159</span>)<br>  at java<span class="hljs-selector-class">.io</span><span class="hljs-selector-class">.FileReader</span>.&lt;init&gt;(FileReader<span class="hljs-selector-class">.java</span>:<span class="hljs-number">72</span>)<br>  at com<span class="hljs-selector-class">.android</span><span class="hljs-selector-class">.xxx</span><span class="hljs-selector-class">.sdk</span><span class="hljs-selector-class">.common</span><span class="hljs-selector-class">.toolbox</span><span class="hljs-selector-class">.FileUtils</span><span class="hljs-selector-class">.readSingleLineStringFromFile</span>(FileUtils<span class="hljs-selector-class">.java</span>:<span class="hljs-number">747</span>)<br><br>本文完。 <br></code></pre></td></tr></table></figure><hr><h1 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h1><h2 id="文件系统目录"><a href="#文件系统目录" class="headerlink" title="文件系统目录"></a>文件系统目录</h2><blockquote><p>/storage/emulated/0/ 对应的是手机-&gt;文件管理-&gt; 内部存储空间</p></blockquote><blockquote><p>/storage/emulated/0/Android/ 有些手机这么目录进不去（踩坑），需要借助一些三方app, 比如下载一个’ES文件浏览器’，他去获取访问权限，用他来查看</p></blockquote><table><thead><tr><th>函数</th><th>对应的目录地址</th></tr></thead><tbody><tr><td>cacheDir</td><td>/data/user/0/&lt;包名&gt;/cache</td></tr><tr><td>dataDir</td><td>/data/user/0/&lt;包名&gt;</td></tr><tr><td>filesDir</td><td>/data/user/0/&lt;包名&gt;/files</td></tr><tr><td>codeCacheDir</td><td>/data/user/0/&lt;包名&gt;/code_cache</td></tr><tr><td>noBackupFilesDir</td><td>/data/user/0/&lt;包名&gt;/no_backup</td></tr><tr><td>obbDir</td><td>/storage/emulated/0/Android/obb/&lt;包名&gt;</td></tr><tr><td>externalCacheDir</td><td>/storage/emulated/0/Android/data/&lt;包名&gt;/cache</td></tr><tr><td>externalFilesDir</td><td>/storage/emulated/0/Android/data/&lt;包名&gt;/files/Download</td></tr></tbody></table><h2 id="如何读写"><a href="#如何读写" class="headerlink" title="如何读写"></a>如何读写</h2><p><strong>正确的读写</strong></p><ul><li>只在外部存储的应用私有目录下，用直接路径读写文件</li><li>访问或者共享媒体文件，使用MediaStore在公共目录下读写文件</li><li>访问或者共享非媒体文件，使用系统的文件选择器SAF在公共目录Download下读写文件</li></ul>]]></content>
    
    
    <categories>
      
      <category>android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>app_process 来调用高权限 API</title>
    <link href="/posts/64a98929/"/>
    <url>/posts/64a98929/</url>
    
    <content type="html"><![CDATA[<h1 id="使用-app-process-来调用高权限-API"><a href="#使用-app-process-来调用高权限-API" class="headerlink" title="使用 app_process 来调用高权限 API"></a>使用 app_process 来调用高权限 API</h1><p>就从 <code>app_process</code> 开始吧。</p><h2 id="app-process"><a href="#app-process" class="headerlink" title="app_process"></a>app_process</h2><p><code>app_process</code> 是 Android 上的一个原生程序，是 APP 进程的主入口点。总之就是个可以让虚拟机从 <code>main()</code> 方法开始执行一个 Java 程序的东西啦。</p><h3 id="参数和用法"><a href="#参数和用法" class="headerlink" title="参数和用法"></a>参数和用法</h3><p>这个命令没有帮助程序，还好 <a href="https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r4/cmds/app_process/app_main.cpp#30">源代码</a> 里说得很清楚</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Usage</span>: app_process [java-<span class="hljs-keyword">options</span>] cmd-dir <span class="hljs-keyword">start</span>-<span class="hljs-keyword">class</span>-<span class="hljs-type">name</span> [<span class="hljs-keyword">options</span>]<br></code></pre></td></tr></table></figure><p>对这些参数的详细介绍也在 <a href="https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r4/cmds/app_process/app_main.cpp#200">源代码</a> 里，基本上是这样</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">java-<span class="hljs-keyword">options</span>     - 传递给 JVM 的参数<br>cmd-dir          - 暂时没有用，学着 init.rc.* 里给传个 /<span class="hljs-keyword">system</span>/bin 就好<br><span class="hljs-keyword">start</span>-<span class="hljs-keyword">class</span>-<span class="hljs-type">name</span> - 程序入口， main() 方法所在的类名<br><span class="hljs-keyword">options</span>          - 可以是下面这些<br>                    <span class="hljs-comment">--zygote 启动 zygote 进程用的</span><br>                    <span class="hljs-comment">--start-system-server 启动系统服务(也是启动 zygote 进程的时候用的)</span><br>                    <span class="hljs-comment">--application 启动应用程序</span><br>                    <span class="hljs-comment">--nice-name=启动之后的进程名称</span><br></code></pre></td></tr></table></figure><p>根据源代码还能得出一些关于这些参数的更加详细的结论。</p><ul><li>根据 <a href="https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r4/cmds/app_process/app_main.cpp#343">这里</a>，传入 <code>--zygote</code> 会启动 <a href="https://android.googlesource.com/platform/frameworks/base.git/+/android-8.0.0_r4/core/java/com/android/internal/os/ZygoteInit.java#671"><code>com.android.internal.os.ZygoteInit</code></a>，否则启动 <a href="https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r4/core/java/com/android/internal/os/RuntimeInit.java#269"><code>com.android.internal.os.RuntimeInit</code></a>。</li><li>可以发现 <code>--start-system-server</code> 只在启动 zygote 时有效。</li><li>在非 zygote 模式中，有无 <code>--application</code> 的选项的区别只是 <a href="https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r4/core/java/com/android/internal/os/RuntimeInit.java#271">是否将 stdout 和 stderr 重定向到 AndroidPrintStream</a> 。</li><li>也只有在 <a href="https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r4/cmds/app_process/app_main.cpp#281">非 zygote 的情况下</a>，<code>--nice-name=</code> 选项有效。</li></ul><p>本文不探讨 zygote 的启动过程，因此要用到哪些参数就很明确了。</p><h3 id="CLASSPATH"><a href="#CLASSPATH" class="headerlink" title="CLASSPATH"></a>CLASSPATH</h3><p>与 Java 相似， Android 支持在环境变量 <code>CLASSPATH</code> 中指定类搜索路径 (CLASSPATH)，此外还可以在虚拟机参数中指定 <a href="https://android.googlesource.com/platform/libcore/+/android-8.0.0_r4/ojluni/src/main/java/java/lang/ClassLoader.java#207"><code>-Djava.class.path=</code></a> 。但是， Android 使用 ART 环境运行 Java ，传统的 Java 字节码文件(.class) 是不能直接运行的，app_process 支持在 CLASSPATH 中指定 dex 或 apk 文件。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gradle"># 使用 dex<br><span class="hljs-keyword">CLASSPATH</span>=<span class="hljs-regexp">/data/</span>local<span class="hljs-regexp">/tmp/</span>test.dex app_process <span class="hljs-regexp">/system/</span>bin moe.haruue.Test<br>app_process -Djava.<span class="hljs-keyword">class</span>.path=<span class="hljs-regexp">/data/</span>local<span class="hljs-regexp">/tmp/</span>test.dex <span class="hljs-regexp">/system/</span>bin moe.haruue.Test<br><br># 使用 apk<br><span class="hljs-keyword">CLASSPATH</span>=<span class="hljs-regexp">/data/</span>app<span class="hljs-regexp">/moe.haruue.test-1/</span>base.apk app_process <span class="hljs-regexp">/system/</span>bin moe.haruue.Test<br>app_process -Djava.<span class="hljs-keyword">class</span>.path=<span class="hljs-regexp">/data/</span>app<span class="hljs-regexp">/moe.haruue.test-1/</span>base.apk <span class="hljs-regexp">/system/</span>bin moe.haruue.Test<br></code></pre></td></tr></table></figure><h3 id="启动一个-app-process-进程"><a href="#启动一个-app-process-进程" class="headerlink" title="启动一个 app_process 进程"></a>启动一个 app_process 进程</h3><p>比较方便的做法是直接使用 apk 作为 CLASSPATH ，而不是使用 dex 。因为在应用安装完成之后，就可以很轻松地将 CLASSPATH 暴露在 adb 可以轻松访问到的位置 (<code>/data/app/com.package.name-*/base.apk</code>) ，而不需要任何额外的操作或者权限。</p><p>只需 4 步就能启动一个 <code>app_process</code> 进程：</p><ol><li>创建或使用一个已有的 Android 应用程序项目，这里假设你使用的包名是 <code>com.package.name</code>。</li><li>增加一个包含有 main 方法的类，这里假设是 <code>com.package.name.Main</code>。</li><li>使用 adb 连接手机，编译并安装这个应用到手机。</li><li>使用 <code>adb shell</code> 在手机上执行对应的 <code>app_process</code> 命令启动进程。</li></ol><h3 id="又是-CLASSPATH"><a href="#又是-CLASSPATH" class="headerlink" title="又是 CLASSPATH"></a>又是 CLASSPATH</h3><p>涉及到的一个问题是确定 apk 的位置，因为 Android 4.4 后将 app 安装在 <code>/data/app/com.package.name-*/base.apk</code>。在 Java 代码中可以使用 <code>context.getPackageManager().getApplicationInfo(context.getPackageName(), 0).publicSourceDir</code> 获取这个路径，在 <code>adb shell</code> 下可以使用 <code>pm path com.package.name</code> ，当然如果你只是想做个测试，用 bash 的通配符搞定就好啦。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">CLASSPATH=<span class="hljs-constructor">$(<span class="hljs-params">echo</span> <span class="hljs-operator">/</span><span class="hljs-params">data</span><span class="hljs-operator">/</span><span class="hljs-params">app</span><span class="hljs-operator">/</span><span class="hljs-params">com</span>.<span class="hljs-params">package</span>.<span class="hljs-params">name</span>-<span class="hljs-operator">*</span><span class="hljs-operator">/</span><span class="hljs-params">base</span>.<span class="hljs-params">apk</span>)</span> \<br>app_process /system/bin com.package.name.Main<br></code></pre></td></tr></table></figure><h3 id="后台运行"><a href="#后台运行" class="headerlink" title="后台运行"></a>后台运行</h3><p>如果想要在后台运行，可以用系统的 <code>nohup</code> 命令 (Android 6.0 把 toolbox 换成 toybox 之后才开始自带这个) ，别忘了重定向 stdout 和 stderr ，并使用 <code>--nice-name=</code> 取个好听的进程名，以便在需要的时候能够使用 killall 结束它。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">CLASSPATH</span>=$(echo <span class="hljs-regexp">/data/</span>app<span class="hljs-regexp">/com.package.name-*/</span>base.apk) \<br>nohup app_process <span class="hljs-regexp">/system/</span>bin --nice-name=process_name com.<span class="hljs-keyword">package</span>.name.Main &gt; <span class="hljs-regexp">/dev/</span><span class="hljs-keyword">null</span> <span class="hljs-number">2</span>&gt;&amp;<span class="hljs-number">1</span> &amp;<br></code></pre></td></tr></table></figure><p>当然你也可以自己写一个 C 程序，在调用 <a href="http://man7.org/linux/man-pages/man3/daemon.3.html"><code>daemon()</code></a> 函数后启动 app_process 进程。</p><h2 id="使用特权-API"><a href="#使用特权-API" class="headerlink" title="使用特权 API"></a>使用特权 API</h2><p>很多特权 API 对第三方开发者并不可见，或者我们需要使用一些奇怪的技巧去调用它，首先需要想办法调用这些看不见的 API 。</p><h3 id="调用隐藏-API"><a href="#调用隐藏-API" class="headerlink" title="调用隐藏 API"></a>调用隐藏 API</h3><p>Android 源代码中使用 <code>@hide</code> 隐藏了大量正常 Android 开发用不到的类和方法，即使它们实际上都是 public 的，Android Studio 还是认为它们不存在，虽然可以通过反射调用，但是还是太麻烦了。</p><p>这里利用一下 Android 的类加载机制。apk 中应用开发者定义的类是由 <a href="https://android.googlesource.com/platform/libcore/+/android-8.0.0_r4/dalvik/src/main/java/dalvik/system/PathClassLoader.java#25">PathClassLoader</a> 加载的，framework 的类则是由 <a href="https://android.googlesource.com/platform/libcore/+/android-8.0.0_r4/ojluni/src/main/java/java/lang/ClassLoader.java#1336">BootClassLoader</a> 加载的，在系统构建 PathClassLoader 的时候将 BootClassLoader <a href="https://android.googlesource.com/platform/libcore/+/android-8.0.0_r4/ojluni/src/main/java/java/lang/ClassLoader.java#224">作为它的 parent</a> 。考虑到类加载器实现了 <a href="https://android.googlesource.com/platform/libcore/+/android-8.0.0_r4/ojluni/src/main/java/java/lang/ClassLoader.java#359">双亲委托机制</a> ，我们可以在项目中定义与 framework 类路径一致的类，在这些类里定义与那些 <code>@hide</code> 方法签名一致，实现为空 (如抛出运行时异常) 的方法，这样 Android Studio 就会识别它们，自动补全也可以正常工作。如果需要的接口是使用 aidl 定义的，我们也可以定义相同的 aidl 文件。</p><p>然而，实际上并没有这么简单，对于 Android Phone &amp; Tablet Module 和 Android Library  Module 来说，Android Studio 也会默认先加载 SDK 里的类，利用上面的方法可以定义那些 Android Studio  本来认为不存在的类 (即 <code>@hide</code> 掉整个 class 的情况) ，而定义 Android Studio 认为已经存在的类 (只 <code>@hide</code> 掉方法或者内部类的情况) 则没有任何效果。这种情况下我们可以将这些实现为空的类放到 Java Library Module 里，这样 Android Studio 就不会加载 SDK 里的类了。类似地，考虑到使用 <code>app_process</code> 启动的进程只是一个 Java 进程，我们也可以根据需要将它放到 Java Library Module 里。</p><p>Android 源代码中还有一些类或方法是包内访问 (package-local) 的，这种情况下只需要在项目中建立它们所在的包，然后在这个包下面建立与源代码中已存在的类类名不重复的类，就可以使用这些类访问它们了。</p><p>注意，标记为 <code>@hide</code> 的 API 在 Android 版本迭代的过程中被作为内部实现处理，可能会经常变化，请谨慎使用，及时适配新的 Android 版本，以防 <a href="https://twitter.com/HaruueIcymoon/status/901686585564946433">在 Android 系统更新的时候被 framework 鄙视</a> 。</p><p>通常情况下，我们使用一个专门的 module 来存放这些实现为空的类，使用另一个专门的 module 写 <code>app_process</code> 的进程部分，并利用 gradle 配置好依赖关系。特别地，如果需要的类和方法在不同的 Android 版本中发生了变化，你可以定义一些代理类，判断 Android 版本并调用到正确的 framework 方法上。</p><h3 id="绕过-context"><a href="#绕过-context" class="headerlink" title="绕过 context"></a>绕过 context</h3><p>实际上通过 <code>app_process</code> 启动的是一个 Java 程序，与一般的 Android 程序不同，我们没有常见的 context 。为了绕过对 context 的需要，还是需要做不少事情。</p><p>比如说需要安装一个 apk ，先考虑一般的套路: </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">context.get<span class="hljs-constructor">PackageManager()</span>.install<span class="hljs-constructor">Package(<span class="hljs-string">&quot;file:///sdcard/path/to/package.apk&quot;</span>, <span class="hljs-params">null</span>, PackageManager.INSTALL_REPLACE_EXISTING, <span class="hljs-params">null</span>)</span><br></code></pre></td></tr></table></figure><p>要绕过对 context 的需要，得研究一下上面的过程都干了什么。</p><p>首先是 <code>context.getPackageManager()</code> ， context 的实现类是 ContextImpl 。我们从源代码中找到 <a href="https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r4/core/java/android/app/ContextImpl.java#227"><code>ContextImpl.getPackageManager()</code></a> ，它先是调用 <code>ActivityThread.getPackageManager()</code> 取得了一个 <a href="https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r4/core/java/android/content/pm/IPackageManager.aidl">IPackageManager</a> 对象，这实际上是一个可以与系统服务进行通信的 AIDL 接口 。在 <a href="https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r4/core/java/android/app/ActivityThread.java#1972"><code>ActivityThread.getPackageManager()</code></a> 中，我们可以看到获取这个对象实际执行的过程: </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">IPackageManager</span>.</span><span class="hljs-module"><span class="hljs-identifier">Stub</span>.</span></span><span class="hljs-keyword">as</span><span class="hljs-constructor">Interface(ServiceManager.<span class="hljs-params">getService</span>(<span class="hljs-string">&quot;package&quot;</span>)</span>);<br></code></pre></td></tr></table></figure><p>实际上几乎所有的系统服务都是使用这样的方法获取的。在 Android 上，原生的跨进程方式只能使用 IBinder 实现，系统在启动的时候使用 <a href="https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r4/core/java/android/os/ServiceManager.java#86"><code>ServiceManager.addSerice()</code></a> 方法注册系统服务，在其它应用的进程中使用 <a href="https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r4/core/java/android/os/ServiceManager.java#50"><code>ServiceManager.getService()</code></a> 方法取得对应的 IBinder 对象。</p><p>回到 <code>ContextImpl.getPackageManager()</code> 。随后返回的是一个 <a href="https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r4/core/java/android/app/ApplicationPackageManager.java"><code>ApplicationPackageManager</code></a> 对象，虽然构建它也需要用到 context 对象，但是我们关注的是它的 <a href="https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r4/core/java/android/app/ApplicationPackageManager.java#1670"><code>installPackage()</code></a> 方法。这个方法也构建了一个 <a href="https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r4/core/java/android/content/pm/PackageManager.java#5639"><code>LegacyPackageInstallObserver</code></a> 对象，最终在 <a href="https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r4/core/java/android/app/ApplicationPackageManager.java#1691"><code>installCommon()</code></a> 方法中传递给了 <code>IPackageManager.installPackageAsUser()</code> ，这是一个与系统进程通信的 IBinder 对象，它的实现实际上在 <a href="https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r4/services/core/java/com/android/server/pm/PackageManagerService.java#14125"><code>PackageInstallerService.installPackageAsUser()</code></a> 中，但是这些类存在于系统进程中，我们不可能直接访问到它们。</p><p>展开这个调用过程，假设我们需要安装的安装包的位置在 <code>/sdcard/test.apk</code> ，并且装好后对系统声明的安装器为 Play 商店，最后我们得到的应该是: </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">IPackageManager</span>.</span><span class="hljs-module"><span class="hljs-identifier">Stub</span>.</span></span><span class="hljs-keyword">as</span><span class="hljs-constructor">Interface(ServiceManager.<span class="hljs-params">getService</span>(<span class="hljs-string">&quot;package&quot;</span>)</span>)<br>    .install<span class="hljs-constructor">PackageAsUser(Uri.<span class="hljs-params">parse</span>(<span class="hljs-string">&quot;/sdcard/test.apk&quot;</span>)</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>, <span class="hljs-keyword">new</span> PackageManager.<span class="hljs-constructor">LegacyPackageInstallObserver(<span class="hljs-params">null</span>)</span>.get<span class="hljs-constructor">Binder()</span>, <span class="hljs-number">0x00000002</span>, <span class="hljs-string">&quot;com.android.vending&quot;</span>, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>在 <code>main()</code> 方法中加入这两行代码，解决一切无法调用隐藏 API 的问题，将随便哪个别的应用的 apk 安装包放到 <code>/sdcard/test.apk</code> 位置，使用 <code>app_process</code> 执行这个程序，随后就能在启动器中看到这个 apk 已经安装好了。</p><h3 id="特权"><a href="#特权" class="headerlink" title="特权"></a>特权</h3><p>与 APP 进程不同，通过 <code>app_process</code> 启动的进程可以在 root 权限和 shell 权限 (adb 默认) 下启动，也就分别拥有了不同的调用的 API 的能力。通常情况下 shell 权限启动的 <code>app_process</code> 只能够调用一些能够完成 adb 本身能做的事情的 API ，例如使用 <code>AppOpsManager</code> 管理应用权限 (类似于 <code>appops</code> 命令)，使用 <code>PackageManager</code> 安装应用程序 (类似于 <a href="https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r4/cmds/pm/src/com/android/commands/pm/Pm.java#407"><code>pm</code></a> 命令)，使用 <code>InputManager</code> 模拟触摸操作 (类似于 <a href="https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r4/cmds/input/src/com/android/commands/input/Input.java"><code>input</code></a> 命令) ，访问 <code>/data/local/tmp</code> 以及 <code>/sdcard</code> 目录。 root 权限启动的 <code>app_process</code> 进程则拥有更多权限，甚至能够调用 signature 保护级别的 API 以及访问整个文件系统。</p><h3 id="为什么使用-app-process-进程"><a href="#为什么使用-app-process-进程" class="headerlink" title="为什么使用 app_process 进程"></a>为什么使用 app_process 进程</h3><p>上文有提到，很多能够用 <code>app_process</code> 进程做的事情实际上都有对应的命令。例如我们可以直接在 adb shell 中使用 Linux 命令访问文件系统，使用 <a href="https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r4/cmds/pm/pm"><code>pm</code></a>, <a href="https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r4/cmds/am/am"><code>am</code></a>, <a href="https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r4/cmds/input/input"><code>input</code></a>, <code>appops</code> 命令等。实际上不少命令只是对调用 <code>app_process</code> 命令进行的一个封装，为了实现一个简单的目的而需要在等待对应的 <code>app_process</code> 进程启动上花费大量的时间，直接执行 shell 命令也可能因为 shell 的特性而引发注入等问题。很显然，在自己的应用程序中使用自定义的 <code>app_process</code> 进程完成批量操作比直接执行命令快很多并且安全很多。</p><h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><p>使用命令行启动的 <code>app_process</code> 进程毕竟是运行在一个单独的进程上，我们不可能将需要让它做的一切事情都放在命令行参数或者硬编码到程序里。让它所在的进程与 APP 进程之间进行通信可以增加程序的易用性。</p><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><p>socket 是 Java 程序中最容易实现的跨进程通信方法了，基本类型和众多实现了 <code>Serializable</code> 接口的类实例都可以很轻松地通过网络传输: </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">ObjectInputStream ois = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ObjectInputStream(<span class="hljs-params">socket</span>.<span class="hljs-params">getInputStream</span>()</span>);<br>ObjectOutputStream oos = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ObjectOutputStream(<span class="hljs-params">socket</span>.<span class="hljs-params">getOutputStream</span>()</span>));<br></code></pre></td></tr></table></figure><p>部分 <code>Parcelable</code> 接口对象也可以丢给网络，先将对象写入一个 Parcel 中，然后利用 <a href="https://developer.android.com/reference/android/os/Parcel.html#marshall()"><code>Parcel.marshall()</code></a> 和 [<code>Parcel.unmarshall()</code>](<a href="https://developer.android.com/reference/android/os/Parcel.html#unmarshall">https://developer.android.com/reference/android/os/Parcel.html#unmarshall</a>(byte[]%2C int%2C int)) 方法序列化和反序列化为 <code>byte[]</code> ，缺点是不支持含有 IBinder 字段的 Parcelable 对象 。</p><h3 id="系统服务"><a href="#系统服务" class="headerlink" title="系统服务"></a>系统服务</h3><p>如同上文提到的。Android 系统使用 IBinder 的跨进程通信方式，系统在启动的时候使用 <a href="https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r4/core/java/android/os/ServiceManager.java#86"><code>ServiceManager.addSerice()</code></a> 方法注册系统服务，在其它应用的进程中使用 <a href="https://android.googlesource.com/platform/frameworks/base/+/android-8.0.0_r4/core/java/android/os/ServiceManager.java#50"><code>ServiceManager.getService()</code></a> 方法取得对应的 IBinder 对象。应用程序则可以使用获取的 IBinder 对象与系统进程通信。</p><p>既然系统可以这样做，我们也可以。前提是需要有 root 权限。</p><p>使用 aidl 写一个接口定义，用一个类实现它，然后就可以使用它。还需要保证在执行 <code>ServiceManager.addSerice()</code> 之后服务进程不能退出，直接用 <code>Looper</code> 就好啦。</p><h4 id="坏耶，是-SELinux"><a href="#坏耶，是-SELinux" class="headerlink" title="坏耶，是 SELinux"></a>坏耶，是 SELinux</h4><p>以上做法在部分手机上没有问题，但是在我的 Nexus 6 上抛出了异常。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">08</span>-<span class="hljs-number">30</span> <span class="hljs-number">13</span>:<span class="hljs-number">45</span>:<span class="hljs-number">13</span>.<span class="hljs-number">866</span> <span class="hljs-number">25754</span>-<span class="hljs-number">25754</span>/moe.haruue.peekintent:listener W/intent:listener: type=<span class="hljs-number">1400</span> audit(<span class="hljs-number">0</span>.<span class="hljs-number">0</span>:<span class="hljs-number">5481</span>): avc: denied &#123; call &#125; for scontext=u:r:untrusted_app:s<span class="hljs-number">0</span>:c<span class="hljs-number">512</span>,c<span class="hljs-number">768</span> tcontext=u:r:su:s<span class="hljs-number">0</span> tclass=binder permissive=<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>实际上是 sepolicy 的问题，用 root 执行一下下面两条命令插入规则好了。</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">sepolicy-inject</span> <span class="hljs-built_in">--live</span> <span class="hljs-string">&quot;allow untrusted_app su binder transfer&quot;</span><br><span class="hljs-string">sepolicy-inject</span> <span class="hljs-built_in">--live</span> <span class="hljs-string">&quot;allow untrusted_app su binder call&quot;</span><br></code></pre></td></tr></table></figure><p>具体做法可以看看 <a href="https://github.com/haruue/PeekIntent/blob/master/server/src/main/java/moe/haruue/server/Main.java">这个</a></p><h3 id="使用-Shizuku-Manager"><a href="#使用-Shizuku-Manager" class="headerlink" title="使用 Shizuku Manager"></a>使用 Shizuku Manager</h3><p><a href="https://github.com/RikkaW/Shizuku">Shizuku Manager</a> 是 RikkaW 参考 <a href="https://github.com/brevent/Brevent">黑域</a> 做的一个项目，目的是使用单一的 <code>app_process</code> 后台进程取代各种需要用户手动通过 <code>adb shell</code> 或者利用 root 权限为每个需要特权 API 的程序启动的 <code>app_process</code> 进程，其它应用在申请用户授权之后就能使用 Shizuku Manager 的 API 调用所需的特权 API 了。当前这个项目仍在完善之中 <del>所以除了 RikkaApps 之外就没人用了</del> 。</p>]]></content>
    
    
    <categories>
      
      <category>android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo整理</title>
    <link href="/posts/a7d9bd28/"/>
    <url>/posts/a7d9bd28/</url>
    
    <content type="html"><![CDATA[<h1 id="简单安装"><a href="#简单安装" class="headerlink" title="简单安装"></a>简单安装</h1><p><a href="https://hexo.io/zh-cn/docs/">hexo官网</a></p><h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装<code>git</code></h2><p>​    不再赘述</p><h1 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装<code>node.js</code></h1><p>可以通过以下命令查看主机中是否安装了<code>node.js</code>和<code>npm</code></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ <span class="hljs-keyword">node</span> <span class="hljs-title">--version</span>    <span class="hljs-comment">#检查是否安装了node.js</span><br>$ npm --<span class="hljs-keyword">version</span>     <span class="hljs-comment">#检查是否安装了npm</span><br></code></pre></td></tr></table></figure><p>如下所示表示已经安装了<code>node.js</code>和<code>npm</code></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">root</span>@***:~# node --version<br><span class="hljs-attribute">v8</span>.<span class="hljs-number">11</span>.<span class="hljs-number">3</span><br><span class="hljs-attribute">root</span>@***:~# npm --version<br><span class="hljs-attribute">6</span>.<span class="hljs-number">7</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><a href="https://nodejs.org/en/download/package-manager/">没有安装的话查看官方指南</a></p><h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装<code>hexo</code></h2><ul><li>使用<code>npm</code>安装    </li></ul><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">$ npm install -g hexo-<span class="hljs-keyword">cli</span><br></code></pre></td></tr></table></figure><ul><li><p>安装以后，可以使用以下两种方式执行 <code>Hexo</code>：</p><ol><li><code>npx hexo &lt;command&gt;</code></li><li>将 <code>Hexo</code> 所在的目录下的 <code>node_modules</code> 添加到环境变量之中即可直接使用 <code>hexo &lt;command&gt;</code>：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">复制hexo所在目录中<span class="hljs-string">&quot;node_modules/.bin&quot;</span>目录位置，在<span class="hljs-string">&quot;~/.profile&quot;</span>或<span class="hljs-string">&quot;~/.bash_profile&quot;</span>或<span class="hljs-string">&quot;~/.zshrc&quot;</span>中写入环境变量<br>例如<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-string">&quot;<span class="hljs-variable">$PATH</span>:~/存档/BlogsRepo/blogs/node_modules/.bin&quot;</span><br>我使用的zsh,在<span class="hljs-string">&quot;~/.zshrc&quot;</span>我中写入.<br><br>或使用<span class="hljs-built_in">echo</span>命令写入文件<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;PATH=&quot;$PATH:~/存档/BlogsRepo/blogs/node_modules/.bin&quot;&#x27;</span> &gt;&gt; ~/.zshrc<br></code></pre></td></tr></table></figure></li></ul><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><ul><li>初始化hexo（在自己建立的任意文件夹里，如果没有添加环境变量，需要使用<code>npx hexo &lt;command&gt;</code>）</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> hexo init &lt;folder&gt;<br><span class="hljs-variable">$</span> <span class="hljs-built_in">cd</span> &lt;folder&gt;<br><span class="hljs-variable">$</span> npm install<br></code></pre></td></tr></table></figure><ul><li>接下来,输入两条命令</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog">hexo <span class="hljs-keyword">generate</span>  <br>hexo server  <br>或者输入命令的简写:  <br>hexo g<br>hexo s<br></code></pre></td></tr></table></figure><p>解释:<br>首先执行”hexo generate”生成相应的静态网页，生成的静态网页以及相关资源都会在public目录下<br>hexo-server模块的主要命令如下，输入”hexo generate”以启动服务器，您的网站会在 <a href="http://localhost:4000/">http://localhost:4000</a> 下启动。在服务器启动期间，Hexo 会监视文件变动并自动更新，您无须重启服务器。<br>注: 如果您想要更改端口，或是在执行时遇到了 EADDRINUSE 错误，可以在执行时使用 -p 选项指定其他端口，如下:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">hexo</span> server -p <span class="hljs-number">5000</span><br></code></pre></td></tr></table></figure><ul><li>接下来, 将hexo部署到github</li></ul><ol><li>安装Git部署插件，输入命令：</li></ol><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install hexo-deployer-git <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><ol start="2"><li>将我们的Hexo与GitHub关联起来，打开站点的配置文件_config.yml，翻到最后修改为：</li></ol><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">type:</span> git<br><span class="hljs-symbol">repo:</span> 博客的仓库地址，用ssh的地址，不要用https的地址<br><span class="hljs-symbol">branch:</span> master<br><span class="hljs-symbol">ps:</span>注意缩进<br></code></pre></td></tr></table></figure><p>其实就是给hexo d 这个命令做相应的配置，让hexo知道你要把blog部署在哪个位置，很显然，我们部署在我们GitHub的仓库里。</p><p>接着，我们分别输入三条命令：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs excel">hexo <span class="hljs-built_in">clean</span> <br>hexo g <br>hexo d  将会部署到github<br></code></pre></td></tr></table></figure><p>全部完成  </p><h1 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h1><ul><li><a href="https://github.com/zthxxx/hexo-theme-Wikitten">wiki样式</a></li><li><a href="https://github.com/jerryc127/hexo-theme-butterfly">md样式<code>hexo-theme-butterfly</code></a></li><li> <a href="https://github.com/bollnh/hexo-theme-material">md样式<code>hexo-theme-material</code></a></li><li><a href="https://github.com/fluid-dev/hexo-theme-fluid">md样式<code>hexo-theme-fluid</code></a></li></ul><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>您可以在 <code>_config.yml</code> 中修改大部分的配置。</p><h2 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h2><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>title</code></td><td align="left">网站标题</td></tr><tr><td align="left"><code>subtitle</code></td><td align="left">网站副标题</td></tr><tr><td align="left"><code>description</code></td><td align="left">网站描述</td></tr><tr><td align="left"><code>keywords</code></td><td align="left">网站的关键词。支持多个关键词。</td></tr><tr><td align="left"><code>author</code></td><td align="left">您的名字</td></tr><tr><td align="left"><code>language</code></td><td align="left">网站使用的语言。对于简体中文用户来说，使用不同的主题可能需要设置成不同的值，请参考你的主题的文档自行设置，常见的有 <code>zh-Hans</code>和 <code>zh-CN</code>。</td></tr><tr><td align="left"><code>timezone</code></td><td align="left">网站时区。Hexo 默认使用您电脑的时区。请参考 <a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones">时区列表</a> 进行设置，如 <code>America/New_York</code>, <code>Japan</code>, 和 <code>UTC</code> 。一般的，对于中国大陆地区可以使用 <code>Asia/Shanghai</code>。</td></tr></tbody></table><p>其中，<code>description</code>主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。<code>author</code>参数用于主题显示文章的作者。</p><h2 id="网址"><a href="#网址" class="headerlink" title="网址"></a>网址</h2><table><thead><tr><th align="left">参数</th><th align="left">描述</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left"><code>url</code></td><td align="left">网址, 必须以 <code>http://</code> 或 <code>https://</code> 开头</td><td align="left"></td></tr><tr><td align="left"><code>root</code></td><td align="left">网站根目录</td><td align="left"><code>url&#39;s pathname</code></td></tr><tr><td align="left"><code>permalink</code></td><td align="left">文章的 <a href="https://hexo.io/zh-cn/docs/permalinks">永久链接</a> 格式</td><td align="left"><code>:year/:month/:day/:title/</code></td></tr><tr><td align="left"><code>permalink_defaults</code></td><td align="left">永久链接中各部分的默认值</td><td align="left"></td></tr><tr><td align="left"><code>pretty_urls</code></td><td align="left">改写 <a href="https://hexo.io/zh-cn/docs/variables"><code>permalink</code></a> 的值来美化 URL</td><td align="left"></td></tr><tr><td align="left"><code>pretty_urls.trailing_index</code></td><td align="left">是否在永久链接中保留尾部的 <code>index.html</code>，设置为 <code>false</code> 时去除</td><td align="left"><code>true</code></td></tr><tr><td align="left"><code>pretty_urls.trailing_html</code></td><td align="left">是否在永久链接中保留尾部的 <code>.html</code>, 设置为 <code>false</code> 时去除 (<em>对尾部的 <code>index.html</code>无效</em>)</td><td align="left"><code>true</code></td></tr></tbody></table><blockquote><p>网站存放在子目录</p><p>如果您的网站存放在子目录中，例如 <code>http://example.com/blog</code>，则请将您的 <code>url</code> 设为 <code>http://example.com/blog</code> 并把 <code>root</code> 设为 <code>/blog/</code>。</p></blockquote><p>例如：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-meta"># 比如，一个页面的永久链接是 http:<span class="hljs-comment">//example.com/foo/bar/index.html</span></span><br><span class="hljs-symbol">pretty_urls:</span><br><span class="hljs-symbol">  trailing_index:</span> false<br><span class="hljs-meta"># 此时页面的永久链接会变为 http:<span class="hljs-comment">//example.com/foo/bar/</span></span><br></code></pre></td></tr></table></figure><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><table><thead><tr><th align="left">参数</th><th align="left">描述</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left"><code>source_dir</code></td><td align="left">资源文件夹，这个文件夹用来存放内容。</td><td align="left"><code>source</code></td></tr><tr><td align="left"><code>public_dir</code></td><td align="left">公共文件夹，这个文件夹用于存放生成的站点文件。</td><td align="left"><code>public</code></td></tr><tr><td align="left"><code>tag_dir</code></td><td align="left">标签文件夹</td><td align="left"><code>tags</code></td></tr><tr><td align="left"><code>archive_dir</code></td><td align="left">归档文件夹</td><td align="left"><code>archives</code></td></tr><tr><td align="left"><code>category_dir</code></td><td align="left">分类文件夹</td><td align="left"><code>categories</code></td></tr><tr><td align="left"><code>code_dir</code></td><td align="left">Include code 文件夹，<code>source_dir</code> 下的子目录</td><td align="left"><code>downloads/code</code></td></tr><tr><td align="left"><code>i18n_dir</code></td><td align="left">国际化（i18n）文件夹</td><td align="left"><code>:lang</code></td></tr><tr><td align="left"><code>skip_render</code></td><td align="left">跳过指定文件的渲染。匹配到的文件将会被不做改动地复制到 <code>public</code> 目录中。您可使用 <a href="https://github.com/micromatch/micromatch#extended-globbing">glob 表达式</a>来匹配路径。</td><td align="left"></td></tr></tbody></table><p>例如：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gradle">skip_render: <span class="hljs-string">&quot;mypage/**/*&quot;</span><br># 将会直接将 `<span class="hljs-keyword">source</span><span class="hljs-regexp">/mypage/i</span>ndex.html` 和 `<span class="hljs-keyword">source</span><span class="hljs-regexp">/mypage/</span>code.js` 不做改动地输出到 <span class="hljs-string">&#x27;public&#x27;</span> 目录<br># 你也可以用这种方法来跳过对指定文章文件的渲染<br>skip_render: <span class="hljs-string">&quot;_posts/test-post.md&quot;</span><br># 这将会忽略对 <span class="hljs-string">&#x27;test-post.md&#x27;</span> 的渲染<br></code></pre></td></tr></table></figure><blockquote><p>提示</p><p>如果您刚刚开始接触 Hexo，通常没有必要修改这一部分的值。</p></blockquote><h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><table><thead><tr><th align="left">参数</th><th align="left">描述</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left"><code>new_post_name</code></td><td align="left">新文章的文件名称</td><td align="left">:title.md</td></tr><tr><td align="left"><code>default_layout</code></td><td align="left">预设布局</td><td align="left">post</td></tr><tr><td align="left"><code>auto_spacing</code></td><td align="left">在中文和英文之间加入空格</td><td align="left">false</td></tr><tr><td align="left"><code>titlecase</code></td><td align="left">把标题转换为 title case</td><td align="left">false</td></tr><tr><td align="left"><code>external_link</code></td><td align="left">在新标签中打开链接</td><td align="left">true</td></tr><tr><td align="left"><code>external_link.enable</code></td><td align="left">在新标签中打开链接</td><td align="left"><code>true</code></td></tr><tr><td align="left"><code>external_link.field</code></td><td align="left">对整个网站（<code>site</code>）生效或仅对文章（<code>post</code>）生效</td><td align="left"><code>site</code></td></tr><tr><td align="left"><code>external_link.exclude</code></td><td align="left">需要排除的域名。主域名和子域名如 <code>www</code> 需分别配置</td><td align="left"><code>[]</code></td></tr><tr><td align="left"><code>filename_case</code></td><td align="left">把文件名称转换为 (1) 小写或 (2) 大写</td><td align="left">0</td></tr><tr><td align="left"><code>render_drafts</code></td><td align="left">显示草稿</td><td align="left">false</td></tr><tr><td align="left"><code>post_asset_folder</code></td><td align="left">启动 <a href="https://hexo.io/zh-cn/docs/asset-folders">Asset 文件夹</a></td><td align="left">false</td></tr><tr><td align="left"><code>relative_link</code></td><td align="left">把链接改为与根目录的相对位址</td><td align="left">false</td></tr><tr><td align="left"><code>future</code></td><td align="left">显示未来的文章</td><td align="left">true</td></tr><tr><td align="left"><code>highlight</code></td><td align="left">代码块的设置, 请参考 <a href="https://hexo.io/docs/syntax-highlight#Highlight-js">Highlight.js</a> 进行设置</td><td align="left"></td></tr><tr><td align="left"><code>prismjs</code></td><td align="left">代码块的设置, 请参考 <a href="https://hexo.io/docs/syntax-highlight#PrismJS">PrismJS</a> 进行设置</td><td align="left"></td></tr></tbody></table><blockquote><p>相对地址</p><p>默认情况下，Hexo 生成的超链接都是绝对地址。例如，如果您的网站域名为 <code>example.com</code>,您有一篇文章名为 <code>hello</code>，那么绝对链接可能像这样：<code>http://example.com/hello.html</code>，它是<strong>绝对</strong>于域名的。相对链接像这样：<code>/hello.html</code>，也就是说，无论用什么域名访问该站点，都没有关系，这在进行反向代理时可能用到。通常情况下，建议使用绝对地址。</p></blockquote><h2 id="分类-amp-标签"><a href="#分类-amp-标签" class="headerlink" title="分类 &amp; 标签"></a>分类 &amp; 标签</h2><table><thead><tr><th align="left">参数</th><th align="left">描述</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left"><code>default_category</code></td><td align="left">默认分类</td><td align="left"><code>uncategorized</code></td></tr><tr><td align="left"><code>category_map</code></td><td align="left">分类别名</td><td align="left"></td></tr><tr><td align="left"><code>tag_map</code></td><td align="left">标签别名</td><td align="left"></td></tr></tbody></table><h2 id="日期-时间格式"><a href="#日期-时间格式" class="headerlink" title="日期 / 时间格式"></a>日期 / 时间格式</h2><p>Hexo 使用 <a href="http://momentjs.com/">Moment.js</a> 来解析和显示时间。</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left"><code>date_format</code></td><td align="left">日期格式</td><td align="left"><code>YYYY-MM-DD</code></td></tr><tr><td align="left"><code>time_format</code></td><td align="left">时间格式</td><td align="left"><code>HH:mm:ss</code></td></tr><tr><td align="left"><code>updated_option</code></td><td align="left">当 Front Matter 中没有指定 <a href="https://hexo.io/zh-cn/docs/variables#%E9%A1%B5%E9%9D%A2%E5%8F%98%E9%87%8F"><code>updated</code></a> 时 <code>updated</code> 的取值</td><td align="left"><code>mtime</code></td></tr></tbody></table><blockquote><p>updated_option</p><p><code>updated_option</code> 控制了当 Front Matter 中没有指定 <code>updated</code> 时，<code>updated</code> 如何取值：</p><ul><li><code>mtime</code>: 使用文件的最后修改时间。这是从 Hexo 3.0.0 开始的默认行为。</li><li><code>date</code>: 使用 <code>date</code> 作为 <code>updated</code> 的值。可被用于 Git 工作流之中，因为使用 Git 管理站点时，文件的最后修改日期常常会发生改变</li><li><code>empty</code>: 直接删除 <code>updated</code>。使用这一选项可能会导致大部分主题和插件无法正常工作。</li></ul><p><code>use_date_for_updated</code> 选项已经被废弃，将会在下个重大版本发布时去除。请改为使用 <code>updated_option: &#39;date&#39;</code>。</p></blockquote><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso">use_date_for_updated<span class="hljs-string">` | 启用以后，如果 Front Matter 中没有指定 `</span>updated<span class="hljs-string">`， [`</span>post.updated<span class="hljs-string">`](https://hexo.io/zh-cn/docs/configuration) 将会使用 `</span><span class="hljs-built_in">date</span><span class="hljs-string">` 的值而不是文件的创建时间。在 Git 工作流中这个选项会很有用 | `</span><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><table><thead><tr><th align="left">参数</th><th align="left">描述</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left"><code>per_page</code></td><td align="left">每页显示的文章量 (0 = 关闭分页功能)</td><td align="left"><code>10</code></td></tr><tr><td align="left"><code>pagination_dir</code></td><td align="left">分页目录</td><td align="left"><code>page</code></td></tr></tbody></table><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>theme</code></td><td align="left">当前主题名称。值为<code>false</code>时禁用主题</td></tr><tr><td align="left"><code>theme_config</code></td><td align="left">主题的配置文件。在这里放置的配置会覆盖主题目录下的 <code>_config.yml</code> 中的配置</td></tr><tr><td align="left"><code>deploy</code></td><td align="left">部署部分的设置</td></tr><tr><td align="left"><code>meta_generator</code></td><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta#%E5%B1%9E%E6%80%A7">Meta generator</a> 标签。 值为 <code>false</code> 时 Hexo 不会在头部插入该标签</td></tr></tbody></table><h3 id="包括或不包括目录和文件"><a href="#包括或不包括目录和文件" class="headerlink" title="包括或不包括目录和文件"></a>包括或不包括目录和文件</h3><p>在 Hexo 配置文件中，通过设置 include/exclude 可以让 Hexo 进行处理或忽略某些目录和文件夹。你可以使用 <a href="https://github.com/isaacs/minimatch">glob 表达式</a> 对目录和文件进行匹配。</p><p><code>include</code> and <code>exclude</code> options only apply to the <code>source/</code> folder, whereas <code>ignore</code> option applies to all folders.</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>include</code></td><td align="left">Hexo 默认会忽略隐藏文件和文件夹（包括名称以下划线和 <code>.</code> 开头的文件和文件夹，Hexo 的 <code>_posts</code> 和 <code>_data</code> 等目录除外）。通过设置此字段将使 Hexo 处理他们并将它们复制到 <code>source</code> 目录下。</td></tr><tr><td align="left"><code>exclude</code></td><td align="left">Hexo 会忽略这些文件和目录</td></tr><tr><td align="left"><code>ignore</code></td><td align="left">Ignore files/folders</td></tr></tbody></table><p>举例：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-meta"># <span class="hljs-meta-keyword">Include</span>/Exclude Files/Folders</span><br>include:<br>  - <span class="hljs-string">&quot;.nojekyll&quot;</span><br>  <span class="hljs-meta"># 包括 <span class="hljs-string">&#x27;source/css/_typing.css&#x27;</span></span><br>  - <span class="hljs-string">&quot;css/_typing.css&quot;</span><br>  <span class="hljs-meta"># 包括 <span class="hljs-string">&#x27;source/_css/&#x27;</span> 中的任何文件，但不包括子目录及其其中的文件。</span><br>  - <span class="hljs-string">&quot;_css/*&quot;</span><br>  <span class="hljs-meta"># 包含 <span class="hljs-string">&#x27;source/_css/&#x27;</span> 中的任何文件和子目录下的任何文件</span><br>  - <span class="hljs-string">&quot;_css/**/*&quot;</span><br><br>exclude:<br>  <span class="hljs-meta"># 不包括 <span class="hljs-string">&#x27;source/js/test.js&#x27;</span></span><br>  - <span class="hljs-string">&quot;js/test.js&quot;</span><br>  <span class="hljs-meta"># 不包括 <span class="hljs-string">&#x27;source/js/&#x27;</span> 中的文件、但包括子目录下的所有目录和文件</span><br>  - <span class="hljs-string">&quot;js/*&quot;</span><br>  <span class="hljs-meta"># 不包括 <span class="hljs-string">&#x27;source/js/&#x27;</span> 中的文件和子目录下的任何文件</span><br>  - <span class="hljs-string">&quot;js/**/*&quot;</span><br>  <span class="hljs-meta"># 不包括 <span class="hljs-string">&#x27;source/js/&#x27;</span> 目录下的所有文件名以 <span class="hljs-string">&#x27;test&#x27;</span> 开头的文件，但包括其它文件和子目录下的单文件</span><br>  - <span class="hljs-string">&quot;js/test*&quot;</span><br>  <span class="hljs-meta"># 不包括 <span class="hljs-string">&#x27;source/js/&#x27;</span> 及其子目录中任何以 <span class="hljs-string">&#x27;test&#x27;</span> 开头的文件</span><br>  - <span class="hljs-string">&quot;js/**/test*&quot;</span><br>  <span class="hljs-meta"># 不要用 exclude 来忽略 <span class="hljs-string">&#x27;source/_posts/&#x27;</span> 中的文件。你应该使用 <span class="hljs-string">&#x27;skip_render&#x27;</span>，或者在要忽略的文件的文件名之前加一个下划线 <span class="hljs-string">&#x27;_&#x27;</span></span><br>  <span class="hljs-meta"># 在这里配置一个 - <span class="hljs-string">&quot;_posts/hello-world.md&quot;</span> 是没有用的。</span><br><br>ignore:<br>  <span class="hljs-meta"># Ignore any folder named <span class="hljs-string">&#x27;foo&#x27;</span>.</span><br>  - <span class="hljs-string">&quot;**/foo&quot;</span><br>  <span class="hljs-meta"># Ignore <span class="hljs-string">&#x27;foo&#x27;</span> folder in <span class="hljs-string">&#x27;themes/&#x27;</span> only.</span><br>  - <span class="hljs-string">&quot;**/themes/*/foo&quot;</span><br>  <span class="hljs-meta"># Same as above, but applies to every subfolders of <span class="hljs-string">&#x27;themes/&#x27;</span>.</span><br>  - <span class="hljs-string">&quot;**/themes/**/foo&quot;</span><br></code></pre></td></tr></table></figure><p>列表中的每一项都必须用单引号或双引号包裹起来。</p><p><code>include</code> 和 <code>exclude</code> 并不适用于 <code>themes/</code> 目录下的文件。如果需要忽略 <code>themes/</code> 目录下的部分文件或文件夹，可以使用 <code>ignore</code> 或在文件名之前添加下划线 <code>_</code>。</p><h3 id="使用代替配置文件"><a href="#使用代替配置文件" class="headerlink" title="使用代替配置文件"></a>使用代替配置文件</h3><p>可以在 hexo-cli 中使用 <code>--config</code> 参数来指定自定义配置文件的路径。你可以使用一个 YAML 或 JSON 文件的路径，也可以使用逗号分隔（无空格）的多个 YAML 或 JSON 文件的路径。例如：</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sml"># use <span class="hljs-symbol">&#x27;custom</span>.yml&#x27; <span class="hljs-keyword">in</span> place <span class="hljs-keyword">of</span> <span class="hljs-symbol">&#x27;_config</span>.yml&#x27;<br>$ hexo server --config custom.yml<br><br># use <span class="hljs-symbol">&#x27;custom</span>.yml&#x27; &amp; <span class="hljs-symbol">&#x27;custom2</span>.json&#x27;, prioritizing <span class="hljs-symbol">&#x27;custom3</span>.yml&#x27;, <span class="hljs-keyword">then</span> <span class="hljs-symbol">&#x27;custom2</span>.json&#x27;<br>$ hexo generate --config custom.yml,custom2.json,custom3.yml<br></code></pre></td></tr></table></figure><p>当你指定了多个配置文件以后，Hexo 会按顺序将这部分配置文件合并成一个 <code>_multiconfig.yml</code>。如果遇到重复的配置，排在后面的文件的配置会覆盖排在前面的文件的配置。这个原则适用于任意数量、任意深度的 YAML 和 JSON 文件。</p><p>例如，使用 <code>--options</code> 指定了两个自定义配置文件：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog">$ hexo <span class="hljs-keyword">generate</span> --<span class="hljs-keyword">config</span> custom<span class="hljs-variable">.yml</span>,custom2<span class="hljs-variable">.json</span><br></code></pre></td></tr></table></figure><p>如果 <code>custom.yml</code> 中指定了 <code>foo: bar</code>，在 custom2.json 中指定了 <code>&quot;foo&quot;: &quot;dinosaur&quot;</code>，那么在 <code>_multiconfig.yml</code> 中你会得到 <code>foo: dinosaur</code>。</p><h3 id="使用代替主题配置文件"><a href="#使用代替主题配置文件" class="headerlink" title="使用代替主题配置文件"></a>使用代替主题配置文件</h3><p>通常情况下，Hexo 主题是一个独立的项目，并拥有一个独立的 <code>_config.yml</code> 配置文件。</p><p>除了自行维护独立的主题配置文件，你也可以在其它地方对主题进行配置。</p><p><strong>配置文件中的 <code>theme_config</code></strong></p><blockquote><p>该特性自 Hexo 2.8.2 起提供</p></blockquote><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-meta"># _config.yml</span><br><span class="hljs-symbol">theme:</span> <span class="hljs-string">&quot;my-theme&quot;</span><br><span class="hljs-symbol">theme_config:</span><br><span class="hljs-symbol">  bio:</span> <span class="hljs-string">&quot;My awesome bio&quot;</span><br><span class="hljs-symbol">  foo:</span><br><span class="hljs-symbol">    bar:</span> <span class="hljs-string">&#x27;a&#x27;</span><br><span class="hljs-meta"># themes/my-theme/_config.yml</span><br><span class="hljs-symbol">bio:</span> <span class="hljs-string">&quot;Some generic bio&quot;</span><br><span class="hljs-symbol">logo:</span> <span class="hljs-string">&quot;a-cool-image.png&quot;</span><br><span class="hljs-symbol">  foo:</span><br><span class="hljs-symbol">    baz:</span> <span class="hljs-string">&#x27;b&#x27;</span><br></code></pre></td></tr></table></figure><p>最终主题配置的输出是：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dts">&#123;<br><span class="hljs-symbol">  bio:</span> <span class="hljs-string">&quot;My awesome bio&quot;</span>,<br><span class="hljs-symbol">  logo:</span> <span class="hljs-string">&quot;a-cool-image.png&quot;</span>,<br><span class="hljs-symbol">  foo:</span> &#123;<br><span class="hljs-symbol">    bar:</span> <span class="hljs-string">&quot;a&quot;</span>,<br><span class="hljs-symbol">    baz:</span> <span class="hljs-string">&quot;b&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>独立的 <code>_config.[theme].yml</code> 文件</strong></p><blockquote><p>该特性自 Hexo 5.0.0 起提供</p></blockquote><p>独立的主题配置文件应放置于站点根目录下，支持 <code>yml</code> 或 <code>json</code> 格式。需要配置站点 <code>_config.yml</code> 文件中的 <code>theme</code> 以供 Hexo 寻找 <code>_config.[theme].yml</code> 文件。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-meta"># _config.yml</span><br><span class="hljs-symbol">theme:</span> <span class="hljs-string">&quot;my-theme&quot;</span><br><span class="hljs-meta"># _config.my-theme.yml</span><br><span class="hljs-symbol">bio:</span> <span class="hljs-string">&quot;My awesome bio&quot;</span><br><span class="hljs-symbol">foo:</span><br><span class="hljs-symbol">  bar:</span> <span class="hljs-string">&#x27;a&#x27;</span><br><span class="hljs-meta"># themes/my-theme/_config.yml</span><br><span class="hljs-symbol">bio:</span> <span class="hljs-string">&quot;Some generic bio&quot;</span><br><span class="hljs-symbol">logo:</span> <span class="hljs-string">&quot;a-cool-image.png&quot;</span><br><span class="hljs-symbol">  foo:</span><br><span class="hljs-symbol">    baz:</span> <span class="hljs-string">&#x27;b&#x27;</span><br></code></pre></td></tr></table></figure><p>最终主题配置的输出是：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dts">&#123;<br><span class="hljs-symbol">  bio:</span> <span class="hljs-string">&quot;My awesome bio&quot;</span>,<br><span class="hljs-symbol">  logo:</span> <span class="hljs-string">&quot;a-cool-image.png&quot;</span>,<br><span class="hljs-symbol">  foo:</span> &#123;<br><span class="hljs-symbol">    bar:</span> <span class="hljs-string">&quot;a&quot;</span>,<br><span class="hljs-symbol">    baz:</span> <span class="hljs-string">&quot;b&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>我们强烈建议你将所有的主题配置集中在一处。如果你不得不在多处配置你的主题，那么这些信息对你将会非常有用：Hexo 在合并主题配置时，Hexo 配置文件中的 <code>theme_config</code> 的优先级最高，其次是 <code>_config.[theme].yml</code> 文件，最后是位于主题目录下的 <code>_config.yml</code> 文件。</p></blockquote><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>安装 <code>Hexo </code>完成后，请执行下列命令，<code>Hexo</code> 将会在指定文件夹中新建所需要的文件。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> hexo init &lt;folder&gt;<br><span class="hljs-variable">$</span> <span class="hljs-built_in">cd</span> &lt;folder&gt;<br><span class="hljs-variable">$</span> npm install<br></code></pre></td></tr></table></figure><p>新建完成后，指定文件夹的目录如下：</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sqf">.<br>├── <span class="hljs-variable">_config</span>.yml<br>├── package.json<br>├── scaffolds<br>├── source<br>|   ├── <span class="hljs-variable">_drafts</span><br>|   └── <span class="hljs-variable">_posts</span><br>└── themes<br></code></pre></td></tr></table></figure><h3 id="config-yml"><a href="#config-yml" class="headerlink" title="_config.yml"></a><code>_config.yml</code></h3><p>网站的 <a href="https://hexo.io/zh-cn/docs/configuration">配置</a> 信息，您可以在此配置大部分的参数。</p><h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a><code>package.json</code></h3><p>应用程序的信息。<a href="https://ejs.co/">EJS</a>, <a href="http://learnboost.github.io/stylus/">Stylus</a> 和 <a href="http://daringfireball.net/projects/markdown/">Markdown</a> renderer 已默认安装，您可以自由移除。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">package</span>.json&#123;<br>  <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;hexo-site&quot;</span>,<br>  <span class="hljs-string">&quot;version&quot;</span>: <span class="hljs-string">&quot;0.0.0&quot;</span>,<br>  <span class="hljs-string">&quot;private&quot;</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-string">&quot;hexo&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;version&quot;</span>: <span class="hljs-string">&quot;&quot;</span><br>  &#125;,<br>  <span class="hljs-string">&quot;dependencies&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;hexo&quot;</span>: <span class="hljs-string">&quot;^3.8.0&quot;</span>,<br>    <span class="hljs-string">&quot;hexo-generator-archive&quot;</span>: <span class="hljs-string">&quot;^0.1.5&quot;</span>,<br>    <span class="hljs-string">&quot;hexo-generator-category&quot;</span>: <span class="hljs-string">&quot;^0.1.3&quot;</span>,<br>    <span class="hljs-string">&quot;hexo-generator-index&quot;</span>: <span class="hljs-string">&quot;^0.2.1&quot;</span>,<br>    <span class="hljs-string">&quot;hexo-generator-tag&quot;</span>: <span class="hljs-string">&quot;^0.2.0&quot;</span>,<br>    <span class="hljs-string">&quot;hexo-renderer-ejs&quot;</span>: <span class="hljs-string">&quot;^0.3.1&quot;</span>,<br>    <span class="hljs-string">&quot;hexo-renderer-stylus&quot;</span>: <span class="hljs-string">&quot;^0.3.3&quot;</span>,<br>    <span class="hljs-string">&quot;hexo-renderer-marked&quot;</span>: <span class="hljs-string">&quot;^0.3.2&quot;</span>,<br>    <span class="hljs-string">&quot;hexo-server&quot;</span>: <span class="hljs-string">&quot;^0.3.3&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="scaffolds"><a href="#scaffolds" class="headerlink" title="scaffolds"></a>scaffolds</h3><p><a href="https://hexo.io/zh-cn/docs/writing">模版</a> 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。</p><p>Hexo的模板是指在新建的文章文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。</p><h3 id="source"><a href="#source" class="headerlink" title="source"></a>source</h3><p>资源文件夹是存放用户资源的地方。除 <code>_posts</code> 文件夹之外，开头命名为 <code>_</code> (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 <code>public</code> 文件夹，而其他文件会被拷贝过去。</p><h3 id="themes"><a href="#themes" class="headerlink" title="themes"></a>themes</h3><p><a href="https://hexo.io/zh-cn/docs/themes">主题</a> 文件夹。Hexo 会根据主题来生成静态页面。</p><h1 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h1><p>可以在命令中指定文章的布局（layout），默认为 <code>post</code>，可以通过修改 <code>_config.yml</code> 中的 <code>default_layout</code> 参数来指定默认布局。</p><h3 id="布局（Layout）"><a href="#布局（Layout）" class="headerlink" title="布局（Layout）"></a>布局（Layout）</h3><p>Hexo 有三种默认布局：<code>post</code>、<code>page</code> 和 <code>draft</code>。在创建这三种不同类型的文件时，它们将会被保存到不同的路径；而您自定义的其他布局和 <code>post</code> 相同，都将储存到 <code>source/_posts</code> 文件夹。</p><table><thead><tr><th align="left">布局</th><th align="left">路径</th></tr></thead><tbody><tr><td align="left"><code>post</code></td><td align="left"><code>source/_posts</code></td></tr><tr><td align="left"><code>page</code></td><td align="left"><code>source</code></td></tr><tr><td align="left"><code>draft</code></td><td align="left"><code>source/_drafts</code></td></tr></tbody></table><blockquote><p>Disabling layout</p><p>If you don’t want an article (post/page) to be processed with a theme, set <code>layout: false</code> in its front-matter. Refer to <a href="https://hexo.io/zh-cn/docs/front-matter#%E5%B8%83%E5%B1%80">this section</a> for more details.</p></blockquote><h3 id="文件名称"><a href="#文件名称" class="headerlink" title="文件名称"></a>文件名称</h3><p>Hexo 默认以标题做为文件名称，但您可编辑 <code>new_post_name</code> 参数来改变默认的文件名称，举例来说，设为 <code>:year-:month-:day-:title.md</code> 可让您更方便的通过日期来管理文章。</p><table><thead><tr><th align="left">变量</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>:title</code></td><td align="left">标题（小写，空格将会被替换为短杠）</td></tr><tr><td align="left"><code>:year</code></td><td align="left">建立的年份，比如， <code>2015</code></td></tr><tr><td align="left"><code>:month</code></td><td align="left">建立的月份（有前导零），比如， <code>04</code></td></tr><tr><td align="left"><code>:i_month</code></td><td align="left">建立的月份（无前导零），比如， <code>4</code></td></tr><tr><td align="left"><code>:day</code></td><td align="left">建立的日期（有前导零），比如， <code>07</code></td></tr><tr><td align="left"><code>:i_day</code></td><td align="left">建立的日期（无前导零），比如， <code>7</code></td></tr></tbody></table><h3 id="草稿"><a href="#草稿" class="headerlink" title="草稿"></a>草稿</h3><p>刚刚提到了 Hexo 的一种特殊布局：<code>draft</code>，这种布局在建立时会被保存到 <code>source/_drafts</code> 文件夹，您可通过 <code>publish</code> 命令将草稿移动到 <code>source/_posts</code> 文件夹，该命令的使用方式与 <code>new</code> 十分类似，您也可在命令中指定 <code>layout</code> 来指定布局。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">$ hexo publish [layout] <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><br></code></pre></td></tr></table></figure><p>草稿默认不会显示在页面中，您可在执行时加上 <code>--draft</code> 参数，或是把 <code>render_drafts</code> 参数设为 <code>true</code> 来预览草稿。</p><h2 id="模版（Scaffold）"><a href="#模版（Scaffold）" class="headerlink" title="模版（Scaffold）"></a>模版（Scaffold）</h2><p>在新建文章时，Hexo 会根据 <code>scaffolds</code> 文件夹内相对应的文件来建立文件，例如：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">$ hexo <span class="hljs-keyword">new</span> <span class="hljs-type">photo</span> <span class="hljs-string">&quot;My Gallery&quot;</span><br></code></pre></td></tr></table></figure><p>在执行这行指令时，Hexo 会尝试在 <code>scaffolds</code> 文件夹中寻找 <code>photo.md</code>，并根据其内容建立文章，以下是您可以在模版中使用的变量：</p><table><thead><tr><th align="left">变量</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>layout</code></td><td align="left">布局</td></tr><tr><td align="left"><code>title</code></td><td align="left">标题</td></tr><tr><td align="left"><code>date</code></td><td align="left">文件建立日期</td></tr></tbody></table><h3 id="支持的格式"><a href="#支持的格式" class="headerlink" title="支持的格式"></a>支持的格式</h3><p>Hexo 支持以任何格式书写文章，只要安装了相应的渲染插件。</p><p>例如，Hexo 默认安装了 <code>hexo-renderer-marked</code> 和 <code>hexo-renderer-ejs</code>，因此你不仅可以用 Markdown 写作，你还可以用 EJS 写作。如果你安装了 <code>hexo-renderer-pug</code>，你甚至可以用 Pug 模板语言书写文章。</p><p>只需要将文章的扩展名从 <code>md</code> 改成 <code>ejs</code>，Hexo 就会使用 <code>hexo-renderer-ejs</code> 渲染这个文件，其他格式同理。</p><h1 id="npm相关问题"><a href="#npm相关问题" class="headerlink" title="npm相关问题"></a><code>npm</code>相关问题</h1><h2 id="1-使用npm命令时报错误Error-EACCES-permission-denied，如何解决？"><a href="#1-使用npm命令时报错误Error-EACCES-permission-denied，如何解决？" class="headerlink" title="1.使用npm命令时报错误Error: EACCES: permission denied，如何解决？"></a>1.使用<code>npm</code>命令时报错误<code>Error: EACCES: permission denied</code>，如何解决？</h2><p>官方的解决方案：<a href="https://docs.npmjs.com/getting-started/fixing-npm-permissions">https://docs.npmjs.com/getting-started/fixing-npm-permissions</a></p><p>官方提供了两种解决方案：</p><ol><li><p>重新安装一个node version manager。（官方推荐）<br>参考地址：<a href="https://docs.npmjs.com/getting-started/installing-node">https://docs.npmjs.com/getting-started/installing-node</a><br>注：这个方法比较繁琐，我选择的是第二种方案。</p></li><li><p>改变<code>npm</code>默认的路径。</p><p>步骤如下：</p></li></ol><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">进入终端，依次输入一下命令<br>（<span class="hljs-number">1</span>）创建<span class="hljs-built_in">global</span>安装任务的目录<br>mkdir ~/.<span class="hljs-built_in">npm</span>-<span class="hljs-built_in">global</span><br>（<span class="hljs-number">2</span>）配置<span class="hljs-built_in">npm</span>使用新的目录<br><span class="hljs-built_in">npm</span> config set prefix <span class="hljs-string">&#x27;~/.npm-global&#x27;</span><br>（<span class="hljs-number">3</span>）在~<span class="hljs-regexp">/.profile文件中增加配置  注：可能没有这个文件。如果用的zsh：是（ ~/</span>.zshrc）；如果用的bash：是(~/.bash_profile)<br><span class="hljs-keyword">export</span> PATH=~/.<span class="hljs-built_in">npm</span>-<span class="hljs-built_in">global</span>/bin:$PATH<br>（<span class="hljs-number">4</span>）配置文件立即生效<br>source ~<span class="hljs-regexp">/.profile 注：我用的zsh,所以命令是（source ~/</span>.zshrc）<br>（<span class="hljs-number">5</span>）重新执行命令<br><span class="hljs-built_in">npm</span> install -g xxxx <br></code></pre></td></tr></table></figure><h2 id="2-通过npm安装主题在哪"><a href="#2-通过npm安装主题在哪" class="headerlink" title="2.通过npm安装主题在哪"></a>2.通过npm安装主题在哪</h2><ul><li>在博客文件夹的node_modules目录下</li></ul><h2 id="3-查看本地安装的所有npm包"><a href="#3-查看本地安装的所有npm包" class="headerlink" title="3. 查看本地安装的所有npm包"></a>3. 查看本地安装的所有npm包</h2><ol><li>查看</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">$ npm list -g --depth 0  // 若需要权限 请加上 sudo 命令<br></code></pre></td></tr></table></figure><ol start="2"><li>更新</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">$ npm update -g xxx<br></code></pre></td></tr></table></figure><ol start="3"><li>删除</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">$ npm uninstall -g xxx<br></code></pre></td></tr></table></figure><h1 id="将-Hexo-部署到-GitHub-Pages"><a href="#将-Hexo-部署到-GitHub-Pages" class="headerlink" title="将 Hexo 部署到 GitHub Pages"></a>将 Hexo 部署到 GitHub Pages</h1><p>Hexo 提供了快速方便的一键部署功能，让您只需一条命令就能将网站部署到服务器上。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>hexo deploy<br></code></pre></td></tr></table></figure><p>在开始之前，您必须先在 <code>_config.yml</code> 中修改参数，一个正确的部署配置中至少要有 <code>type</code> 参数，例如：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br></code></pre></td></tr></table></figure><p>您可同时使用多个 deployer，Hexo 会依照顺序执行每个 deployer。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repo:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">type:</span> <span class="hljs-string">heroku</span><br>  <span class="hljs-attr">repo:</span><br></code></pre></td></tr></table></figure><p>Refer to the <a href="https://hexo.io/plugins/">Plugins</a> list for more deployment plugins.</p><blockquote><p>缩进</p><p>YAML依靠缩进来确定元素间的从属关系。因此，请确保每个deployer的缩进长度相同，并且使用空格缩进。</p></blockquote><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><ol><li>安装 <a href="https://github.com/hexojs/hexo-deployer-git">hexo-deployer-git</a>。</li></ol><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">$ npm install hexo-deployer-git <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><ol><li>修改配置。</li></ol><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repo:</span> <span class="hljs-params">&lt;repository url&gt;</span> <span class="hljs-meta">#https:<span class="hljs-comment">//bitbucket.org/JohnSmith/johnsmith.bitbucket.io</span></span><br><span class="hljs-symbol">  branch:</span> [branch]<br><span class="hljs-symbol">  message:</span> [message]<br></code></pre></td></tr></table></figure><table><thead><tr><th align="left">参数</th><th align="left">描述</th><th align="left">默认</th></tr></thead><tbody><tr><td align="left"><code>repo</code></td><td align="left">库（Repository）地址</td><td align="left"></td></tr><tr><td align="left"><code>branch</code></td><td align="left">分支名称</td><td align="left"><code>gh-pages</code> (GitHub) <code>coding-pages</code> (Coding.net) <code>master</code> (others)</td></tr><tr><td align="left"><code>message</code></td><td align="left">自定义提交信息</td><td align="left"><code>Site updated: &#123;&#123; now('YYYY-MM-DD HH:mm:ss') &#125;&#125;</code>)</td></tr><tr><td align="left"><code>token</code></td><td align="left">Optional token value to authenticate with the repo. Prefix with <code>$</code> to read token from environment variable</td><td align="left"></td></tr></tbody></table><ol><li>生成站点文件并推送至远程库。执行 <code>hexo clean &amp;&amp; hexo deploy</code>。</li></ol><ul><li>You will be prompted with username and password of the target repository, unless you authenticate with a token or ssh key.</li><li>hexo-deployer-git does not store your username and password. Use <a href="https://git-scm.com/docs/git-credential-cache">git-credential-cache</a> to store them temporarily.</li></ul><ol><li>登入 Github/BitBucket/Gitlab，请在库设置（Repository Settings）中将默认分支设置为<code>_config.yml</code>配置中的分支名称。稍等片刻，您的站点就会显示在您的Github Pages中。</li></ol><h3 id="这一切是如何发生的？"><a href="#这一切是如何发生的？" class="headerlink" title="这一切是如何发生的？"></a>这一切是如何发生的？</h3><p>当执行 <code>hexo deploy</code> 时，Hexo 会将 <code>public</code> 目录中的文件和目录推送至 <code>_config.yml</code> 中指定的远端仓库和分支中，并且<strong>完全覆盖</strong>该分支下的已有内容。</p><blockquote><p>For 使用 Git 管理站点目录的用户</p><p>由于 Hexo 的部署默认使用分支 <code>master</code>，所以如果你同时正在使用 Git 管理你的站点目录，你应当注意你的部署分支应当不同于写作分支。<br>一个好的实践是将站点目录和 Pages 分别存放在两个不同的 Git 仓库中，可以有效避免相互覆盖。<br>Hexo 在部署你的站点生成的文件时并不会更新你的站点目录。因此你应该手动提交并推送你的写作分支。</p></blockquote><p>此外，如果您的 Github Pages 需要使用 CNAME 文件<strong>自定义域名</strong>，请将 CNAME 文件置于 <code>source</code> 目录下，只有这样 <code>hexo deploy</code> 才能将 CNAME 文件一并推送至部署分支。</p><h2 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h2><p>Hexo 生成的所有文件都放在 <code>public</code> 文件夹中，您可以将它们复制到您喜欢的地方。</p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><ol><li>安装 <a href="https://github.com/hexojs/hexo-deployer-git">hexo-deployer-git</a>.</li><li>在 <strong>_config.yml</strong>（如果有已存在的请删除）添加如下配置：</li></ol><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repo:</span> https:<span class="hljs-comment">//github.com/&lt;username&gt;/&lt;project&gt;</span><br>  <span class="hljs-meta"># example, https:<span class="hljs-comment">//github.com/hexojs/hexojs.github.io</span></span><br><span class="hljs-symbol">  branch:</span> gh-pages<br></code></pre></td></tr></table></figure><ol><li>运行 <code>hexo clean &amp;&amp; hexo deploy</code> 。</li><li>查看 <em>username</em>.github.io 上的网页是否部署成功。</li></ol><h1 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h1><h2 id="init"><a href="#init" class="headerlink" title="init"></a>init</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">$ hexo <span class="hljs-keyword">init</span> [folder]<br></code></pre></td></tr></table></figure><p>新建一个网站。如果没有设置 <code>folder</code> ，Hexo 默认在目前的文件夹建立网站。</p><p>本命令相当于执行了以下几步：</p><ol><li>Git clone <a href="https://github.com/hexojs/hexo-starter">hexo-starter</a> 和 <a href="https://github.com/hexojs/hexo-theme-landscape">hexo-theme-landscape</a> 主题到当前目录或指定目录。</li><li>使用 <a href="https://classic.yarnpkg.com/lang/en/">Yarn 1</a>、<a href="https://pnpm.js.org/">pnpm</a> 或 <a href="https://docs.npmjs.com/cli/install">npm</a> 包管理器下载依赖（如有已安装多个，则列在前面的优先）。npm 默认随 <a href="https://hexo.io/docs/#Install-Node-js">Node.js</a> 安装。</li></ol><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss">$ hexo <span class="hljs-keyword">new</span> [layout] &lt;<span class="hljs-built_in">title</span>&gt;<br></code></pre></td></tr></table></figure><p>新建一篇文章。如果没有设置 <code>layout</code> 的话，默认使用 <a href="https://hexo.io/zh-cn/docs/configuration">_config.yml</a> 中的 <code>default_layout</code> 参数代替。如果标题包含空格的话，请使用引号括起来。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">$ hexo <span class="hljs-keyword">new</span> <span class="hljs-string">&quot;post title with whitespace&quot;</span><br></code></pre></td></tr></table></figure><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-p</code>, <code>--path</code></td><td align="left">自定义新文章的路径</td></tr><tr><td align="left"><code>-r</code>, <code>--replace</code></td><td align="left">如果存在同名文章，将其替换</td></tr><tr><td align="left"><code>-s</code>, <code>--slug</code></td><td align="left">文章的 Slug，作为新文章的文件名和发布后的 URL</td></tr></tbody></table><p>默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 <code>index.md</code> 文件。你可以使用 <code>--path</code> 参数来覆盖上述行为、自行决定文件的目录：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">hexo <span class="hljs-keyword">new</span> <span class="hljs-type">page</span> --path about/me <span class="hljs-string">&quot;About me&quot;</span><br></code></pre></td></tr></table></figure><p>以上命令会创建一个 <code>source/about/me.md</code> 文件，同时 Front Matter 中的 title 为 <code>&quot;About me&quot;</code></p><p>注意！title 是必须指定的！如果你这么做并不能达到你的目的：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">hexo <span class="hljs-keyword">new</span> page <span class="hljs-comment">--path about/me</span><br></code></pre></td></tr></table></figure><p>此时 Hexo 会创建 <code>source/_posts/about/me.md</code>，同时 <code>me.md</code> 的 Front Matter 中的 title 为 <code>&quot;page&quot;</code>。这是因为在上述命令中，hexo-cli 将 <code>page</code> 视为指定文章的标题、并采用默认的 <code>layout</code>。</p><h2 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h2><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog">$ hexo <span class="hljs-keyword">generate</span><br></code></pre></td></tr></table></figure><p>生成静态文件。</p><table><thead><tr><th align="left">选项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-d</code>, <code>--deploy</code></td><td align="left">文件生成后立即部署网站</td></tr><tr><td align="left"><code>-w</code>, <code>--watch</code></td><td align="left">监视文件变动</td></tr><tr><td align="left"><code>-b</code>, <code>--bail</code></td><td align="left">生成过程中如果发生任何未处理的异常则抛出异常</td></tr><tr><td align="left"><code>-f</code>, <code>--force</code></td><td align="left">强制重新生成文件 Hexo 引入了差分机制，如果 <code>public</code> 目录存在，那么 <code>hexo g</code> 只会重新生成改动的文件。 使用该参数的效果接近 <code>hexo clean &amp;&amp; hexo generate</code></td></tr><tr><td align="left"><code>-c</code>, <code>--concurrency</code></td><td align="left">最大同时生成文件的数量，默认无限制</td></tr></tbody></table><p>该命令可以简写为</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>hexo g<br></code></pre></td></tr></table></figure><h2 id="publish"><a href="#publish" class="headerlink" title="publish"></a>publish</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">$ hexo publish [layout] <span class="hljs-tag">&lt;<span class="hljs-name">filename</span>&gt;</span><br></code></pre></td></tr></table></figure><p>发表草稿。</p><h2 id="server"><a href="#server" class="headerlink" title="server"></a>server</h2><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">$ hexo <span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><p>启动服务器。默认情况下，访问网址为： <code>http://localhost:4000/</code>。</p><table><thead><tr><th align="left">选项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-p</code>, <code>--port</code></td><td align="left">重设端口</td></tr><tr><td align="left"><code>-s</code>, <code>--static</code></td><td align="left">只使用静态文件</td></tr><tr><td align="left"><code>-l</code>, <code>--log</code></td><td align="left">启动日记记录，使用覆盖记录格式</td></tr></tbody></table><h2 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h2><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>hexo deploy<br></code></pre></td></tr></table></figure><p>部署网站。</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-g</code>, <code>--generate</code></td><td align="left">部署之前预先生成静态文件</td></tr></tbody></table><p>该命令可以简写为：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>hexo d<br></code></pre></td></tr></table></figure><h2 id="render"><a href="#render" class="headerlink" title="render"></a>render</h2><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs prolog">$ hexo render &lt;file1&gt; [file2] ...<br></code></pre></td></tr></table></figure><p>渲染文件。</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-o</code>, <code>--output</code></td><td align="left">设置输出路径</td></tr></tbody></table><h2 id="migrate"><a href="#migrate" class="headerlink" title="migrate"></a>migrate</h2><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm">$ hexo migrate &lt;<span class="hljs-keyword">type</span>&gt;<br></code></pre></td></tr></table></figure><p>从其他博客系统 <a href="https://hexo.io/zh-cn/docs/migration">迁移内容</a>。</p><h2 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h2><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>hexo clean<br></code></pre></td></tr></table></figure><p>清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。</p><p>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p><h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm">$ hexo list &lt;<span class="hljs-keyword">type</span>&gt;<br></code></pre></td></tr></table></figure><p>列出网站资料。</p><h2 id="version"><a href="#version" class="headerlink" title="version"></a>version</h2><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">$ hexo <span class="hljs-built_in">version</span><br></code></pre></td></tr></table></figure><p>显示 Hexo 版本。</p><h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><h2 id="部署插件"><a href="#部署插件" class="headerlink" title="部署插件"></a>部署插件</h2><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">安装： npm install hexo-deployer-git <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><p>将我们的Hexo与GitHub关联起来，打开站点的配置文件_config.yml，翻到最后修改为：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">type:</span> git<br><span class="hljs-symbol">repo:</span> 博客的仓库地址，用ssh的地址，不要用https的地址<br><span class="hljs-symbol">branch:</span> master<br><span class="hljs-symbol">ps:</span>注意缩进<br></code></pre></td></tr></table></figure><p>其实就是给hexo d 这个命令做相应的配置，让hexo知道你要把blog部署在哪个位置，很显然，我们部署在我们GitHub的仓库里。</p><h2 id="控制台"><a href="#控制台" class="headerlink" title="控制台"></a>控制台</h2><p>地址：<a href="https://github.com/jaredly/hexo-admin">github</a></p><p><strong>ps</strong>:对于 2.x，请使用此插件的 0.3.0 版。 1.x 及更高版本仅支持 Hexo v3.x。</p><p>其实第三条的 hexo d 就是部署网站命令，d是deploy的缩写。完成后，打开浏览器，在地址栏输入你的放置个人网站的仓库路径，即” <a href="http://xxxx.github.io&quot;,就可以看到你的博客,使用hexo/">http://xxxx.github.io&quot;,就可以看到你的博客,使用Hexo</a> Admin 插件写博客, <a href="%E2%80%9Dhttps://jaredforsyth.com/hexo-admin/%22">官网链接:</a><br>    安装方法<br>    第一步:下载启动</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">npm install --save hexo-admin<br>hexo server -d<br>open http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">4000</span><span class="hljs-regexp">/admin/</span><br></code></pre></td></tr></table></figure><p>第二步：配置<br>在Hexo 全局配置文件_config.yml最后添加类似如下内容</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">admin</span>:<span class="hljs-string"></span><br>  <span class="hljs-attr">username</span>: <span class="hljs-string">AlexLin</span><br>  <span class="hljs-attr">password_hash</span>: <span class="hljs-string">be121740bf988b2225a313fa1f107ca1</span><br>  <span class="hljs-attr">secret</span>: <span class="hljs-string">your admin password</span><br><br><span class="hljs-attr">secret</span> :<span class="hljs-string">你的后台管理密码</span><br><span class="hljs-attr">password_hash</span>: <span class="hljs-string">用密码生成的哈希串.</span><br><span class="hljs-meta">若是部署到github</span> <span class="hljs-string">pages,是不会上传hexo admin的,没有必要添加密码.</span><br></code></pre></td></tr></table></figure><h2 id="永久链接"><a href="#永久链接" class="headerlink" title="永久链接"></a>永久链接</h2><p>地址：<a href="https://github.com/rozbo/hexo-abbrlink">github</a></p><p>使用：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">安装： npm install hexo-abbrlink <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><p>修改 config.yml ：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">permalink: posts<span class="hljs-regexp">/:abbrlink/</span><br></code></pre></td></tr></table></figure><p>There are two settings:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">alg <span class="hljs-comment">-- Algorithm (currently support crc16 and crc32, which crc16 is default)</span><br><span class="hljs-built_in">rep</span> <span class="hljs-comment">-- Represent (the generated link could be presented in hex or dec value)</span><br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># abbrlink config</span><br><span class="hljs-attr">abbrlink:</span><br>  <span class="hljs-attr">alg:</span> <span class="hljs-string">crc32</span>      <span class="hljs-comment">#support crc16(default) and crc32</span><br>  <span class="hljs-attr">rep:</span> <span class="hljs-string">hex</span>        <span class="hljs-comment">#support dec(default) and hex</span><br>  <span class="hljs-attr">drafts:</span> <span class="hljs-literal">false</span>   <span class="hljs-comment">#(true)Process draft,(false)Do not process draft. false(default) </span><br>  <span class="hljs-comment"># Generate categories from directory-tree</span><br>  <span class="hljs-comment"># depth: the max_depth of directory-tree you want to generate, should &gt; 0</span><br>  <span class="hljs-attr">auto_category:</span><br>     <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span>  <span class="hljs-comment">#true(default)</span><br>     <span class="hljs-attr">depth:</span>        <span class="hljs-comment">#3(default)</span><br>     <span class="hljs-attr">over_write:</span> <span class="hljs-literal">false</span> <br>  <span class="hljs-attr">auto_title:</span> <span class="hljs-literal">false</span> <span class="hljs-comment">#enable auto title, it can auto fill the title by path</span><br>  <span class="hljs-attr">auto_date:</span> <span class="hljs-literal">false</span> <span class="hljs-comment">#enable auto date, it can auto fill the date by time today</span><br>  <span class="hljs-attr">force:</span> <span class="hljs-literal">false</span> <span class="hljs-comment">#enable force mode,in this mode, the plugin will ignore the cache, and calc the abbrlink for every post even it already had abbrlink.</span><br></code></pre></td></tr></table></figure><h2 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h2><p>地址：<a href="https://github.com/chenzhutian/hexo-all-minifier">github</a></p><p>使用：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">$ npm install hexo-<span class="hljs-keyword">all</span>-minifier <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><p>对于 Mac 用户，也许你需要安装更多的东西</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">$ brew install libtool <span class="hljs-built_in">auto</span>make <span class="hljs-built_in">auto</span>conf nasm<br></code></pre></td></tr></table></figure><p>修改修改 config.yml 以启用该插件（更多设置查看插件github页面）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">all_minifier:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h2 id="看板娘"><a href="#看板娘" class="headerlink" title="看板娘"></a>看板娘</h2><p>地址： <a href="https://github.com/stevenjoezhang/live2d-widget">github</a></p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ul><li>hexo使用theme出现<code>“ &#123;% extends ‘_layout.swig‘ %&#125; &#123;% import ‘_macro/post.swig‘ as post_template %&#125;“</code>问题：</li></ul><p>​    原因是hexo在5.0之后把swig给删除了需要自己手动安装</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> i hexo-renderer-swig<br></code></pre></td></tr></table></figure><p>​    安装时有可能highlights提示版本过低。（install the latest v10 version of Highlight.js）</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> install highlight.js@latest<br></code></pre></td></tr></table></figure><h6 id="注-常用命令"><a href="#注-常用命令" class="headerlink" title="注: 常用命令"></a>注: 常用命令</h6><ul><li>想要删除hexo</li></ul><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">npm uninstall hexo-<span class="hljs-keyword">cli</span> -g<br></code></pre></td></tr></table></figure><p>文件夹中的blog，手动删除。<br>另外，进行重装之前，如果还是在原来位置，必须手动清理了才能迁移安装。  </p><ul><li>其他常用的Hexo 命令  </li></ul><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs axapta">npm install hexo -g <span class="hljs-meta">#安装Hexo</span><br>npm update hexo -g <span class="hljs-meta">#升级  </span><br>hexo init <span class="hljs-meta">#初始化博客  </span><br>hexo n <span class="hljs-string">&quot;我的博客&quot;</span> == hexo <span class="hljs-keyword">new</span> <span class="hljs-string">&quot;我的博客&quot;</span> <span class="hljs-meta">#新建文章(在/source/_posts文件夹中创建)  </span><br>hexo g == hexo generate <span class="hljs-meta">#生成  </span><br>hexo s == hexo <span class="hljs-keyword">server</span> <span class="hljs-meta">#本地部署, 启动服务预览  </span><br>hexo d == hexo deploy <span class="hljs-meta">#部署,部署到github等  </span><br>hexo <span class="hljs-keyword">server</span> <span class="hljs-meta">#Hexo会监视文件变动并自动更新，无须重启服务器  </span><br>hexo <span class="hljs-keyword">server</span> -s <span class="hljs-meta">#静态模式  </span><br>hexo <span class="hljs-keyword">server</span> -p <span class="hljs-number">5000</span> <span class="hljs-meta">#更改端口  </span><br>hexo <span class="hljs-keyword">server</span> -i <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span> <span class="hljs-meta">#自定义 IP  </span><br>hexo clean <span class="hljs-meta">#清除缓存，若是网页正常情况下可以忽略这条命令,清除缓存文件为了避免不必要的错误，在生成静态文件前，强烈建议先运行此命令.它会清除本地站点文件夹下的缓存文件（db.json）和已有的静态文件（public)  </span><br><br>注: 修改配置后,需要 “hexo g”重新生成 . 若是修改了themes的配置 , 可以不用重新生成,直接F5刷新浏览器页面就可以预览.<br>对于上面的两种常用命令, hexo提供了简写 hexo s -g(生成并预览)和hexo g -d(生成并远程部署)  <br></code></pre></td></tr></table></figure><ul><li>完善配置文件  </li></ul><p><a href="%22https://hexo.io/zh-cn/docs/configuration%22">官网链接</a><br>修改hexo的根文件夹里的_config.yml :  </p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs vbnet">先修改<br><span class="hljs-symbol">title:</span> <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-symbol">subtitle:</span> <span class="hljs-comment">&#x27;&#x27;</span><br><span class="hljs-symbol">description:</span> <span class="hljs-comment">&#x27;&#x27;</span><br><span class="hljs-symbol">keywords:</span><br><span class="hljs-symbol">author:</span>  <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-symbol">language:</span> zh-CN #此项注意, language文件夹里可能没有zh-Han , 但是由zh-CN .  <br><span class="hljs-symbol">url:</span><span class="hljs-string">&quot;此处修改为自己的网址&quot;</span><br>主题  <br><span class="hljs-symbol">theme:</span> 修改为themes文件夹下的主题名称<br></code></pre></td></tr></table></figure><p>使用init命令后,有如下文件夹  </p><pre><code>.├── _config.yml├── package.json├── scaffolds├── source|   ├── _drafts|   └── _posts└── themes</code></pre><ol><li>node_modules 是node.js各种库的目录  </li><li>public是生成的网页文件目录  </li><li>Scaffold(模版文件夹)<br>在新建文章时，Hexo 会根据 scaffolds 文件夹内相对应的文件来建立文件.<br>Hexo的模板是指在新建的markdown文件中默认填充的内容。<br>例如，如果修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。也就是说，通过hexo命令每新建一个文章，都会包含指定模板文件中的内容。  </li><li>Cource<br>资源文件夹是存放用户资源的地方，如markdown文章。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去.<br>注意：除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略.  </li><li>themes<br>主题文件夹。Hexo 会根据主题来解析source目录中的markdown文件生成静态页面。官网主题详述</li><li>package.json<br>应用程序的信息，以及需要安装的模块信息</li></ol><ul><li>写作,可以执行下列命令来创建一篇新文章。  </li></ul><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss">$ hexo <span class="hljs-keyword">new</span> [layout] &lt;<span class="hljs-built_in">title</span>&gt;<br></code></pre></td></tr></table></figure><p>可以在命令中指定文章的布局（layout），不指定默认为 post，也可以通过修改 _config.yml 中的 default_layout 参数来指定默认布局。创建的新文章会自动加上指定布局对应的模板文件中的内容。 </p><ul><li><p>布局<br>Hexo 有三种默认布局（Layout）：post、page 和 draft，它们分别对应不同的路径，而自定义的其他布局和 post 相同，都将储存到 source/_posts 文件夹.<br>如果你不想你的文章被处理，你可以将 Front-Matter 中的layout: 设为 false  </p></li><li><p>模板<br>例如  </p></li></ul><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">$ hexo <span class="hljs-keyword">new</span> <span class="hljs-type">photo</span> <span class="hljs-string">&quot;My Gallery&quot;</span><br></code></pre></td></tr></table></figure><p>在执行这行指令时，Hexo 会尝试在 scaffolds 文件夹中寻找 photo.md，并根据其内容建立文章. 以下是您可以在模版中使用的变量：<br>变量描述 :<br><code>layout</code>布局<br><code>title</code>标题<br><code>date</code>文件建立日期  </p><ul><li>Front-matter<br>Front-matter是文件最上方以 — 分隔的区域，用于指定个别文件的变量，举例来说：</li></ul><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs applescript"> <span class="hljs-comment">---</span><br>title: Hello World<br><span class="hljs-built_in">date</span>: <span class="hljs-number">2013</span>/<span class="hljs-number">7</span>/<span class="hljs-number">13</span> <span class="hljs-number">20</span>:<span class="hljs-number">46</span>:<span class="hljs-number">25</span><br> <span class="hljs-comment">---</span><br></code></pre></td></tr></table></figure><p><code>注意：一般Front-matter使用的yaml语法，yaml语法需要注意空格，如title: Hello World冒号需要有一个空格，当然除YAML 外，你也可以使用 JSON 来编写 Front-matter。</code></p>]]></content>
    
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java注解</title>
    <link href="/posts/3f6454bb/"/>
    <url>/posts/3f6454bb/</url>
    
    <content type="html"><![CDATA[<h1 id="process方法的调用方式"><a href="#process方法的调用方式" class="headerlink" title="process方法的调用方式"></a>process方法的调用方式</h1><p>注释处理分多轮完成。每一轮都从编译器开始搜索源文件中的注释并选择适合这些注释的注释处理器。依次在相应的源上调用每个注释处理器。</p><p>如果在此过程中生成了任何文件，则以生成的文件作为其输入开始另一轮。这个过程一直持续到在处理阶段没有新文件产生。</p><p>依次在相应的源上调用每个注释处理器。如果在此过程中生成了任何文件，则以生成的文件作为其输入开始另一轮。这个过程一直持续到在处理阶段没有新文件产生。</p><p>注释处理 <code>API </code>位于<code>javax.annotation.processing</code>包中。您必须实现的主要接口是<em>Processor</em>接口，它具有<code>AbstractProcessor</code>类形式的部分实现。这个类是我们将要扩展以创建我们自己的注释处理器的类。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">原文：<br>The annotation processing <span class="hljs-keyword">is</span> done <span class="hljs-keyword">in</span> multiple rounds. <span class="hljs-keyword">Each</span> round starts <span class="hljs-keyword">with</span> the compiler searching <span class="hljs-keyword">for</span> the annotations <span class="hljs-keyword">in</span> the source files <span class="hljs-keyword">and</span> choosing the annotation processors suited <span class="hljs-keyword">for</span> these annotations. <span class="hljs-keyword">Each</span> annotation processor, <span class="hljs-keyword">in</span> turn, <span class="hljs-keyword">is</span> <span class="hljs-keyword">called</span> <span class="hljs-keyword">on</span> the corresponding sources.<br><br><span class="hljs-keyword">If</span> <span class="hljs-keyword">any</span> files are <span class="hljs-keyword">generated</span> during this process, another round <span class="hljs-keyword">is</span> started <span class="hljs-keyword">with</span> the <span class="hljs-keyword">generated</span> files <span class="hljs-keyword">as</span> its <span class="hljs-keyword">input</span>. This process continues <span class="hljs-keyword">until</span> <span class="hljs-keyword">no</span> <span class="hljs-built_in">new</span> files are <span class="hljs-keyword">generated</span> during the processing stage.<br><br><span class="hljs-keyword">Each</span> annotation processor, <span class="hljs-keyword">in</span> turn, <span class="hljs-keyword">is</span> <span class="hljs-keyword">called</span> <span class="hljs-keyword">on</span> the corresponding sources. <span class="hljs-keyword">If</span> <span class="hljs-keyword">any</span> files are <span class="hljs-keyword">generated</span> during this process, another round <span class="hljs-keyword">is</span> started <span class="hljs-keyword">with</span> the <span class="hljs-keyword">generated</span> files <span class="hljs-keyword">as</span> its <span class="hljs-keyword">input</span>. This process continues <span class="hljs-keyword">until</span> <span class="hljs-keyword">no</span> <span class="hljs-built_in">new</span> files are <span class="hljs-keyword">generated</span> during the processing stage.<br><br>The annotation processing API <span class="hljs-keyword">is</span> located <span class="hljs-keyword">in</span> the javax.annotation.processing package. The main interface that you’ll have <span class="hljs-keyword">to</span> implement <span class="hljs-keyword">is</span> the Processor interface, which has a partial implementation <span class="hljs-keyword">in</span> the form <span class="hljs-keyword">of</span> AbstractProcessor <span class="hljs-keyword">class</span>. This <span class="hljs-keyword">class</span> <span class="hljs-keyword">is</span> the one we’re going <span class="hljs-keyword">to</span> extend <span class="hljs-keyword">to</span> <span class="hljs-keyword">create</span> our own annotation processor.<br><br><br></code></pre></td></tr></table></figure><p>这是一个实现处理器的例子：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@SupportedAnnotationTypes</span>(<span class="hljs-string">&quot;com.baeldung.annotation.processor.BuilderProperty&quot;</span>)<span class="hljs-comment">//指定这个处理器能处理的注解</span><br><span class="hljs-variable">@SupportedSourceVersion</span>(SourceVersion.RELEASE_8)<br><span class="hljs-variable">@AutoService</span>(Processor.class)<br>public class BuilderProcessor extends AbstractProcessor &#123;<br><br>    <span class="hljs-variable">@Override</span><br>    public boolean process(Set&lt;? extends TypeElement&gt; annotations, <br>      RoundEnvironment roundEnv) &#123;<br>        <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不仅可以指定具体的注释类名称，还可以指定通配符，例如<code>“com.baeldung.annotation.\*”</code> 来处理<code>com.baeldung.annotation</code>包及其所有子包中的注释，甚至可以<em>“*”</em>来处理所有注释.</p><p>我们必须实现的单一方法是处理本身的<code>process</code>方法。编译器为每个包含匹配注释的源文件调用它。</p><p>注释作为第一个<code>Set&lt;? extends TypeElement&gt; annotations</code>参数，有关当前处理轮次的信息作为<code>RoundEnviroment roundEnv</code>参数传递。</p><p>如果您的注释处理器已经处理了所有传递的注释，并且您不希望它们被传递到列表中的其他注释处理器，则返回<em>布尔</em>值应该为<em>true</em>。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">原文：<br>You can specify <span class="hljs-keyword">not</span> only <span class="hljs-keyword">the</span> concrete annotation class names but also wildcards, like “com.baeldung.annotation.*” <span class="hljs-built_in">to</span> <span class="hljs-built_in">process</span> annotations inside <span class="hljs-keyword">the</span> com.baeldung.annotation package <span class="hljs-keyword">and</span> all its sub packages, <span class="hljs-keyword">or</span> even “*” <span class="hljs-built_in">to</span> <span class="hljs-built_in">process</span> all annotations.<br><br>The single method that we’ll have <span class="hljs-built_in">to</span> implement is <span class="hljs-keyword">the</span> <span class="hljs-built_in">process</span> method that does <span class="hljs-keyword">the</span> processing itself. It is called <span class="hljs-keyword">by</span> <span class="hljs-keyword">the</span> compiler <span class="hljs-keyword">for</span> every source <span class="hljs-built_in">file</span> containing <span class="hljs-keyword">the</span> matching annotations.<br><br>Annotations are passed <span class="hljs-keyword">as</span> <span class="hljs-keyword">the</span> <span class="hljs-keyword">first</span> Set<span class="hljs-meta">&lt;?</span> extends TypeElement&gt; annotations argument, <span class="hljs-keyword">and</span> <span class="hljs-keyword">the</span> information about <span class="hljs-keyword">the</span> current processing <span class="hljs-built_in">round</span> is passed <span class="hljs-keyword">as</span> <span class="hljs-keyword">the</span> RoundEnviroment roundEnv argument.<br><br>The <span class="hljs-literal">return</span> boolean <span class="hljs-built_in">value</span> should be <span class="hljs-literal">true</span> <span class="hljs-keyword">if</span> your annotation processor has processed all <span class="hljs-keyword">the</span> passed annotations, <span class="hljs-keyword">and</span> you don<span class="hljs-string">&#x27;t want them to be passed to other annotation processors down the list.</span><br></code></pre></td></tr></table></figure><p>总结：</p><p>在我们自定义的处理器类中，我们指定了这个处理器类可以处理的注解。</p><p>然后，<code>java</code>编译器会依次调用注册好的注解处理器处理注解，这会有多轮处理。</p><p>在调用注解处理器的时候，编译器会筛选出这个注解处理器可以处理的注解信息给它处理。</p><p>在当前注解处理器处理注解的时候，如果产生的新类里依旧包含注解，那么，在其他所有注解处理器完成处理之后，会进行第二轮处理，第三轮，直到没有新的注解产生。</p><ul><li><p>例子：</p><ul><li><p><strong>MainActivity</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>&#123;<br><br>    <span class="hljs-meta">@BindView</span>(<span class="hljs-type">R</span>.id.tv_hello)<br>    <span class="hljs-type">TextView</span> tvHello;<br>  &#125;<br></code></pre></td></tr></table></figure></li><li><p>在第一轮处理注解时，我们生成了新的类,而这个类使用**@Keep**注解标记了，那么注解处理器就会        开始下一轮的处理，直到生成的类里面再也没有任何注解了。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">@Keep<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">MainActivity</span>$<span class="hljs-symbol">Binding</span> &#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h1 id="解析注解的步骤"><a href="#解析注解的步骤" class="headerlink" title="解析注解的步骤"></a>解析注解的步骤</h1><h2 id="插件化注解处理API的使用步骤大概如下："><a href="#插件化注解处理API的使用步骤大概如下：" class="headerlink" title="插件化注解处理API的使用步骤大概如下："></a>插件化注解处理API的使用步骤大概如下：</h2><ul><li>1、自定义一个Annotation Processor，需要继承<code>javax.annotation.processing.AbstractProcessor</code>，需要重写<code>process()</code>方法。<ul><li> 1.1、此外还需要实现几个简单的方法<code>init ()</code>、<code>getSupportedSourceVersion()</code>、<code>getSupportedAnnotationTypes()</code> </li></ul></li><li>2、自定义一个注解，注解的元注解需要指定<code>@Retention(RetentionPolicy.SOURCE)</code>。</li><li>3、需要在声明的自定义Annotation Processor中使用<code>javax.annotation.processing.SupportedAnnotationTypes</code>指定在第2步创建的注解类型的名称(注意需要全类名，”包名.注解类型名称”，否则会不生效)。</li><li>4、需要在声明的自定义Annotation Processor中使用<code>javax.annotation.processing.SupportedSourceVersion</code>指定编译版本。</li><li>5、可选操作，可以通在声明的自定义Annotation Processor中使用<code>javax.annotation.processing.SupportedOptions</code>指定编译参数。</li></ul><h2 id="配置和注册"><a href="#配置和注册" class="headerlink" title="配置和注册"></a>配置和注册</h2><ul><li>创建一个自定义Annotation Processor继承于AbstractProcessor</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AutoService(Processor.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractProcessor</span> </span>&#123;<br> 。。。省略。。。<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>@AutoService(Processor.class) :向javac注册我们这个自定义的注解处理器，这样，在javac编译时，才会调用到我们这个自定义的注解处理器方法。<br> AutoService这里主要是用来生成<br> <strong>建议直接采用@AutoService(Processor.class)进行自定义注解处理器注册，简洁方便</strong></p></li><li><p>其他方式注册</p><p>例如：</p><p>我们模仿一下测试框架Junit里面的@Test注解，在运行时通过Annotation Processor获取到使用了自定义的@Test注解对应的方法的信息。因为如果想要动态修改一个类或者方法的代码内容，需要使用到字节码修改工具例如ASM等，这些操作过于深入，日后再谈。先定义一个注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> club.throwable.processor;<br><br><span class="hljs-keyword">import</span> java.lang.annotation.ElementType;<br><span class="hljs-keyword">import</span> java.lang.annotation.Retention;<br><span class="hljs-keyword">import</span> java.lang.annotation.RetentionPolicy;<br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> throwable</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> v1.0</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 2018/5/27 11:18</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Target(&#123;ElementType.METHOD&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Test &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>定义一个注解处理器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SupportedAnnotationTypes(value = &#123;&quot;club.throwable.processor.Test&quot;&#125;)</span><br><span class="hljs-meta">@SupportedSourceVersion(value = SourceVersion.RELEASE_8)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnnotationProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractProcessor</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">process</span><span class="hljs-params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Log in AnnotationProcessor.process&quot;</span>);<br>        <span class="hljs-keyword">for</span> (TypeElement typeElement : annotations) &#123;<br>            System.out.println(typeElement);<br>        &#125;<br>        System.out.println(roundEnv);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编写一个主类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;success&quot;</span>);<br>        test();<br>    &#125;<br><br>    <span class="hljs-meta">@Test(value = &quot;method is test&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span><span class="hljs-keyword">throws</span> Exception</span>&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着需要指定Processor，如果使用IDEA的话，Compiler-&gt;Annotation Processors中的Enable annotation processing必须勾选。然后可以通过下面几种方式指定指定Processor。</p><ul><li><p>1、直接使用编译参数指定，例如：javac -processor club.throwable.processor.AnnotationProcessor Main.java。</p></li><li><p>2、<strong>通过服务注册指定</strong>，就是META-INF/services/javax.annotation.processing.Processor文件中添加club.throwable.processor.AnnotationProcessor。</p><ul><li><p>具体手动注册方法如下：</p><ol><li><p>创建一个<br>META-INF/services/javax.annotation.processing.Processor文件，<br>其内容是一系列的自定义注解处理器完整有效类名集合，以换行切割。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.MyProcessor</span><br>com<span class="hljs-selector-class">.foo</span><span class="hljs-selector-class">.OtherProcessor</span><br>net<span class="hljs-selector-class">.blabla</span>.SpecialProcessor<br></code></pre></td></tr></table></figure><ul><li>文件放在<code>/src/main/resources/META-INF/services/javax.annotation.processing.Processor</code></li><li>处理器类文件放在<code>/src/main/java/com/example/annotationcomplierlib/AnnotationComplier.java</code></li></ul></li><li><p>将自定义注解处理器和<br>META-INF/services/javax.annotation.processing.Processor打包成一个.jar文件。所以其目录结构大概如下所示：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css">MyProcessor<span class="hljs-selector-class">.jar</span><br>    - com<br>        - example<br>            - MyProcessor<span class="hljs-selector-class">.class</span><br><br>    - META-INF<br>        - services<br>            - javax<span class="hljs-selector-class">.annotation</span><span class="hljs-selector-class">.processing</span><span class="hljs-selector-class">.Processor</span><br></code></pre></td></tr></table></figure></li></ol></li></ul></li><li><p>3、通过Maven的编译插件的配置指定如下：</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">encoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">encoding</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">annotationProcessors</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">annotationProcessor</span>&gt;</span><br>                club.throwable.processor.AnnotationProcessor<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">annotationProcessor</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">annotationProcessors</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br></code></pre></td></tr></table></figure><p>值得注意的是，以上三点生效的前提是club.throwable.processor.AnnotationProcessor已经被编译过，否则编译的时候就会报错：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-attr">[ERROR]</span> Bad service configuration file, or exception thrown while<br>constructing Processor <span class="hljs-selector-tag">object</span>: javax<span class="hljs-selector-class">.annotation</span><span class="hljs-selector-class">.processing</span><span class="hljs-selector-class">.Processor</span>: <br>Provider club<span class="hljs-selector-class">.throwable</span><span class="hljs-selector-class">.processor</span><span class="hljs-selector-class">.AnnotationProcessor</span> not found<br></code></pre></td></tr></table></figure><p>解决方法有两种，第一种是提前使用命令或者IDEA右键club.throwable.processor.AnnotationProcessor对它进行编译；第二种是把club.throwable.processor.AnnotationProcessor放到一个独立的Jar包引入。我在这里使用第一种方式解决。</p><p>最后，使用Maven命令mvn compile进行编译。输出如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Log <span class="hljs-keyword">in</span> AnnotationProcessor.process<br>[<span class="hljs-attribute">errorRaised</span>=<span class="hljs-literal">false</span>, rootElements=[club.throwable.processor.Test,club.throwable.processor.Main, club.throwable.processor.AnnotationProcessor, <span class="hljs-attribute">processingOver</span>=<span class="hljs-literal">false</span>]<br>Log <span class="hljs-keyword">in</span> AnnotationProcessor.process<br>[<span class="hljs-attribute">errorRaised</span>=<span class="hljs-literal">false</span>, rootElements=[], <span class="hljs-attribute">processingOver</span>=<span class="hljs-literal">false</span>]<br>Log <span class="hljs-keyword">in</span> AnnotationProcessor.process<br>[<span class="hljs-attribute">errorRaised</span>=<span class="hljs-literal">false</span>, rootElements=[], <span class="hljs-attribute">processingOver</span>=<span class="hljs-literal">true</span>]<br></code></pre></td></tr></table></figure><p>可见编译期间AnnotationProcessor生效了。</p></li></ul><h2 id="备注："><a href="#备注：" class="headerlink" title="备注："></a>备注：</h2><ul><li>Gradle配置如下：</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs php"><br>dependencies &#123;<br>    implementation fileTree(<span class="hljs-keyword">include</span>: [<span class="hljs-string">&#x27;*.jar&#x27;</span>], dir: <span class="hljs-string">&#x27;libs&#x27;</span>)<br><br>    implementation project(<span class="hljs-string">&#x27;:annotation&#x27;</span>)<br>    <span class="hljs-comment">//用于自动为 JAVA Processor 生成 META-INF 信息。</span><br>    implementation <span class="hljs-string">&#x27;com.google.auto.service:auto-service:1.0-rc3&#x27;</span><br>    <span class="hljs-comment">//快速生成.java文件的库</span><br>    implementation <span class="hljs-string">&#x27;com.squareup:javapoet:1.8.0&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><code>Processor</code> 重写父类的几个方法：</p><ul><li><code>process()</code>方法，这里是处理注解内部逻辑的，也是本文的关键点之一；</li><li><code>getSupportedSourceVersion()</code>：设置支持的版本，一般用最新的就好；</li></ul><ul><li><p><code>getSupportedAnnotationTypes()</code>：添加支持的注解类型，可以是单个／多个，用Set存储；</p></li><li><p><code>init ()</code>：一些初始化操作，获取一些有用的系统工具类，比如生成文件、打印信息、处理元素等；</p></li></ul></li></ul><p>​            <code>getSupportedSourceVersion()</code>、<code>getSupportedAnnotationTypes()</code>这2个方法还有一种    简单的方式来实现，如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@AutoService</span>(Processor.class)<br>@SupportedAnnotationTypes(&#123;&quot;com<span class="hljs-selector-class">.zx</span><span class="hljs-selector-class">.annotation</span>&quot;&#125;)<br><span class="hljs-keyword">@SupportedSourceVersion</span>(SourceVersion.RELEASE_8)<br>public class ViewInjectProcessor extends AbstractProcessor &#123;&#125;<br></code></pre></td></tr></table></figure><p>是通过注解来实现的，看上去是比较简洁</p><ul><li><code>@SupportedAnnotationTypes()</code>可以申明一个注解数组，但是这种字符串拼接容易出错；</li><li><code>@SupportedSourceVersion</code>：设置支持的源码版本，可以是RELEASE_0～RELEASE_8，但是不能使用<code>latestSupported()</code>设置最新的版本；</li></ul><h1 id="方法讲解"><a href="#方法讲解" class="headerlink" title="方法讲解"></a>方法讲解</h1><p>我们今天只说Processor。先从接口的方法介绍起把。</p><table><thead><tr><th>变量和类型</th><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>Iterable&lt;? extends Completion&gt;</code></td><td>getCompletions(Element element, AnnotationMirror annotation, ExecutableElement member, String userText)</td><td>返回一个空的迭代完成。</td></tr><tr><td><code>Set&lt;String&gt;</code></td><td>getSupportedAnnotationTypes()</td><td>如果处理器类使用SupportedAnnotationTypes进行批注，则返回与注释具有相同字符串集的不可修改集。</td></tr><tr><td><code>Set&lt;String&gt;</code></td><td>getSupportedOptions()</td><td>如果处理器类使用SupportedOptions进行批注，则返回具有与批注相同的字符串集的不可修改集。</td></tr><tr><td><code>SourceVersion</code></td><td>getSupportedSourceVersion()</td><td>如果处理器类使用SupportedSourceVersion进行批注，请在批注中返回源版本。</td></tr><tr><td><code>void</code></td><td>init(ProcessingEnvironment processingEnv)</td><td>通过将 processingEnv字段设置为 processingEnv参数的值，使用处理环境初始化处理器。</td></tr><tr><td><code>boolean</code></td><td>process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</td><td>处理源自前一轮的类型元素的一组注释类型，并返回此处理器是否声明了这些注释类型。 如果返回true ，则声明注释类型，并且不会要求后续处理器处理它们; 如果返回false ，则注释类型无人认领，可能会要求后续处理器处理它们。 处理器可以总是返回相同的布尔值，或者可以根据其自己选择的标准改变结果。</td></tr></tbody></table><ul><li><p>init：<br>初始化工作，我们可以得到一些有用的工具，例如 Filer，我们需要它将生成的代码写入文件中</p><p>init(ProcessingEnvironment env):每个Annotation Processor必须***<br> 有一个空的构造函数 ***。编译期间，init()会自动被注解处理工具调用，并传入ProcessingEnviroment参数，通过该参数可以获取到很多有用的工具类:  <strong>Elements , Types , Filer</strong>  等等</p></li><li><p>process：<br>最重要的方法，所有的注解处理都是在此完成</p><p>process(Set&lt;? extends TypeElement&gt; annoations, RoundEnvironment roundEnv):Annotation Processor扫描出的结果会存储进roundEnv中，可以在这里获取到注解内容，编写你的操作逻辑。注意,process()函数中不能直接进行异常抛出,否则的话,运行Annotation Processor的进程会异常崩溃,然后弹出一大堆让人捉摸不清的堆栈调用日志显示.</p></li><li><p>getSupportedAnnotationTypes：<br>返回我们所要处理的注解的一个集合</p><p>getSupportedAnnotationTypes(): 该函数用于指定该自定义注解处理器(Annotation Processor)是注册给哪些注解的(Annotation),注解(Annotation)指定必须是完整的包名+类名(eg:com.example.MyAnnotation)</p></li><li><p>getSupportedSourceVersion：<br>要支持的java版本</p><p>getSupportedSourceVersion():用于指定你的java版本，一般返回：SourceVersion.latestSupported()。当然，你也可以指定具体java版本：<br> return SourceVersion.RELEASE_7;</p></li></ul><h2 id="ProcessingEnvironment"><a href="#ProcessingEnvironment" class="headerlink" title="ProcessingEnvironment"></a>ProcessingEnvironment</h2><p>这个类很重要，要考的。这个类会在函数init的时候被传入，主要的工具类方法都在这个类上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ProcessingEnvironment</span> </span>&#123;<br>    <span class="hljs-function">Map&lt;String, String&gt; <span class="hljs-title">getOptions</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">Messager <span class="hljs-title">getMessager</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">Filer <span class="hljs-title">getFiler</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">Elements <span class="hljs-title">getElementUtils</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">Types <span class="hljs-title">getTypeUtils</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">SourceVersion <span class="hljs-title">getSourceVersion</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">Locale <span class="hljs-title">getLocale</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Filer 就是文件流输出路径，当我们用AbstractProcess生成一个java类的时候，我们需要保存在Filer指定的目录下。</p><p>Messager 输出日志工具，需要输出一些日志相关的时候我们就要使用这个了。</p><p>Elements 获取元素信息的工具，比如说一些类信息继承关系等。</p><p>Types 类型相关的工具类，processor java代码不同的是，当process执行的时候，class的由于类并没有被传递出来，所以大部分都行都是用element来代替了，所以很多类型比较等等的就会转化成type相关的进行比较了。</p><p>类型相关的都被转化成了一个叫TypeMirror，其getKind方法返回类型信息，其中包含了基础类型以及引用类型。</p><p>举个简单的例子，当一个实现了注解的Element被传入的时候，我们要判断Element是不是实现了特定接口，那么应该如何做呢？</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">private</span> Elements elementUtils;<br><span class="hljs-keyword">private</span> Types types;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> synchronized <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">init</span>(<span class="hljs-params">ProcessingEnvironment processingEnv</span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>.init(processingEnv);<br>    types = processingEnv.getTypeUtils();<br>    elementUtils = processingEnv.getElementUtils();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-function"><span class="hljs-title">isSubType</span>(<span class="hljs-params">Element element, <span class="hljs-built_in">String</span> className</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> element != <span class="hljs-literal">null</span> &amp;&amp; isSubType(element.asType(), className);<br>&#125;<br><br><span class="hljs-keyword">public</span> TypeMirror <span class="hljs-function"><span class="hljs-title">typeMirror</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> className</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> typeElement(className).asType();<br>&#125;<br><br><span class="hljs-keyword">public</span> TypeElement <span class="hljs-function"><span class="hljs-title">typeElement</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> className</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> elementUtils.getTypeElement(className);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-function"><span class="hljs-title">isSubType</span>(<span class="hljs-params">TypeMirror <span class="hljs-keyword">type</span>, <span class="hljs-built_in">String</span> className</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">type</span> != <span class="hljs-literal">null</span> &amp;&amp; types.isSubtype(<span class="hljs-keyword">type</span>, typeMirror(className));<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>其中isSubType方法是判断传入的Element是不是一个接口的实现类。首先我们要将对象都转化成Element, 然后将两个element转化成TypeMirror，之后调用Types的isSubtype方法对两个TypeMirror进行比较，如果发现类型一样，则该输入的Element是特定接口的实现类。</strong></p><h2 id="process"><a href="#process" class="headerlink" title="process()"></a>process()</h2><p>扫描代码的时候会把当前获取到的，此processer能处理的annotations传入当前方法</p><h3 id="Processor的kapt优化"><a href="#Processor的kapt优化" class="headerlink" title="Processor的kapt优化"></a>Processor的kapt优化</h3><p>kotlin对apt做了很多优化，内部完成了增量编译。但是对于低版本的autoservice，其增量编译会被关闭。</p><p>这里简单给各位大佬做下这方面的升级就好了。</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs clean">apply plugin: <span class="hljs-string">&#x27;java-library&#x27;</span><br>apply plugin: <span class="hljs-string">&#x27;kotlin&#x27;</span><br>apply plugin: <span class="hljs-string">&#x27;kotlin-kapt&#x27;</span><br><br>dependencies &#123;<br>    <span class="hljs-keyword">implementation</span> <span class="hljs-string">&#x27;com.google.auto.service:auto-service:1.0-rc5&#x27;</span><br>    <span class="hljs-keyword">implementation</span> <span class="hljs-string">&#x27;com.squareup:javapoet:1.10.0&#x27;</span><br>    <span class="hljs-keyword">implementation</span> <span class="hljs-string">&#x27;com.github.leifzhang:RouterAnnotation:0.5.0&#x27;</span><br>    <span class="hljs-keyword">implementation</span> <span class="hljs-string">&quot;org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version&quot;</span><br>    kapt <span class="hljs-string">&quot;com.google.auto.service:auto-service:1.0-rc5&quot;</span><br>&#125;<br>sourceCompatibility = <span class="hljs-number">1.8</span><br>targetCompatibility = <span class="hljs-number">1.8</span><br><br></code></pre></td></tr></table></figure><p>简单的说就是把processor 升级到rc5，然后用kapt的方式去把它注册起来就行了。</p><h2 id="缺点和总结"><a href="#缺点和总结" class="headerlink" title="缺点和总结"></a>缺点和总结</h2><p>缺点：apt能做的事情还是比较有限的</p><ol><li>javapoet只能新增一个类，而不能对当前类进行更改。</li><li>proessor在javac执行之前，所以只能对当前moudule生效</li><li>当Module一多，可能会有类名冲突的问题</li></ol><p>但是apt还是能帮助我们解决很多问题的，我们可以把一些机械化的操作，通过anntation的方式去简化，比如butterknife，这样开发就可以有更多的精力去专注做写别的事情。一部分abtest赋值的操作其实也可以用同样的方式去调整。</p><hr><h2 id="一些疑问"><a href="#一些疑问" class="headerlink" title="一些疑问"></a>一些疑问</h2><ul><li>注解处理器processor为什么要在META-INF注册？</li><li>注解处理器processor是如何被系统调用的？</li><li>注解申明和注解处理器为什么要分Module处理？</li><li>apt项目不会增加apk体积？</li></ul><p>先来回顾一下之前项目的部分目录结构</p><p><img src="https://upload-images.jianshu.io/upload_images/4134622-6cfb718f3055b89b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image.png</p><p>先明确一些概念：<br> <code>AbstractProcessor</code>是抽象处理器，开发apt时都必须继承这个类来生成<code>.java</code>文件，实现的这个类后叫做注解处理器，也就是这里的<code>ButterKnifeProcessor</code>。</p><h4 id="Q1-注解处理器processor为什么要在META-INF注册？"><a href="#Q1-注解处理器processor为什么要在META-INF注册？" class="headerlink" title="Q1:注解处理器processor为什么要在META-INF注册？"></a>Q1:注解处理器processor为什么要在META-INF注册？</h4><hr><p><code>META-INF</code>的作用<br> META-INF, 相当于一个信息包，用于存放一些meta information相关的文件。用来配置应用程序、扩展程序、类加载器和服务<a href="https://links.jianshu.com/go?to=https://www.baidu.com/s?wd=manifest.mf&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">manifest.mf</a>文件，在用jar打包时自动生成。</p><p>在之前的文章中说过，通过<code>@AutoService(Processor.class)</code>注解把注解处理器<code>ButterKnifeProcessor</code>注册到META-INF/services中，这里的包名是<code>META-INF/services/javax.annotation.processing.Processor</code>,<br> 这个文件的内容是</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">com<span class="hljs-selector-class">.zx</span><span class="hljs-selector-class">.processor</span><span class="hljs-selector-class">.ButterKnifeProcessor</span><br></code></pre></td></tr></table></figure><p>这个包名其实就是<code>@AutoService(Processor.class)</code>里面的<code>Processor</code>类；而文件内容就是注解处理器。</p><p><strong>在编译时，java编译器（javac）会去META-INF中查找实现了的AbstractProcessor的子类，并且调用该类的process函数，最终生成<code>.java</code>文件。</strong>其实就像activity需要注册一样，就是要到META-INF注册 ，javac才知道要给你调用哪个类来处理注解。</p><h4 id="Q2：注解处理器processor是如何被系统调用的？"><a href="#Q2：注解处理器processor是如何被系统调用的？" class="headerlink" title="Q2：注解处理器processor是如何被系统调用的？"></a>Q2：注解处理器processor是如何被系统调用的？</h4><hr><p>一些细心的同学应该发现了这个问题，我们并没有手动调用<code>AbstractProcessor</code>这个注解处理器类，那系统是什么时间调用的？又是如何调用的？这其实就牵扯到apt工作机制。</p><p>在上一问中，我们已经了解到，在编译时javac会查找所有的 在META_INF 中注册的注解处理器来处理注解。</p><p>到这里，好像有点清楚了，大概知道javac会去找到Processor并调用。但是呢还是没找到直接源头，因为它不像我们面向对象编程中可以准确追踪到是哪个对象调用的。</p><p>别着急，先来看这么个东西.<br> 是我项目中使用到注解的<code>app.Gradle</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp">dependencies &#123;<br>    <span class="hljs-function">implementation <span class="hljs-title">project</span>(<span class="hljs-params"><span class="hljs-string">&#x27;:annotation&#x27;</span></span>)</span><br><span class="hljs-function">    implementation <span class="hljs-title">project</span>(<span class="hljs-params"><span class="hljs-string">&#x27;:inject_api&#x27;</span></span>)</span><br><span class="hljs-function">    <span class="hljs-comment">//gradle3.0以上apt的实现方式</span></span><br><span class="hljs-function">    annotationProcessor <span class="hljs-title">project</span>(<span class="hljs-params"><span class="hljs-string">&#x27;:processor&#x27;</span></span>)</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><p>这里的<code>annotationProcessor</code>有点特别，没错，它是<strong>APT</strong>实现方案的一种。这里简单介绍一下：</p><blockquote><p>APT实现方案<br> <code>android-apt</code>和<code>annotationProcessor</code>功能是一样的，都是apt的实现方案，前者是个人开发者提供，比较早（现在不再维护了），后者是google官方开发的内置在<code>gradle</code>里的apt。</p><p>annotationProcessor是APT工具中的一种，是google开发的内置框架，不需要引入，可以直接在<code>build.gradle</code>文件中使用。</p></blockquote><p>只有在你使用注解的地方引入了<code>annotationProcessor</code>，系统才会主动调用注解处理类<code>Processor</code>,才会最终生成如下的<code>.java</code>文件</p><p><img src="TyporaRaw/java%E6%B3%A8%E8%A7%A3.assets/4134622-86775724faaeaa3e.png" alt="img"></p><p>apt生成类.png</p><p>这里先简单总结一下：<br> 2.1、在完成注解处理类<code>Processor</code>之后，需要做2件事情：</p><ul><li>1、在META-INF目录下注册<code>Processor</code>；</li><li>2、在项目中使用注解的地方添加apt工具<code>annotationProcessor</code></li></ul><p>2.2、APT 4要素<br> 　<strong>注解处理器（AbstractProcess）+ 代码处理（javaPoet）+ 处理器注册（AutoService）+ apt（annotationProcessor）</strong></p><p><code>APT(Annotation Processing Tool)总结</code><br> 首先，APT是javac提供的一种工具，它在编译时扫描、解析、处理注解。它会对源代码文件进行检测，找出用户自定义的注解，根据注解、注解处理器和相应的apt工具自动生成代码。这段代码是根据用户编写的注解处理逻辑去生成的。<strong>最终将生成的新的源文件与原来的源文件共同编译（注意：APT并不能对源文件进行修改操作，只能生成新的文件，例如往原来的类中添加方法）</strong>。具体流程图如下图所示：</p><p><img src="TyporaRaw/java%E6%B3%A8%E8%A7%A3.assets/4134622-b1f7494d18e216d1.png" alt="img"></p><p>apt工作流程.png</p><p>APT技术的使用，需要我们遵守一定的规则。大家先看一下整个APT项目项目构建的一个规则图，具体如下所示：</p><p><img src="TyporaRaw/java%E6%B3%A8%E8%A7%A3.assets/4134622-55d88199566ac011.png" alt="img"></p><h4 id="Q3：注解申明和注解处理器为什么要分Module处理？"><a href="#Q3：注解申明和注解处理器为什么要分Module处理？" class="headerlink" title="Q3：注解申明和注解处理器为什么要分Module处理？"></a>Q3：注解申明和注解处理器为什么要分Module处理？</h4><hr><p>先来回顾一下之前的项目结构：</p><p><img src="TyporaRaw/java%E6%B3%A8%E8%A7%A3.assets/4134622-1a701ad9e6425883.png" alt="img"></p><ul><li><code>annotation</code>：申明注解 （java lib）</li><li><code>processor</code>：注解处理器（java lib）</li><li><code>inject_api</code>：调用处理器中生成的类 （android lib）</li><li><code>app</code>：项目使用 （android lib）</li></ul><p>我们都知道注解处理器都需要继承<code>AbstractProcessor</code>类，但是<code>AbstractProcessor</code>是JDK中的类，不在android sdk中，所以需要放在单独的java lib中；而<code>processor</code>中需要依赖自定义注解，把<code>annotation</code>抽成一个独立的lib，便于维护。</p><p><strong>那注解声明和注解处理为什么要分开呢？可不可以放在一起？</strong><br> 先说结论：可以放在一起，放在一起对功能上没有什么影响；但是一般不放在一起，原因如下：</p><blockquote><p>我们都知道<code>processor</code>的作用是：在编译器解析注解、生成新的<code>.java</code>文件。<strong>这个lib只在编译器用到，是不会被打包进apk的。</strong>对于调用者来说，你只是想使用这个注解，而不希望你已经编译好的项目中引进注解处理器相关的内容，所以为了不引入没必要的文件，我们一般选择将注解声明和注解处理分开处理。</p></blockquote><p>到这里apt相关知识就说完了，我们也可以理解为什么<code>ButterKnife</code>这种注解库不会增加项目体积了。</p><p>想了解更多apt知识，可以参考：<br> <a href="https://www.jianshu.com/p/b6b3283968e0">https://www.jianshu.com/p/b6b3283968e0</a></p><p>感谢<br> <a href="https://links.jianshu.com/go?to=https://blog.csdn.net/xx326664162/article/details/68490059">你必须知道的APT、annotationProcessor、android-apt、Provided、自定义注解</a></p><p>作者：唠嗑008<br>链接：<a href="https://www.jianshu.com/p/89ac9a2513c4">https://www.jianshu.com/p/89ac9a2513c4</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>注解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java注解-网络博客</title>
    <link href="/posts/fcdbf97b/"/>
    <url>/posts/fcdbf97b/</url>
    
    <content type="html"><![CDATA[<h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a><strong>一、<a href="https://www.baeldung.com/java-annotation-processing-builder">介绍</a></strong></h2><p>本文<strong>介绍了 Java 源代码级别的注释处理，</strong>并提供了使用此技术在编译期间生成其他源文件的示例。</p><h2 id="2-注解处理的应用"><a href="#2-注解处理的应用" class="headerlink" title="2.注解处理的应用"></a><strong>2.注解处理的应用</strong></h2><p>源代码级注释处理首先出现在 Java 5 中。它是一种在编译阶段生成额外源文件的便捷技术。</p><p>源文件不必是 Java 文件——您可以根据源代码中的注释生成任何类型的描述、元数据、文档、资源或任何其他类型的文件。</p><p>注释处理在许多无处不在的 Java 库中被积极使用，例如，在 QueryDSL 和 JPA 中生成元类，在 Lombok 库中使用样板代码扩充类。</p><p>需要注意的重要一点是<strong>注解处理 API 的局限性——它只能用于生成新文件，不能用于更改现有文件</strong>。</p><p>值得注意的例外是<a href="https://projectlombok.org/">Lombok</a>库，它使用注解处理作为引导机制将自身包含到编译过程中并通过一些内部编译器 API 修改 AST。这种 hacky 技术与注释处理的预期目的无关，因此不在本文中讨论。</p><h2 id="3-注解处理API"><a href="#3-注解处理API" class="headerlink" title="3.注解处理API"></a><strong>3.注解处理API</strong></h2><p>注释处理分多轮完成。每一轮都从编译器开始搜索源文件中的注释并选择适合这些注释的注释处理器。依次在相应的源上调用每个注释处理器。</p><p>如果在此过程中生成了任何文件，则以生成的文件作为其输入开始另一轮。这个过程一直持续到在处理阶段没有新文件产生。</p><p>依次在相应的源上调用每个注释处理器。如果在此过程中生成了任何文件，则以生成的文件作为其输入开始另一轮。这个过程一直持续到在处理阶段没有新文件产生。</p><p>注释处理 API 位于<em>javax.annotation.processing</em>包中。您必须实现的主要接口是<em>Processor</em>接口，它具有<em>AbstractProcessor</em>类形式的部分实现。这个类是我们将要扩展以创建我们自己的注释处理器的类。</p><h2 id="4-设置项目"><a href="#4-设置项目" class="headerlink" title="4. 设置项目"></a><strong>4. 设置项目</strong></h2><p>为了演示注释处理的可能性，我们将开发一个简单的处理器来为带注释的类生成流畅的对象构建器。</p><p>我们将把我们的项目分成两个 Maven 模块。其中一个，<em>注释处理器</em>模块，将包含处理器本身和注释，另一个，<em>注释用户</em>模块，将包含被注释的类。这是注释处理的典型用例。</p><p><em>annotation-processor</em>模块的设置如下。我们将使用 Google 的<a href="https://github.com/google/auto/tree/master/service">自动服务</a>库来生成稍后将讨论的处理器元数据文件，以及针对 Java 8 源代码调整的<em>maven-compiler-plugin</em>。这些依赖项的版本被提取到属性部分。</p><p>最新版本的[自动服务](<a href="https://search.maven.org/classic/#search|gav|1|g%3A&quot;com.google.auto.service&quot;">https://search.maven.org/classic/#search|gav|1|g%3A&quot;com.google.auto.service&quot;</a> AND a%3A”auto-service”)库和[maven-compiler-plugin](<a href="https://search.maven.org/classic/#search|gav|1|g%3A&quot;org.apache.maven.plugins&quot;">https://search.maven.org/classic/#search|gav|1|g%3A&quot;org.apache.maven.plugins&quot;</a> AND a%3A”maven-compiler-plugin”)可以在 Maven 中央存储库中找到：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">auto-service.version</span>&gt;</span>1.0-rc2<span class="hljs-tag">&lt;/<span class="hljs-name">auto-service.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">maven-compiler-plugin.version</span>&gt;</span><br>      3.5.1<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">maven-compiler-plugin.version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.auto.service<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>auto-service<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;auto-service.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;maven-compiler-plugin.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><p>带有注释源的<em>annotation-user</em> Maven 模块不需要任何特殊调整，除了在依赖项部分添加对 annotation-processor 模块的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baeldung<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>annotation-processing<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="5-定义注释"><a href="#5-定义注释" class="headerlink" title="5. 定义注释"></a><strong>5. 定义注释</strong></h2><p>假设我们的<em>annotation-user</em>模块中有一个简单的 POJO 类，其中包含几个字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-comment">// getters and setters …</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>我们想创建一个构建器助手类来更流畅地实例化<em>Person</em>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Person person = <span class="hljs-keyword">new</span> PersonBuilder()<br>  .setAge(<span class="hljs-number">25</span>)<br>  .setName(<span class="hljs-string">&quot;John&quot;</span>)<br>  .build();<br></code></pre></td></tr></table></figure><p>这个<em>PersonBuilder</em>类是一代的明显选择，因为它的结构完全由<em>Person</em> setter 方法定义。</p><p>让我们在<em>注释处理器</em>模块中为 setter 方法创建一个*@BuilderProperty<em>注释。它将允许我们为每个注释了 setter 方法的类生成</em>Builder*类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> BuilderProperty &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>带有<em>ElementType.METHOD</em>参数的*@Target*注解确保此注解只能放在一个方法上。</p><p>在<em>SOURCE</em>保留策略的手段，这个注释是唯一可用的源处理过程中，而不是在运行时可用。</p><p>带有*@BuilderProperty<em>注解的属性的</em>Person*类将如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-meta">@BuilderProperty</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-meta">@BuilderProperty</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-comment">// getters …</span><br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-实现-处理器"><a href="#6-实现-处理器" class="headerlink" title="6. 实现*处理器*"></a><strong>6. 实现*处理器*</strong></h2><h3 id="6-1-创建一个-AbstractProcessor-子类"><a href="#6-1-创建一个-AbstractProcessor-子类" class="headerlink" title="6.1. 创建一个*AbstractProcessor*子类"></a><strong>6.1. 创建一个*AbstractProcessor*子类</strong></h3><p>我们将从在<em>注释处理器</em>Maven 模块中扩展<em>AbstractProcessor</em>类开始。</p><p>首先，我们应该指定该处理器能够处理的注释，以及支持的源代码版本。这可以通过实施方法进行<em>getSupportedAnnotationTypes</em>和<em>getSupportedSourceVersion</em>的的<em>处理器</em>接口或通过注释你的类*@SupportedAnnotationTypes<em>和</em>@SupportedSourceVersion*注解。</p><p>所述*@AutoService<em>注释是的一部分</em>自动服务*库，并允许生成，这将在下面的章节进行说明处理器的元数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SupportedAnnotationTypes(</span><br><span class="hljs-meta">  &quot;com.baeldung.annotation.processor.BuilderProperty&quot;)</span><br><span class="hljs-meta">@SupportedSourceVersion(SourceVersion.RELEASE_8)</span><br><span class="hljs-meta">@AutoService(Processor.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BuilderProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractProcessor</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">process</span><span class="hljs-params">(Set&lt;? extends TypeElement&gt; annotations, </span></span><br><span class="hljs-params"><span class="hljs-function">      RoundEnvironment roundEnv)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>您不仅可以指定具体的注释类名称，还可以指定通配符，例如<em>“com.baeldung.annotation.*”</em>来处理<em>com.baeldung.annotation</em>包及其所有子包中的注释，甚至可以<em>“*”</em>来处理所有注释.</p><p>我们必须实现的单一方法是处理本身的<em>process</em>方法。编译器为每个包含匹配注释的源文件调用它。</p><p>注释作为第一个<em>Set&lt;? extends TypeElement&gt; annotations</em>参数，有关当前处理轮次的信息作为<em>RoundEnviroment roundEnv</em>参数传递。</p><p>如果您的注释处理器已经处理了所有传递的注释，并且您不希望它们被传递到列表中的其他注释处理器，则返回<em>布尔</em>值应该为<em>true</em>。</p><h3 id="6-2-收集数据"><a href="#6-2-收集数据" class="headerlink" title="6.2. 收集数据"></a><strong>6.2. 收集数据</strong></h3><p>我们的处理器还没有真正做任何有用的事情，所以让我们用代码填充它。</p><p>首先，我们需要遍历在类中找到的所有注释类型——在我们的例子中，<em>注释</em>集将有一个与*@BuilderProperty*注释相对应的元素，即使这个注释在源文件中多次出现。</p><p>尽管如此，为了完整起见，最好将<em>process</em>方法实现为迭代周期：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">process</span><span class="hljs-params">(Set&lt;? extends TypeElement&gt; annotations, </span></span><br><span class="hljs-params"><span class="hljs-function">  RoundEnvironment roundEnv)</span> </span>&#123;<br><br>    <span class="hljs-keyword">for</span> (TypeElement annotation : annotations) &#123;<br>        Set&lt;? extends Element&gt; annotatedElements <br>          = roundEnv.getElementsAnnotatedWith(annotation);<br>        <br>        <span class="hljs-comment">// …</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在此代码中，我们使用<em>RoundEnvironment</em>实例接收所有使用*@BuilderProperty<em>注释的元素。对于</em>Person<em>类，这些元素对应于</em>setName<em>和</em>setAge*方法。</p><p><em>@BuilderProperty</em>注释的用户可能会错误地注释实际上不是 setter 的方法。setter 方法名称应以<em>set</em>开头，并且该方法应接收单个参数。所以让我们把小麦和谷壳分开。</p><p>在以下代码中，我们使用*Collectors.partitioningBy()*收集器将带注释的方法拆分为两个集合：正确注释的 setter 和其他错误注释的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;Boolean, List&lt;Element&gt;&gt; annotatedMethods = annotatedElements.stream().collect(<br>  Collectors.partitioningBy(element -&gt;<br>    ((ExecutableType) element.asType()).getParameterTypes().size() == <span class="hljs-number">1</span><br>    &amp;&amp; element.getSimpleName().toString().startsWith(<span class="hljs-string">&quot;set&quot;</span>)));<br><br>List&lt;Element&gt; setters = annotatedMethods.get(<span class="hljs-keyword">true</span>);<br>List&lt;Element&gt; otherMethods = annotatedMethods.get(<span class="hljs-keyword">false</span>);<br></code></pre></td></tr></table></figure><p>在这里，我们使用<em>Element.asType()<em>方法来接收</em>TypeMirror</em>类的实例，即使我们仅处于源处理阶段，它也为我们提供了一些内省类型的能力。</p><p>我们应该警告用户有关错误注释的方法，因此让我们使用可从<em>AbstractProcessor.processingEnv</em>保护字段访问的<em>Messager</em>实例。以下几行将在源处理阶段为每个错误注释的元素输出错误：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">otherMethods.forEach(element -&gt;<br>  processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,<br>    <span class="hljs-string">&quot;@BuilderProperty must be applied to a setXxx method &quot;</span> <br>      + <span class="hljs-string">&quot;with a single argument&quot;</span>, element));<br></code></pre></td></tr></table></figure><p>当然，如果正确的 setters 集合为空，则继续当前类型元素集合迭代是没有意义的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (setters.isEmpty()) &#123;<br>    <span class="hljs-keyword">continue</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果 setter 集合至少有一个元素，我们将使用它从封闭元素中获取完全限定的类名，在 setter 方法的情况下，它似乎是源类本身：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">String className = ((TypeElement) setters.get(<span class="hljs-number">0</span>)<br>  .getEnclosingElement()).getQualifiedName().toString();<br></code></pre></td></tr></table></figure><p>生成构建器类所需的最后一点信息是 setter 名称与其参数类型名称之间的映射：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;String, String&gt; setterMap = setters.stream().collect(Collectors.toMap(<br>    setter -&gt; setter.getSimpleName().toString(),<br>    setter -&gt; ((ExecutableType) setter.asType())<br>      .getParameterTypes().get(<span class="hljs-number">0</span>).toString()<br>));<br></code></pre></td></tr></table></figure><h3 id="6-3-生成输出文件"><a href="#6-3-生成输出文件" class="headerlink" title="6.3. 生成输出文件"></a><strong>6.3. 生成输出文件</strong></h3><p>现在我们有了生成构建器类所需的所有信息：源类的名称、它的所有 setter 名称以及它们的参数类型。</p><p>为了生成输出文件，我们将使用<em>AbstractProcessor.processingEnv</em>受保护属性中的对象再次提供的<em>Filer</em>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">JavaFileObject builderFile = processingEnv.getFiler()<br>  .createSourceFile(builderClassName);<br><span class="hljs-keyword">try</span> (PrintWriter out = <span class="hljs-keyword">new</span> PrintWriter(builderFile.openWriter())) &#123;<br>    <span class="hljs-comment">// writing generated file to out …</span><br>&#125;<br></code></pre></td></tr></table></figure><p>下面提供了<em>writeBuilderFile</em>方法的完整代码。我们只需要计算源类和构建器类的包名、完全限定的构建器类名和简单类名。其余的代码非常简单。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeBuilderFile</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  String className, Map&lt;String, String&gt; setterMap)</span> </span><br><span class="hljs-function">  <span class="hljs-keyword">throws</span> IOException </span>&#123;<br><br>    String packageName = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">int</span> lastDot = className.lastIndexOf(<span class="hljs-string">&#x27;.&#x27;</span>);<br>    <span class="hljs-keyword">if</span> (lastDot &gt; <span class="hljs-number">0</span>) &#123;<br>        packageName = className.substring(<span class="hljs-number">0</span>, lastDot);<br>    &#125;<br><br>    String simpleClassName = className.substring(lastDot + <span class="hljs-number">1</span>);<br>    String builderClassName = className + <span class="hljs-string">&quot;Builder&quot;</span>;<br>    String builderSimpleClassName = builderClassName<br>      .substring(lastDot + <span class="hljs-number">1</span>);<br><br>    JavaFileObject builderFile = processingEnv.getFiler()<br>      .createSourceFile(builderClassName);<br>    <br>    <span class="hljs-keyword">try</span> (PrintWriter out = <span class="hljs-keyword">new</span> PrintWriter(builderFile.openWriter())) &#123;<br><br>        <span class="hljs-keyword">if</span> (packageName != <span class="hljs-keyword">null</span>) &#123;<br>            out.print(<span class="hljs-string">&quot;package &quot;</span>);<br>            out.print(packageName);<br>            out.println(<span class="hljs-string">&quot;;&quot;</span>);<br>            out.println();<br>        &#125;<br><br>        out.print(<span class="hljs-string">&quot;public class &quot;</span>);<br>        out.print(builderSimpleClassName);<br>        out.println(<span class="hljs-string">&quot; &#123;&quot;</span>);<br>        out.println();<br><br>        out.print(<span class="hljs-string">&quot;    private &quot;</span>);<br>        out.print(simpleClassName);<br>        out.print(<span class="hljs-string">&quot; object = new &quot;</span>);<br>        out.print(simpleClassName);<br>        out.println(<span class="hljs-string">&quot;();&quot;</span>);<br>        out.println();<br><br>        out.print(<span class="hljs-string">&quot;    public &quot;</span>);<br>        out.print(simpleClassName);<br>        out.println(<span class="hljs-string">&quot; build() &#123;&quot;</span>);<br>        out.println(<span class="hljs-string">&quot;        return object;&quot;</span>);<br>        out.println(<span class="hljs-string">&quot;    &#125;&quot;</span>);<br>        out.println();<br><br>        setterMap.entrySet().forEach(setter -&gt; &#123;<br>            String methodName = setter.getKey();<br>            String argumentType = setter.getValue();<br><br>            out.print(<span class="hljs-string">&quot;    public &quot;</span>);<br>            out.print(builderSimpleClassName);<br>            out.print(<span class="hljs-string">&quot; &quot;</span>);<br>            out.print(methodName);<br><br>            out.print(<span class="hljs-string">&quot;(&quot;</span>);<br><br>            out.print(argumentType);<br>            out.println(<span class="hljs-string">&quot; value) &#123;&quot;</span>);<br>            out.print(<span class="hljs-string">&quot;        object.&quot;</span>);<br>            out.print(methodName);<br>            out.println(<span class="hljs-string">&quot;(value);&quot;</span>);<br>            out.println(<span class="hljs-string">&quot;        return this;&quot;</span>);<br>            out.println(<span class="hljs-string">&quot;    &#125;&quot;</span>);<br>            out.println();<br>        &#125;);<br><br>        out.println(<span class="hljs-string">&quot;&#125;&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-运行示例"><a href="#7-运行示例" class="headerlink" title="7. 运行示例"></a><strong>7. 运行示例</strong></h2><p>要查看代码生成的运行情况，您应该从公共父根编译两个模块，或者首先编译<em>annotation-processor</em>模块，然后编译<em>annotation-user</em>模块。</p><p>生成的<em>PersonBuilder</em>类可以在<em>annotation-user/target/generated-sources/annotations/com/baeldung/annotation/PersonBuilder.java</em>文件中找到，应该如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.baeldung.annotation;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonBuilder</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Person object = <span class="hljs-keyword">new</span> Person();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Person <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> object;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PersonBuilder <span class="hljs-title">setName</span><span class="hljs-params">(java.lang.String value)</span> </span>&#123;<br>        object.setName(value);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PersonBuilder <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        object.setAge(value);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-注册处理器的其他方式"><a href="#8-注册处理器的其他方式" class="headerlink" title="8. 注册处理器的其他方式"></a><strong>8. 注册处理器的其他方式</strong></h2><p>要在编译阶段使用注释处理器，您还有其他几个选项，具体取决于您的用例和您使用的工具。</p><h3 id="8-1-使用注释处理器工具"><a href="#8-1-使用注释处理器工具" class="headerlink" title="8.1. 使用注释处理器工具"></a><strong>8.1. 使用注释处理器工具</strong></h3><p>该<em>贴切</em>工具是用于处理源文件一个特殊的命令行实用程序。它是 Java 5 的一部分，但从 Java 7 开始，它被弃用，取而代之的是其他选项，并在 Java 8 中完全删除。本文不会讨论它。</p><h3 id="8-2-使用编译器密钥"><a href="#8-2-使用编译器密钥" class="headerlink" title="8.2. 使用编译器密钥"></a><strong>8.2. 使用编译器密钥</strong></h3><p>该*-processor*编译器关键是一个标准的JDK设施，以增加编译器的源处理阶段，自己的注释处理器。</p><p>请注意，处理器本身和注释必须已经在单独的编译中编译为类并存在于类路径中，因此您应该做的第一件事是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">javac com/baeldung/annotation/processor/BuilderProcessor<br>javac com/baeldung/annotation/processor/BuilderProperty<br></code></pre></td></tr></table></figure><p>然后，您使用*-processor*键对您的源代码进行实际编译，指定您刚刚编译的注释处理器类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">javac -processor com.baeldung.annotation.processor.MyProcessor Person.java<br></code></pre></td></tr></table></figure><p>要一次性指定多个注释处理器，您可以用逗号分隔它们的类名，如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">javac -processor package1.Processor1,package2.Processor2 SourceFile.java<br></code></pre></td></tr></table></figure><h3 id="8-3-使用-Maven"><a href="#8-3-使用-Maven" class="headerlink" title="8.3. 使用 Maven"></a><strong>8.3. 使用 Maven</strong></h3><p>的<em>Maven的编译器插件</em>允许指定注释处理器作为其结构的一部分。</p><p>这是为编译器插件添加注释处理器的示例。您还可以使用<em>generateSourcesDirectory</em>配置参数指定将生成的源放入的目录。</p><p>请注意，<em>BuilderProcessor</em>类应该已经被编译，例如，从构建依赖项中的另一个 jar 导入：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">encoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">encoding</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">generatedSourcesDirectory</span>&gt;</span>$&#123;project.build.directory&#125;<br>                  /generated-sources/<span class="hljs-tag">&lt;/<span class="hljs-name">generatedSourcesDirectory</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">annotationProcessors</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">annotationProcessor</span>&gt;</span><br>                        com.baeldung.annotation.processor.BuilderProcessor<br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">annotationProcessor</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">annotationProcessors</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="8-4-将处理器-Jar-添加到类路径"><a href="#8-4-将处理器-Jar-添加到类路径" class="headerlink" title="8.4. 将处理器 Jar 添加到类路径"></a><strong>8.4. 将处理器 Jar 添加到类路径</strong></h3><p>您可以简单地将带有处理器类的特殊结构的 jar 添加到编译器的类路径中，而不是在编译器选项中指定注释处理器。</p><p>要自动选择它，编译器必须知道处理器类的名称。因此，您必须在<em>META-INF/services/javax.annotation.processing.Processor</em>文件中将其指定为处理器的完全限定类名：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">com.baeldung.annotation.processor.BuilderProcessor<br></code></pre></td></tr></table></figure><p>您还可以从这个 jar 中指定多个处理器，通过用新行分隔它们来自动拾取：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">package1.Processor1<br>package2.Processor2<br>package3.Processor3<br></code></pre></td></tr></table></figure><p>如果使用Maven构建这个jar，并尝试将这个文件直接放到<em>src/main/resources/META-INF/services</em>目录下，会遇到如下错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">[ERROR] Bad service configuration file, or exception thrown <span class="hljs-keyword">while</span> <br>constructing Processor object: javax.annotation.processing.Processor: <br>Provider com.baeldung.annotation.processor.BuilderProcessor not found<br></code></pre></td></tr></table></figure><p>这是因为当<em>BuilderProcessor</em>文件尚未编译时，编译器会在模块本身的<em>源代码处理</em>阶段尝试使用此文件。在 Maven 构建的资源复制阶段，该文件必须放在另一个资源目录中并复制到<em>META-INF/services</em>目录，或者（甚至更好）在构建期间生成。</p><p>下一节中讨论的 Google<em>自动服务</em>库允许使用简单的注释生成此文件。</p><h3 id="8-5-使用-Google“auto-service”库"><a href="#8-5-使用-Google“auto-service”库" class="headerlink" title="8.5. 使用 Google“auto service”库"></a><strong>8.5. 使用 Google“auto service”库</strong></h3><p>要自动生成注册文件，您可以使用Google 的<em>自动服务</em>库中的*@AutoService*注释，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AutoService(Processor.class)</span><br><span class="hljs-keyword">public</span> BuilderProcessor extends AbstractProcessor &#123;<br>    <span class="hljs-comment">// …</span><br>&#125;<br></code></pre></td></tr></table></figure><p>此注释本身由来自自动服务库的注释处理器处理。该处理器生成包含<em>BuilderProcessor</em>类名的<em>META-INF/services/javax.annotation.processing.Processor</em>文件。</p><h2 id="9-结论"><a href="#9-结论" class="headerlink" title="9. 结论"></a><strong>9. 结论</strong></h2><p>在本文中，我们使用为 POJO 生成 Builder 类的示例演示了源级注释处理。我们还提供了几种在您的项目中注册注释处理器的替代方法。</p><p>本文的源代码可<a href="https://github.com/eugenp/tutorials/tree/master/annotations">在 GitHub 上找到</a>。</p><h1 id="原文："><a href="#原文：" class="headerlink" title="原文："></a>原文：</h1><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a><strong>1. <a href="https://www.baeldung.com/java-annotation-processing-builder">Introduction</a></strong></h2><p>This article is <strong>an intro to Java source-level annotation processing</strong> and provides examples of using this technique for generating additional source files during compilation.</p><h2 id="2-Applications-of-Annotation-Processing"><a href="#2-Applications-of-Annotation-Processing" class="headerlink" title="2. Applications of Annotation Processing"></a><strong>2. Applications of Annotation Processing</strong></h2><p>The source-level annotation processing first appeared in Java 5. It is a handy technique for generating additional source files during the compilation stage.</p><p>The source files don’t have to be Java files — you can generate any kind of description, metadata, documentation, resources, or any other type of files, based on annotations in your source code.</p><p>Annotation processing is actively used in many ubiquitous Java libraries, for instance, to generate metaclasses in QueryDSL and JPA, to augment classes with boilerplate code in Lombok library.</p><p>An important thing to note is <strong>the limitation of the annotation processing API — it can only be used to generate new files, not to change existing ones</strong>.</p><p>The notable exception is the <a href="https://projectlombok.org/">Lombok</a> library which uses annotation processing as a bootstrapping mechanism to include itself into the compilation process and modify the AST via some internal compiler APIs. This hacky technique has nothing to do with the intended purpose of annotation processing and therefore is not discussed in this article.</p><h2 id="3-Annotation-Processing-API"><a href="#3-Annotation-Processing-API" class="headerlink" title="3. Annotation Processing API"></a><strong>3. Annotation Processing API</strong></h2><p>The annotation processing is done in multiple rounds. Each round starts with the compiler searching for the annotations in the source files and choosing the annotation processors suited for these annotations. Each annotation processor, in turn, is called on the corresponding sources.</p><p>If any files are generated during this process, another round is started with the generated files as its input. This process continues until no new files are generated during the processing stage.</p><p>Each annotation processor, in turn, is called on the corresponding sources. If any files are generated during this process, another round is started with the generated files as its input. This process continues until no new files are generated during the processing stage.</p><p>The annotation processing API is located in the <em>javax.annotation.processing</em> package. The main interface that you’ll have to implement is the <em>Processor</em> interface, which has a partial implementation in the form of <em>AbstractProcessor</em> class. This class is the one we’re going to extend to create our own annotation processor.</p><h2 id="4-Setting-Up-the-Project"><a href="#4-Setting-Up-the-Project" class="headerlink" title="4. Setting Up the Project"></a><strong>4. Setting Up the Project</strong></h2><p>To demonstrate the possibilities of annotation processing, we will develop a simple processor for generating fluent object builders for annotated classes.</p><p>We’re going to split our project into two Maven modules. One of them, <em>annotation-processor</em> module, will contain the processor itself together with the annotation, and another, the <em>annotation-user</em> module, will contain the annotated class. This is a typical use case of annotation processing.</p><p>The settings for the <em>annotation-processor</em> module are as follows. We’re going to use the Google’s <a href="https://github.com/google/auto/tree/master/service">auto-service</a> library to generate processor metadata file which will be discussed later, and the <em>maven-compiler-plugin</em> tuned for the Java 8 source code. The versions of these dependencies are extracted to the properties section.</p><p>Latest versions of the [auto-service](<a href="https://search.maven.org/classic/#search|gav|1|g%3A&quot;com.google.auto.service&quot;">https://search.maven.org/classic/#search|gav|1|g%3A&quot;com.google.auto.service&quot;</a> AND a%3A”auto-service”) library and [maven-compiler-plugin](<a href="https://search.maven.org/classic/#search|gav|1|g%3A&quot;org.apache.maven.plugins&quot;">https://search.maven.org/classic/#search|gav|1|g%3A&quot;org.apache.maven.plugins&quot;</a> AND a%3A”maven-compiler-plugin”) can be found in Maven Central repository:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">auto-service.version</span>&gt;</span>1.0-rc2<span class="hljs-tag">&lt;/<span class="hljs-name">auto-service.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">maven-compiler-plugin.version</span>&gt;</span><br>      3.5.1<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">maven-compiler-plugin.version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.auto.service<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>auto-service<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;auto-service.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;maven-compiler-plugin.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><p>The <em>annotation-user</em> Maven module with the annotated sources does not need any special tuning, except adding a dependency on the annotation-processor module in the dependencies section:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baeldung<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>annotation-processing<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="5-Defining-an-Annotation"><a href="#5-Defining-an-Annotation" class="headerlink" title="5. Defining an Annotation"></a><strong>5. Defining an Annotation</strong></h2><p>Suppose we have a simple POJO class in our <em>annotation-user</em> module with several fields:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-comment">// getters and setters …</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>We want to create a builder helper class to instantiate the <em>Person</em> class more fluently:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Person person = <span class="hljs-keyword">new</span> PersonBuilder()<br>  .setAge(<span class="hljs-number">25</span>)<br>  .setName(<span class="hljs-string">&quot;John&quot;</span>)<br>  .build();<br></code></pre></td></tr></table></figure><p>This <em>PersonBuilder</em> class is an obvious choice for a generation, as its structure is completely defined by the <em>Person</em> setter methods.</p><p>Let’s create a <em>@BuilderProperty</em> annotation in the <em>annotation-processor</em> module for the setter methods. It will allow us to generate the <em>Builder</em> class for each class that has its setter methods annotated:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> BuilderProperty &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>The <em>@Target</em> annotation with the <em>ElementType.METHOD</em> parameter ensures that this annotation can be only put on a method.</p><p>The <em>SOURCE</em> retention policy means that this annotation is only available during source processing and is not available at runtime.</p><p>The <em>Person</em> class with properties annotated with the <em>@BuilderProperty</em> annotation will look as follows:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-meta">@BuilderProperty</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-meta">@BuilderProperty</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-comment">// getters …</span><br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-Implementing-a-Processor"><a href="#6-Implementing-a-Processor" class="headerlink" title="6. Implementing a *Processor*"></a><strong>6. Implementing a *Processor*</strong></h2><h3 id="6-1-Creating-an-AbstractProcessor-Subclass"><a href="#6-1-Creating-an-AbstractProcessor-Subclass" class="headerlink" title="6.1. Creating an *AbstractProcessor* Subclass"></a><strong>6.1. Creating an *AbstractProcessor* Subclass</strong></h3><p>We’ll start with extending the <em>AbstractProcessor</em> class inside the <em>annotation-processor</em> Maven module.</p><p>First, we should specify annotations that this processor is capable of processing, and also the supported source code version. This can be done either by implementing the methods <em>getSupportedAnnotationTypes</em> and <em>getSupportedSourceVersion</em> of the <em>Processor</em> interface or by annotating your class with <em>@SupportedAnnotationTypes</em> and <em>@SupportedSourceVersion</em> annotations.</p><p>The <em>@AutoService</em> annotation is a part of the <em>auto-service</em> library and allows to generate the processor metadata which will be explained in the following sections.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SupportedAnnotationTypes(</span><br><span class="hljs-meta">  &quot;com.baeldung.annotation.processor.BuilderProperty&quot;)</span><br><span class="hljs-meta">@SupportedSourceVersion(SourceVersion.RELEASE_8)</span><br><span class="hljs-meta">@AutoService(Processor.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BuilderProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractProcessor</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">process</span><span class="hljs-params">(Set&lt;? extends TypeElement&gt; annotations, </span></span><br><span class="hljs-params"><span class="hljs-function">      RoundEnvironment roundEnv)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>You can specify not only the concrete annotation class names but also wildcards, like <em>“com.baeldung.annotation.*”</em> to process annotations inside the <em>com.baeldung.annotation</em> package and all its sub packages, or even <em>“*”</em> to process all annotations.</p><p>The single method that we’ll have to implement is the <em>process</em> method that does the processing itself. It is called by the compiler for every source file containing the matching annotations.</p><p>Annotations are passed as the first <em>Set&lt;? extends TypeElement&gt; annotations</em> argument, and the information about the current processing round is passed as the <em>RoundEnviroment roundEnv</em> argument.</p><p>The return <em>boolean</em> value should be <em>true</em> if your annotation processor has processed all the passed annotations, and you don’t want them to be passed to other annotation processors down the list.</p><h3 id="6-2-Gathering-Data"><a href="#6-2-Gathering-Data" class="headerlink" title="6.2. Gathering Data"></a><strong>6.2. Gathering Data</strong></h3><p>Our processor does not really do anything useful yet, so let’s fill it with code.</p><p>First, we’ll need to iterate through all annotation types that are found in the class — in our case, the <em>annotations</em> set will have a single element corresponding to the <em>@BuilderProperty</em> annotation, even if this annotation occurs multiple times in the source file.</p><p>Still, it’s better to implement the <em>process</em> method as an iteration cycle, for completeness sake:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">process</span><span class="hljs-params">(Set&lt;? extends TypeElement&gt; annotations, </span></span><br><span class="hljs-params"><span class="hljs-function">  RoundEnvironment roundEnv)</span> </span>&#123;<br><br>    <span class="hljs-keyword">for</span> (TypeElement annotation : annotations) &#123;<br>        Set&lt;? extends Element&gt; annotatedElements <br>          = roundEnv.getElementsAnnotatedWith(annotation);<br>        <br>        <span class="hljs-comment">// …</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>In this code, we use the <em>RoundEnvironment</em> instance to receive all elements annotated with the <em>@BuilderProperty</em> annotation. In the case of the <em>Person</em> class, these elements correspond to the <em>setName</em> and <em>setAge</em> methods.</p><p><em>@BuilderProperty</em> annotation’s user could erroneously annotate methods that are not actually setters. The setter method name should start with <em>set</em>, and the method should receive a single argument. So let’s separate the wheat from the chaff.</p><p>In the following code, we use the <em>Collectors.partitioningBy()</em> collector to split annotated methods into two collections: correctly annotated setters and other erroneously annotated methods:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;Boolean, List&lt;Element&gt;&gt; annotatedMethods = annotatedElements.stream().collect(<br>  Collectors.partitioningBy(element -&gt;<br>    ((ExecutableType) element.asType()).getParameterTypes().size() == <span class="hljs-number">1</span><br>    &amp;&amp; element.getSimpleName().toString().startsWith(<span class="hljs-string">&quot;set&quot;</span>)));<br><br>List&lt;Element&gt; setters = annotatedMethods.get(<span class="hljs-keyword">true</span>);<br>List&lt;Element&gt; otherMethods = annotatedMethods.get(<span class="hljs-keyword">false</span>);<br></code></pre></td></tr></table></figure><p>Here we use the <em>Element.asType()</em> method to receive an instance of the <em>TypeMirror</em> class which gives us some ability to introspect types even though we are only at the source processing stage.</p><p>We should warn the user about incorrectly annotated methods, so let’s use the <em>Messager</em> instance accessible from the <em>AbstractProcessor.processingEnv</em> protected field. The following lines will output an error for each erroneously annotated element during the source processing stage:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">otherMethods.forEach(element -&gt;<br>  processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,<br>    <span class="hljs-string">&quot;@BuilderProperty must be applied to a setXxx method &quot;</span> <br>      + <span class="hljs-string">&quot;with a single argument&quot;</span>, element));<br></code></pre></td></tr></table></figure><p>Of course, if the correct setters collection is empty, there is no point of continuing the current type element set iteration:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (setters.isEmpty()) &#123;<br>    <span class="hljs-keyword">continue</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>If the setters collection has at least one element, we’re going to use it to get the fully qualified class name from the enclosing element, which in case of the setter method appears to be the source class itself:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">String className = ((TypeElement) setters.get(<span class="hljs-number">0</span>)<br>  .getEnclosingElement()).getQualifiedName().toString();<br></code></pre></td></tr></table></figure><p>The last bit of information we need to generate a builder class is a map between the names of the setters and the names of their argument types:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;String, String&gt; setterMap = setters.stream().collect(Collectors.toMap(<br>    setter -&gt; setter.getSimpleName().toString(),<br>    setter -&gt; ((ExecutableType) setter.asType())<br>      .getParameterTypes().get(<span class="hljs-number">0</span>).toString()<br>));<br></code></pre></td></tr></table></figure><h3 id="6-3-Generating-the-Output-File"><a href="#6-3-Generating-the-Output-File" class="headerlink" title="6.3. Generating the Output File"></a><strong>6.3. Generating the Output File</strong></h3><p>Now we have all the information we need to generate a builder class: the name of the source class, all its setter names, and their argument types.</p><p>To generate the output file, we’ll use the <em>Filer</em> instance provided again by the object in the <em>AbstractProcessor.processingEnv</em> protected property:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">JavaFileObject builderFile = processingEnv.getFiler()<br>  .createSourceFile(builderClassName);<br><span class="hljs-keyword">try</span> (PrintWriter out = <span class="hljs-keyword">new</span> PrintWriter(builderFile.openWriter())) &#123;<br>    <span class="hljs-comment">// writing generated file to out …</span><br>&#125;<br></code></pre></td></tr></table></figure><p>The complete code of the <em>writeBuilderFile</em> method is provided below. We only need to calculate the package name, fully qualified builder class name, and simple class names for the source class and the builder class. The rest of the code is pretty straightforward.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeBuilderFile</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  String className, Map&lt;String, String&gt; setterMap)</span> </span><br><span class="hljs-function">  <span class="hljs-keyword">throws</span> IOException </span>&#123;<br><br>    String packageName = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">int</span> lastDot = className.lastIndexOf(<span class="hljs-string">&#x27;.&#x27;</span>);<br>    <span class="hljs-keyword">if</span> (lastDot &gt; <span class="hljs-number">0</span>) &#123;<br>        packageName = className.substring(<span class="hljs-number">0</span>, lastDot);<br>    &#125;<br><br>    String simpleClassName = className.substring(lastDot + <span class="hljs-number">1</span>);<br>    String builderClassName = className + <span class="hljs-string">&quot;Builder&quot;</span>;<br>    String builderSimpleClassName = builderClassName<br>      .substring(lastDot + <span class="hljs-number">1</span>);<br><br>    JavaFileObject builderFile = processingEnv.getFiler()<br>      .createSourceFile(builderClassName);<br>    <br>    <span class="hljs-keyword">try</span> (PrintWriter out = <span class="hljs-keyword">new</span> PrintWriter(builderFile.openWriter())) &#123;<br><br>        <span class="hljs-keyword">if</span> (packageName != <span class="hljs-keyword">null</span>) &#123;<br>            out.print(<span class="hljs-string">&quot;package &quot;</span>);<br>            out.print(packageName);<br>            out.println(<span class="hljs-string">&quot;;&quot;</span>);<br>            out.println();<br>        &#125;<br><br>        out.print(<span class="hljs-string">&quot;public class &quot;</span>);<br>        out.print(builderSimpleClassName);<br>        out.println(<span class="hljs-string">&quot; &#123;&quot;</span>);<br>        out.println();<br><br>        out.print(<span class="hljs-string">&quot;    private &quot;</span>);<br>        out.print(simpleClassName);<br>        out.print(<span class="hljs-string">&quot; object = new &quot;</span>);<br>        out.print(simpleClassName);<br>        out.println(<span class="hljs-string">&quot;();&quot;</span>);<br>        out.println();<br><br>        out.print(<span class="hljs-string">&quot;    public &quot;</span>);<br>        out.print(simpleClassName);<br>        out.println(<span class="hljs-string">&quot; build() &#123;&quot;</span>);<br>        out.println(<span class="hljs-string">&quot;        return object;&quot;</span>);<br>        out.println(<span class="hljs-string">&quot;    &#125;&quot;</span>);<br>        out.println();<br><br>        setterMap.entrySet().forEach(setter -&gt; &#123;<br>            String methodName = setter.getKey();<br>            String argumentType = setter.getValue();<br><br>            out.print(<span class="hljs-string">&quot;    public &quot;</span>);<br>            out.print(builderSimpleClassName);<br>            out.print(<span class="hljs-string">&quot; &quot;</span>);<br>            out.print(methodName);<br><br>            out.print(<span class="hljs-string">&quot;(&quot;</span>);<br><br>            out.print(argumentType);<br>            out.println(<span class="hljs-string">&quot; value) &#123;&quot;</span>);<br>            out.print(<span class="hljs-string">&quot;        object.&quot;</span>);<br>            out.print(methodName);<br>            out.println(<span class="hljs-string">&quot;(value);&quot;</span>);<br>            out.println(<span class="hljs-string">&quot;        return this;&quot;</span>);<br>            out.println(<span class="hljs-string">&quot;    &#125;&quot;</span>);<br>            out.println();<br>        &#125;);<br><br>        out.println(<span class="hljs-string">&quot;&#125;&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-Running-the-Example"><a href="#7-Running-the-Example" class="headerlink" title="7. Running the Example"></a><strong>7. Running the Example</strong></h2><p>To see the code generation in action, you should either compile both modules from the common parent root or first compile the <em>annotation-processor</em> module and then the <em>annotation-user</em> module.</p><p>The generated <em>PersonBuilder</em> class can be found inside the <em>annotation-user/target/generated-sources/annotations/com/baeldung/annotation/PersonBuilder.java</em> file and should look like this:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.baeldung.annotation;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonBuilder</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Person object = <span class="hljs-keyword">new</span> Person();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Person <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> object;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PersonBuilder <span class="hljs-title">setName</span><span class="hljs-params">(java.lang.String value)</span> </span>&#123;<br>        object.setName(value);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PersonBuilder <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        object.setAge(value);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-Alternative-Ways-of-Registering-a-Processor"><a href="#8-Alternative-Ways-of-Registering-a-Processor" class="headerlink" title="8. Alternative Ways of Registering a Processor"></a><strong>8. Alternative Ways of Registering a Processor</strong></h2><p>To use your annotation processor during the compilation stage, you have several other options, depending on your use case and the tools you use.</p><h3 id="8-1-Using-the-Annotation-Processor-Tool"><a href="#8-1-Using-the-Annotation-Processor-Tool" class="headerlink" title="8.1. Using the Annotation Processor Tool"></a><strong>8.1. Using the Annotation Processor Tool</strong></h3><p>The <em>apt</em> tool was a special command line utility for processing source files. It was a part of Java 5, but since Java 7 it was deprecated in favour of other options and removed completely in Java 8. It will not be discussed in this article.</p><h3 id="8-2-Using-the-Compiler-Key"><a href="#8-2-Using-the-Compiler-Key" class="headerlink" title="8.2. Using the Compiler Key"></a><strong>8.2. Using the Compiler Key</strong></h3><p>The <em>-processor</em> compiler key is a standard JDK facility to augment the source processing stage of the compiler with your own annotation processor.</p><p>Note that the processor itself and the annotation have to be already compiled as classes in a separate compilation and present on the classpath, so the first thing you should do is:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">javac com/baeldung/annotation/processor/BuilderProcessor<br>javac com/baeldung/annotation/processor/BuilderProperty<br></code></pre></td></tr></table></figure><p>Then you do the actual compilation of your sources with the <em>-processor</em> key specifying the annotation processor class you’ve just compiled:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">javac -processor com.baeldung.annotation.processor.MyProcessor Person.java<br></code></pre></td></tr></table></figure><p>To specify several annotation processors in one go, you can separate their class names with commas, like this:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">javac -processor package1.Processor1,package2.Processor2 SourceFile.java<br></code></pre></td></tr></table></figure><h3 id="8-3-Using-Maven"><a href="#8-3-Using-Maven" class="headerlink" title="8.3. Using Maven"></a><strong>8.3. Using Maven</strong></h3><p>The <em>maven-compiler-plugin</em> allows specifying annotation processors as part of its configuration.</p><p>Here’s an example of adding annotation processor for the compiler plugin. You could also specify the directory to put generated sources into, using the <em>generatedSourcesDirectory</em> configuration parameter.</p><p>Note that the <em>BuilderProcessor</em> class should already be compiled, for instance, imported from another jar in the build dependencies:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">encoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">encoding</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">generatedSourcesDirectory</span>&gt;</span>$&#123;project.build.directory&#125;<br>                  /generated-sources/<span class="hljs-tag">&lt;/<span class="hljs-name">generatedSourcesDirectory</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">annotationProcessors</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">annotationProcessor</span>&gt;</span><br>                        com.baeldung.annotation.processor.BuilderProcessor<br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">annotationProcessor</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">annotationProcessors</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="8-4-Adding-a-Processor-Jar-to-the-Classpath"><a href="#8-4-Adding-a-Processor-Jar-to-the-Classpath" class="headerlink" title="8.4. Adding a Processor Jar to the Classpath"></a><strong>8.4. Adding a Processor Jar to the Classpath</strong></h3><p>Instead of specifying the annotation processor in the compiler options, you may simply add a specially structured jar with the processor class to the classpath of the compiler.</p><p>To pick it up automatically, the compiler has to know the name of the processor class. So you have to specify it in the <em>META-INF/services/javax.annotation.processing.Processor</em> file as a fully qualified class name of the processor:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">com.baeldung.annotation.processor.BuilderProcessor<br></code></pre></td></tr></table></figure><p>You can also specify several processors from this jar to pick up automatically by separating them with a new line:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">package1.Processor1<br>package2.Processor2<br>package3.Processor3<br></code></pre></td></tr></table></figure><p>If you use Maven to build this jar and try to put this file directly into the <em>src/main/resources/META-INF/services</em> directory, you’ll encounter the following error:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">[ERROR] Bad service configuration file, or exception thrown <span class="hljs-keyword">while</span> <br>constructing Processor object: javax.annotation.processing.Processor: <br>Provider com.baeldung.annotation.processor.BuilderProcessor not found<br></code></pre></td></tr></table></figure><p>This is because the compiler tries to use this file during the <em>source-processing</em> stage of the module itself when the <em>BuilderProcessor</em> file is not yet compiled. The file has to be either put inside another resource directory and copied to the <em>META-INF/services</em> directory during the resource copying stage of the Maven build, or (even better) generated during the build.</p><p>The Google <em>auto-service</em> library, discussed in the following section, allows generating this file using a simple annotation.</p><h3 id="8-5-Using-the-Google-auto-service-Library"><a href="#8-5-Using-the-Google-auto-service-Library" class="headerlink" title="8.5. Using the Google *auto-service* Library"></a><strong>8.5. Using the Google *auto-service* Library</strong></h3><p>To generate the registration file automatically, you can use the <em>@AutoService</em> annotation from the Google’s <em>auto-service</em> library, like this:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AutoService(Processor.class)</span><br><span class="hljs-keyword">public</span> BuilderProcessor extends AbstractProcessor &#123;<br>    <span class="hljs-comment">// …</span><br>&#125;<br></code></pre></td></tr></table></figure><p>This annotation is itself processed by the annotation processor from the auto-service library. This processor generates the <em>META-INF/services/javax.annotation.processing.Processor</em> file containing the <em>BuilderProcessor</em> class name.</p><h2 id="9-Conclusion"><a href="#9-Conclusion" class="headerlink" title="9. Conclusion"></a><strong>9. Conclusion</strong></h2><p>In this article, we’ve demonstrated source-level annotation processing using an example of generating a Builder class for a POJO. We have also provided several alternative ways of registering annotation processors in your project.</p><p>The source code for the article is available <a href="https://github.com/eugenp/tutorials/tree/master/annotations">on GitHub</a>.</p><hr><h1 id="官方qpi文档"><a href="#官方qpi文档" class="headerlink" title="官方qpi文档"></a>官方qpi文档</h1><p>可以看到,AbstractProcessor实现了接口Processor,那么,我们在来看下Processor的api文档:</p><blockquote><p>javax.annotation.processing<br> Interface Processor</p><p>All Known Implementing Classes:<br> <a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/AbstractProcessor.html">AbstractProcessor</a></p><hr><p>public interface Processor</p></blockquote><blockquote><p>The interface for an annotation processor.</p></blockquote><blockquote><p>Annotation processing happens in a sequence of <a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/RoundEnvironment.html">rounds</a>. On each round, a processor may be asked to [process](<a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/Processor.html#process">https://link.jianshu.com?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/Processor.html#process</a>(java.util.Set, javax.annotation.processing.RoundEnvironment)) a subset of the annotations found on the source and class files produced by a prior round. The inputs to the first round of processing are the initial inputs to a run of the tool; these initial inputs can be regarded as the output of a virtual zeroth round of processing. If a processor was asked to process on a given round, it will be asked to process on subsequent rounds, including the last round, even if there are no annotations for it to process. The tool infrastructure may also ask a processor to process files generated implicitly by the tool’s operation.<br> Each implementation of a Processor  must provide a public no-argument constructor to be used by tools to instantiate the processor. The tool infrastructure will interact with classes implementing this interface as follows:</p><ol><li>If an existing Processor object is not being used, to create an instance of a processor the tool calls the no-arg constructor of the processor class.</li><li>Next, the tool calls the <a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/Processor.html#init(javax.annotation.processing.ProcessingEnvironment)">init </a> method with an appropriate ProcessingEnvironment .</li><li>Afterwards, the tool calls <a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/Processor.html#getSupportedAnnotationTypes()">getSupportedAnnotationTypes </a>, <a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/Processor.html#getSupportedOptions()">getSupportedOptions </a>, and <a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/Processor.html#getSupportedSourceVersion()">getSupportedSourceVersion </a>. These methods are only called once per run, not on each round.</li><li>As appropriate, the tool calls the [process<br> ](<a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/Processor.html#process">https://link.jianshu.com?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/Processor.html#process</a>(java.util.Set, javax.annotation.processing.RoundEnvironment)) method on the Processor object; a new Processor object is <em>not</em> created for each round.</li></ol><p>If a processor object is created and used without the above protocol being followed, then the processor’s behavior is not defined by this interface specification.The tool uses a <em>discovery process</em> to find annotation processors and decide whether or not they should be run. By configuring the tool, the set of potential processors can be controlled. For example, for a <a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/tools/JavaCompiler.html">JavaCompiler </a> the list of candidate processors to run can be <a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/tools/JavaCompiler.CompilationTask.html#setProcessors(java.lang.Iterable)">set directly</a> or controlled by a <a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/tools/StandardLocation.html#ANNOTATION_PROCESSOR_PATH">search path</a> used for a <a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/java/util/ServiceLoader.html">service-style</a> lookup. Other tool implementations may have different configuration mechanisms, such as command line options; for details, refer to the particular tool’s documentation. Which processors the tool asks to [run](<a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/Processor.html#process">https://link.jianshu.com?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/Processor.html#process</a>(java.util.Set, javax.annotation.processing.RoundEnvironment)) is a function of what annotations are present on the <a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/RoundEnvironment.html#getRootElements()">root elements</a>, what <a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/Processor.html#getSupportedAnnotationTypes()">annotation types a processor processes</a>, and whether or not a processor [claims the annotations it processes](<a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/Processor.html#process">https://link.jianshu.com?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/Processor.html#process</a>(java.util.Set, javax.annotation.processing.RoundEnvironment)). A processor will be asked to process a subset of the annotation types it supports, possibly an empty set. For a given round, the tool computes the set of annotation types on the root elements. If there is at least one annotation type present, as processors claim annotation types, they are removed from the set of unmatched annotations. When the set is empty or no more processors are available, the round has run to completion. If there are no annotation types present, annotation processing still occurs but only <em>universal processors</em> which support processing “<em>“<br> can claim the (empty) set of annotation types.<br> Note that if a processor supports “</em>“<br> and returns true<br> , all annotations are claimed. Therefore, a universal processor being used to, for example, implement additional validity checks should return false<br> so as to not prevent other such checkers from being able to run.<br> If a processor throws an uncaught exception, the tool may cease other active annotation processors. If a processor raises an error, the current round will run to completion and the subsequent round will indicate an <a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/RoundEnvironment.html#errorRaised()">error was raised</a>. Since annotation processors are run in a cooperative environment, a processor should throw an uncaught exception only in situations where no error recovery or reporting is feasible.<br> The tool environment is not required to support annotation processors that access environmental resources, either <a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/RoundEnvironment.html">per round</a> or <a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/ProcessingEnvironment.html">cross-round</a>, in a multi-threaded fashion.<br> If the methods that return configuration information about the annotation processor return null<br> , return other invalid input, or throw an exception, the tool infrastructure must treat this as an error condition.<br> To be robust when running in different tool implementations, an annotation processor should have the following properties:</p><ol><li>The result of processing a given input is not a function of the presence or absence of other inputs (orthogonality).</li><li>Processing the same input produces the same output (consistency).</li><li>Processing input <em>A</em> followed by processing input <em>B</em> is equivalent to processing <em>B</em> then <em>A</em>(commutativity)</li><li>Processing an input does not rely on the presence of the output of other annotation processors (independence)</li></ol><p>The <a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/Filer.html">Filer </a> interface discusses restrictions on how processors can operate on files.<br> Note that implementors of this interface may find it convenient to extend <a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/AbstractProcessor.html">AbstractProcessor </a> rather than implementing this interface directly.</p><p>Since:<br> 1.6</p></blockquote><p>注解处理发生在一系列回合中.每个回合中,注解处理器都有可能被叫去处理由上一次注解产生的源码和类文件中的找到的注解子集.第一次注解处理回合的输入就是工具第一次运行的输入;这些初始输入可以认为是一个虚拟的第零次注解处理回合的输出.如果注解处理器被叫去处理一个特定的回合,那么接下来的回合它都会继续处理,即使后续回合没有它需要处理的注解.注解处理器有可能会被叫去处理由(编译)工具隐式生成的文件.每个注解处理器的实现都必须提供一个公有的无参构造函数,由工具进行实例化.工具会与实现该接口(Processor)的类进行如下交互:</p><ol><li>如果一个已存在的Processor实例未被使用,(编译)工具会调用注解处理器的无参构造函数实例化出一个Processor对象.</li><li>接下来,(编译)工具会调用init函数,并传入一个合适的ProcessingEnvironment.</li><li>之后,(编译)工具会调用getSupportedAnnotationTypes,getSupportedOptions和getSupportedSourceVersion.这些方法只会在每一次运行时被调用一次,而不会在每个注解回合都被调用.</li><li>正常情况下,(编译)工具会调用注解处理器实例的process函数;每个注解回合并不会产生新的注解实例.</li></ol><p>如果一个注解处理器实例被创建,但是使用却没有遵循上述协议,那么这个注解处理器的行为并未被该接口规范定义.(编译)工具使用搜索程序去找到注解处理器并决定它们是否得以运行.通过配置(编译)工具,潜在的注解处理器可以被控制.比如,对于javaCompiler,候选处理器可以直接被指定或者通过使用service-style查找指定搜索路径进行控制.其他(编译)工具可以具有不同的配置机制,比如控制行选项;具体点讲,参考特定工具文档.(编译)工具会调用运行的注解处理器是由root elements指示的注解,是注解处理器处理的注解类型和注解处理器声明它要处理的注解的方法.注解处理器会被叫去处理它支持的注解类型子集,有可能是一个空的集合.在给定回合,(编译)工具会计算root elements的注解类型集合.如果有最少一个注解类型存在,就是注解处理器声明的注解类型之一,它们就会被从未匹配的注解类型集合中移除.当(未匹配)注解集合为空或者没有其它的注解处理器,那么该注解处理回合就结束了.如果没有声明注解类型,只有通用处理器(支持处理”<em>“声明(空)所有注解类型集合)仍然会进行注解处理.注意如果一个注解处理器支持”</em>“并且返回true,则所有的注解类型都被声明.因此,一个通用注解处理器如果被用于实现附加有效检验,那么应该返回false,为了不防止这类检验器得以运行.如果一个注解处理器抛出了一个未捕获异常,(编译)工具可能会停止其他活动的注解处理器.如果一个注解处理器引起了一个错误,当前注解回合会结束,并且后续回合会指明一个错误产生了.因为注解处理器都是运行在共同协作的环境中,只有当错误恢复或报告提交是无法执行的情况下,注解处理器才允许抛出一个未捕获异常.<br> (编译)工具环境不要求要支持注解处理器能以多线程方式在每一回合或交叉回合能访问环境资源.<br> 如果返回注解处理器的配置信息的方法返回null,返回其他无效输入,或者抛出一个异常,(编译)工具必须将这些当做是一个错误条件.<br> 为了在不同的工具实现能够健壮运行,注解处理器必须有以下性能:</p><ol><li>对于一个给定的输入的处理结果,不影响其他输入的存在或缺失(正交性)</li><li>处于相同的输入会产生相同的输出(一致性)</li><li>先处理输入A,然后处于输入B等同于先处理B在处理A(可交换性)</li><li>处理输入会依赖于其他注解处理器的输出(独立性)</li></ol><p>Filer接口讨论了注解处理器操作文件的限定.<br> 请知悉Processor的实现通过继承AbstractProcessor会比直接实现该接口更加方便.</p><p>简单总结如下:</p><ul><li>Annotation Processor可能会被多次调用.</li><li>Annotation Processor被调用一次后,后续若还有注解处理,该Annotation Processor仍然会继续被调用.</li><li>自定义Annotation Processor必须带有一个无参构造函数,让javac进行实例化.</li><li>如果Annotation Processor抛出一个未捕获异常,javac可能会停止其他的Annotation Processor.只有在无法抛出错误或报告的情况下,才允许抛出异常.</li><li>Annotation Processor运行在一个独立的jvm中,所以可以将它看成是一个java应用程序.</li></ul><p>作者：Whyn<br>链接：<a href="https://www.jianshu.com/p/b6b3283968e0">https://www.jianshu.com/p/b6b3283968e0</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><hr><h1 id="插件化注解处理API-Pluggable-Annotation-Processing-API"><a href="#插件化注解处理API-Pluggable-Annotation-Processing-API" class="headerlink" title="插件化注解处理API(Pluggable Annotation Processing API)"></a><a href="https://www.cnblogs.com/throwable/p/9139908.html">插件化注解处理API(Pluggable Annotation Processing API)</a></h1><h1 id="Java奇技淫巧-插件化注解处理API-Pluggable-Annotation-Processing-API"><a href="#Java奇技淫巧-插件化注解处理API-Pluggable-Annotation-Processing-API" class="headerlink" title="Java奇技淫巧-插件化注解处理API(Pluggable Annotation Processing API)"></a>Java奇技淫巧-插件化注解处理API(Pluggable Annotation Processing API)</h1><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://blog.csdn.net/Chinajash/article/details/1471081">JDK6的新特性之六:插入式注解处理API(Pluggable Annotation Processing API)</a></li><li><a href="http://www.baeldung.com/java-annotation-processing-builder">Java Annotation Processing and Creating a Builder</a></li></ul><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>插件化注解处理(Pluggable Annotation Processing)API<a href="http://jcp.org/en/jsr/detail?id=269">JSR 269</a>提供一套标准API来处理Annotations<a href="http://jcp.org/en/jsr/detail?id=175">JSR 175</a>,实际上JSR 269不仅仅用来处理Annotation，我觉得更强大的功能是它建立了Java 语言本身的一个模型,它把method、package、constructor、type、variable、enum、annotation等Java语言元素映射为Types和Elements，从而将Java语言的语义映射成为对象，我们可以在javax.lang.model包下面可以看到这些类。所以我们可以利用JSR 269提供的API来构建一个功能丰富的元编程(metaprogramming)环境。JSR 269用Annotation Processor在编译期间而不是运行期间处理Annotation, Annotation Processor相当于编译器的一个插件,所以称为插入式注解处理.如果Annotation Processor处理Annotation时(执行process方法)产生了新的Java代码，编译器会再调用一次Annotation Processor，如果第二次处理还有新代码产生，就会接着调用Annotation Processor，直到没有新代码产生为止。每执行一次process()方法被称为一个”round”，这样整个Annotation processing过程可以看作是一个round的序列。JSR 269主要被设计成为针对Tools或者容器的API。这个特性虽然在JavaSE 6已经存在，但是很少人知道它的存在。下一篇介绍的<strong>Java奇技淫巧-lombok</strong>就是使用这个特性实现编译期的代码插入的。另外，如果没有猜错，像IDEA在编写代码时候的标记语法错误的红色下划线也是通过这个特性实现的。KAPT(Annotation Processing for Kotlin)，也就是Kotlin的编译也是通过此特性的。</p><p>Pluggable Annotation Processing API的核心是Annotation Processor即注解处理器，一般需要继承抽象类<code>javax.annotation.processing.AbstractProcessor</code>。注意，与运行时注解<code>RetentionPolicy.RUNTIME</code>不同，注解处理器只会处理编译期注解，也就是<code>RetentionPolicy.SOURCE</code>的注解类型，处理的阶段位于Java代码编译期间。</p><h1 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h1><p>插件化注解处理API的使用步骤大概如下：</p><ul><li>1、自定义一个Annotation Processor，需要继承<code>javax.annotation.processing.AbstractProcessor</code>，并覆写process方法。</li><li>2、自定义一个注解，注解的元注解需要指定<code>@Retention(RetentionPolicy.SOURCE)</code>。</li><li>3、需要在声明的自定义Annotation Processor中使用<code>javax.annotation.processing.SupportedAnnotationTypes</code>指定在第2步创建的注解类型的名称(注意需要全类名，”包名.注解类型名称”，否则会不生效)。</li><li>4、需要在声明的自定义Annotation Processor中使用<code>javax.annotation.processing.SupportedSourceVersion</code>指定编译版本。</li><li>5、可选操作，可以通在声明的自定义Annotation Processor中使用<code>javax.annotation.processing.SupportedOptions</code>指定编译参数。</li></ul><h1 id="实战例子"><a href="#实战例子" class="headerlink" title="实战例子"></a>实战例子</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础#"></a>基础<a href="https://www.cnblogs.com/throwable/p/9139908.html#%E5%9F%BA%E7%A1%80">#</a></h2><p>下面我们模仿一下测试框架Junit里面的@Test注解，在运行时通过Annotation Processor获取到使用了自定义的@Test注解对应的方法的信息。因为如果想要动态修改一个类或者方法的代码内容，需要使用到字节码修改工具例如ASM等，这些操作过于深入，日后再谈。先定义一个注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> club.throwable.processor;<br><br><span class="hljs-keyword">import</span> java.lang.annotation.ElementType;<br><span class="hljs-keyword">import</span> java.lang.annotation.Retention;<br><span class="hljs-keyword">import</span> java.lang.annotation.RetentionPolicy;<br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> throwable</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> v1.0</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 2018/5/27 11:18</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Target(&#123;ElementType.METHOD&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Test &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>定义一个注解处理器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SupportedAnnotationTypes(value = &#123;&quot;club.throwable.processor.Test&quot;&#125;)</span><br><span class="hljs-meta">@SupportedSourceVersion(value = SourceVersion.RELEASE_8)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnnotationProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractProcessor</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">process</span><span class="hljs-params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Log in AnnotationProcessor.process&quot;</span>);<br>        <span class="hljs-keyword">for</span> (TypeElement typeElement : annotations) &#123;<br>            System.out.println(typeElement);<br>        &#125;<br>        System.out.println(roundEnv);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编写一个主类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;success&quot;</span>);<br>        test();<br>    &#125;<br><br>    <span class="hljs-meta">@Test(value = &quot;method is test&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span><span class="hljs-keyword">throws</span> Exception</span>&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着需要指定Processor，如果使用IDEA的话，Compiler-&gt;Annotation Processors中的Enable annotation processing必须勾选。然后可以通过下面几种方式指定指定Processor。</p><ul><li>1、直接使用编译参数指定，例如：javac -processor club.throwable.processor.AnnotationProcessor Main.java。</li><li>2、通过服务注册指定，就是META-INF/services/javax.annotation.processing.Processor文件中添加club.throwable.processor.AnnotationProcessor。</li><li>3、通过Maven的编译插件的配置指定如下：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">encoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">encoding</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">annotationProcessors</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">annotationProcessor</span>&gt;</span><br>                club.throwable.processor.AnnotationProcessor<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">annotationProcessor</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">annotationProcessors</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br></code></pre></td></tr></table></figure><p>值得注意的是，以上三点生效的前提是club.throwable.processor.AnnotationProcessor已经被编译过，否则编译的时候就会报错：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-attr">[ERROR]</span> Bad service configuration file, or exception thrown while<br>constructing Processor <span class="hljs-selector-tag">object</span>: javax<span class="hljs-selector-class">.annotation</span><span class="hljs-selector-class">.processing</span><span class="hljs-selector-class">.Processor</span>: <br>Provider club<span class="hljs-selector-class">.throwable</span><span class="hljs-selector-class">.processor</span><span class="hljs-selector-class">.AnnotationProcessor</span> not found<br></code></pre></td></tr></table></figure><p>解决方法有两种，第一种是提前使用命令或者IDEA右键club.throwable.processor.AnnotationProcessor对它进行编译；第二种是把club.throwable.processor.AnnotationProcessor放到一个独立的Jar包引入。我在这里使用第一种方式解决。</p><p>最后，使用Maven命令mvn compile进行编译。输出如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Log <span class="hljs-keyword">in</span> AnnotationProcessor.process<br>[<span class="hljs-attribute">errorRaised</span>=<span class="hljs-literal">false</span>, rootElements=[club.throwable.processor.Test,club.throwable.processor.Main, club.throwable.processor.AnnotationProcessor, <span class="hljs-attribute">processingOver</span>=<span class="hljs-literal">false</span>]<br>Log <span class="hljs-keyword">in</span> AnnotationProcessor.process<br>[<span class="hljs-attribute">errorRaised</span>=<span class="hljs-literal">false</span>, rootElements=[], <span class="hljs-attribute">processingOver</span>=<span class="hljs-literal">false</span>]<br>Log <span class="hljs-keyword">in</span> AnnotationProcessor.process<br>[<span class="hljs-attribute">errorRaised</span>=<span class="hljs-literal">false</span>, rootElements=[], <span class="hljs-attribute">processingOver</span>=<span class="hljs-literal">true</span>]<br></code></pre></td></tr></table></figure><p>可见编译期间AnnotationProcessor生效了。</p><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶#"></a>进阶<a href="https://www.cnblogs.com/throwable/p/9139908.html#%E8%BF%9B%E9%98%B6">#</a></h2><p>下面是一个例子直接修改类的代码，为实体类的Setter方法对应的属性生成一个Builder类，也就是原来的类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-meta">@Builder</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(Integer age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-meta">@Builder</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>生成的Builder类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonBuilder</span> </span>&#123;<br> <br>    <span class="hljs-keyword">private</span> Person object = <span class="hljs-keyword">new</span> Person();<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Person <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> object;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PersonBuilder <span class="hljs-title">setName</span><span class="hljs-params">(java.lang.String value)</span> </span>&#123;<br>        object.setName(value);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PersonBuilder <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        object.setAge(value);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>自定义的注解如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.METHOD&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Builder &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>自定义的注解处理器如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> javax.annotation.processing.AbstractProcessor;<br><span class="hljs-keyword">import</span> javax.annotation.processing.RoundEnvironment;<br><span class="hljs-keyword">import</span> javax.annotation.processing.SupportedAnnotationTypes;<br><span class="hljs-keyword">import</span> javax.annotation.processing.SupportedSourceVersion;<br><span class="hljs-keyword">import</span> javax.lang.model.SourceVersion;<br><span class="hljs-keyword">import</span> javax.lang.model.element.Element;<br><span class="hljs-keyword">import</span> javax.lang.model.element.TypeElement;<br><span class="hljs-keyword">import</span> javax.lang.model.type.ExecutableType;<br><span class="hljs-keyword">import</span> javax.tools.Diagnostic;<br><span class="hljs-keyword">import</span> javax.tools.JavaFileObject;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.PrintWriter;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.util.Set;<br><span class="hljs-keyword">import</span> java.util.stream.Collectors;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> throwable</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> v1.0</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 2018/5/27 11:21</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@SupportedAnnotationTypes(value = &#123;&quot;club.throwable.processor.builder.Builder&quot;&#125;)</span><br><span class="hljs-meta">@SupportedSourceVersion(value = SourceVersion.RELEASE_8)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BuilderProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractProcessor</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">process</span><span class="hljs-params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (TypeElement typeElement : annotations) &#123;<br>            Set&lt;? extends Element&gt; annotatedElements = roundEnv.getElementsAnnotatedWith(typeElement);<br>            Map&lt;Boolean, List&lt;Element&gt;&gt; annotatedMethods<br>                    = annotatedElements.stream().collect(Collectors.partitioningBy(<br>                    element -&gt; ((ExecutableType) element.asType()).getParameterTypes().size() == <span class="hljs-number">1</span><br>                            &amp;&amp; element.getSimpleName().toString().startsWith(<span class="hljs-string">&quot;set&quot;</span>)));<br>            List&lt;Element&gt; setters = annotatedMethods.get(<span class="hljs-keyword">true</span>);<br>            List&lt;Element&gt; otherMethods = annotatedMethods.get(<span class="hljs-keyword">false</span>);<br>            otherMethods.forEach(element -&gt;<br>                    processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,<br>                            <span class="hljs-string">&quot;@Builder must be applied to a setXxx method &quot;</span><br>                                    + <span class="hljs-string">&quot;with a single argument&quot;</span>, element));<br>            Map&lt;String, String&gt; setterMap = setters.stream().collect(Collectors.toMap(<br>                    setter -&gt; setter.getSimpleName().toString(),<br>                    setter -&gt; ((ExecutableType) setter.asType())<br>                            .getParameterTypes().get(<span class="hljs-number">0</span>).toString()<br>            ));<br>            String className = ((TypeElement) setters.get(<span class="hljs-number">0</span>)<br>                    .getEnclosingElement()).getQualifiedName().toString();<br>            <span class="hljs-keyword">try</span> &#123;<br>                writeBuilderFile(className, setterMap);<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeBuilderFile</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">            String className, Map&lt;String, String&gt; setterMap)</span></span><br><span class="hljs-function">            <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        String packageName = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">int</span> lastDot = className.lastIndexOf(<span class="hljs-string">&#x27;.&#x27;</span>);<br>        <span class="hljs-keyword">if</span> (lastDot &gt; <span class="hljs-number">0</span>) &#123;<br>            packageName = className.substring(<span class="hljs-number">0</span>, lastDot);<br>        &#125;<br>        String simpleClassName = className.substring(lastDot + <span class="hljs-number">1</span>);<br>        String builderClassName = className + <span class="hljs-string">&quot;Builder&quot;</span>;<br>        String builderSimpleClassName = builderClassName<br>                .substring(lastDot + <span class="hljs-number">1</span>);<br><br>        JavaFileObject builderFile = processingEnv.getFiler().createSourceFile(builderClassName);<br><br>        <span class="hljs-keyword">try</span> (PrintWriter out = <span class="hljs-keyword">new</span> PrintWriter(builderFile.openWriter())) &#123;<br><br>            <span class="hljs-keyword">if</span> (packageName != <span class="hljs-keyword">null</span>) &#123;<br>                out.print(<span class="hljs-string">&quot;package &quot;</span>);<br>                out.print(packageName);<br>                out.println(<span class="hljs-string">&quot;;&quot;</span>);<br>                out.println();<br>            &#125;<br>            out.print(<span class="hljs-string">&quot;public class &quot;</span>);<br>            out.print(builderSimpleClassName);<br>            out.println(<span class="hljs-string">&quot; &#123;&quot;</span>);<br>            out.println();<br>            out.print(<span class="hljs-string">&quot;    private &quot;</span>);<br>            out.print(simpleClassName);<br>            out.print(<span class="hljs-string">&quot; object = new &quot;</span>);<br>            out.print(simpleClassName);<br>            out.println(<span class="hljs-string">&quot;();&quot;</span>);<br>            out.println();<br>            out.print(<span class="hljs-string">&quot;    public &quot;</span>);<br>            out.print(simpleClassName);<br>            out.println(<span class="hljs-string">&quot; build() &#123;&quot;</span>);<br>            out.println(<span class="hljs-string">&quot;        return object;&quot;</span>);<br>            out.println(<span class="hljs-string">&quot;    &#125;&quot;</span>);<br>            out.println();<br>            setterMap.forEach((methodName, argumentType) -&gt; &#123;<br>                out.print(<span class="hljs-string">&quot;    public &quot;</span>);<br>                out.print(builderSimpleClassName);<br>                out.print(<span class="hljs-string">&quot; &quot;</span>);<br>                out.print(methodName);<br><br>                out.print(<span class="hljs-string">&quot;(&quot;</span>);<br><br>                out.print(argumentType);<br>                out.println(<span class="hljs-string">&quot; value) &#123;&quot;</span>);<br>                out.print(<span class="hljs-string">&quot;        object.&quot;</span>);<br>                out.print(methodName);<br>                out.println(<span class="hljs-string">&quot;(value);&quot;</span>);<br>                out.println(<span class="hljs-string">&quot;        return this;&quot;</span>);<br>                out.println(<span class="hljs-string">&quot;    &#125;&quot;</span>);<br>                out.println();<br>            &#125;);<br>            out.println(<span class="hljs-string">&quot;&#125;&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>主类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>      <span class="hljs-comment">//PersonBuilder在编译之后才会生成，这里需要编译后才能这样写</span><br>      Person person  = <span class="hljs-keyword">new</span> PersonBuilder().setAge(<span class="hljs-number">25</span>).setName(<span class="hljs-string">&quot;doge&quot;</span>).build();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>先手动编译BuilderProcessor，然后在META-INF/services/javax.annotation.processing.Processor文件中添加<code>club.throwable.processor.builder.BuilderProcessor</code>，最后执行Maven命令mvn compile进行编译。</p><p>编译后控制台输出:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[errorRaised=<span class="hljs-literal">false</span>, rootElements=[club.throwable.processor.builder.PersonBuilder], processingOver=<span class="hljs-literal">false</span>]<br></code></pre></td></tr></table></figure><p>编译成功之后，target/classes包下面的club.throwable.processor.builder子包路径中会新增了一个类<code>PersonBuilder</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> club.throwable.processor.builder;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonBuilder</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Person object = <span class="hljs-keyword">new</span> Person();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PersonBuilder</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Person <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.object;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PersonBuilder <span class="hljs-title">setName</span><span class="hljs-params">(String value)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.object.setName(value);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PersonBuilder <span class="hljs-title">setAge</span><span class="hljs-params">(Integer value)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.object.setAge(value);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个类就是编译期新增的。在这个例子中，编译期新增的类貌似没有什么作用。但是，如果像lombok那样对原来的实体类添加新的方法，那样的话就比较有用了。因为些类或者方法是编译期添加的，因此在代码中直接使用会标红。因此，lombok提供了IDEA或者eclipse的插件，插件的功能的实现估计也是用了插件式注解处理API。</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>注解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nix包管理</title>
    <link href="/posts/321c9b4b/"/>
    <url>/posts/321c9b4b/</url>
    
    <content type="html"><![CDATA[<h1 id="在manjaro上使用nix包管理"><a href="#在manjaro上使用nix包管理" class="headerlink" title="在manjaro上使用nix包管理"></a>在manjaro上使用nix包管理</h1><h1 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h1><ol><li><a href="https://nixos.org/manual/nix/stable/installation/installing-binary.html">手册</a></li></ol><h1 id="普通安装"><a href="#普通安装" class="headerlink" title="普通安装"></a>普通安装</h1><ol><li><p> 分一个ext4分区</p></li><li><p>在根目录下创建nix文件夹</p></li><li><p>使用<code>chown username /nix</code> 改变nix目录的所属者</p></li><li><p>使用磁盘工具，将分好的分区挂载到<code>/nix</code>目录</p></li><li><p>安装nix</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ sh &lt;(curl -L https:<span class="hljs-regexp">//</span>nixos.org<span class="hljs-regexp">/nix/i</span>nstall) --no-daemon  <span class="hljs-comment">#单用户</span><br></code></pre></td></tr></table></figure></li><li><p>卸载nix：删除<code>/nix</code>目录即可</p></li></ol><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>查询可供安装的软件包。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">nix-<span class="hljs-keyword">env</span> -qa<br></code></pre></td></tr></table></figure><p>查找软件包</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim">nix-env -<span class="hljs-keyword">qa</span> firefox<br>和<br>nix-env -<span class="hljs-keyword">qa</span> | <span class="hljs-keyword">grep</span> <span class="hljs-string">&quot;firefox&quot;</span> <br></code></pre></td></tr></table></figure><p> 要安装软件包，通过指定软件包版本使用以下命令，例如安装火狐</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">nix-env -<span class="hljs-selector-tag">i</span> firefox<br></code></pre></td></tr></table></figure><p>在本地系统上，Nix将包存储在<strong>Nix存储中</strong> ，默认情况下为**/ nix / store**目录，其中每个包都有自己唯一的子目录。 例如， <strong>apache-tomcat</strong>包存储在：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/nix/</span>store/<span class="hljs-number">95</span>gmgnxlrcpkhlm00fa5ax8kvd6189py-apache-tomcat-<span class="hljs-number">9.0</span>.<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>在此路径中，随机字符<strong>95gmgnxlrcpkhlm00fa5ax8kvd6189py</strong>是包的唯一标识符，它考虑了所有依赖项。</p><p>您可以使用以下命令列出已安装的软件包。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">$ nix-<span class="hljs-keyword">env</span> -q<br></code></pre></td></tr></table></figure><p>要升级<strong>apache-tomcat</strong>软件包，可以使用<code>-u</code> upgrade开关</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">$ nix-<span class="hljs-keyword">env</span> -u apache-tomcat<br></code></pre></td></tr></table></figure><p>如果要删除/擦除<strong>apache-tomcat</strong> ，请使用<code>-e</code>标志。 这里，包不会立即从系统中删除，只会使其未使用。 这很有用，因为您想要进行回滚，或者它可能位于其他用户的配置文件中。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">$ nix-<span class="hljs-keyword">env</span> -e apache-tomcat<br></code></pre></td></tr></table></figure><p>删除包后，您可以使用<strong>nix-collect-garbage</strong>实用程序进行一些垃圾<strong>回收</strong> 。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>nix-collect-garbage<br></code></pre></td></tr></table></figure><h3 id="多用户安装-如何在Linux中删除Nix包管理器"><a href="#多用户安装-如何在Linux中删除Nix包管理器" class="headerlink" title="多用户安装 如何在Linux中删除Nix包管理器"></a>多用户安装 如何在Linux中删除Nix包管理器</h3><p>要卸载Nix，请一次删除所有与nix相关的文件。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo rm -rf <span class="hljs-regexp">/etc/</span>profile<span class="hljs-regexp">/nix.sh /</span>etc<span class="hljs-regexp">/nix /</span>nix ~root<span class="hljs-regexp">/.nix-profile ~root/</span>.nix-defexpr ~root<span class="hljs-regexp">/.nix-channels ~/</span>.nix-profile ~<span class="hljs-regexp">/.nix-defexpr ~/</span>.nix-channels<br></code></pre></td></tr></table></figure><p>在具有systemd的系统上，运行以下命令以停止所有与nix相关的服务并禁用它们。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo systemctl stop nix-daemon.socket</span><br><span class="hljs-meta">$</span><span class="bash"> sudo systemctl stop nix-daemon.service</span><br><span class="hljs-meta">$</span><span class="bash"> sudo systemctl <span class="hljs-built_in">disable</span> nix-daemon.socket</span><br><span class="hljs-meta">$</span><span class="bash"> sudo systemctl <span class="hljs-built_in">disable</span> nix-daemon.service</span><br><span class="hljs-meta">$</span><span class="bash"> sudo systemctl daemon-reload</span><br></code></pre></td></tr></table></figure><p>如果使用的macos,你需要运行</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">sudo launchctl unload /Library/LaunchDaemons/org<span class="hljs-selector-class">.nixos</span><span class="hljs-selector-class">.nix-daemon</span><span class="hljs-selector-class">.plist</span><br>sudo rm /Library/LaunchDaemons/org<span class="hljs-selector-class">.nixos</span><span class="hljs-selector-class">.nix-daemon</span>.plist<br></code></pre></td></tr></table></figure><p>此外，您需要删除这些文件中对Nix的任何引用： <strong>/ etc / profile</strong> ， <strong>/ etc / bashrc</strong>和**/ etc / zshrc** 。</p><p>有关更多信息，请参阅我们已查看的上述实用程序的手册页。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> <span class="hljs-built_in">man</span> nix<span class="hljs-literal">-channel</span><br><span class="hljs-variable">$</span> <span class="hljs-built_in">man</span> nix<span class="hljs-literal">-env</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>nix os</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安装fbterm</title>
    <link href="/posts/d4eef720/"/>
    <url>/posts/d4eef720/</url>
    
    <content type="html"><![CDATA[<h1 id="安装fbterm"><a href="#安装fbterm" class="headerlink" title="安装fbterm:"></a>安装fbterm:</h1><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pamac <span class="hljs-keyword">install</span> fbterm<br></code></pre></td></tr></table></figure><h1 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h1><h2 id="将用户加入video组-并更改fbterm权限"><a href="#将用户加入video组-并更改fbterm权限" class="headerlink" title="将用户加入video组,并更改fbterm权限:"></a>将用户加入video组,并更改fbterm权限:</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">==&gt; 若想使用非根用户运行fbterm，需要把用户加入video组：<br><span class="hljs-comment">#username为用户名，video为fbterm所在组</span><br>sudo gpasswd -a YOUR_USERNAME video<br><br>==&gt; 若想非根用户可使用键盘快捷方式，需要：<br>sudo setcap <span class="hljs-string">&#x27;cap_sys_tty_config+ep&#x27;</span> <span class="hljs-regexp">/usr/</span>bin/fbterm<br>或者：<br>sudo chmod u+s <span class="hljs-regexp">/usr/</span>bin/fbterm<br></code></pre></td></tr></table></figure><h2 id="tty自动进入fbterm"><a href="#tty自动进入fbterm" class="headerlink" title="tty自动进入fbterm"></a>tty自动进入fbterm</h2><p>修改用户配置文件“home/.bashrc”或“home/.zshrc”。在.bashrc或.zshrc最后中添加如下判断:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#进入tty自动启动fbterm</span><br><span class="hljs-keyword">if</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$TERM</span>&quot;</span> = <span class="hljs-string">&quot;linux&quot;</span> ]; <span class="hljs-keyword">then</span><br><span class="hljs-comment"># 此处使用了别名,如此当我们退出fbterm后,便能够通过简单的命令:fbterm,</span><br><span class="hljs-comment"># 重新启动fbterm了,而不用再指定LANG.</span><br><span class="hljs-built_in">alias</span> fbterm=<span class="hljs-string">&#x27;LANG=zh_CN.UTF-8 fbterm&#x27;</span><br>fbterm<br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><h1 id="创建fbterm的配置文件"><a href="#创建fbterm的配置文件" class="headerlink" title="创建fbterm的配置文件"></a>创建fbterm的配置文件</h1><p><strong>在~/.config/位置创建fbterm文件夹，在此文件夹下创建fbtermrc文件</strong></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade">mkdir ~<span class="hljs-regexp">/.config/</span>fbterm<br>cd ~<span class="hljs-regexp">/.config/</span>fbterm<br>touch fbtermrc<br></code></pre></td></tr></table></figure><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><p>配置文件在 ~/.config/fbterm/fbtermrc</p><p>首先注意，konsole/gnome-terminal 等 X11 环境的终端模拟器的字体拿到 fbterm 中百分之百会走形。因此一些很漂亮的比如 consolas，monaco，andale 等都很丑。你可以在 .fbtermrc 中自己试验。原因是 fbterm 使用 fontconfig 挑字体，freetype 渲染，但是 <strong>freetype 中依赖 libxft 的部分它作为一个终端无法使用</strong>。</p><p>中文字体测试过文泉驿微米黑、正黑、点阵宋和 unibit，都不行。其中点阵宋显示很清晰，但是宽度太大，其他完全就不清晰。微软、苹果家的字体都是要求 freetype 渲染的，就不要想了。我摸索出的最佳字体配置如下：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">font-names</span>=DejaVu Sans Mo<span class="hljs-literal">no</span>,Droid Sans Fallback<br><span class="hljs-attr">font-size</span>=<span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">text-encodings</span>=UTF-<span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p>也在 .fbtermrc 中配置。</p><h3 id="键盘快捷键"><a href="#键盘快捷键" class="headerlink" title="键盘快捷键"></a>键盘快捷键</h3><p>启动提示：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">[<span class="hljs-keyword">input</span>] can&#x27;t change kernel keymap <span class="hljs-keyword">table</span>, all shortcuts will NOT work,  see SECURITY <span class="hljs-keyword">NOTES</span> section of <span class="hljs-keyword">man</span> page <span class="hljs-keyword">for</span> solution.<br></code></pre></td></tr></table></figure><p>原因：fbterm 需要设置内核键盘映射表来设定快捷键。这就需要 fbterm 是一个 setuid 0 的程序（不然普通用户还是设置不了快捷键因为没权限操作内核）。fbterm 也只在设置快捷键时会自动转为 root。因此安全上是可以放心的。</p><p>解决：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo chmod u+s <span class="hljs-regexp">/usr/</span>bin/fbterm<br></code></pre></td></tr></table></figure><h3 id="背景图片"><a href="#背景图片" class="headerlink" title="背景图片"></a>背景图片</h3><p>安装 home:MargueriteSu 源的 fbv 软件，把下面脚本保存成 cfbterm</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">    #!/bin/bash<br><br>    # fbterm-bi: a <span class="hljs-keyword">wrapper</span> script <span class="hljs-keyword">to</span>  <span class="hljs-keyword">enable</span>  background<br>image <span class="hljs-keyword">with</span> fbterm<br>    # <span class="hljs-keyword">usage</span>: fbterm-bi /<span class="hljs-type">path</span>/<span class="hljs-keyword">to</span>/image fbterm-<span class="hljs-keyword">options</span><br><br>    echo -ne &quot;\e[?25l&quot; # hide <span class="hljs-keyword">cursor</span><br><br>    fbv -ciuker &quot;这里是你的图片的完整路径&quot; &lt;&lt; EOF<br>    q<br>    EOF<br><br>    shift<br>    export FBTERM_BACKGROUND_IMAGE=<span class="hljs-number">1</span><br>    exec fbterm &quot;$@&quot;<br></code></pre></td></tr></table></figure><p>然后：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo cp -r cfbterm <span class="hljs-regexp">/usr/</span>bin<br></code></pre></td></tr></table></figure><p>以后每次都用 cfbterm 命令启动控制台。图片支持 png/jpeg/jpg/bmp 格式，建议用 png，jpeg 的颜色渐变在终端下显示很丑。</p><h3 id="输入法"><a href="#输入法" class="headerlink" title="输入法"></a>输入法</h3><p>安装 fcitx-fbterm。然后在 /home/marguerite/.fbtermrc 的最后：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">input-<span class="hljs-function"><span class="hljs-keyword">method</span>=<span class="hljs-title">fcitx</span>-<span class="hljs-title">fbterm</span></span><br></code></pre></td></tr></table></figure><p>网上有说 fcitx 和 fbterm 的进终端自动启动，但那个不支持背景图片。如果你不需要背景图片，可以把：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua"># If you <span class="hljs-keyword">do</span> console login, it will start fbterm <span class="hljs-keyword">and</span> fcitx-fbterm by default.<br><br><span class="hljs-string">[[ $(tty) == \/dev\/tty[0-9]* ]]</span> &amp;&amp; fcitx-fbterm-helper<br></code></pre></td></tr></table></figure><p>写入到 /home/marguerite/.bashrc。</p><p>使用背景图片的启动方法是：</p><ul><li>登录终端</li><li>cfbterm 启动 fbterm</li><li>在 fbterm 中运行 fcitx -d 启动 fcitx</li></ul><h3 id="256-色"><a href="#256-色" class="headerlink" title="256 色"></a>256 色</h3><p>fbterm 支持 256 色，使用：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">TERM</span>=fbterm vim .fbtermrc<br></code></pre></td></tr></table></figure><p>这样的命令来启动程序即可。不想每次都这么做，在 .fbtermrc 的最后写入：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">TERM</span>=fbterm<br></code></pre></td></tr></table></figure><p>即可。</p><h3 id="灰白改纯白"><a href="#灰白改纯白" class="headerlink" title="灰白改纯白"></a>灰白改纯白</h3><p>fbterm 里面默认的白色实际上是灰白，不习惯的可以在 .fbtermrc 的最后写入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># restore white color</span><br><span class="hljs-built_in">echo</span> -ne <span class="hljs-string">&quot;\e]P7ffffff&quot;</span><br></code></pre></td></tr></table></figure><p>即可。</p><h3 id="鼠标"><a href="#鼠标" class="headerlink" title="鼠标"></a>鼠标</h3><p>要先设置 gpm。使用：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo yast mouse</span> <br></code></pre></td></tr></table></figure><p>来选择你想在终端中使用的鼠标。然后，</p><p>在终端登录后<strong>默认的 bash</strong> 中，使用：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo <span class="hljs-regexp">/etc/i</span>nit.d/gpm start <br></code></pre></td></tr></table></figure><p>启动 gpm 鼠标服务器。之后正常进入 fbterm 用鼠标。</p><h3 id="终端截图"><a href="#终端截图" class="headerlink" title="终端截图"></a>终端截图</h3><p>安装 home:MargueriteSu 源中的 fbshot。使用：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">fbshot</span> -s 读秒 图片保存路径<br></code></pre></td></tr></table></figure><p>来截图。</p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件，终端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>aria2整理</title>
    <link href="/posts/49c06d08/"/>
    <url>/posts/49c06d08/</url>
    
    <content type="html"><![CDATA[<h1 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h1><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> pacman -S aria<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h2 id="2-Aria2-配置说明"><a href="#2-Aria2-配置说明" class="headerlink" title="2.Aria2 配置说明"></a>2.Aria2 配置说明</h2><ol><li>创建<code>/home/用户名/.config/aria2/</code>文件夹，新建一个名为aria2.conf的配置文件，并把下面的配置示例修改后复制进去</li><li>创建<code>/home/用户名/.aria2/</code>文件夹，用touch命令建立两个文件<code>aria2.session</code>和<code>input.session</code></li><li>第二步里的路径可以自行修改，在配置文件里填写好就行</li></ol><ul><li><p><strong>完整选项说明请参考 <a href="https://aria2.github.io/manual/en/html/aria2c.html">Aria2 Manual</a></strong></p></li><li><p><strong>参数 <code>--dir</code> <code>--input-file</code> <code>--save-session</code> 根据实际情况修改路径</strong></p></li><li><p>配置示例, 可根据需要修改各项参数</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta">## &#x27;#&#x27;开头为注释内容, 选项都有相应的注释说明, 根据需要修改 ##</span><br><span class="hljs-meta">## 被注释的选项填写的是默认值, 建议在需要修改时再取消注释  ##</span><br><br><span class="hljs-meta">## 文件保存相关 ##</span><br><br><span class="hljs-meta"># 文件的保存路径(可使用绝对路径或相对路径), 默认: 当前启动位置</span><br>dir=$&#123;HOME&#125;/下载<br><span class="hljs-meta"># 启用磁盘缓存, 0为禁用缓存, 需1.16以上版本, 默认:16M</span><br><span class="hljs-meta">#disk-cache=32M</span><br><span class="hljs-meta"># 文件预分配方式, 能有效降低磁盘碎片, 默认:prealloc</span><br><span class="hljs-meta"># 预分配所需时间: none &lt; falloc ? trunc &lt; prealloc</span><br><span class="hljs-meta"># falloc和trunc则需要文件系统和内核支持</span><br><span class="hljs-meta"># NTFS建议使用falloc, EXT3/4建议trunc, MAC 下需要注释此项</span><br><span class="hljs-meta">#file-allocation=none</span><br><span class="hljs-meta"># 断点续传</span><br>continue=<span class="hljs-literal">true</span><br><br><span class="hljs-meta">## 下载连接相关 ##</span><br><br><span class="hljs-meta"># 最大同时下载任务数, 运行时可修改, 默认:5</span><br><span class="hljs-meta">#max-concurrent-downloads=5</span><br><span class="hljs-meta"># 同一服务器连接数, 添加时可指定, 默认:1</span><br>max-connection-per-server=<span class="hljs-number">5</span><br><span class="hljs-meta"># 最小文件分片大小, 添加时可指定, 取值范围1M -1024M, 默认:20M</span><br><span class="hljs-meta"># 假定size=10M, 文件为20MiB 则使用两个来源下载; 文件为15MiB 则使用一个来源下载</span><br>min-split-size=<span class="hljs-number">10</span>M<br><span class="hljs-meta"># 单个任务最大线程数, 添加时可指定, 默认:5</span><br><span class="hljs-meta">#split=5</span><br><span class="hljs-meta"># 整体下载速度限制, 运行时可修改, 默认:0</span><br><span class="hljs-meta">#max-overall-download-limit=0</span><br><span class="hljs-meta"># 单个任务下载速度限制, 默认:0</span><br><span class="hljs-meta">#max-download-limit=0</span><br><span class="hljs-meta"># 整体上传速度限制, 运行时可修改, 默认:0</span><br><span class="hljs-meta">#max-overall-upload-limit=0</span><br><span class="hljs-meta"># 单个任务上传速度限制, 默认:0</span><br><span class="hljs-meta">#max-upload-limit=0</span><br><span class="hljs-meta"># 禁用IPv6, 默认:false</span><br><span class="hljs-meta">#disable-ipv6=true</span><br><span class="hljs-meta"># 连接超时时间, 默认:60</span><br><span class="hljs-meta">#timeout=60</span><br><span class="hljs-meta"># 最大重试次数, 设置为0表示不限制重试次数, 默认:5</span><br><span class="hljs-meta">#max-tries=5</span><br><span class="hljs-meta"># 设置重试等待的秒数, 默认:0</span><br><span class="hljs-meta">#retry-wait=0</span><br><br><span class="hljs-meta">## 进度保存相关 ##</span><br><br><span class="hljs-meta"># 从会话文件中读取下载任务。比如： /etc/aria2/aria2.session</span><br>input-file=$&#123;HOME&#125;/.aria2/input.session<br><span class="hljs-meta"># 在Aria2退出时保存`错误/未完成`的下载任务到会话文件。比如： /etc/aria2/aria2.session</span><br>save-session=$&#123;HOME&#125;/.aria2/aria2.session<br><span class="hljs-meta"># 定时保存会话, 0为退出时才保存, 需1.16.1以上版本, 默认:0</span><br><span class="hljs-meta">#save-session-interval=60</span><br><br><span class="hljs-meta">## RPC相关设置 ##</span><br><br><span class="hljs-meta"># 启用RPC, 默认:false</span><br>enable-rpc=<span class="hljs-literal">true</span><br><span class="hljs-meta"># 允许所有来源, 默认:false</span><br>rpc-allow-origin-all=<span class="hljs-literal">true</span><br><span class="hljs-meta"># 允许非外部访问, 默认:false</span><br>rpc-listen-all=<span class="hljs-literal">true</span><br><span class="hljs-meta"># 事件轮询方式, 取值:[epoll, kqueue, port, poll, select], 不同系统默认值不同</span><br><span class="hljs-meta">#event-poll=select</span><br><span class="hljs-meta"># RPC监听端口, 端口被占用时可以修改, 默认:6800</span><br><span class="hljs-meta">#rpc-listen-port=6800</span><br><span class="hljs-meta"># 设置的RPC授权令牌, v1.18.4新增功能, 取代 --rpc-user 和 --rpc-passwd 选项</span><br><span class="hljs-meta">#rpc-secret=&lt;TOKEN&gt;</span><br><span class="hljs-meta"># 设置的RPC访问用户名, 此选项新版已废弃, 建议改用 --rpc-secret 选项</span><br><span class="hljs-meta">#rpc-user=&lt;USER&gt;</span><br><span class="hljs-meta"># 设置的RPC访问密码, 此选项新版已废弃, 建议改用 --rpc-secret 选项</span><br><span class="hljs-meta">#rpc-passwd=&lt;PASSWD&gt;</span><br><span class="hljs-meta"># 是否启用 RPC 服务的 SSL/TLS 加密,</span><br><span class="hljs-meta"># 启用加密后 RPC 服务需要使用 https 或者 wss 协议连接</span><br><span class="hljs-meta">#rpc-secure=true</span><br><span class="hljs-meta"># 在 RPC 服务中启用 SSL/TLS 加密时的证书文件,</span><br><span class="hljs-meta"># 使用 PEM 格式时，您必须通过 --rpc-private-key 指定私钥</span><br><span class="hljs-meta">#rpc-certificate=/path/to/certificate.pem</span><br><span class="hljs-meta"># 在 RPC 服务中启用 SSL/TLS 加密时的私钥文件</span><br><span class="hljs-meta">#rpc-private-key=/path/to/certificate.key</span><br><br><span class="hljs-meta">## BT/PT下载相关 ##</span><br><br><span class="hljs-meta"># 当下载的是一个种子(以.torrent结尾)时, 自动开始BT任务, 默认:true</span><br><span class="hljs-meta">#follow-torrent=true</span><br><span class="hljs-meta"># BT监听端口, 当端口被屏蔽时使用, 默认:6881-6999</span><br>listen-port=<span class="hljs-number">51413</span><br><span class="hljs-meta"># 单个种子最大连接数, 默认:55</span><br><span class="hljs-meta">#bt-max-peers=55</span><br><span class="hljs-meta"># 打开DHT功能, PT需要禁用, 默认:true</span><br>enable-dht=<span class="hljs-literal">false</span><br><span class="hljs-meta"># 打开IPv6 DHT功能, PT需要禁用</span><br><span class="hljs-meta">#enable-dht6=false</span><br><span class="hljs-meta"># DHT网络监听端口, 默认:6881-6999</span><br><span class="hljs-meta">#dht-listen-port=6881-6999</span><br><span class="hljs-meta"># 本地节点查找, PT需要禁用, 默认:false</span><br><span class="hljs-meta">#bt-enable-lpd=false</span><br><span class="hljs-meta"># 种子交换, PT需要禁用, 默认:true</span><br>enable-peer-exchange=<span class="hljs-literal">false</span><br><span class="hljs-meta"># 每个种子限速, 对少种的PT很有用, 默认:50K</span><br><span class="hljs-meta">#bt-request-peer-speed-limit=50K</span><br><span class="hljs-meta"># 客户端伪装, PT需要</span><br>peer-id-prefix=-TR2770-<br>user-agent=Transmission/<span class="hljs-number">2.77</span><br>peer-agent=Transmission/<span class="hljs-number">2.77</span><br><span class="hljs-meta"># 当种子的分享率达到这个数时, 自动停止做种, 0为一直做种, 默认:1.0</span><br>seed-ratio=<span class="hljs-number">0</span><br><span class="hljs-meta"># 强制保存会话, 即使任务已经完成, 默认:false</span><br><span class="hljs-meta"># 较新的版本开启后会在任务完成后依然保留.aria2文件</span><br><span class="hljs-meta">#force-save=false</span><br><span class="hljs-meta"># BT校验相关, 默认:true</span><br><span class="hljs-meta">#bt-hash-check-seed=true</span><br><span class="hljs-meta"># 继续之前的BT任务时, 无需再次校验, 默认:false</span><br>bt-seed-unverified=<span class="hljs-literal">true</span><br><span class="hljs-meta"># 保存磁力链接元数据为种子文件(.torrent文件), 默认:false</span><br>bt-save-metadata=<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="使用aria2下载"><a href="#使用aria2下载" class="headerlink" title="使用aria2下载"></a>使用aria2下载</h2><ol><li><p>在终端里输入<code>aria2c</code> 启动服务，出现监听端口</p></li><li><p>用浏览器打开<a href="http://aria2c.com/">Aria2 Web 控制台</a></p></li><li><p>不使用aria2时在终端里按下<code>ctrl+c</code>回车停止aria2服务</p></li></ol><h2 id="Aria2-相关下载"><a href="#Aria2-相关下载" class="headerlink" title="Aria2 相关下载"></a>Aria2 相关下载</h2><ul><li><p><a href="https://github.com/aria2/aria2/releases/latest">Aria2 源码/程序下载</a></p></li><li><p><a href="http://aria2c.com/archiver/aria2.conf">配置示例下载</a></p></li><li><p>重要文件</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs 1c">aria2.conf    <span class="hljs-meta"># 配置文件 可以自己根据说明修改</span><br>aria2.session <span class="hljs-meta"># 任务保存文件 错误/未完成任务会保存在这里（下载历史）</span><br>Aria2.<span class="hljs-built_in">log</span> <span class="hljs-meta">#（日志，空文件就行）</span><br>input.session <span class="hljs-meta"># 从会话文件中读取下载任务</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h1><p>推荐使用AriaNG</p><p><a href="http://ariang.mayswind.net/zh_Hans/">ariaNg下载到本地使用</a></p><h2 id="创建-systemd-守护进程"><a href="#创建-systemd-守护进程" class="headerlink" title="创建 systemd 守护进程"></a>创建 systemd 守护进程</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo vim /etc/systemd/user/aria2.service<br>[Unit]<br><span class="hljs-attribute">Description</span>=Aria2<span class="hljs-built_in"> Service</span><br><span class="hljs-built_in"></span><span class="hljs-attribute">After</span>=network.target<br><br>[Service]<br><span class="hljs-attribute">Type</span>=forking<br><span class="hljs-attribute">WorkingDirectory</span>=%h<br><span class="hljs-attribute">ExecStart</span>=/usr/bin/aria2c --daemon --enable-rpc --rpc-listen-all --rpc-allow-origin-all -c -D  <span class="hljs-attribute">--conf-path</span>=%h/.config/aria2/aria2.conf<br><br>[Install]<br><span class="hljs-attribute">WantedBy</span>=default.target<br><span class="hljs-comment"># 启动</span><br>systemctl --user start aria2.service<br>systemctl --user <span class="hljs-builtin-name">enable</span> aria2.service<br></code></pre></td></tr></table></figure><h2 id="YAAW-使用说明"><a href="#YAAW-使用说明" class="headerlink" title="YAAW 使用说明"></a>YAAW 使用说明</h2><p><strong>JSON-RPC Path</strong></p><ul><li><p><code>JSON-RPC Path</code> 默认为: <code>http://localhost:6800/jsonrpc</code></p></li><li><p>如果提示 </p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">Aria2</span> RPC 服务器错误<br></code></pre></td></tr></table></figure><p> 按照以下方法修改             </p><ul><li><p><strong><code>host</code></strong>: 指运行 Aria2 所在机器的 IP 或者名字</p></li><li><p><strong><code>port</code></strong>: 使用 <code>--rpc-listen-port</code> 选项设置的端口, 未设置则是 <code>6800</code></p></li><li><p>普通情况设置为: <code>http://host:port/jsonrpc</code></p></li><li><p>使用 <code>--rpc-secret=xxxxxx</code> 选项设置为: <code>http://token:xxxxxx@host:port/jsonrpc</code></p></li><li><p>使用 <code>--rpc-user=user --rpc-passwd=pwd </code> 选项设置为: <code>http://user:pwd@host:port/jsonrpc</code></p></li><li><p>以上 <code>JSON-RPC Path</code> 中的 <code>http</code> 可以用 <code>ws</code> 替代, 代表使用 <code>WebSocket 协议</code></p></li><li><p>当使用 <a href="https://aria2c.com/">https://aria2c.com</a> 访问时, 需要使用 <code>https</code> 或 <code>wss</code> 协议</p></li></ul></li></ul><p><strong>Tips</strong></p><ul><li>在 YAAW 中对 Aria2 的设置会在 Aria2 重启后丢失, 必要的设置请写入配置文件</li><li>已经下载完成的任务会在 Aria2 重启后消失, 除非启用了 <code>--force-save</code> 选项</li><li>因界面已汉化, 其他不再赘述.</li></ul><h2 id="YAAW-搭配脚本"><a href="#YAAW-搭配脚本" class="headerlink" title="YAAW 搭配脚本"></a>YAAW 搭配脚本</h2><p><strong>迅雷离线</strong></p><ul><li><p>Chrome Extension: <a href="https://chrome.google.com/webstore/detail/eehlmkfpnagoieibahhcghphdbjcdmen">ThunderLixianAssistant</a></p></li><li><p>UserScript: <a href="https://github.com/binux/ThunderLixianExporter">ThunderLixianExporter</a></p></li><li><p><a href="https://greasyfork.org/scripts/2398-lixianexporter">https://greasyfork.org/scripts/2398-lixianexporter</a>)</p></li></ul><p><strong>百度网盘</strong></p><ul><li>Chrome Extension: <a href="https://chrome.google.com/webstore/detail/mjaenbjdjmgolhoafkohbhhbaiedbkno">BaiduExporter</a></li><li>Firefox Addons: <a href="https://github.com/acgotaku/BaiduExporter">BaiduExporter</a></li><li>UserScript: <a href="https://greasyfork.org/scripts/294-baidupandownloadhelper">BaiduPanDownloadHelper</a></li></ul><p><strong>其他脚本</strong></p><ul><li>Chrome Extension: <a href="https://chrome.google.com/webstore/detail/nimeojfecmndgolmlmjghjmbpdkhhogl">添加到aria2</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>软件</tag>
      
      <tag>aria2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>livedata</title>
    <link href="/posts/fc565935/"/>
    <url>/posts/fc565935/</url>
    
    <content type="html"><![CDATA[<p>map和switchmap的区别</p><p><strong>Map()</strong> is conceptually identical to the use in RXJava, basically you are changing a parameter of LiveData in another one </p><p><strong>SwitchMap()</strong> instead you are going to substitute the LiveData itself with another one! Typical case is when you retrieve some data from a Repository for instance and to “eliminate” the previous LiveData (to garbage collect, to make it more efficient the memory usually) you pass a <strong>new</strong> LiveData that execute the same action( getting a query for instance) </p><p>译文：相反，您将用另一个替换 LiveData 本身！ 典型的情况是，例如，当您从存储库中检索一些数据并“消除”以前的 LiveData（垃圾收集，通常使内存更有效）时，您传递一个执行相同操作的新 LiveData（获取查询 实例）</p><hr><h4 id="TRANSFORMATIONS"><a href="#TRANSFORMATIONS" class="headerlink" title="TRANSFORMATIONS:"></a>TRANSFORMATIONS:</h4><p>Transformation basically applies a function to the values stored in the <a href="https://developer.android.com/topic/libraries/architecture/livedata">LiveData</a> object and propagates the result to the downstream. There are currently two types of Transformations we have.</p><ol><li>[**Transformations.map**](<a href="https://developer.android.com/reference/android/arch/lifecycle/Transformations#map">https://developer.android.com/reference/android/arch/lifecycle/Transformations#map</a>(android.arch.lifecycle.LiveData, android.arch.core.util.Function)): The <strong>map</strong> lets you apply a function to the output of <a href="https://developer.android.com/topic/libraries/architecture/livedata">LiveData</a> and then propagates the result to the downstream.</li><li>[**Transformations.switchMap**:](<a href="https://developer.android.com/reference/android/arch/lifecycle/Transformations.html#switchMap">https://developer.android.com/reference/android/arch/lifecycle/Transformations.html#switchMap</a>(android.arch.lifecycle.LiveData, android.arch.core.util.Function&gt;)) The <strong>swicthMap</strong> function transformation is a lot like a <strong>map</strong> but for mapping function that emits <a href="https://developer.android.com/topic/libraries/architecture/livedata">LiveData</a> instead of values. Again <strong>switchMap</strong> functions propagate <a href="https://developer.android.com/topic/libraries/architecture/livedata">LiveData</a> to downstream instead of single value.</li></ol><h4 id="EXAMPLE-OF-TRANSFORMATIONS-MAP"><a href="#EXAMPLE-OF-TRANSFORMATIONS-MAP" class="headerlink" title="EXAMPLE OF TRANSFORMATIONS.MAP:"></a>EXAMPLE OF TRANSFORMATIONS.MAP:</h4><p>Let’s take a scenario where we need to show <a href="https://developer.android.com/reference/android/support/design/widget/Snackbar">Snackbar</a> whenever a new user added to the database. The <a href="https://developer.android.com/reference/android/support/design/widget/Snackbar">Snackbar</a> shows data of a custom <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html">String</a> with username added in it.</p><p><a href="https://codinginfinite.com/wp-content/uploads/2018/07/videotogif_2018.07.22_15.36.40.gif"><img src="TyporaRaw/Livedata.assets/videotogif_2018.07.22_15.36.40.gif" alt="img"></a></p><p>You see a demo right, let’s create our <a href="https://developer.android.com/topic/libraries/architecture/viewmodel">ViewModel</a> class to hold the <a href="https://developer.android.com/topic/libraries/architecture/livedata">LiveData</a> of <strong>User</strong>.</p><h5 id="TRANSFORMATIONVIEWMODEL-CLASS"><a href="#TRANSFORMATIONVIEWMODEL-CLASS" class="headerlink" title="TRANSFORMATIONVIEWMODEL CLASS:"></a>TRANSFORMATIONVIEWMODEL CLASS:</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TransformationViewModel</span> : <span class="hljs-type">ViewModel</span></span>() &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> userLiveData = MutableLiveData&lt;User&gt;()<br><br>    <span class="hljs-keyword">val</span> userAddedData: LiveData&lt;String&gt; = Transformations.map(userLiveData, ::someFunc)<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">someFunc</span><span class="hljs-params">(user: <span class="hljs-type">User</span>)</span></span> = <span class="hljs-string">&quot;New user <span class="hljs-subst">$&#123;user.username&#125;</span> added to database!&quot;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">addNewUser</span><span class="hljs-params">(user: <span class="hljs-type">User</span>)</span></span> = apply &#123; userLiveData.value = user &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>There are two things noticeable here.</p><ul><li>First, we are not exposing our user <a href="https://developer.android.com/topic/libraries/architecture/livedata">LiveData</a> to publically. We have given a public function to just add the User object. By doing this we’re keeping our Immutability principle.</li><li>Second, for adding the map Transformations we need to provide source <a href="https://developer.android.com/topic/libraries/architecture/livedata">LiveData</a> and function from which you need to return your custom value. You see in our case we’re returning a custom <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html">String</a> with username add in it.</li></ul><p>So, we create our <a href="https://developer.android.com/topic/libraries/architecture/viewmodel">ViewModel</a> and <a href="https://developer.android.com/topic/libraries/architecture/livedata">LiveData</a> with map Transformations, let’s see how we gonna use this <a href="https://developer.android.com/topic/libraries/architecture/viewmodel">ViewModel</a> inside our <a href="https://developer.android.com/reference/android/app/Activity">Activity</a>.</p><h5 id="MAINACTIVITY"><a href="#MAINACTIVITY" class="headerlink" title="MAINACTIVITY:"></a>MAINACTIVITY:</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> : <span class="hljs-type">AppCompatActivity</span></span>() &#123;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(savedInstanceState: <span class="hljs-type">Bundle</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState)<br>        setContentView(R.layout.activity_main)<br>        <span class="hljs-keyword">val</span> viewModel = ViewModelProviders.of(<span class="hljs-keyword">this</span>).<span class="hljs-keyword">get</span>(TransformationViewModel::<span class="hljs-keyword">class</span>.java)<br>        viewModel.userAddedData.observe(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">object</span> : Observer&lt;String&gt;&#123;<br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onChanged</span><span class="hljs-params">(t: <span class="hljs-type">String</span>?)</span></span> &#123;<br>                Snackbar.make(mainActivityRootView, t!!, Snackbar.LENGTH_SHORT).show()<br>            &#125;<br>        &#125;)<br>        addUserButton.setOnClickListener &#123;<br>            viewModel.addNewUser(User(addNewEditText.text.toString()))<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>The <a href="https://developer.android.com/reference/android/app/Activity">Activity</a> is very basic, in here we’re only observing our <a href="https://developer.android.com/topic/libraries/architecture/livedata">LiveData</a> instance. Whenever the user object added to <a href="https://developer.android.com/topic/libraries/architecture/livedata">LiveData</a> it automatically calls <em>the <a href="https://developer.android.com/reference/android/arch/lifecycle/Observer.html#onChanged(T)">onChanged</a></em> method with the custom <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/index.html">String</a>.</p><h4 id="EXAMPLE-OF-TRANSFORMATIONS-SWITCHMAP"><a href="#EXAMPLE-OF-TRANSFORMATIONS-SWITCHMAP" class="headerlink" title="EXAMPLE OF TRANSFORMATIONS.SWITCHMAP:"></a>EXAMPLE OF TRANSFORMATIONS.SWITCHMAP:</h4><p>Let’s take another scenario where I need to search user by username and show the result inside the <a href="https://developer.android.com/reference/android/support/v7/widget/RecyclerView">RecyclerView</a>.</p><p><a href="https://codinginfinite.com/wp-content/uploads/2018/07/videotogif_2018.07.24_01.24.14.gif"><img src="TyporaRaw/Livedata.assets/videotogif_2018.07.24_01.24.14.gif" alt="img"></a></p><p>You see the demo right let’s create our <a href="https://developer.android.com/topic/libraries/architecture/viewmodel">ViewModel</a> class to search users with the name.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserRepo</span></span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">searchUserWithName</span><span class="hljs-params">(name : <span class="hljs-type">String</span>)</span></span> : LiveData&lt;List&lt;User&gt;&gt;&#123;<br>      ..... logic <span class="hljs-keyword">for</span> search user<br>   &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserViewModel</span> : <span class="hljs-type">ViewModel</span></span>() &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> query = MutableLiveData&lt;String&gt;()<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> userRepo = UserRepo()<br><br>    <span class="hljs-keyword">val</span> userNameResult: LiveData&lt;List&lt;User&gt;&gt; = Transformations.map(<br>            query,<br>            ::temp<br>    )<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">temp</span><span class="hljs-params">(name: <span class="hljs-type">String</span>)</span></span> = userRepo.searchUserWithName(name)<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">searchUserByName</span><span class="hljs-params">(name: <span class="hljs-type">String</span>)</span></span> = apply &#123; query.value = name &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>You see in our <a href="https://developer.android.com/topic/libraries/architecture/viewmodel">ViewModel</a> class we’re getting the data from our <strong>UserRepo</strong> class. So, whenever something is searched, we’ll get users with the name, then the repository creates a new instance of <a href="https://developer.android.com/topic/libraries/architecture/livedata">LiveData</a> and returned the list of users. And finally based on the result we display the data.</p><p>To clarify the things between [*map*](<a href="https://developer.android.com/reference/android/arch/lifecycle/Transformations#map">https://developer.android.com/reference/android/arch/lifecycle/Transformations#map</a>(android.arch.lifecycle.LiveData, android.arch.core.util.Function)) and <em>[switchMap](<a href="https://developer.android.com/reference/android/arch/lifecycle/Transformations.html#switchMap">https://developer.android.com/reference/android/arch/lifecycle/Transformations.html#switchMap</a>(android.arch.lifecycle.LiveData, android.arch.core.util.Function&gt;)),</em> I use <em>[map](<a href="https://developer.android.com/reference/android/arch/lifecycle/Transformations#map">https://developer.android.com/reference/android/arch/lifecycle/Transformations#map</a>(android.arch.lifecycle.LiveData, android.arch.core.util.Function))</em> method so that, we could see what happened if we use <em>[map](<a href="https://developer.android.com/reference/android/arch/lifecycle/Transformations#map">https://developer.android.com/reference/android/arch/lifecycle/Transformations#map</a>(android.arch.lifecycle.LiveData, android.arch.core.util.Function))</em> method instead of [*swicthMap*](<a href="https://developer.android.com/reference/android/arch/lifecycle/Transformations.html#switchMap">https://developer.android.com/reference/android/arch/lifecycle/Transformations.html#switchMap</a>(android.arch.lifecycle.LiveData, android.arch.core.util.Function&gt;)) when we need to return <a href="https://developer.android.com/topic/libraries/architecture/livedata">LiveData</a>.</p><h5 id="PROBLEM"><a href="#PROBLEM" class="headerlink" title="PROBLEM:"></a>PROBLEM:</h5><p>Let’s say we’re looking for the username Alice. The repository is creating a new instance of that <strong>User</strong> <a href="https://developer.android.com/topic/libraries/architecture/livedata">LiveData</a> class and after that, we display the users. After some time we need to look for the username Bob there’s the repository creates a new instance of <a href="https://developer.android.com/topic/libraries/architecture/livedata">LiveData</a> and our <strong>UI</strong> subscribes to that <a href="https://developer.android.com/topic/libraries/architecture/livedata">LiveData</a>. So at this moment, our <strong>UI</strong> subscribes to two instances of <a href="https://developer.android.com/topic/libraries/architecture/livedata">LiveData</a> because we never remove the previous one. So it means whenever our repository changes the user’s data it sends two times subscription. Now, how do we solve this problem…?</p><p>译文：</p><p>假设我们正在寻找用户名 Alice。 存储库正在创建该 <strong>User</strong> <a href="https://developer.android.com/topic/libraries/architecture/livedata">LiveData</a> 类的新实例，之后，我们显示用户。 一段时间后，我们需要查找用户名 Bob，存储库会创建一个 <a href="https://developer.android.com/topic/libraries/architecture/livedata">LiveData</a> 的新实例，并且我们的 <strong>UI</strong> 订阅 <a href="https://developer.android.com/topic/libraries/architecture/livedata">LiveData</a>。 所以此时，我们的 <strong>UI</strong> 订阅了两个 <a href="https://developer.android.com/topic/libraries/architecture/livedata">LiveData</a> 实例，因为我们从未删除前一个。 因此，这意味着每当我们的存储库更改用户的数据时，它都会发送两次订阅。 现在，我们如何解决这个问题……？</p><h5 id="SOLUTION"><a href="#SOLUTION" class="headerlink" title="SOLUTION:"></a>SOLUTION:</h5><p>What we actually need is a mechanism that allows us to stop observing from the previous source whenever we want to observe a new one. In order to this, we would use <em>[switchMap](<a href="https://developer.android.com/reference/android/arch/lifecycle/Transformations.html#switchMap">https://developer.android.com/reference/android/arch/lifecycle/Transformations.html#switchMap</a>(android.arch.lifecycle.LiveData, android.arch.core.util.Function&gt;)).</em> Under the hood, <em>[switchMap](<a href="https://developer.android.com/reference/android/arch/lifecycle/Transformations.html#switchMap">https://developer.android.com/reference/android/arch/lifecycle/Transformations.html#switchMap</a>(android.arch.lifecycle.LiveData, android.arch.core.util.Function&gt;))</em> uses the <a href="https://developer.android.com/reference/android/arch/lifecycle/MediatorLiveData">MediatorLiveData</a> that removes the initial source whenever the new source is added. In short, it does all the mechanism removing and adding a new <a href="https://developer.android.com/reference/android/arch/lifecycle/Observer">Observer</a> for us.</p><p>译文：</p><p>我们真正需要的是一种机制，当我们想观察一个新的来源时，它可以让我们停止从以前的来源观察。 为此，我们将使用 switchMap。 在底层，switchMap 使用 MediatorLiveData，只要添加了新源，它就会删除初始源。 简而言之，它为我们完成了删除和添加新观察者的所有机制。</p><p>Now our <a href="https://developer.android.com/topic/libraries/architecture/viewmodel">ViewModel</a> class will look like this.</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserRepo</span></span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">searchUserWithName</span><span class="hljs-params">(name  : <span class="hljs-type">String</span>)</span></span> : LiveData&lt;List&lt;User&gt;&gt;&#123;<br>         .... logic <span class="hljs-keyword">for</span> search user<br>   &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserViewModel</span> : <span class="hljs-type">ViewModel</span></span>() &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> query = MutableLiveData&lt;String&gt;()<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> userRepo = UserRepo()<br><br>    <span class="hljs-keyword">val</span> userNameResult: LiveData&lt;List&lt;User&gt;&gt; = Transformations.switchMap(<br>            query,<br>            ::temp<br>    )<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">temp</span><span class="hljs-params">(name: <span class="hljs-type">String</span>)</span></span> = userRepo.searchUserWithName(name)<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">searchUserByName</span><span class="hljs-params">(name: <span class="hljs-type">String</span>)</span></span> = apply &#123; query.value = name &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>All the code remain the same instead of the*[ switchMap](<a href="https://developer.android.com/reference/android/arch/lifecycle/Transformations.html#switchMap">https://developer.android.com/reference/android/arch/lifecycle/Transformations.html#switchMap</a>(android.arch.lifecycle.LiveData, android.arch.core.util.Function&gt;))* method. Now here we only need our <a href="https://developer.android.com/reference/android/app/Activity">Activity</a> class to observe this <a href="https://developer.android.com/topic/libraries/architecture/livedata">LiveData</a>. The following shows the <strong>MainActivity</strong> class.</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> MainActivity : <span class="hljs-constructor">AppCompatActivity()</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> userList: MutableList&lt;User&gt; = <span class="hljs-constructor">ArrayList()</span><br>    <span class="hljs-keyword">private</span> lateinit var userAdapter: UserAdapter<br><br>    override <span class="hljs-keyword">fun</span> on<span class="hljs-constructor">Create(<span class="hljs-params">savedInstanceState</span>: Bundle?)</span> &#123;<br>        super.on<span class="hljs-constructor">Create(<span class="hljs-params">savedInstanceState</span>)</span><br>        set<span class="hljs-constructor">ContentView(R.<span class="hljs-params">layout</span>.<span class="hljs-params">activity_main</span>)</span><br>        userRecyclerView.layoutManager = <span class="hljs-constructor">LinearLayoutManager(<span class="hljs-params">this</span>)</span><br>        userRecyclerView.set<span class="hljs-constructor">HasFixedSize(<span class="hljs-params">true</span>)</span><br>        userAdapter = <span class="hljs-constructor">UserAdapter(<span class="hljs-params">this</span>, <span class="hljs-params">userList</span>)</span><br>        userRecyclerView.adapter = userAdapter<br>        <span class="hljs-keyword">val</span> viewModel = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ViewModelProviders</span>.</span></span><span class="hljs-keyword">of</span>(this).get(UserViewModel::<span class="hljs-keyword">class</span>.java)<br>        searchUserButton.setOnClickListener &#123; viewModel.search<span class="hljs-constructor">UserByName(<span class="hljs-params">addNewEditText</span>.<span class="hljs-params">text</span>.<span class="hljs-params">toString</span>()</span>) &#125;<br>        viewModel.userNameResult.observe(this, Observer &#123;<br>            <span class="hljs-keyword">if</span> (userList.is<span class="hljs-constructor">NotEmpty()</span>)<br>                userList.clear<span class="hljs-literal">()</span><br>            userList.add<span class="hljs-constructor">All(<span class="hljs-params">it</span>!!)</span><br>            userAdapter.notify<span class="hljs-constructor">DataSetChanged()</span><br>        &#125;)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>The <a href="https://developer.android.com/reference/android/app/Activity">Activity</a> is very basic. After setting the <a href="https://developer.android.com/reference/android/support/v7/widget/RecyclerView">RecyclerView</a> properties, whenever the user clicks the button we’re calling our <a href="https://developer.android.com/topic/libraries/architecture/viewmodel">ViewModel</a> class function to search the users with a username. And in the last, we simply observing the <a href="https://developer.android.com/topic/libraries/architecture/livedata">LiveData</a> coming from our <a href="https://developer.android.com/topic/libraries/architecture/viewmodel">ViewModel</a> class.</p><p>Alright, guys, I’m going to end this blog here. You can also download the complete source code of the above example.</p><p><a href="https://github.com/CodingInfinite/LiveDataExample">Download Complete Code</a></p><p>If you’ve any queries regarding this post on Transformations or any problem with <a href="https://developer.android.com/topic/libraries/architecture/livedata">LiveData</a> please do comment below.</p><p>Thank you for being here and keep reading…</p>]]></content>
    
    
    
    <tags>
      
      <tag>android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>lru缓存</title>
    <link href="/posts/37ac4483/"/>
    <url>/posts/37ac4483/</url>
    
    <content type="html"><![CDATA[<p>这篇帖子先分析内存缓存是如何实现的。好吧开始进入正题。</p><p>　　BitmapUtils内存缓存的核心类LruMemoryCache，LruMemoryCache代码和v4包的LruCache一样，只是加了一个存储超期的处理，这里分析LruCache源码。LRU即Least Recently Used，近期最少使用算法。也就是当内存缓存达到设定的最大值时将内存缓存中近期最少使用的对象移除，有效的避免了OOM的出现。</p><p>​     讲到LruCache不得不提一下LinkedHashMap，因为LruCache中Lru算法的实现就是通过LinkedHashMap来实现的。LinkedHashMap继承于HashMap，它使用了一个双向链表来存储Map中的Entry顺序关系，这种顺序有两种，一种是LRU顺序，一种是插入顺序，这可以由其构造函数public LinkedHashMap(int initialCapacity,float loadFactor, boolean  accessOrder)指定。所以，对于get、put、remove等操作，LinkedHashMap除了要做HashMap做的事情，还做些调整Entry顺序链表的工作。LruCache中将LinkedHashMap的顺序设置为LRU顺序来实现LRU缓存，每次调用get(也就是从内存缓存中取图片)，则将该对象移到链表的尾端。调用put插入新的对象也是存储在链表尾端，这样当内存缓存达到设定的最大值时，将链表头部的对象（近期最少用到的）移除。关于LinkedHashMap详解请前往<a href="http://www.cnblogs.com/children/archive/2012/10/02/2710624.html%E3%80%82">http://www.cnblogs.com/children/archive/2012/10/02/2710624.html。</a></p><p>​    下面看下LruCache的源码，我都注释的很详细了。</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">  <span class="hljs-number">1</span> <span class="hljs-comment">/*</span><br><span class="hljs-comment">  2  * Copyright (C) 2011 The Android Open Source Project</span><br><span class="hljs-comment">  3  *</span><br><span class="hljs-comment">  4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span><br><span class="hljs-comment">  5  * you may not use this file except in compliance with the License.</span><br><span class="hljs-comment">  6  * You may obtain a copy of the License at</span><br><span class="hljs-comment">  7  *</span><br><span class="hljs-comment">  8  *      http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="hljs-comment">  9  *</span><br><span class="hljs-comment"> 10  * Unless required by applicable law or agreed to in writing, software</span><br><span class="hljs-comment"> 11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span><br><span class="hljs-comment"> 12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="hljs-comment"> 13  * See the License for the specific language governing permissions and</span><br><span class="hljs-comment"> 14  * limitations under the License.</span><br><span class="hljs-comment"> 15  */</span><br> <span class="hljs-number">16</span> <br> <span class="hljs-number">17</span> <span class="hljs-keyword">package</span> android.support.v4.util;<br> <span class="hljs-number">18</span> <br> <span class="hljs-number">19</span> <span class="hljs-keyword">import</span> java.util.LinkedHashMap;<br> <span class="hljs-number">20</span> <span class="hljs-keyword">import</span> java.util.Map;<br> <span class="hljs-number">21</span> <br> <span class="hljs-number">22</span> <span class="hljs-comment">/**</span><br><span class="hljs-comment"> 23  * Static library version of &#123;<span class="hljs-doctag">@link</span> android.util.LruCache&#125;. Used to write apps</span><br><span class="hljs-comment"> 24  * that run on API levels prior to 12. When running on API level 12 or above,</span><br><span class="hljs-comment"> 25  * this implementation is still used; it does not try to switch to the</span><br><span class="hljs-comment"> 26  * framework&#x27;s implementation. See the framework SDK documentation for a class</span><br><span class="hljs-comment"> 27  * overview.</span><br><span class="hljs-comment"> 28  */</span><br> <span class="hljs-number">29</span> <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LruCache</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt; </span>&#123;<br> <span class="hljs-number">30</span>     <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> LinkedHashMap&lt;K, V&gt; map;<br> <span class="hljs-number">31</span> <br> <span class="hljs-number">32</span>     <span class="hljs-comment">/** Size of this cache in units. Not necessarily the number of elements. */</span><br> <span class="hljs-number">33</span>     <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;    <span class="hljs-comment">//当前cache的大小</span><br> <span class="hljs-number">34</span>     <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> maxSize; <span class="hljs-comment">//cache最大大小</span><br> <span class="hljs-number">35</span> <br> <span class="hljs-number">36</span>     <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> putCount;       <span class="hljs-comment">//put的次数</span><br> <span class="hljs-number">37</span>     <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> createCount;    <span class="hljs-comment">//create的次数</span><br> <span class="hljs-number">38</span>     <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> evictionCount;  <span class="hljs-comment">//回收的次数</span><br> <span class="hljs-number">39</span>     <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> hitCount;       <span class="hljs-comment">//命中的次数</span><br> <span class="hljs-number">40</span>     <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> missCount;      <span class="hljs-comment">//未命中次数</span><br> <span class="hljs-number">41</span> <br> <span class="hljs-number">42</span>     <span class="hljs-comment">/**</span><br><span class="hljs-comment"> 43      * <span class="hljs-doctag">@param</span> maxSize for caches that do not override &#123;<span class="hljs-doctag">@link</span> #sizeOf&#125;, this is</span><br><span class="hljs-comment"> 44      *     the maximum number of entries in the cache. For all other caches,</span><br><span class="hljs-comment"> 45      *     this is the maximum sum of the sizes of the entries in this cache.</span><br><span class="hljs-comment"> 46      */</span><br> <span class="hljs-number">47</span>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LruCache</span><span class="hljs-params">(<span class="hljs-keyword">int</span> maxSize)</span> </span>&#123;<br> <span class="hljs-function">48         <span class="hljs-title">if</span> <span class="hljs-params">(maxSize &lt;= <span class="hljs-number">0</span>)</span> </span>&#123;<br> <span class="hljs-number">49</span>             <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;maxSize &lt;= 0&quot;</span>);<br> <span class="hljs-number">50</span>         &#125;<br> <span class="hljs-number">51</span>         <span class="hljs-keyword">this</span>.maxSize = maxSize;<br> <span class="hljs-number">52</span>         <span class="hljs-comment">//将LinkedHashMap的accessOrder设置为true来实现LRU</span><br> <span class="hljs-number">53</span>         <span class="hljs-keyword">this</span>.map = <span class="hljs-keyword">new</span> LinkedHashMap&lt;K, V&gt;(<span class="hljs-number">0</span>, <span class="hljs-number">0.75</span>f, <span class="hljs-keyword">true</span>);  <br> <span class="hljs-number">54</span>     &#125;<br> <span class="hljs-number">55</span> <br> <span class="hljs-number">56</span>     <span class="hljs-comment">/**</span><br><span class="hljs-comment"> 57      * Returns the value for &#123;<span class="hljs-doctag">@code</span> key&#125; if it exists in the cache or can be</span><br><span class="hljs-comment"> 58      * created by &#123;<span class="hljs-doctag">@code</span> #create&#125;. If a value was returned, it is moved to the</span><br><span class="hljs-comment"> 59      * head of the queue. This returns null if a value is not cached and cannot</span><br><span class="hljs-comment"> 60      * be created.</span><br><span class="hljs-comment"> 61      * 通过key获取相应的item，或者创建返回相应的item。相应的item会移动到队列的尾部，</span><br><span class="hljs-comment"> 62      * 如果item的value没有被cache或者不能被创建，则返回null。</span><br><span class="hljs-comment"> 63      */</span><br> <span class="hljs-number">64</span>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-function">V <span class="hljs-title">get</span><span class="hljs-params">(K key)</span> </span>&#123;<br> <span class="hljs-function">65         <span class="hljs-title">if</span> <span class="hljs-params">(key == <span class="hljs-keyword">null</span>)</span> </span>&#123;<br> <span class="hljs-number">66</span>             <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">&quot;key == null&quot;</span>);<br> <span class="hljs-number">67</span>         &#125;<br> <span class="hljs-number">68</span> <br> <span class="hljs-number">69</span>         V mapValue;<br> <span class="hljs-function">70         <span class="hljs-title">synchronized</span> <span class="hljs-params">(<span class="hljs-keyword">this</span>)</span> </span>&#123;<br> <span class="hljs-number">71</span>             mapValue = map.get(key);<br> <span class="hljs-function">72             <span class="hljs-title">if</span> <span class="hljs-params">(mapValue != <span class="hljs-keyword">null</span>)</span> </span>&#123;<br> <span class="hljs-number">73</span>                 <span class="hljs-comment">//mapValue不为空表示命中，hitCount+1并返回mapValue对象</span><br> <span class="hljs-number">74</span>                 hitCount++;<br> <span class="hljs-number">75</span>                 <span class="hljs-keyword">return</span> mapValue;<br> <span class="hljs-number">76</span>             &#125;<br> <span class="hljs-number">77</span>             missCount++;  <span class="hljs-comment">//未命中</span><br> <span class="hljs-number">78</span>         &#125;<br> <span class="hljs-number">79</span> <br> <span class="hljs-number">80</span>         <span class="hljs-comment">/*</span><br><span class="hljs-comment"> 81          * Attempt to create a value. This may take a long time, and the map</span><br><span class="hljs-comment"> 82          * may be different when create() returns. If a conflicting value was</span><br><span class="hljs-comment"> 83          * added to the map while create() was working, we leave that value in</span><br><span class="hljs-comment"> 84          * the map and release the created value.</span><br><span class="hljs-comment"> 85          * 如果未命中，则试图创建一个对象，这里create方法返回null,并没有实现创建对象的方法</span><br><span class="hljs-comment"> 86          * 如果需要事项创建对象的方法可以重写create方法。因为图片缓存时内存缓存没有命中会去</span><br><span class="hljs-comment"> 87          * 文件缓存中去取或者从网络下载，所以并不需要创建。</span><br><span class="hljs-comment"> 88          */</span><br> <span class="hljs-number">89</span>         V createdValue = create(key);<br> <span class="hljs-function">90         <span class="hljs-title">if</span> <span class="hljs-params">(createdValue == <span class="hljs-keyword">null</span>)</span> </span>&#123;<br> <span class="hljs-number">91</span>             <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br> <span class="hljs-number">92</span>         &#125;<br> <span class="hljs-number">93</span>         <span class="hljs-comment">//假如创建了新的对象，则继续往下执行</span><br> <span class="hljs-function">94         <span class="hljs-title">synchronized</span> <span class="hljs-params">(<span class="hljs-keyword">this</span>)</span> </span>&#123;<br> <span class="hljs-number">95</span>             createCount++;  <br> <span class="hljs-number">96</span>             <span class="hljs-comment">//将createdValue加入到map中，并且将原来键为key的对象保存到mapValue</span><br> <span class="hljs-number">97</span>             mapValue = map.put(key, createdValue);   <br> <span class="hljs-function">98             <span class="hljs-title">if</span> <span class="hljs-params">(mapValue != <span class="hljs-keyword">null</span>)</span> </span>&#123;<br> <span class="hljs-number">99</span>                 <span class="hljs-comment">// There was a conflict so undo that last put</span><br><span class="hljs-number">100</span>                 <span class="hljs-comment">//如果mapValue不为空，则撤销上一步的put操作。</span><br><span class="hljs-function">101                 map.<span class="hljs-title">put</span><span class="hljs-params">(key, mapValue)</span></span>;<br><span class="hljs-number">102</span>             &#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-number">103</span>                 <span class="hljs-comment">//加入新创建的对象之后需要重新计算size大小</span><br><span class="hljs-number">104</span>                 size += safeSizeOf(key, createdValue);<br><span class="hljs-number">105</span>             &#125;<br><span class="hljs-number">106</span>         &#125;<br><span class="hljs-number">107</span> <br><span class="hljs-function">108         <span class="hljs-title">if</span> <span class="hljs-params">(mapValue != <span class="hljs-keyword">null</span>)</span> </span>&#123;<br><span class="hljs-function">109             <span class="hljs-title">entryRemoved</span><span class="hljs-params">(<span class="hljs-keyword">false</span>, key, createdValue, mapValue)</span></span>;<br><span class="hljs-number">110</span>             <span class="hljs-keyword">return</span> mapValue;<br><span class="hljs-number">111</span>         &#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-number">112</span>             <span class="hljs-comment">//每次新加入对象都需要调用trimToSize方法看是否需要回收</span><br><span class="hljs-function">113             <span class="hljs-title">trimToSize</span><span class="hljs-params">(maxSize)</span></span>;<br><span class="hljs-number">114</span>             <span class="hljs-keyword">return</span> createdValue;<br><span class="hljs-number">115</span>         &#125;<br><span class="hljs-number">116</span>     &#125;<br><span class="hljs-number">117</span> <br><span class="hljs-number">118</span>     <span class="hljs-comment">/**</span><br><span class="hljs-comment">119      * Caches &#123;<span class="hljs-doctag">@code</span> value&#125; for &#123;<span class="hljs-doctag">@code</span> key&#125;. The value is moved to the head of</span><br><span class="hljs-comment">120      * the queue.</span><br><span class="hljs-comment">121      *</span><br><span class="hljs-comment">122      * <span class="hljs-doctag">@return</span> the previous value mapped by &#123;<span class="hljs-doctag">@code</span> key&#125;.</span><br><span class="hljs-comment">123      */</span><br><span class="hljs-number">124</span>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-function">V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;<br><span class="hljs-function">125         <span class="hljs-title">if</span> <span class="hljs-params">(key == <span class="hljs-keyword">null</span> || value == <span class="hljs-keyword">null</span>)</span> </span>&#123;<br><span class="hljs-number">126</span>             <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">&quot;key == null || value == null&quot;</span>);<br><span class="hljs-number">127</span>         &#125;<br><span class="hljs-number">128</span> <br><span class="hljs-number">129</span>         V previous;<br><span class="hljs-function">130         <span class="hljs-title">synchronized</span> <span class="hljs-params">(<span class="hljs-keyword">this</span>)</span> </span>&#123;<br><span class="hljs-number">131</span>             putCount++;<br><span class="hljs-number">132</span>             size += safeSizeOf(key, value);  <span class="hljs-comment">//size加上预put对象的大小</span><br><span class="hljs-number">133</span>             previous = map.put(key, value);<br><span class="hljs-function">134             <span class="hljs-title">if</span> <span class="hljs-params">(previous != <span class="hljs-keyword">null</span>)</span> </span>&#123;<br><span class="hljs-number">135</span>                 <span class="hljs-comment">//如果之前存在键为key的对象，则size应该减去原来对象的大小</span><br><span class="hljs-number">136</span>                 size -= safeSizeOf(key, previous);<br><span class="hljs-number">137</span>             &#125;<br><span class="hljs-number">138</span>         &#125;<br><span class="hljs-number">139</span> <br><span class="hljs-function">140         <span class="hljs-title">if</span> <span class="hljs-params">(previous != <span class="hljs-keyword">null</span>)</span> </span>&#123;<br><span class="hljs-function">141             <span class="hljs-title">entryRemoved</span><span class="hljs-params">(<span class="hljs-keyword">false</span>, key, previous, value)</span></span>;<br><span class="hljs-number">142</span>         &#125;<br><span class="hljs-number">143</span>         <span class="hljs-comment">//每次新加入对象都需要调用trimToSize方法看是否需要回收</span><br><span class="hljs-function">144         <span class="hljs-title">trimToSize</span><span class="hljs-params">(maxSize)</span></span>;<br><span class="hljs-number">145</span>         <span class="hljs-keyword">return</span> previous;<br><span class="hljs-number">146</span>     &#125;<br><span class="hljs-number">147</span> <br><span class="hljs-number">148</span>     <span class="hljs-comment">/**</span><br><span class="hljs-comment">149      * <span class="hljs-doctag">@param</span> maxSize the maximum size of the cache before returning. May be -1</span><br><span class="hljs-comment">150      *     to evict even 0-sized elements.</span><br><span class="hljs-comment">151      * 此方法根据maxSize来调整内存cache的大小，如果maxSize传入-1，则清空缓存中的所有对象</span><br><span class="hljs-comment">152      */</span><br><span class="hljs-number">153</span>     <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">trimToSize</span><span class="hljs-params">(<span class="hljs-keyword">int</span> maxSize)</span> </span>&#123;<br><span class="hljs-function">154         <span class="hljs-title">while</span> <span class="hljs-params">(<span class="hljs-keyword">true</span>)</span> </span>&#123;<br><span class="hljs-number">155</span>             K key;<br><span class="hljs-number">156</span>             V value;<br><span class="hljs-function">157             <span class="hljs-title">synchronized</span> <span class="hljs-params">(<span class="hljs-keyword">this</span>)</span> </span>&#123;<br><span class="hljs-number">158</span>                 <span class="hljs-keyword">if</span> (size &lt; <span class="hljs-number">0</span> || (map.isEmpty() &amp;&amp; size != <span class="hljs-number">0</span>)) &#123;<br><span class="hljs-number">159</span>                     <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(getClass().getName()<br><span class="hljs-number">160</span>                             + <span class="hljs-string">&quot;.sizeOf() is reporting inconsistent results!&quot;</span>);<br><span class="hljs-number">161</span>                 &#125;<br><span class="hljs-number">162</span>                 <span class="hljs-comment">//如果当前size小于maxSize或者map没有任何对象,则结束循环</span><br><span class="hljs-number">163</span>                 <span class="hljs-keyword">if</span> (size &lt;= maxSize || map.isEmpty()) &#123;<br><span class="hljs-number">164</span>                     <span class="hljs-keyword">break</span>;<br><span class="hljs-number">165</span>                 &#125;<br><span class="hljs-number">166</span>                 <span class="hljs-comment">//移除链表头部的元素，并进入下一次循环</span><br><span class="hljs-number">167</span>                 Map.Entry&lt;K, V&gt; toEvict = map.entrySet().iterator().next();<br><span class="hljs-number">168</span>                 key = toEvict.getKey();<br><span class="hljs-number">169</span>                 value = toEvict.getValue();<br><span class="hljs-function">170                 map.<span class="hljs-title">remove</span><span class="hljs-params">(key)</span></span>;<br><span class="hljs-number">171</span>                 size -= safeSizeOf(key, value);<br><span class="hljs-number">172</span>                 evictionCount++;  <span class="hljs-comment">//回收次数+1</span><br><span class="hljs-number">173</span>             &#125;<br><span class="hljs-number">174</span> <br><span class="hljs-function">175             <span class="hljs-title">entryRemoved</span><span class="hljs-params">(<span class="hljs-keyword">true</span>, key, value, <span class="hljs-keyword">null</span>)</span></span>;<br><span class="hljs-number">176</span>         &#125;<br><span class="hljs-number">177</span>     &#125;<br><span class="hljs-number">178</span> <br><span class="hljs-number">179</span>     <span class="hljs-comment">/**</span><br><span class="hljs-comment">180      * Removes the entry for &#123;<span class="hljs-doctag">@code</span> key&#125; if it exists.</span><br><span class="hljs-comment">181      *</span><br><span class="hljs-comment">182      * <span class="hljs-doctag">@return</span> the previous value mapped by &#123;<span class="hljs-doctag">@code</span> key&#125;.</span><br><span class="hljs-comment">183      * 从内存缓存中根据key值移除某个对象并返回该对象</span><br><span class="hljs-comment">184      */</span><br><span class="hljs-number">185</span>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-function">V <span class="hljs-title">remove</span><span class="hljs-params">(K key)</span> </span>&#123;<br><span class="hljs-function">186         <span class="hljs-title">if</span> <span class="hljs-params">(key == <span class="hljs-keyword">null</span>)</span> </span>&#123;<br><span class="hljs-number">187</span>             <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">&quot;key == null&quot;</span>);<br><span class="hljs-number">188</span>         &#125;<br><span class="hljs-number">189</span> <br><span class="hljs-number">190</span>         V previous;<br><span class="hljs-function">191         <span class="hljs-title">synchronized</span> <span class="hljs-params">(<span class="hljs-keyword">this</span>)</span> </span>&#123;<br><span class="hljs-number">192</span>             previous = map.remove(key);<br><span class="hljs-function">193             <span class="hljs-title">if</span> <span class="hljs-params">(previous != <span class="hljs-keyword">null</span>)</span> </span>&#123;<br><span class="hljs-number">194</span>                 size -= safeSizeOf(key, previous);<br><span class="hljs-number">195</span>             &#125;<br><span class="hljs-number">196</span>         &#125;<br><span class="hljs-number">197</span> <br><span class="hljs-function">198         <span class="hljs-title">if</span> <span class="hljs-params">(previous != <span class="hljs-keyword">null</span>)</span> </span>&#123;<br><span class="hljs-function">199             <span class="hljs-title">entryRemoved</span><span class="hljs-params">(<span class="hljs-keyword">false</span>, key, previous, <span class="hljs-keyword">null</span>)</span></span>;<br><span class="hljs-number">200</span>         &#125;<br><span class="hljs-number">201</span> <br><span class="hljs-number">202</span>         <span class="hljs-keyword">return</span> previous;<br><span class="hljs-number">203</span>     &#125;<br><span class="hljs-number">204</span> <br><span class="hljs-number">205</span>     <span class="hljs-comment">/**</span><br><span class="hljs-comment">206      * Called for entries that have been evicted or removed. This method is</span><br><span class="hljs-comment">207      * invoked when a value is evicted to make space, removed by a call to</span><br><span class="hljs-comment">208      * &#123;<span class="hljs-doctag">@link</span> #remove&#125;, or replaced by a call to &#123;<span class="hljs-doctag">@link</span> #put&#125;. The default</span><br><span class="hljs-comment">209      * implementation does nothing.</span><br><span class="hljs-comment">210      *</span><br><span class="hljs-comment">211      * &lt;p&gt;The method is called without synchronization: other threads may</span><br><span class="hljs-comment">212      * access the cache while this method is executing.</span><br><span class="hljs-comment">213      *</span><br><span class="hljs-comment">214      * <span class="hljs-doctag">@param</span> evicted true if the entry is being removed to make space, false</span><br><span class="hljs-comment">215      *     if the removal was caused by a &#123;<span class="hljs-doctag">@link</span> #put&#125; or &#123;<span class="hljs-doctag">@link</span> #remove&#125;.</span><br><span class="hljs-comment">216      * <span class="hljs-doctag">@param</span> newValue the new value for &#123;<span class="hljs-doctag">@code</span> key&#125;, if it exists. If non-null,</span><br><span class="hljs-comment">217      *     this removal was caused by a &#123;<span class="hljs-doctag">@link</span> #put&#125;. Otherwise it was caused by</span><br><span class="hljs-comment">218      *     an eviction or a &#123;<span class="hljs-doctag">@link</span> #remove&#125;.</span><br><span class="hljs-comment">219      */</span><br><span class="hljs-number">220</span>     <span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">entryRemoved</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> evicted, K key, V oldValue, V newValue)</span> </span>&#123;&#125;<br><span class="hljs-number">221</span> <br><span class="hljs-number">222</span>     <span class="hljs-comment">/**</span><br><span class="hljs-comment">223      * Called after a cache miss to compute a value for the corresponding key.</span><br><span class="hljs-comment">224      * Returns the computed value or null if no value can be computed. The</span><br><span class="hljs-comment">225      * default implementation returns null.</span><br><span class="hljs-comment">226      *</span><br><span class="hljs-comment">227      * &lt;p&gt;The method is called without synchronization: other threads may</span><br><span class="hljs-comment">228      * access the cache while this method is executing.</span><br><span class="hljs-comment">229      *</span><br><span class="hljs-comment">230      * &lt;p&gt;If a value for &#123;<span class="hljs-doctag">@code</span> key&#125; exists in the cache when this method</span><br><span class="hljs-comment">231      * returns, the created value will be released with &#123;<span class="hljs-doctag">@link</span> #entryRemoved&#125;</span><br><span class="hljs-comment">232      * and discarded. This can occur when multiple threads request the same key</span><br><span class="hljs-comment">233      * at the same time (causing multiple values to be created), or when one</span><br><span class="hljs-comment">234      * thread calls &#123;<span class="hljs-doctag">@link</span> #put&#125; while another is creating a value for the same</span><br><span class="hljs-comment">235      * key.</span><br><span class="hljs-comment">236      */</span><br><span class="hljs-number">237</span>     <span class="hljs-keyword">protected</span> <span class="hljs-function">V <span class="hljs-title">create</span><span class="hljs-params">(K key)</span> </span>&#123;<br><span class="hljs-number">238</span>         <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br><span class="hljs-number">239</span>     &#125;<br><span class="hljs-number">240</span> <br><span class="hljs-number">241</span>     <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">safeSizeOf</span><span class="hljs-params">(K key, V value)</span> </span>&#123;<br><span class="hljs-number">242</span>         <span class="hljs-keyword">int</span> result = sizeOf(key, value);<br><span class="hljs-function">243         <span class="hljs-title">if</span> <span class="hljs-params">(result &lt; <span class="hljs-number">0</span>)</span> </span>&#123;<br><span class="hljs-number">244</span>             <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;Negative size: &quot;</span> + key + <span class="hljs-string">&quot;=&quot;</span> + value);<br><span class="hljs-number">245</span>         &#125;<br><span class="hljs-number">246</span>         <span class="hljs-keyword">return</span> result;<br><span class="hljs-number">247</span>     &#125;<br><span class="hljs-number">248</span> <br><span class="hljs-number">249</span>     <span class="hljs-comment">/**</span><br><span class="hljs-comment">250      * Returns the size of the entry for &#123;<span class="hljs-doctag">@code</span> key&#125; and &#123;<span class="hljs-doctag">@code</span> value&#125; in</span><br><span class="hljs-comment">251      * user-defined units.  The default implementation returns 1 so that size</span><br><span class="hljs-comment">252      * is the number of entries and max size is the maximum number of entries.</span><br><span class="hljs-comment">253      *</span><br><span class="hljs-comment">254      * &lt;p&gt;An entry&#x27;s size must not change while it is in the cache.</span><br><span class="hljs-comment">255      * 用来计算单个对象的大小，这里默认返回1，一般需要重写该方法来计算对象的大小</span><br><span class="hljs-comment">256      * xUtils中创建LruMemoryCache时就重写了sizeOf方法来计算bitmap的大小</span><br><span class="hljs-comment">257      * mMemoryCache = new LruMemoryCache&lt;MemoryCacheKey, Bitmap&gt;(globalConfig.getMemoryCacheSize()) &#123;</span><br><span class="hljs-comment">258      *       <span class="hljs-doctag">@Override</span></span><br><span class="hljs-comment">259      *       protected int sizeOf(MemoryCacheKey key, Bitmap bitmap) &#123;</span><br><span class="hljs-comment">260      *           if (bitmap == null) return 0;</span><br><span class="hljs-comment">261      *           return bitmap.getRowBytes() * bitmap.getHeight();</span><br><span class="hljs-comment">262      *       &#125;</span><br><span class="hljs-comment">263      *   &#125;;</span><br><span class="hljs-comment">264      *</span><br><span class="hljs-comment">265      */</span><br><span class="hljs-number">266</span>     <span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sizeOf</span><span class="hljs-params">(K key, V value)</span> </span>&#123;<br><span class="hljs-number">267</span>         <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-number">268</span>     &#125;<br><span class="hljs-number">269</span> <br><span class="hljs-number">270</span>     <span class="hljs-comment">/**</span><br><span class="hljs-comment">271      * Clear the cache, calling &#123;<span class="hljs-doctag">@link</span> #entryRemoved&#125; on each removed entry.</span><br><span class="hljs-comment">272      * 清空内存缓存</span><br><span class="hljs-comment">273      */</span><br><span class="hljs-number">274</span>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">evictAll</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-function">275         <span class="hljs-title">trimToSize</span><span class="hljs-params">(<span class="hljs-number">-1</span>)</span></span>; <span class="hljs-comment">// -1 will evict 0-sized elements</span><br><span class="hljs-number">276</span>     &#125;<br><span class="hljs-number">277</span> <br><span class="hljs-number">278</span>     <span class="hljs-comment">/**</span><br><span class="hljs-comment">279      * For caches that do not override &#123;<span class="hljs-doctag">@link</span> #sizeOf&#125;, this returns the number</span><br><span class="hljs-comment">280      * of entries in the cache. For all other caches, this returns the sum of</span><br><span class="hljs-comment">281      * the sizes of the entries in this cache.</span><br><span class="hljs-comment">282      */</span><br><span class="hljs-number">283</span>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">final</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-number">284</span>         <span class="hljs-keyword">return</span> size;<br><span class="hljs-number">285</span>     &#125;<br><span class="hljs-number">286</span> <br><span class="hljs-number">287</span>     <span class="hljs-comment">/**</span><br><span class="hljs-comment">288      * For caches that do not override &#123;<span class="hljs-doctag">@link</span> #sizeOf&#125;, this returns the maximum</span><br><span class="hljs-comment">289      * number of entries in the cache. For all other caches, this returns the</span><br><span class="hljs-comment">290      * maximum sum of the sizes of the entries in this cache.</span><br><span class="hljs-comment">291      */</span><br><span class="hljs-number">292</span>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">final</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxSize</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-number">293</span>         <span class="hljs-keyword">return</span> maxSize;<br><span class="hljs-number">294</span>     &#125;<br><span class="hljs-number">295</span> <br><span class="hljs-number">296</span>     <span class="hljs-comment">/**</span><br><span class="hljs-comment">297      * Returns the number of times &#123;<span class="hljs-doctag">@link</span> #get&#125; returned a value.</span><br><span class="hljs-comment">298      */</span><br><span class="hljs-number">299</span>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">final</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hitCount</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-number">300</span>         <span class="hljs-keyword">return</span> hitCount;<br><span class="hljs-number">301</span>     &#125;<br><span class="hljs-number">302</span> <br><span class="hljs-number">303</span>     <span class="hljs-comment">/**</span><br><span class="hljs-comment">304      * Returns the number of times &#123;<span class="hljs-doctag">@link</span> #get&#125; returned null or required a new</span><br><span class="hljs-comment">305      * value to be created.</span><br><span class="hljs-comment">306      */</span><br><span class="hljs-number">307</span>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">final</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">missCount</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-number">308</span>         <span class="hljs-keyword">return</span> missCount;<br><span class="hljs-number">309</span>     &#125;<br><span class="hljs-number">310</span> <br><span class="hljs-number">311</span>     <span class="hljs-comment">/**</span><br><span class="hljs-comment">312      * Returns the number of times &#123;<span class="hljs-doctag">@link</span> #create(Object)&#125; returned a value.</span><br><span class="hljs-comment">313      */</span><br><span class="hljs-number">314</span>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">final</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">createCount</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-number">315</span>         <span class="hljs-keyword">return</span> createCount;<br><span class="hljs-number">316</span>     &#125;<br><span class="hljs-number">317</span> <br><span class="hljs-number">318</span>     <span class="hljs-comment">/**</span><br><span class="hljs-comment">319      * Returns the number of times &#123;<span class="hljs-doctag">@link</span> #put&#125; was called.</span><br><span class="hljs-comment">320      */</span><br><span class="hljs-number">321</span>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">final</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">putCount</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-number">322</span>         <span class="hljs-keyword">return</span> putCount;<br><span class="hljs-number">323</span>     &#125;<br><span class="hljs-number">324</span> <br><span class="hljs-number">325</span>     <span class="hljs-comment">/**</span><br><span class="hljs-comment">326      * Returns the number of values that have been evicted.</span><br><span class="hljs-comment">327      */</span><br><span class="hljs-number">328</span>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">final</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">evictionCount</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-number">329</span>         <span class="hljs-keyword">return</span> evictionCount;<br><span class="hljs-number">330</span>     &#125;<br><span class="hljs-number">331</span> <br><span class="hljs-number">332</span>     <span class="hljs-comment">/**</span><br><span class="hljs-comment">333      * Returns a copy of the current contents of the cache, ordered from least</span><br><span class="hljs-comment">334      * recently accessed to most recently accessed.</span><br><span class="hljs-comment">335      */</span><br><span class="hljs-number">336</span>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">final</span> Map&lt;K, V&gt; snapshot() &#123;<br><span class="hljs-number">337</span>         <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LinkedHashMap&lt;K, V&gt;(map);<br><span class="hljs-number">338</span>     &#125;<br><span class="hljs-number">339</span> <br><span class="hljs-number">340</span>     <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">final</span> <span class="hljs-function">String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-number">341</span>         <span class="hljs-keyword">int</span> accesses = hitCount + missCount;<br><span class="hljs-number">342</span>         <span class="hljs-keyword">int</span> hitPercent = accesses != <span class="hljs-number">0</span> ? (<span class="hljs-number">100</span> * hitCount / accesses) : 0;<br><span class="hljs-number">343</span>         <span class="hljs-function"><span class="hljs-keyword">return</span> String.<span class="hljs-title">format</span><span class="hljs-params">(<span class="hljs-string">&quot;LruCache[maxSize=%d,hits=%d,misses=%d,hitRate=%d%%]&quot;</span>,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-number">344</span>                 maxSize, hitCount, missCount, hitPercent)</span></span>;<br><span class="hljs-number">345</span>     &#125;<br><span class="hljs-number">346</span> &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ssh使用</title>
    <link href="/posts/f4bf1653/"/>
    <url>/posts/f4bf1653/</url>
    
    <content type="html"><![CDATA[<h1 id="实践原理："><a href="#实践原理：" class="headerlink" title="实践原理："></a>实践原理：</h1><p>读者一定很好奇SSH认证的流程，这里给出一张粗陋的图简单解释一下：</p><p><img src="TyporaRaw/SSH%E4%BD%BF%E7%94%A8.assets/1200.jpeg" alt="img"></p><p>如果我们事先在服务器中存储了USER1的公钥(后面会讲解如何做)，则USER1发起SSH连接服务器的流程如下：</p><ul><li>1.USER1发起SSH请求</li><li>2.服务器生成随机数R1发给USER1，USER1用私钥加密生成R2。</li><li>3.USER1把R2回发给服务器，服务器用公钥解密并对比R1，相同则成功连接。</li></ul><p>其实很简单，但是如果还不懂，没有关系，可以先做一遍，再会过头来看，让我们开始吧。</p><h2 id="实践步骤1：生成密钥对"><a href="#实践步骤1：生成密钥对" class="headerlink" title="实践步骤1：生成密钥对"></a>实践步骤1：生成密钥对</h2><p>读者可能有两个疑惑：</p><h3 id="第一，生成的密钥对应当放在何处？"><a href="#第一，生成的密钥对应当放在何处？" class="headerlink" title="第一，生成的密钥对应当放在何处？"></a>第一，生成的密钥对应当放在何处？</h3><p>因为密钥一定要牢牢把握在自己手中，不能让别人知道。所以我们一定要在自己的物理机上生成密钥对，千万不能在远程计算机上生成，否则就不符合密钥的定义了。</p><h3 id="第二，如何生成密钥对？"><a href="#第二，如何生成密钥对？" class="headerlink" title="第二，如何生成密钥对？"></a>第二，如何生成密钥对？</h3><ol><li><p>在本机终端运行<code>ssh-keygen</code>命令, 即可生成一对默认的RSA密钥。使用<code> -t</code>命令指定密钥类型， 使用<code>-f</code> 选项指定生成文件的文件名具体可以通过<code>man ssh-keygen</code>查看。我们用默认的RSA密钥即可: <code>ssh-keygen -t rsa</code>。</p></li><li><p>然后自己输入保存的路径和文件名，推荐保存到home目录的.ssh文件夹下。</p></li><li><p>输入管理密码(不建议为空，并且需记住)。注意，这里的密码是防止别人用你的电脑SSH无密码登陆远程服务器，可以理解成开机密码，可防止别人乱动你的电脑。</p></li></ol><h3 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h3><p>生成ssh key的时候，可以通过 <code>-f</code> 选项指定生成文件的文件名，如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ssh-keygen -t rsa -f <span class="hljs-built_in">test</span>   -C <span class="hljs-string">&quot;test key&quot;</span><br>                     ~~文件名   ~~~~ 备注<br></code></pre></td></tr></table></figure><p>如果没有指定文件名，会询问你输入文件名:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">$ ssh-keygen<br>Generating public/private rsa key pair.<br>Enter file in which to save the key (/home/huqiu/.ssh/id_rsa):<br></code></pre></td></tr></table></figure><p>你可以输入你想要的文件名，这里我们输入<code>test</code>。</p><h4 id="密码"><a href="#密码" class="headerlink" title="密码"></a>密码</h4><p>之后，会询问你是否需要输入密码。输入密码之后，以后每次都要输入密码。请根据你的安全需要决定是否需要密码，如果不需要，直接回车:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ssh-keygen -t rsa -f <span class="hljs-built_in">test</span> -C <span class="hljs-string">&quot;test key&quot;</span><br>Generating public/private rsa key pair.<br>Enter passphrase (empty <span class="hljs-keyword">for</span> no passphrase):<br>Enter same passphrase again:<br></code></pre></td></tr></table></figure><h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><p>如果文件名是<code>test</code>，结果是:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ll <span class="hljs-built_in">test</span>*<br>-rw------- 1 username username 1675 Sep 15 13:24 <span class="hljs-built_in">test</span><br>-rw-r--r-- 1 username username  390 Sep 15 13:24 test.pub<br></code></pre></td></tr></table></figure><h4 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h4><p>上面生成的命令中，<code>-C</code>选项是公钥文件中的备注:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ cat test.pub<br>ssh-rsa<br>。。。。省略。。。。== <span class="hljs-built_in">test</span> key<br>                 ~~~~备注<br></code></pre></td></tr></table></figure><h4 id="文件的权限"><a href="#文件的权限" class="headerlink" title="文件的权限"></a>文件的权限</h4><p>为了让私钥文件和公钥文件能够在认证中起作用，请确保权限正确。</p><p>对于<code>.ssh</code> 以及父文件夹，当前用户用户一定要有执行权限，其他用户最多只能有执行权限。</p><p>对于公钥和私钥文件也是: 当前用户一定要有执行权限，其他用户最多只能有执行权限。</p><blockquote><p>对于利用公钥登录，对其他用户配置执行权限是没有问题的。但是对于git，公钥和私钥, 以及config等相关文件的权限，其他用户不可有任何权限。</p></blockquote><h2 id="实践步骤2：把公钥内容复制到服务器的认证列表中"><a href="#实践步骤2：把公钥内容复制到服务器的认证列表中" class="headerlink" title="实践步骤2：把公钥内容复制到服务器的认证列表中"></a>实践步骤2：把公钥内容复制到服务器的认证列表中</h2><p>这里读者可能又有三个问题。</p><h4 id="第一，什么是服务器认证列表？"><a href="#第一，什么是服务器认证列表？" class="headerlink" title="第一，什么是服务器认证列表？"></a>第一，什么是服务器认证列表？</h4><p>服务器认证列表是一个文件，可以理解为&lt;存储用户SSH公钥的地方&gt;，因为SSH是一个验证过程，所以服务器需要事先保存对方的公钥，这样管理员就可以指定哪些用户(准确说是密钥对)可以登录了。</p><h4 id="第二，认证列表的路径是什么？"><a href="#第二，认证列表的路径是什么？" class="headerlink" title="第二，认证列表的路径是什么？"></a>第二，认证列表的路径是什么？</h4><p>在服务器的配置文件<code>/etc/ssh/sshd_config</code>中记录的着认证列表的目录。</p><p>首先, 我们可以先进入服务器(若没有设置SSH登陆只能用密码登陆)，然后进入此路径查看：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">cd <span class="hljs-regexp">/etc/</span>ssh<br>cat sshd_config<br></code></pre></td></tr></table></figure><p>sshd_config文件示例：</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs vala">。。。省略<br><br><span class="hljs-meta">#LoginGraceTime 2m</span><br><span class="hljs-meta"># 登录宽限期</span><br>PermitRootLogin no<br><span class="hljs-meta">#PermitRootLogin值改为 prohibit-password 允许root登录，但是禁止root用密码登录。允许root登录，设为yes。不允许root登录，设为no。</span><br><span class="hljs-meta">#StrictModes yes</span><br><span class="hljs-meta"># 严格模式</span><br><span class="hljs-meta">#MaxAuthTries 6</span><br><span class="hljs-meta"># 最大验证次数</span><br><span class="hljs-meta">#MaxSessions 10</span><br><span class="hljs-meta"># 最大会话数</span><br><br><span class="hljs-meta"># PubkeyAuthentication yes</span><br><span class="hljs-meta"># 公钥认证</span><br><br><span class="hljs-meta"># The default is to check both .ssh/authorized_keys and .ssh/authorized_keys2</span><br><span class="hljs-meta"># but this is overridden so installations will only check .ssh/authorized_keys</span><br><span class="hljs-meta"># 默认是同时检查 .ssh/authorized_keys 和 .ssh/authorized_keys2</span><br><span class="hljs-meta"># 但这是被覆盖的，所以安装只会检查 .ssh/authorized_keys</span><br><br><br>AuthorizedKeysFile      .ssh/authorized_keys # 注意这一句！！！（<span class="hljs-number">1</span>）<br><br><br><span class="hljs-meta"># To disable tunneled clear text passwords, change to no here!</span><br><span class="hljs-meta"># 要禁用明文密码，请在此处更改为 no！</span><br>PasswordAuthentication no<br><span class="hljs-meta"># no是禁止用户密码登陆</span><br><span class="hljs-meta">#PermitEmptyPasswords no</span><br><span class="hljs-meta">#yes允许空密码 no不允许空密码</span><br><br>。。。省略<br></code></pre></td></tr></table></figure><p>（1）即<code>~/.ssh/authorized_keys</code>(注意，此文件不一定存在)</p><h4 id="第三，如何把公钥复制进认证列表？"><a href="#第三，如何把公钥复制进认证列表？" class="headerlink" title="第三，如何把公钥复制进认证列表？"></a>第三，如何把公钥复制进认证列表？</h4><p>首先，认证列表文件不一定存在，所以我们要先在远程服务器上执行创建命令, 并设置权限：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">mkdir .ssh  <span class="hljs-comment">//创建文件夹</span><br>touch .ssh/authorized_keys  <span class="hljs-comment">// 创建文件</span><br>chmod <span class="hljs-number">700</span> .ssh      <span class="hljs-comment">//设置权限</span><br>chmod <span class="hljs-number">644</span> .ssh/auauthorized_keys  <span class="hljs-comment">//设置权限</span><br></code></pre></td></tr></table></figure><p>然后用<code>nano</code>编辑器打开:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">nano ~<span class="hljs-regexp">/.ssh/</span>authorized_keys<br></code></pre></td></tr></table></figure><p>如果没设置过SSH的公钥，里面内容是为空的。如果设置过SSH公钥，则空行添加公钥。</p><p>最后把实践步骤1中生成的公钥内容复制粘贴到里面。可以采用文本打开复制，也可以用<code>nano</code>编辑器复制。这里演示方式为<code>nano</code>打开复制：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">nano ~<span class="hljs-regexp">/.ssh/</span>MyLinux.pub<br></code></pre></td></tr></table></figure><p>运行后复制粘贴到远程服务器的认证列表中退出保存即可：</p><p>这样我们就可以用SSH登陆了。</p><h2 id="实践步骤3：SSH远程连接Linux服务器"><a href="#实践步骤3：SSH远程连接Linux服务器" class="headerlink" title="实践步骤3：SSH远程连接Linux服务器"></a>实践步骤3：SSH远程连接Linux服务器</h2><p>一切设置都已完成，我们如何连接到远程服务器呢？<br> 命令格式如下：</p><p>1首先开启ssh <strong><code>systemctl start sshd</code>开启<code>sshd</code>服务</strong></p><p>2连接命令格式如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">ssh student<span class="hljs-keyword">@127</span>.0.0.1 -p <span class="hljs-number">2222</span> -i ~/.ssh/MyLinux<br></code></pre></td></tr></table></figure><p><img src="TyporaRaw/SSH%E4%BD%BF%E7%94%A8.assets/990.jpeg" alt="img"></p><ul><li>1表示ssh连接</li><li>2表示服务器上的用户名</li><li>3表示远程主机的host IP(这里是本机)</li><li>4表示远程主机端口(默认22，<a href="https://link.jianshu.com/?t=https://www.vagrantup.com/docs/getting-started/">vagrant</a>采用2222, 本文不讨论)</li><li>5表示用户私钥</li></ul><p>然后输入该密钥对的管理密码即可连接服务器。</p><h2 id="实践步骤4：设置只许SSH登录不可密码登陆"><a href="#实践步骤4：设置只许SSH登录不可密码登陆" class="headerlink" title="实践步骤4：设置只许SSH登录不可密码登陆"></a>实践步骤4：设置只许SSH登录不可密码登陆</h2><p>最终我们的目的是消除密码登陆这一留给黑客的安全隐患，而只采用用SSH登陆，故我们在服务器配置文件<code>/etc/ssh/sshd_config</code>里小小的设置一下即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">nano /etc/ssh/sshd_config<br></code></pre></td></tr></table></figure><p>把其中的<code>PasswordAuthentication</code>中的yes改成no就不可再用密码登陆了。</p><h2 id="ssh配置文件"><a href="#ssh配置文件" class="headerlink" title="ssh配置文件"></a>ssh配置文件</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle">* ssh-server配置文件位于<span class="hljs-regexp">/etc/</span>ssh/sshd_config，在这里可以定义SSH的服务端口，默认端口是<span class="hljs-number">22</span><br>* 作为服务端，~<span class="hljs-regexp">/.ssh/</span>authorized_keys文件中<br>* ssh会把你每个你访问过计算机的公钥(<span class="hljs-keyword">public</span> key)都记录在~<span class="hljs-regexp">/.ssh/</span>known_hosts<br></code></pre></td></tr></table></figure><ul><li><p><strong>home/.ssh/.config</strong></p><p>这个文件里可以管理ssh连接，不同的主机使用不同的密钥，例如：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># gitee</span><br>Host gitee.com<br>HostName gitee.com<br>PreferredAuthentications publickey<br>IdentityFile ~<span class="hljs-regexp">/.ssh/gi</span>tee_id_rsa<br><span class="hljs-comment"># github</span><br>Host github.com<br>HostName github.com<br>PreferredAuthentications publickey<br>IdentityFile ~<span class="hljs-regexp">/.ssh/i</span>d_rsa<br></code></pre></td></tr></table></figure></li><li><p><strong>authorized_keys</strong></p></li></ul><p>我们需要本地机器ssh访问远程服务器时为了减少输入密码的步骤，基本上都会在本地机器生成ssh公钥，然后将本地ssh公钥复制到远程服务器的<code>.ssh/authorized_keys</code>中，这样就可以免密登录了。（ 服务器之间访问同理）。<br>流程如下</p><pre><code>本机生成 ssh公钥；复制本机公钥到远程服务器.ssh/authorized_keys中，authorized_keys文件不存在则创建；本机直接ssh连接远程；结束</code></pre><ul><li><strong>known_hosts</strong></li></ul><p>第一次连接远程数据库时我们可以发现我们本地的.ssh/目录下多了一个文件<code>known_hosts</code>，里面有我们刚刚连接的服务器的信息（如果以前就存在<code>known_hosts</code>，则会发现多了刚刚连接的服务器的信息）。<br><code>known_hosts</code>文件每连接一个新的远程服务器都会产生一份数据，如下：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">0.0.0.0</span> ecdsa-sha2-nistp256 AAAA...........=<br></code></pre></td></tr></table></figure><p>包括远程机器<code>ip</code>、远程机器公钥<br><code>known_hosts</code>有什么用？<br>手动修改一下远程机器A的密钥，然后再连接远程机器A，提示：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vbnet">The authenticity <span class="hljs-keyword">of</span> host <span class="hljs-comment">&#x27;0.0.0.0 (0.0.0.0)&#x27; can&#x27;t be established.</span><br>ECDSA <span class="hljs-keyword">key</span> fingerprint <span class="hljs-built_in">is</span> SHA256:xxxxxxxx.<br>Are you sure you want <span class="hljs-keyword">to</span> <span class="hljs-keyword">continue</span> connecting (yes/no)?<br></code></pre></td></tr></table></figure><p>得到类似这种提示，大概意思就是登录远程机器A验证失败，然后向你确定是否需要继续连接。<br>known_hosts的作用就很明显了，known_hosts的作用就是记录你曾经远程连接过的机器信息。如果远程机器信息不变，则直接连接，如果改变了ssh就会问你一下，小子，你还连不连了？<br>如果你yes， 他就重新保存一份到known_hosts文件了。</p><ul><li>总结一下： 1. authorized_keys由本地主机生成，多用于放在远程主机实现免密登录 2. known_hosts放在本地主机，用来记录连接过的远程主机</li></ul>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>ssh</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git常用</title>
    <link href="/posts/d6fdba1b/"/>
    <url>/posts/d6fdba1b/</url>
    
    <content type="html"><![CDATA[<h2 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h2><p>安装完成后，还需要配置git，在命令行输入：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog">$ git <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> user<span class="hljs-variable">.name</span> <span class="hljs-string">&quot;Your Name&quot;</span><br>$ git <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> user<span class="hljs-variable">.email</span> <span class="hljs-string">&quot;email@example.com&quot;</span><br></code></pre></td></tr></table></figure><p>Git 使用一系列配置文件来保存你自定义的行为。 它首先会查找系统级的 <code>/etc/gitconfig</code> 文件，该文件含有系统里每位用户及他们所拥有的仓库的配置值。 如果你传递 <code>--system</code> 选项给 <code>git config</code>，它就会读写该文件。</p><p>接下来 Git 会查找每个用户的 <code>~/.gitconfig</code> 文件（或者 <code>~/.config/git/config</code> 文件）。 你可以传递 <code>--global</code> 选项让 Git 读写该文件。</p><p>最后 Git 会查找你正在操作的仓库所对应的 Git 目录下的配置文件（<code>.git/config</code>）。 这个文件中的值只对该仓库有效，它对应于向 <code>git config</code> 传递 <code>--local</code> 选项。</p><p>以上三个层次中每层的配置（系统、全局、本地）都会覆盖掉上一层次的配置，所以 <code>.git/config</code> 中的值会覆盖掉 <code>/etc/gitconfig</code> 中所对应的值。</p><ul><li><p>注</p><p>注意<code>git config</code>命令的<code>--global</code>参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p><p>Git 的配置文件是纯文本的，所以你可以直接手动编辑这些配置文件，输入合乎语法的值。 但是运行 <code>git config</code> 命令会更简单些。</p></li></ul><h3 id="配置ssh"><a href="#配置ssh" class="headerlink" title="配置ssh"></a>配置ssh</h3><p>第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有<code>id_rsa</code>和<code>id_rsa.pub</code>这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>ssh-keygen -t rsa -C <span class="hljs-string">&quot;youremail@example.com&quot;</span><br></code></pre></td></tr></table></figure><p>你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。</p><p>如果一切顺利的话，可以在用户主目录里找到<code>.ssh</code>目录，里面有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，这两个就是SSH Key的秘钥对，<code>id_rsa</code>是私钥，不能泄露出去，<code>id_rsa.pub</code>是公钥，可以放心地告诉任何人。</p><p>第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：</p><p>然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴<code>id_rsa.pub</code>文件的内容。</p><p>使用下面命令</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Swift">ssh <span class="hljs-operator">-</span><span class="hljs-type">T</span> git<span class="hljs-meta">@github</span>.com<br></code></pre></td></tr></table></figure><p>测试是否配置成功</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">Hi RoninLee! You<span class="hljs-symbol">&#x27;ve</span> successfully authenticated, but GitHub does <span class="hljs-keyword">not</span> provide shell <span class="hljs-keyword">access</span>.<br></code></pre></td></tr></table></figure><p>出现这样一段话，即证明配置成功。</p><h2 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h2><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">git</span>@github.com:Knightwood/Aplayer.git <span class="hljs-comment">#克隆项目</span><br>git <span class="hljs-keyword">clone</span> <span class="hljs-title">-b</span> <span class="hljs-tag">&lt;分支名称&gt;</span> git@github.com:Knightwood/Aplayer.git <span class="hljs-comment">#克隆特定的分支</span><br></code></pre></td></tr></table></figure><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">git <span class="hljs-keyword">branch </span><span class="hljs-comment"># 查看分支</span><br>git <span class="hljs-keyword">branch </span>&lt;分支名称&gt; <span class="hljs-comment">#创建新分支</span><br>git checkout -<span class="hljs-keyword">b </span>&lt;分支名称&gt; <span class="hljs-comment">#创建新分支并切换到新分支</span><br>git checkout &lt;分支名称&gt; <span class="hljs-comment">#切换到新的分支</span><br>git <span class="hljs-keyword">branch </span>-r <span class="hljs-comment">#查看远程分支</span><br>git <span class="hljs-keyword">branch </span>-a <span class="hljs-comment">#查看所有分支</span><br>git push <span class="hljs-keyword">origin </span>[<span class="hljs-keyword">branch </span>name] <span class="hljs-comment">#将新分支推送到github</span><br>git <span class="hljs-keyword">branch </span>-d [<span class="hljs-keyword">branch </span>name] <span class="hljs-comment">#删除本地分支</span><br>git push <span class="hljs-keyword">origin </span>:[<span class="hljs-keyword">branch </span>name] <span class="hljs-comment">#删除github远程分支</span><br></code></pre></td></tr></table></figure><h2 id="提交代码"><a href="#提交代码" class="headerlink" title="提交代码"></a>提交代码</h2><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">git <span class="hljs-built_in">add</span> all <span class="hljs-comment">#可以提交未跟踪、修改和删除文件（无论在哪个目录执行都会提交相应文件）</span><br>git <span class="hljs-built_in">add</span> . <span class="hljs-comment">#可以提交未跟踪和修改文件，但是不处理删除文件（只能够提交当前目录或者它后代目录下相应文件）</span><br><span class="hljs-comment">-----</span><br>git commit <span class="hljs-comment">#提交代码</span><br>git commit -m <span class="hljs-string">&quot;add my code to new branchB&quot;</span> <span class="hljs-comment"># -m 参数：可以直接在后面添加提交信息。</span><br>git push origin [branch name] <span class="hljs-comment">#push 到git仓库</span><br>git commit -<span class="hljs-keyword">a</span> -m <span class="hljs-string">&#x27;合并module&#x27;</span> <span class="hljs-comment"># -a 把所有未暂存的提交.-m 附带了题解信息</span><br></code></pre></td></tr></table></figure><h2 id="删除历史版本，保留当前状态"><a href="#删除历史版本，保留当前状态" class="headerlink" title="删除历史版本，保留当前状态"></a>删除历史版本，保留当前状态</h2><blockquote><p>有时候，我们误提交了某些隐私文件，使用<code>git rm xxx</code>删除后，其实版本库中是有历史记录的，想要删除这些记录，但是又不想删除仓库，重建来提交。那么就想办法删除历史记录了。<br>我们当然不能直接删除.git文件夹，这将导致git存储库出现不可预知的问题。<br>要删除所有提交历史记录，但将代码保持在当前状态，可以按照以下方式安全地执行此操作：</p></blockquote><ol><li><p>创建并切换到<code>latest_branch</code>分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout --orphan latest_branch 创建orphan分支，名为latest_branch<br>注：<br>如果不提交东西，这个分支实际上没有创建<br></code></pre></td></tr></table></figure></li><li><p>添加所有文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add -A<br></code></pre></td></tr></table></figure></li><li><p>提交更改</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git commit -am <span class="hljs-string">&quot;删除历史版本记录，初始化仓库&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>删除分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch -D master<br></code></pre></td></tr></table></figure></li><li><p>将当前分支重命名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch -m master<br></code></pre></td></tr></table></figure></li><li><p>强制更新存储库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push -f origin master<br></code></pre></td></tr></table></figure></li></ol><p><em>解决方案来自：<a href="https://cloud.tencent.com/developer/ask/30403/answer/39134">如何删除GitHub中的所有提交历史记录？</a></em></p><ul><li><p>git checkout –orphan的核心用途是在非新存储库上以类似git init的状态创建分支。</p><p>没有这种能力，您所有的git分支都将有一个共同的祖先，即您的初始提交。这是很常见的情况，但绝不是唯一的情况。例如，git允许您将多个独立项目作为单个存储库中的不同分支进行跟踪。</p><p>这就是为什么您的文件被报告为”要提交的更改”的原因：在git init状态下，尚未创建第一个提交，因此所有文件都是git新的。</p><p>用途：例如GitHub Pages，将存储库的网站存储在存储库中但位于单独的分支上。除了该网站的历史记录外，没有任何其他原因可以存储该分支机构。</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kotlin dsl</title>
    <link href="/posts/8b583c45/"/>
    <url>/posts/8b583c45/</url>
    
    <content type="html"><![CDATA[<p>这阵子在研究Kotlin，它提供了类似DSL的语法能力，一些在Java中写起来冗长的方法，在Kotlin中则可以方便的使用，同时具有很高的可读性。</p><p>举个例子，如果我们要构造这样的xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">student</span> <span class="hljs-attr">enable</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>张三<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">gender</span>&gt;</span>男<span class="hljs-tag">&lt;/<span class="hljs-name">gender</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">remark</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">student</span>&gt;</span><br>复制代码<br></code></pre></td></tr></table></figure><p>如果使用Java来做的话，是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> javax.xml.parsers.DocumentBuilderFactory;<br><span class="hljs-keyword">import</span> javax.xml.parsers.ParserConfigurationException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XmlExample</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ParserConfigurationException </span>&#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">var</span> document = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();<br>        document.setXmlStandalone(<span class="hljs-keyword">true</span>);<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">var</span> student = document.createElement(<span class="hljs-string">&quot;student&quot;</span>);<br>        student.setAttribute(<span class="hljs-string">&quot;enable&quot;</span>, <span class="hljs-string">&quot;true&quot;</span>);<br>        document.appendChild(student);<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">var</span> name = document.createElement(<span class="hljs-string">&quot;name&quot;</span>);<br>        name.appendChild(document.createTextNode(<span class="hljs-string">&quot;张三&quot;</span>));<br>        student.appendChild(name);<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">var</span> gender = document.createElement(<span class="hljs-string">&quot;gender&quot;</span>);<br>        gender.appendChild(document.createTextNode(<span class="hljs-string">&quot;男&quot;</span>));<br>        student.appendChild(gender);<br>        student.appendChild(document.createElement(<span class="hljs-string">&quot;remark&quot;</span>));<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>简单的例子看起来还算清晰，但如果层级变多了可读性会迅速下降。</p><p>接下来给大伙整个活，我用Kotlin写一个DSL，效果是这样的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    document &#123;<br>        <span class="hljs-string">&quot;student&quot;</span>(<span class="hljs-string">&quot;enable&quot;</span> to <span class="hljs-string">&quot;true&quot;</span>) &#123;<br>            <span class="hljs-string">&quot;name&quot;</span>&#123; +<span class="hljs-string">&quot;张三&quot;</span> &#125;<br>            <span class="hljs-string">&quot;gender&quot;</span>&#123; +<span class="hljs-string">&quot;男&quot;</span> &#125;<br>            <span class="hljs-string">&quot;remark&quot;</span>()<br>        &#125;<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>可以看出代码和xml的结构是一一对应的，这样我们就非常方便地构造了一个xml实例。</p><p>以上效果的全部实现代码包括import在内仅53行，并且支持格式化输出：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> org.w3c.dom.Document<br><span class="hljs-keyword">import</span> org.w3c.dom.Node<br><span class="hljs-keyword">import</span> java.io.ByteArrayOutputStream<br><span class="hljs-keyword">import</span> javax.xml.parsers.DocumentBuilderFactory<br><span class="hljs-keyword">import</span> javax.xml.transform.OutputKeys<br><span class="hljs-keyword">import</span> javax.xml.transform.TransformerFactory<br><span class="hljs-keyword">import</span> javax.xml.transform.dom.DOMSource<br><span class="hljs-keyword">import</span> javax.xml.transform.stream.StreamResult<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> defaultDocumentBuilder = DocumentBuilderFactory.newInstance().newDocumentBuilder()<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> defaultTransformerFactory = TransformerFactory.newInstance()<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">document</span><span class="hljs-params">(block: <span class="hljs-type">DocumentBuilderDsl</span>.() -&gt; <span class="hljs-type">Unit</span>)</span></span>: Document = defaultDocumentBuilder.newDocument().apply &#123;<br>    xmlStandalone = <span class="hljs-literal">true</span><br>    block(DocumentBuilderDsl(<span class="hljs-keyword">this</span>))<br>&#125;<br><br><span class="hljs-meta">@DslMarker</span><br><span class="hljs-meta">@Target(AnnotationTarget.CLASS)</span><br><span class="hljs-keyword">annotation</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XmlDsl</span></span><br><br><span class="hljs-meta">@XmlDsl</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DocumentBuilderDsl</span></span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> document: Document) &#123;<br>    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> String.<span class="hljs-title">invoke</span><span class="hljs-params">(<span class="hljs-keyword">vararg</span> attributes: <span class="hljs-type">Pair</span>&lt;<span class="hljs-type">String</span>, String?&gt;)</span></span>: Node = <span class="hljs-keyword">this</span>(*attributes) &#123;&#125;<br>    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> String.<span class="hljs-title">invoke</span><span class="hljs-params">(<span class="hljs-keyword">vararg</span> attributes: <span class="hljs-type">Pair</span>&lt;<span class="hljs-type">String</span>, String?&gt;, block: <span class="hljs-type">NodeBuilderDsl</span>.() -&gt; <span class="hljs-type">Unit</span>)</span></span>: Node =<br>        document.appendChild(document.createElement(<span class="hljs-keyword">this</span>).apply &#123;<br>            attributes.forEach &#123; setAttribute(it.first, it.second) &#125;<br>            block(NodeBuilderDsl(document, <span class="hljs-keyword">this</span>))<br>        &#125;)<br>&#125;<br><br><span class="hljs-meta">@XmlDsl</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NodeBuilderDsl</span></span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> document: Document, <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> node: Node) &#123;<br>    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> String.<span class="hljs-title">invoke</span><span class="hljs-params">(<span class="hljs-keyword">vararg</span> attributes: <span class="hljs-type">Pair</span>&lt;<span class="hljs-type">String</span>, String?&gt;)</span></span>: Node = <span class="hljs-keyword">this</span>(*attributes) &#123;&#125;<br>    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> String.<span class="hljs-title">invoke</span><span class="hljs-params">(<span class="hljs-keyword">vararg</span> attributes: <span class="hljs-type">Pair</span>&lt;<span class="hljs-type">String</span>, String?&gt;, block: <span class="hljs-type">NodeBuilderDsl</span>.() -&gt; <span class="hljs-type">Unit</span>)</span></span>: Node =<br>        node.appendChild(document.createElement(<span class="hljs-keyword">this</span>).apply &#123;<br>            attributes.forEach &#123; setAttribute(it.first, it.second) &#125;<br>            block(NodeBuilderDsl(document, <span class="hljs-keyword">this</span>))<br>        &#125;)<br><br>    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> String.<span class="hljs-title">unaryPlus</span><span class="hljs-params">()</span></span>: Node = node.appendChild(document.createTextNode(<span class="hljs-keyword">this</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> Document.<span class="hljs-title">asXml</span><span class="hljs-params">(format: <span class="hljs-type">Boolean</span> = <span class="hljs-literal">false</span>, indentAmount: <span class="hljs-type">Int</span> = <span class="hljs-number">4</span>)</span></span>: String = ByteArrayOutputStream().use &#123;<br>    defaultTransformerFactory.newTransformer().apply &#123;<br>        <span class="hljs-keyword">if</span> (format) &#123;<br>            setOutputProperty(OutputKeys.INDENT, <span class="hljs-string">&quot;yes&quot;</span>)<br>            setOutputProperty(<span class="hljs-string">&quot;&#123;http://xml.apache.org/xslt&#125;indent-amount&quot;</span>, indentAmount.toString())<br>            setOutputProperty(OutputKeys.STANDALONE, <span class="hljs-string">&quot;yes&quot;</span>)<br>        &#125;<br>    &#125;.transform(DOMSource(<span class="hljs-keyword">this</span>), StreamResult(it))<br>    it.toString()<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>还有用poi构造Excel的也可以这样玩，如果我们要构造一个表格：</p><table><thead><tr><th>姓名</th><th>性别</th></tr></thead><tbody><tr><td>张三</td><td>男</td></tr></tbody></table><p>那么我们就可以这样写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> workbook = workbook&lt;XSSFWorkbook&gt; &#123;<br>        sheet &#123;<br>            row &#123;<br>                cell &#123; setCellValue(<span class="hljs-string">&quot;姓名&quot;</span>) &#125;<br>                cell &#123; setCellValue(<span class="hljs-string">&quot;性别&quot;</span>) &#125;<br>            &#125;<br>            row &#123;<br>                cell &#123; setCellValue(<span class="hljs-string">&quot;张三&quot;</span>) &#125;<br>                cell &#123; setCellValue(<span class="hljs-string">&quot;男&quot;</span>) &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    workbook.write(File(<span class="hljs-string">&quot;src/main/resources/test.xlsx&quot;</span>))<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>实现代码比上面的xml还少，还支持合并单元格：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> org.apache.poi.hssf.usermodel.HSSFWorkbook<br><span class="hljs-keyword">import</span> org.apache.poi.ss.usermodel.*<br><span class="hljs-keyword">import</span> org.apache.poi.ss.util.CellRangeAddress<br><span class="hljs-keyword">import</span> org.apache.poi.xssf.usermodel.XSSFWorkbook<br><span class="hljs-keyword">import</span> java.io.File<br><span class="hljs-keyword">import</span> java.io.FileOutputStream<br><br><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;<span class="hljs-keyword">reified</span> T : Workbook&gt;</span> <span class="hljs-title">workbook</span><span class="hljs-params">(block: <span class="hljs-type">WorkbookBuilderDsl</span>.() -&gt; <span class="hljs-type">Unit</span>)</span></span>: Workbook &#123;<br>    <span class="hljs-keyword">val</span> workbook = <span class="hljs-keyword">when</span> (T::<span class="hljs-class"><span class="hljs-keyword">class</span>) </span>&#123;<br>        HSSFWorkbook::<span class="hljs-class"><span class="hljs-keyword">class</span> -&gt; <span class="hljs-title">HSSFWorkbook</span></span>()<br>        XSSFWorkbook::<span class="hljs-class"><span class="hljs-keyword">class</span> -&gt; <span class="hljs-title">XSSFWorkbook</span></span>()<br>        <span class="hljs-keyword">else</span> -&gt; error(<span class="hljs-string">&quot;不支持的类型：<span class="hljs-subst">$&#123;T::class&#125;</span>&quot;</span>)<br>    &#125;<br>    block(WorkbookBuilderDsl(workbook))<br>    <span class="hljs-keyword">return</span> workbook<br>&#125;<br><br><span class="hljs-meta">@DslMarker</span><br><span class="hljs-meta">@Target(AnnotationTarget.CLASS)</span><br><span class="hljs-keyword">annotation</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WorkbookDsl</span></span><br><br><span class="hljs-meta">@WorkbookDsl</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WorkbookBuilderDsl</span></span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> workbook: Workbook) &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">sheet</span><span class="hljs-params">(sheetName: <span class="hljs-type">String</span>? = <span class="hljs-literal">null</span>, block: <span class="hljs-type">SheetBuilderDsl</span>.() -&gt; <span class="hljs-type">Unit</span>)</span></span>: Sheet =<br>        (<span class="hljs-keyword">if</span> (sheetName != <span class="hljs-literal">null</span>) workbook.createSheet(sheetName) <span class="hljs-keyword">else</span> workbook.createSheet()).also &#123; block(SheetBuilderDsl(it)) &#125;<br>&#125;<br><br><span class="hljs-meta">@WorkbookDsl</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SheetBuilderDsl</span></span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> sheet: Sheet) &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> rownum = <span class="hljs-number">0</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">row</span><span class="hljs-params">(block: <span class="hljs-type">RowBuilderDsl</span>.() -&gt; <span class="hljs-type">Unit</span>)</span></span>: Row = sheet.createRow(rownum).also &#123; block(RowBuilderDsl(it, rownum++)) &#125;<br>&#125;<br><br><span class="hljs-meta">@WorkbookDsl</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RowBuilderDsl</span></span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> row: Row, <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> rownum: <span class="hljs-built_in">Int</span>) &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> column = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> sheet = row.sheet<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">cell</span><span class="hljs-params">(type: <span class="hljs-type">CellType</span>? = <span class="hljs-literal">null</span>, rowspan: <span class="hljs-type">Int</span> = <span class="hljs-number">1</span>, colspan: <span class="hljs-type">Int</span> = <span class="hljs-number">1</span>, block: <span class="hljs-type">Cell</span>.() -&gt; <span class="hljs-type">Unit</span>)</span></span>: Cell &#123;<br>        <span class="hljs-keyword">if</span> (colspan &gt; <span class="hljs-number">1</span> || rowspan &gt; <span class="hljs-number">1</span>) sheet.addMergedRegion(CellRangeAddress(rownum, rownum + rowspan - <span class="hljs-number">1</span>, column, column + colspan - <span class="hljs-number">1</span>))<br>        sheet.mergedRegions<br>            .firstOrNull &#123; rownum <span class="hljs-keyword">in</span> it.firstRow..it.lastRow &amp;&amp; column <span class="hljs-keyword">in</span> it.firstColumn..it.lastColumn &#125;<br>            ?.also &#123; <span class="hljs-keyword">if</span> (rownum != it.firstRow || column != it.firstColumn) column = it.lastColumn + <span class="hljs-number">1</span> &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">if</span> (type != <span class="hljs-literal">null</span>) row.createCell(column++, type) <span class="hljs-keyword">else</span> row.createCell(column++)).also(block)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> Workbook.<span class="hljs-title">write</span><span class="hljs-params">(file: <span class="hljs-type">File</span>)</span></span> &#123;<br>    use &#123; it.write(FileOutputStream(file)) &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>有兴趣的同学可以玩下，当然这些只是实现了核心功能，如果要完善的实现可以根据情况自行修改，有时间的话我也打算就以上的内容放到Github分享出来。</p><p>作者：Gigaplant<br>链接：<a href="https://juejin.cn/post/7011486906995179528">https://juejin.cn/post/7011486906995179528</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 </p>]]></content>
    
    
    
    <tags>
      
      <tag>kotlin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pacman包管理</title>
    <link href="/posts/dd409eba/"/>
    <url>/posts/dd409eba/</url>
    
    <content type="html"><![CDATA[<h1 id="pacman包管理"><a href="#pacman包管理" class="headerlink" title="pacman包管理"></a>pacman包管理</h1><h4 id="安装指定的包"><a href="#安装指定的包" class="headerlink" title="安装指定的包"></a>安装指定的包</h4><p>安装或者升级单个软件包，或者一列软件包（包含依赖包），使用如下命令：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-attr"># pacman -S package_name1</span> package_<span class="hljs-symbol">name2</span> ...<br></code></pre></td></tr></table></figure><p>用正则表达式安装多个软件包（参见 <a href="https://bbs.archlinux.org/viewtopic.php?id=7179">这个帖子</a>）：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"># pacman -S <span class="hljs-constructor">$(<span class="hljs-params">pacman</span> -Ssq <span class="hljs-params">package_regex</span>)</span><br></code></pre></td></tr></table></figure><p>有时候在不同的软件仓库中，一个软件包有多个版本（比如[extra]和[testing]）。可以选择一个来安装：</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># pacman -S extra/package_name</span><br></code></pre></td></tr></table></figure><p>安装多个含有相似名称的软件包，而并非整个包组或全部匹配的软件包； 例如，<a href="https://archlinux.org/groups/x86_64/plasma/">plasma</a>:</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># pacman -S plasma-&#123;desktop,mediacenter,nm&#125;</span><br></code></pre></td></tr></table></figure><p>当然，可以多层扩展，并不作限制：</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># pacman -S plasma-&#123;workspace&#123;,-wallpapers&#125;,pa&#125;</span><br></code></pre></td></tr></table></figure><h5 id="虚包"><a href="#虚包" class="headerlink" title="虚包"></a>虚包</h5><p>虚拟软件包是一个特殊的软件包，它本身并不存在，但由一或多个其它软件包提供。虚拟软件包允许其它软件包不以某一个特定的包为依赖，以应对有多个候选的情况。虚包不能用它们的名称安装，相反它们会在你安装<em>提供</em>虚包的软件包时被安装到你的系统中。</p><h4 id="安装包组"><a href="#安装包组" class="headerlink" title="安装包组"></a>安装包组</h4><p>一些包属于一个可以同时安装的<a href="https://wiki.archlinux.org/index.php/Meta_package_and_package_group_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">软件包组</a>。例如，运行下面的命令</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># pacman -S gnome</span><br></code></pre></td></tr></table></figure><p>会提醒用户选择 <code>gnome</code> 内需要安装的包。</p><p>有的包组包含大量的软件包，有时用户只需其中几个。除了逐一键入序号外，pacman 还支持选择或排除某个区间内的的软件包：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Enter</span> a selection (default=<span class="hljs-literal">all</span>): <span class="hljs-number">1</span>-<span class="hljs-number">10</span> <span class="hljs-number">15</span><br></code></pre></td></tr></table></figure><p>这将选中序号 1 至 10 和 15 的软件包。而</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Enter</span> a selection (default=<span class="hljs-literal">all</span>): ^<span class="hljs-number">5</span>-<span class="hljs-number">8</span> ^<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>将会选中除了序号 5 至 8 和 2 之外的所有软件包。</p><p>想要查看哪些包属于 gnome 组，运行：</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># pacman -Sg gnome</span><br></code></pre></td></tr></table></figure><p>也可以访问 <a href="https://archlinux.org/groups/">https://archlinux.org/groups/</a> 查看可用的包组。</p><p><strong>注意：</strong> 如果列表中的包已经安装在系统中，它会被重新安装，即使它已经是最新的。可以用 <code>--needed</code> 选项覆盖这种行为。</p><h3 id="删除软件包"><a href="#删除软件包" class="headerlink" title="删除软件包"></a>删除软件包</h3><p>删除单个软件包，保留其全部已经安装的依赖关系</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># pacman -R package_name</span><br></code></pre></td></tr></table></figure><p>删除指定软件包，及其所有没有被其他已安装软件包使用的依赖关系：</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># pacman -Rs package_name</span><br></code></pre></td></tr></table></figure><p>上面这条命令在移除包含其他所需包的组时有时候会拒绝运行。这种情况下可以尝试</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># pacman -Rsu package_name</span><br></code></pre></td></tr></table></figure><p>要删除软件包和所有依赖这个软件包的程序:</p><p><strong>警告：</strong> 此操作是递归的，请小心检查，可能会一次删除大量的软件包。</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># pacman -Rsc package_name</span><br></code></pre></td></tr></table></figure><p>要删除一个被其他软件包依赖的软件包，但是不删除依赖这个软件包的其他软件包：</p><p><strong>警告：</strong> 此操作有破坏系统的能力，应该尽量避免使用。详情请看 <a href="https://wiki.archlinux.org/index.php/System_maintenance#Avoid_certain_pacman_commands">避免某些 Pacman 命令</a>。</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># pacman -Rdd package_name</span><br></code></pre></td></tr></table></figure><p><em>pacman</em> 删除某些程序时会备份重要配置文件，在其后面加上*.pacsave扩展名。-n 选项可以避免备份这些文件：</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ceylon">pacman -Rn <span class="hljs-keyword">package</span><span class="hljs-number">_n</span>ame<br></code></pre></td></tr></table></figure><p><strong>注意：</strong> <em>pacman</em> 不会删除软件自己创建的文件（例如主目录中的“点文件”不会被删除。）</p><h3 id="升级软件包"><a href="#升级软件包" class="headerlink" title="升级软件包"></a>升级软件包</h3><p><strong>警告：</strong></p><ul><li>建议用户遵守<a href="https://wiki.archlinux.org/index.php/System_maintenance_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E6%9B%B4%E6%96%B0%E7%B3%BB%E7%BB%9F">System maintenance (简体中文)#更新系统</a>的指导，定期更新系统，并不盲目地执行这些命令。</li><li>Arch 只支持系统完整升级，详细参见<a href="https://wiki.archlinux.org/index.php/System_maintenance_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E4%B8%8D%E6%94%AF%E6%8C%81%E9%83%A8%E5%88%86%E5%8D%87%E7%BA%A7">System maintenance (简体中文)#不支持部分升级</a>和<a href="https://wiki.archlinux.org/index.php/Pacman_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E5%8C%85">#安装软件包</a>。</li></ul><p>一个 <em>pacman</em> 命令就可以升级整个系统。花费的时间取决于系统有多老。这个命令会同步非本地(local)软件仓库并升级系统的软件包：</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># pacman -Syu</span><br></code></pre></td></tr></table></figure><h3 id="查询包数据库"><a href="#查询包数据库" class="headerlink" title="查询包数据库"></a>查询包数据库</h3><p><em>pacman</em> 使用 <code>-Q</code> 参数查询本地软件包数据库， <code>-S</code> 查询同步数据库，以及 <code>-F</code>查询文件数据库。要了解每个参数的子选项，分别参见 <a href="https://wiki.archlinux.org/index.php?title=Template:Pacman_-Q_--help&action=edit&redlink=1">Template:Pacman -Q –help</a>，<a href="https://wiki.archlinux.org/index.php?title=Template:Pacman_-S_--help&action=edit&redlink=1">Template:Pacman -S –help</a>和<a href="https://wiki.archlinux.org/index.php?title=Template:Pacman_-F_--help&action=edit&redlink=1">Template:Pacman -F –help</a>。</p><p><em>pacman</em> 可以在包数据库中查询软件包，查询位置包含了软件包的名字和描述：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">$ pacman -Ss <span class="hljs-built_in">string</span>1 <span class="hljs-built_in">string</span>2 ...<br></code></pre></td></tr></table></figure><p>有时，<code>-s</code>的内置正则会匹配很多不需要的结果，所以应当指定仅搜索包名，而非描述或其他子段:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>pacman -Ss <span class="hljs-string">&#x27;^vim-&#x27;</span><br></code></pre></td></tr></table></figure><p>要查询已安装的软件包：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">$ pacman -Qs <span class="hljs-built_in">string</span>1 <span class="hljs-built_in">string</span>2 ...<br></code></pre></td></tr></table></figure><p>按文件名查找软件库：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">$ pacman -F <span class="hljs-built_in">string</span>1 <span class="hljs-built_in">string</span>2 ...<br></code></pre></td></tr></table></figure><p>显示软件包的详尽的信息：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>pacman -Si package_name<br></code></pre></td></tr></table></figure><p>查询本地安装包的详细信息：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>pacman -Qi package_name<br></code></pre></td></tr></table></figure><p>使用两个 <code>-i</code> 将同时显示备份文件和修改状态：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>pacman -Qii package_name<br></code></pre></td></tr></table></figure><p>要获取已安装软件包所包含文件的列表：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>pacman -Ql package_name<br></code></pre></td></tr></table></figure><p>查询远程库中软件包包含的文件：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>pacman -Fl package_name<br></code></pre></td></tr></table></figure><p>检查软件包安装的文件是否都存在：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>pacman -Qk package_name<br></code></pre></td></tr></table></figure><p>两个参数<code>k</code>将会执行一次更彻底的检查。 查询数据库获取某个文件属于哪个软件包：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ pacman -Qo <span class="hljs-regexp">/path/</span>to/file_name<br></code></pre></td></tr></table></figure><p>查询文件属于远程数据库中的哪个软件包：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ pacman -F <span class="hljs-regexp">/path/</span>to/file_name<br></code></pre></td></tr></table></figure><p>要罗列所有不再作为依赖的软件包(孤立orphans)：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>pacman -Qdt<br></code></pre></td></tr></table></figure><p><strong>提示：</strong> 将上述命令添加到 pacman 的一个处理后 <a href="https://wiki.archlinux.org/index.php/Pacman_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#Hooks">hook</a>用于在如果有处理产生孤立包后获得提示。这在当有软件包被仓库放弃时是有用的，因为任何被抛弃的包都会成为本地的一个孤立包（除非它是被显式安装的）。要避免在没有找到孤立包时”failed to execute command”的错误，在你的 hook 中为<code>Exec</code>使用如下的指令: <code>/usr/bin/bash -c &quot;/usr/bin/pacman -Qtd || /usr/bin/echo &#39;=&gt; None found.&#39;&quot;</code></p><p>要罗列所有明确安装而且不被其它包依赖的软件包：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>pacman -Qet<br></code></pre></td></tr></table></figure><p>更多例子查看<a href="https://wiki.archlinux.org/index.php/Pacman_tips">pacman tips</a>。</p><h4 id="Pactree"><a href="#Pactree" class="headerlink" title="Pactree"></a>Pactree</h4><p><strong>注意：</strong> <a href="https://man.archlinux.org/man/pactree.8">pactree(8)</a>不再是<a href="https://archlinux.org/packages/?name=pacman">pacman</a>的一部分。它现在在<a href="https://archlinux.org/packages/?name=pacman-contrib">pacman-contrib</a>中。</p><p>要显示软件包的依赖树：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>pactree package_name<br></code></pre></td></tr></table></figure><p>检查一个<em>安装</em>的软件包被那些包依赖，将递归标识<code>-r</code>传递给 <em>pactree</em>，或者使用 <a href="https://aur.archlinux.org/packages/pkgtools/">pkgtools</a>AUR中的<em>whoneeds</em></p><h4 id="数据库结构"><a href="#数据库结构" class="headerlink" title="数据库结构"></a>数据库结构</h4><p>pacman数据库通常位于 <code>/var/lib/pacman/sync</code>. 对于每一个在<code>/etc/pacman.conf</code>中指定的软件仓库， 这里都有一个一致的数据库。数据库文件夹里每个tar.gz文件都包含着一个仓库的软件包信息。例如<a href="https://archlinux.org/packages/?name=which">which</a> 包:</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">$ tree which<span class="hljs-string">-2</span>.21<span class="hljs-string">-5</span><br>which<span class="hljs-string">-2</span>.21<span class="hljs-string">-5</span><br>|-- desc<br></code></pre></td></tr></table></figure><p>这个 <code>depends</code> 项列出了该软件的依赖包， 而<code>desc</code>有该包的介绍，例如文件大小和MD5值 。</p><h3 id="清理软件包缓存"><a href="#清理软件包缓存" class="headerlink" title="清理软件包缓存"></a>清理软件包缓存</h3><p><em>pacman</em> 将下载的软件包保存在 <code>/var/cache/pacman/pkg/</code> 并且不会自动移除旧的和未安装版本的软件包。这样做有一些好处：</p><ol><li>这样允许<a href="https://wiki.archlinux.org/index.php/Downgrading_packages_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">降级</a>软件包而不需要通过其他方式提取旧版本，例如 <a href="https://wiki.archlinux.org/index.php/Arch_Linux_Archive_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">Arch Linux Archive</a>.</li><li>被卸载的软件包可以轻易地直接从缓存文件夹重新安装，不需要重新从软件仓库下载。</li></ol><p>然而，需要定期手动清理缓存来避免该文件夹无限制增大。</p><p><a href="https://archlinux.org/packages/?name=pacman-contrib">pacman-contrib</a> 提供的 <a href="https://man.archlinux.org/man/paccache.8">paccache(8)</a> 脚本默认会删除所有缓存的版本和已卸载的软件包，除了最近的3个会被保留：</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># paccache -r</span><br></code></pre></td></tr></table></figure><p><a href="https://wiki.archlinux.org/index.php/Enable">启用</a> 和 <a href="https://wiki.archlinux.org/index.php/Start">启动</a> <code>paccache.timer</code>来每周删除不使用的包。</p><p><strong>提示：</strong> 可以使用 <a href="https://wiki.archlinux.org/index.php/Pacman_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#Hooks">hook</a> 自动执行清理，参考[<a href="https://bbs.archlinux.org/viewtopic.php?pid=1694743#p1694743">1]</a>和<a href="https://aur.archlinux.org/packages/pacman-cleanup-hook/">pacman-cleanup-hook</a>AUR。</p><p>也可以自己设置保留最近几个版本：</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># paccache -rk1</span><br></code></pre></td></tr></table></figure><p>添加<code>-u</code>/<code>--uninstalled</code>开关来限制<em>paccache</em>的行为只作用于卸载的包。例如清理所有卸载的包的缓存版本，可以用以下命令:</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># paccache -ruk0</span><br></code></pre></td></tr></table></figure><p>或者你可以将安装其结合，同时作用于安装的和卸载的包，例如想要保留最近两个安装的包但是移除所有卸载的包的缓存版本，使用以下命令：</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># paccache -rk2 -ruk0</span><br></code></pre></td></tr></table></figure><p>更多参数参见<code>paccache -h</code>。</p><p><em>pacman</em>也有一些内建参数用于清除缓存和那些不再在<code>/etc/pacman.conf</code>配置文件中列出的软件仓库残留数据库文件。然而<em>pacman</em>并不提供保留一定数量的过去版本的功能，因此它比<em>paccache</em>的默认选项更加激进。</p><p>要删除目前没有安装的所有缓存的包，和没有被使用的同步数据库，执行：</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># pacman -Sc</span><br></code></pre></td></tr></table></figure><p>要删除缓存中的全部文件，使用两次<code>-c</code>开关。这是最为激进的方式，将会清空缓存文件夹：</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># pacman -Scc</span><br></code></pre></td></tr></table></figure><p><strong>警告：</strong> 应当避免从缓存中删除所有过去版本和卸载的包，除非需要更多磁盘空间。这样会导致无法降级或重新安装包而不再次下载他们</p><p><a href="https://aur.archlinux.org/packages/pkgcacheclean/">pkgcacheclean</a>AUR以及<a href="https://aur.archlinux.org/packages/pacleaner/">pacleaner</a>AUR是两个进一步清理缓存的替代工具</p><h3 id="其它命令"><a href="#其它命令" class="headerlink" title="其它命令"></a>其它命令</h3><p>升级系统时安装其他软件包：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-attr"># pacman -Syu package_name1</span> package_<span class="hljs-symbol">name2</span> ...<br></code></pre></td></tr></table></figure><p>下载包而不安装它：</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># pacman -Sw package_name</span><br></code></pre></td></tr></table></figure><p>安装一个<strong>本地</strong>包(不从源里下载）：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"># pacman -U <span class="hljs-regexp">/path/</span>to<span class="hljs-regexp">/package/</span>package_name-version.pkg.tar.xz<br></code></pre></td></tr></table></figure><p>要将本地包保存至缓存，可执行：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"># pacman -U file:///<span class="hljs-type">path</span>/<span class="hljs-keyword">to</span>/package/package_name-<span class="hljs-keyword">version</span>.pkg.tar.xz<br></code></pre></td></tr></table></figure><p>安装一个<strong>远程</strong>包（不在 <em>pacman</em> 配置的源里面）：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta"># pacman -U http:<span class="hljs-comment">//www.example.com/repo/example.pkg.tar.xz</span></span><br></code></pre></td></tr></table></figure><p>要禁用 <code>-S</code>, <code>-U</code> 和 <code>-R</code> 动作，可以使用 <code>-p</code> 选项.</p><p><em>pacman</em> 会列出需要安装和删除的软件，并在执行动作前要求需要的权限。</p><h3 id="安装原因"><a href="#安装原因" class="headerlink" title="安装原因"></a>安装原因</h3><p><em>pacman</em>数据库按照软件包被安装的原因，将其分为两类：</p><ul><li><strong>显式安装</strong>：那些真正地被传递给通用<em>pacman</em><code>-S</code>和<code>-U</code>命令的包；</li><li><strong>依赖</strong>：那些虽然（一般）从未被传递给<em>pacman</em>安装命令，但由于被其它显式安装的包<a href="https://wiki.archlinux.org/index.php/Dependency">需要</a>从而被隐式安装的包</li></ul><p>当安装软件包时，可以把安装原因强制设为<strong>依赖</strong>:</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># pacman -S --asdeps package_name</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong> 用<code>--asdeps</code>安装可选依赖将导致如果你<a href="https://wiki.archlinux.org/index.php/Pacman/Tips_and_tricks#Removing_unused_packages_.28orphans.29">移除孤立包</a>，<em>pacman</em>将会一同移除剩下的可选依赖。</p><p>但是当重新安装该软件包时，安装原因将会被设为软件包所默认的。</p><p>显式安装的软件包列表可用<code>pacman -Qe</code>获取, 与之互补的已安装的依赖包可用<code>pacman -Qd</code>获取。</p><p>改变某个已安装软件包的安装原因，可以执行：</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># pacman -D --asdeps package_name</span><br></code></pre></td></tr></table></figure><p><strong>注意：</strong> 在升级时使用<code>--asdeps</code>和<code>--asexplicit</code>选项，例如<code>pacman -Syu *package_name* --asdeps</code>，是不被推荐的。这会导致不仅改变要被安装的软件包的安装原因，也会改变被升级的软件包的安装原因。</p><h3 id="查询一个包含具体文件的包名"><a href="#查询一个包含具体文件的包名" class="headerlink" title="查询一个包含具体文件的包名"></a>查询一个包含具体文件的包名</h3><p>同步文件数据库:</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># pacman -Fy</span><br></code></pre></td></tr></table></figure><p>查询包含某个文件的包名，比如:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># pacman -F pacman</span><br>core/pacman <span class="hljs-number">5.0</span>.<span class="hljs-number">1</span>-<span class="hljs-number">4</span><br>    usr<span class="hljs-regexp">/bin/</span>pacman<br>    usr<span class="hljs-regexp">/share/</span>bash-completion<span class="hljs-regexp">/completions/</span>pacman<br>extra/xscreensaver <span class="hljs-number">5.36</span>-<span class="hljs-number">1</span><br>    usr<span class="hljs-regexp">/lib/</span>xscreensaver/pacman<br></code></pre></td></tr></table></figure><p><strong>提示：</strong>  可以设置一个 <code>crontab</code> 或者 <code>systemd timer</code> 来定期同步文件信息数据库。</p><p>如果需要高级功能请安装 <a href="https://wiki.archlinux.org/index.php/Pkgfile">pkgfile</a>，它使用一个单独的数据库来保存文件和它们所关联的软件包的信息。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p><em>pacman</em> 的配置文件位于<code>/etc/pacman.conf</code>。 <a href="https://archlinux.org/pacman/pacman.conf.5.html">man pacman.conf</a> 可以查看配置文件的进一步信息。</p><h3 id="通用选项"><a href="#通用选项" class="headerlink" title="通用选项"></a>通用选项</h3><p>通用选项都在<code>[options]</code>段。阅读 man 手册或者查看默认的 pacman.conf 可以获得有关信息和用法。</p><h3 id="升级前对比版本"><a href="#升级前对比版本" class="headerlink" title="升级前对比版本"></a>升级前对比版本</h3><p>要查看旧版和新版的有效安装包，请取消<code>/etc/pacman.conf</code>中”VerbosePkgLists”的注释。修改后的<code>pacman -Syu</code>输出如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Package</span> (<span class="hljs-number">6</span>)             Old Version  New Version  Net Change  Download Size<br><br><span class="hljs-attribute">extra</span>/libmariadbclient  <span class="hljs-number">10</span>.<span class="hljs-number">1</span>.<span class="hljs-number">9</span>-<span class="hljs-number">4</span>     <span class="hljs-number">10</span>.<span class="hljs-number">1</span>.<span class="hljs-number">10</span>-<span class="hljs-number">1</span>      <span class="hljs-number">0</span>.<span class="hljs-number">03</span> MiB       <span class="hljs-number">4</span>.<span class="hljs-number">35</span> MiB<br><span class="hljs-attribute">extra</span>/libpng            <span class="hljs-number">1</span>.<span class="hljs-number">6</span>.<span class="hljs-number">19</span>-<span class="hljs-number">1</span>     <span class="hljs-number">1</span>.<span class="hljs-number">6</span>.<span class="hljs-number">20</span>-<span class="hljs-number">1</span>       <span class="hljs-number">0</span>.<span class="hljs-number">00</span> MiB       <span class="hljs-number">0</span>.<span class="hljs-number">23</span> MiB<br><span class="hljs-attribute">extra</span>/mariadb           <span class="hljs-number">10</span>.<span class="hljs-number">1</span>.<span class="hljs-number">9</span>-<span class="hljs-number">4</span>     <span class="hljs-number">10</span>.<span class="hljs-number">1</span>.<span class="hljs-number">10</span>-<span class="hljs-number">1</span>      <span class="hljs-number">0</span>.<span class="hljs-number">26</span> MiB      <span class="hljs-number">13</span>.<span class="hljs-number">80</span> MiB<br></code></pre></td></tr></table></figure><h4 id="在升级时跳过软件包"><a href="#在升级时跳过软件包" class="headerlink" title="在升级时跳过软件包"></a>在升级时跳过软件包</h4><p><strong>警告：</strong> 在跳过软件包时要小心，因为<a href="https://wiki.archlinux.org/index.php/System_maintenance_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E4%B8%8D%E6%94%AF%E6%8C%81%E9%83%A8%E5%88%86%E5%8D%87%E7%BA%A7">部分升级不受支持</a></p><p>要想在<a href="https://wiki.archlinux.org/index.php/Pacman_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E5%8D%87%E7%BA%A7%E8%BD%AF%E4%BB%B6%E5%8C%85">升级</a>系统时跳过特定的软件包，用像如下的命令指明：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">IgnorePkg</span>=linux<br></code></pre></td></tr></table></figure><p>多软件包可以用空格隔开，或者用另外的<code>IgnorePkg</code>行。也可使用 <a href="https://en.wikipedia.org/wiki/glob_(programming)">glob</a> 模式。如果只打算忽略一次升级，可以使用 <code>--ignore</code> 选项，这时使用逗号隔开的列表。</p><p>忽略了的软件包依然可通过 <code>pacman -S</code> 升级。这种情况下<em>pacman</em>会提醒你这些软件包已经被包含在<code>IgnorePkg</code>声明中。</p><h4 id="在升级时跳过软件包组"><a href="#在升级时跳过软件包组" class="headerlink" title="在升级时跳过软件包组"></a>在升级时跳过软件包组</h4><p><strong>警告：</strong> 在跳过软件包时要小心，因为<a href="https://wiki.archlinux.org/index.php/System_maintenance_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E4%B8%8D%E6%94%AF%E6%8C%81%E9%83%A8%E5%88%86%E5%8D%87%E7%BA%A7">部分升级不受支持</a></p><p>和软件包一样，也可以不升级某个软件包组：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">IgnoreGroup</span> = gnome<br></code></pre></td></tr></table></figure><h4 id="在升级时跳过文件"><a href="#在升级时跳过文件" class="headerlink" title="在升级时跳过文件"></a>在升级时跳过文件</h4><p>所有在<code>NoUpgrade</code>指令中列出的文件都会在软件包被安装/升级时不会被更改，并且新文件会以带有*.pacnew*后缀名的形式安装</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">NoUpgrade=path<span class="hljs-regexp">/to/</span><span class="hljs-keyword">file</span><br></code></pre></td></tr></table></figure><p><strong>注意：</strong> 这个路径指软件包中的文件，所以不要包括开头的斜线。</p><h4 id="在安装时跳过文件"><a href="#在安装时跳过文件" class="headerlink" title="在安装时跳过文件"></a>在安装时跳过文件</h4><p>要总是跳过某些文件夹的安装，可以将它们放到 <code>NoExtract</code> 中，例如不想安装 <a href="https://wiki.archlinux.org/index.php/Systemd">systemd</a> 模块：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">NoExtract=usr<span class="hljs-regexp">/lib/</span>systemd<span class="hljs-regexp">/system/</span>*<br></code></pre></td></tr></table></figure><p>后面的规则覆盖前面的规则，加上 <code>!</code> 可以取消跳过效果。</p><p><strong>提示：</strong> <em>pacman</em>会在更新locales已经被<em>localepurge</em>或者<em>bleachbit</em>清除的包时发出警告。将<code>CheckSpace</code>参数加入<code>pacman.conf</code>能够抑制这种警告，但是要意识到space-check功能将会对所有软件包禁用。</p><h3 id="保留多个配置文件"><a href="#保留多个配置文件" class="headerlink" title="保留多个配置文件"></a>保留多个配置文件</h3><p>如果你有多个配置文件（比如，主配置和启用了<a href="https://wiki.archlinux.org/index.php/Official_repositories_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#testing_%E4%BB%93%E5%BA%93">测试仓库</a>的配置文件），需要共享一些设置，你可以在配置文件中使用<code>Include</code>选项，例如：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">Include</span> = <span class="hljs-regexp">/path/</span>to<span class="hljs-regexp">/common/</span>settings<br></code></pre></td></tr></table></figure><p><code>*/path/to/common/settings*</code>文件中是两个配置文件共享的相同配置。</p><h3 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h3><p><em>pacman</em>可以在处理前后，运行<code>/usr/share/libalpm/hooks/</code>文件夹下的hooks，更多的hooks文件夹可以通过<code>HooDir</code>选项在<code>pacman.conf</code>中指明，默认<code>/etc/pacman.d/hooks</code>。Hook文件必须以*.hook*为后缀。Pacman hooks不是交互式的。</p><p><em>pacman</em> hooks用于，比如说，和<code>systemd-sysusers</code>和<code>systemd-tmpfiles</code>结合来在安装包时自动创建系统用户和文件。例如，<a href="https://archlinux.org/packages/?name=tomcat8">tomcat8</a>指明它想要创建一个叫做<code>tomcat8</code>的系统用户和一些属于该用户的文件。当<em>pacman</em>确定<a href="https://archlinux.org/packages/?name=tomcat8">tomcat8</a>包含文件指明用户和临时文件时，<em>pacman</em> hooks <code>systemd-sysusers.hook</code>和<code>systemd-tmpfiles.hook</code>唤起<code>systemd-sysusers</code>和<code>systemd-tmpfiles</code>。</p><p>有关 alpm hooks 的更多信息，参见<a href="https://man.archlinux.org/man/alpm-hooks.5">alpm-hooks(5)</a>。</p><h3 id="软件仓库"><a href="#软件仓库" class="headerlink" title="软件仓库"></a>软件仓库</h3><p>除了特殊的<a href="https://wiki.archlinux.org/index.php/Pacman_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E9%80%9A%E7%94%A8%E9%80%89%E9%A1%B9">通用选项</a>节, 每个<code>pacman.conf</code>中的<code>[section]</code>都定义了一个使用的软件包仓库，<em>仓库</em>是多个软件包的<em>逻辑</em>上的集合，他们<em>物理</em>上存储在一个或多个服务器：这也是为什么每一个服务器都叫做这个仓库的<em>镜像</em>。</p><p>仓库区分为<a href="https://wiki.archlinux.org/index.php/Official_repositories_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">官方仓库</a>与<a href="https://wiki.archlinux.org/index.php/Unofficial_user_repositories_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">非官方仓库</a>。配置文件中仓库的顺序十分重要；当几个仓库出现同名安装包，不管版本号如何，<em>pacman</em>将使用配置文件中排前的仓库。要在添加后使用某个仓库，你需要先<a href="https://wiki.archlinux.org/index.php/Pacman_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E5%8D%87%E7%BA%A7%E8%BD%AF%E4%BB%B6%E5%8C%85">升级</a>整个系统</p><p>每个仓库节都可以直接指定镜像列表或者<code>Include</code>引用其他的文件：例如，官方镜像引用了<code>/etc/pacman.d/mirrorlist/</code>。具体查看<a href="https://wiki.archlinux.org/index.php/Mirrors_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">Mirrors (简体中文)</a>。</p><h3 id="软件包的安全性"><a href="#软件包的安全性" class="headerlink" title="软件包的安全性"></a>软件包的安全性</h3><p><em>pacman</em> 支持软件包签名，会为软件包提供额外的安全性。默认配置，<code>SigLevel = Required DatabaseOptional</code> 将启用全局签名验证，但会被每个软件仓库的 <code>SigLevel</code> 行所覆盖。有关软件包签名和签名验证的更多细节，参见 <a href="https://wiki.archlinux.org/index.php/Pacman-key_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">pacman-key</a>。</p><hr><h2 id="Manjaro包管理常用命令"><a href="#Manjaro包管理常用命令" class="headerlink" title="Manjaro包管理常用命令"></a>Manjaro包管理常用命令</h2><ul><li>对整个系统进行更新</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo pacman -Syu   <br></code></pre></td></tr></table></figure><ul><li>升级软件包</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo pacman -Syu<br></code></pre></td></tr></table></figure><ul><li>安装或者升级单个软件包，或者一列软件包（包含依赖包），使用如下命令：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo pacman -S package_name1 package_name2 ...<br></code></pre></td></tr></table></figure><ul><li>与上面命令不同的是，该命令将在同步包数据库后再执行安装</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo pacman -Sy package_name<br></code></pre></td></tr></table></figure><ul><li>安装本地包</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo pacman -U local_package_name#其扩展名为pkg.tar.gz或pkg.tar.xz<br></code></pre></td></tr></table></figure><ul><li>安装一个远程包</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo pacman -U url#不在 pacman 配置的源里面，例：pacman -U http://www.example.com/repo/example.pkg.tar.xz<br></code></pre></td></tr></table></figure><ul><li>在仓库中搜索含关键字的包</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo pacman -Ss keyword<br></code></pre></td></tr></table></figure><ul><li>查看已安装软件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo pacman -Qs keyword     <br></code></pre></td></tr></table></figure><ul><li>删除单个软件包，保留其全部已经安装的依赖关系</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo pacman -R package_name<br></code></pre></td></tr></table></figure><ul><li>删除指定软件包，及其所有没有被其他已安装软件包使用的依赖关系：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo pacman -Rs package_name#要删除软件包和所有依赖这个软件包的程序，警告: 此操作是递归的，请小心检查，可能会一次删除大量的软件包。<br></code></pre></td></tr></table></figure><ul><li>清理软件包缓存</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo pacman -Sc<br></code></pre></td></tr></table></figure><ul><li>清理所有的缓存文件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo pacman -Scc<br></code></pre></td></tr></table></figure><ul><li>清除系统中无用的包</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo pacman -R $(pacman -Qdtq)<br></code></pre></td></tr></table></figure><ul><li><strong>从 AUR 安装软件包</strong>  </li><li>yay 安装命令不需要加 sudo</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">yay -S package <br></code></pre></td></tr></table></figure><ul><li>yay删除包</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">yay -Rns package <br></code></pre></td></tr></table></figure><ul><li>升级所有已安装的包</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">yay -Syu<br></code></pre></td></tr></table></figure><ul><li>打印系统统计信息</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">yay -Ps<br></code></pre></td></tr></table></figure><ul><li>检查安装的版本</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">yay -Qi package<br></code></pre></td></tr></table></figure><hr><h1 id="AUR国内源"><a href="#AUR国内源" class="headerlink" title="AUR国内源"></a>AUR国内源</h1><p>笔者在写这篇文章的时候，网上的资料并不多。毕竟选择Arch的用户较少，而选择<strong>Yay</strong>的用户更少。<strong>Yay</strong>默认使用法国的aur.archlinux.org作为AUR源，这样的速度显然不是我们可以接受的，因此我们需要切换为国内的tuna源</p><p><strong>Yay</strong>在安装好以后是默认不生成配置文件的。这就难以去更改默认源。笔者搜罗GIthub上的issue，根据 <a href="https://github.com/Jguer/yay/issues/697">#697</a> Issue，运行以下命令更新软件源和系统，顺便创建配置文件</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">yay</span> <span class="hljs-literal">-</span><span class="hljs-comment">Syu</span> --<span class="hljs-comment">devel</span> --<span class="hljs-comment">combinedupgrade</span> --<span class="hljs-comment">save</span><br></code></pre></td></tr></table></figure><p>然后编辑<code>~/.config/yay/config.json</code>文件，就可以看到熟悉的aururl参数啦，那么把它替换为<code>https://aur.tuna.tsinghua.edu.cn</code>即可</p><hr><h1 id="yay命令"><a href="#yay命令" class="headerlink" title="yay命令"></a>yay命令</h1><table><thead><tr><th align="left"><code>yay &lt;Search Term&gt;</code></th><th>Present package-installation selection menu.</th></tr></thead><tbody><tr><td align="left"><code>yay -Ps</code></td><td>Print system statistics.</td></tr><tr><td align="left"><code>yay -Yc</code></td><td>Clean unneeded dependencies.</td></tr><tr><td align="left"><code>yay -G &lt;AUR Package&gt;</code></td><td>Download PKGBUILD from ABS or AUR.</td></tr><tr><td align="left"><code>yay -Y --gendb</code></td><td>Generate development package database used for devel update.</td></tr><tr><td align="left"><code>yay -Syu --devel --timeupdate</code></td><td>Perform system upgrade, but also check for development package  updates and use PKGBUILD modification time (not version number) to  determine update.</td></tr></tbody></table><p>使用 yay：</p><p>搜索：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">yay -Ss &lt;package-name&gt;<br></code></pre></td></tr></table></figure><p>安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">yay -S &lt;package-name&gt;<br></code></pre></td></tr></table></figure><hr><h1 id="有关yay的基本用法，请参阅下面的示例。"><a href="#有关yay的基本用法，请参阅下面的示例。" class="headerlink" title="有关yay的基本用法，请参阅下面的示例。"></a>有关yay的基本用法，请参阅下面的示例。</h1><p>示例1：使用yay安装包</p><p>使用选项-S使用yay从AUR安装软件包：</p><p>$ yay -S package</p><p>示例2：使用yay删除包</p><p>要删除包，请使用-Rns选项：</p><p>$ yay -Rns package</p><p>示例3：启动包选择菜单</p><p>使用：</p><p>$ yay <Search Term></p><p>示例4：使用yay升级已安装的软件包</p><p>要升级所有已安装的包，请使用以下选项：</p><p>$ yay -Syu</p><p> 要包含开发包，请使用：</p><p>$ yay -Syu –devel –timeupdate</p><p>示例5：使用yay清除不需要的依赖项</p><p>使用选项可删除系统上所有不需要的依赖项：</p><p>$ yay -Yc</p><p>示例6：使用yay打印系统统计信息</p><p>要打印系统统计信息，请使用-Ps：</p><p>$ yay -Ps</p><p>示例7：生成用于开发更新的开发包DB</p><p>$ yay -Y –gendb</p><p>至此，yay基本使用方法就讲到这了。</p><hr><h1 id="snap"><a href="#snap" class="headerlink" title="snap"></a>snap</h1><h3 id="如何使用snap"><a href="#如何使用snap" class="headerlink" title="如何使用snap"></a>如何使用snap</h3><p>列出计算机上所有snap安装情况：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo snap list</span><br></code></pre></td></tr></table></figure><p>在应用商店中查找snap：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo snap <span class="hljs-builtin-name">find</span> &lt;软件包名&gt;<br></code></pre></td></tr></table></figure><p>安装Snap软件：</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bnf">sudo snap install <span class="hljs-attribute">&lt;snap软件包名&gt;</span><br></code></pre></td></tr></table></figure><p>更新Snap软件：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">sudo snap <span class="hljs-built_in">ref</span>resh &lt;snap软件包名&gt;<br></code></pre></td></tr></table></figure><p>更新所有的snap软件包：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">sudo snap <span class="hljs-keyword">refresh</span> <span class="hljs-keyword">all</span><br></code></pre></td></tr></table></figure><p>要将Snap还原到以前安装的版本：</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bnf">sudo snap revert <span class="hljs-attribute">&lt;snap软件包名&gt;</span><br></code></pre></td></tr></table></figure><p>卸载snap软件：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo snap <span class="hljs-builtin-name">remove</span> &lt;snap软件包名&gt;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>pacman</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>manjaro常用命令</title>
    <link href="/posts/bc52529d/"/>
    <url>/posts/bc52529d/</url>
    
    <content type="html"><![CDATA[<h3 id="常规配置"><a href="#常规配置" class="headerlink" title="常规配置"></a>常规配置</h3><h4 id="软件源"><a href="#软件源" class="headerlink" title="软件源"></a>软件源</h4><p>配置中国的镜像</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gauss">sudo pacman-mirrors -g  <span class="hljs-meta"># 排列源，可不执行</span><br>sudo pacman-mirrors -c China -m <span class="hljs-built_in">rank</span> <span class="hljs-meta"># 更改源，在跳出的对话框里选择想要的源</span><br></code></pre></td></tr></table></figure><p>同步并更新系统：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo pacman -Syyu</span><br></code></pre></td></tr></table></figure><h4 id="pacman常用命令"><a href="#pacman常用命令" class="headerlink" title="pacman常用命令"></a>pacman常用命令</h4><h5 id="更新系统"><a href="#更新系统" class="headerlink" title="更新系统"></a>更新系统</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">sudo</span> <span class="hljs-string">pacman</span> <span class="hljs-string">-Syu</span>    <span class="hljs-comment">#对整个系统进行更新</span><br><span class="hljs-string">sudo</span> <span class="hljs-string">acman</span> <span class="hljs-string">-Syy</span>        <span class="hljs-comment">#强制更新</span><br><span class="hljs-string">sudo</span> <span class="hljs-string">acman</span> <span class="hljs-string">-Syudd</span>    <span class="hljs-comment">#  使用 -dd跳过所有检测</span><br><span class="hljs-attr">sudo acman -Sy:</span> <span class="hljs-string">从服务器下载新的软件包数据库（实际上就是下载远程仓库最新软件列表到本地）。</span><br><span class="hljs-attr">sudo acman -Su:</span> <span class="hljs-string">升级所有已安装的软件包。</span><br><span class="hljs-attr">sudo acman -Syyu:</span> <span class="hljs-string">更新软件库并更新系统</span><br></code></pre></td></tr></table></figure><h5 id="搜索包"><a href="#搜索包" class="headerlink" title="搜索包"></a>搜索包</h5><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs ceylon">pacman 使用 -Q 参数查询本地软件包数据库， -S 查询同步数据库，以及 -F查询文件数据库。<br><br>pacman -Ss keyword在仓库中搜索含关键字的包，查询位置包含了软件包的名字和描述<br>有时，-s的内置正则会匹配很多不需要的结果，所以应当指定仅搜索包名，而非描述或其他子段: <br>pacman -Ss <span class="hljs-string">&#x27;^vim-&#x27;</span><br><br><br>pacman -Sl &lt;repo&gt;:<br>显示软件仓库中所有软件的列表<br>    可以省略，通常这样用:pacman -Sl | 关键字<br><br>pacman -Qs keyword搜索已安装的包（常用）<br>pacman -Qu: 列出所有可升级的软件包<br>pacman -Qt: 列出不被任何软件要求的软件包<br><br>pacman -Q 软件名: 查看软件包是否已安装，已安装则显示软件包名称和版本<br>pacman -Qi <span class="hljs-keyword">package</span><span class="hljs-number">_n</span>ame查询本地安装包的详细信息<br>pacman -Ql <span class="hljs-keyword">package</span><span class="hljs-number">_n</span>ame列出该包的文件<br>pacman -F string<span class="hljs-number">1</span> string<span class="hljs-number">2</span> ... 按文件名查找软件库：<br>pacman -Si <span class="hljs-keyword">package</span><span class="hljs-number">_n</span>ame显示远程软件包的详尽的信息<br>pacman -Qii <span class="hljs-keyword">package</span><span class="hljs-number">_n</span>ame使用两个 -i 将同时显示备份文件和修改状态<br>pacman -Ql <span class="hljs-keyword">package</span><span class="hljs-number">_n</span>ame要获取已安装软件包所包含文件的列表<br>pacman -Fl <span class="hljs-keyword">package</span><span class="hljs-number">_n</span>ame查询远程库中软件包包含的文件<br>pacman -Qk <span class="hljs-keyword">package</span><span class="hljs-number">_n</span>ame检查软件包安装的文件是否都存在<br>pacman -Fo /path/to/file<span class="hljs-number">_n</span>ame查询文件属于远程数据库中的哪个软件包<br>pacman -Qdt要罗列所有不再作为依赖的软件包(孤立orphans)<br>pacman -Qet要罗列所有明确安装而且不被其它包依赖的软件包<br><br>pacman -Sg: 列出软件仓库上所有的软件包组<br>pacman -Qg: 列出本地已经安装的软件包组和子包（pacman -Qg 软件包组: 和pacman -Sg 软件包组完全一样）<br></code></pre></td></tr></table></figure><h5 id="软件依赖"><a href="#软件依赖" class="headerlink" title="软件依赖"></a>软件依赖</h5><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ceylon">pactree <span class="hljs-keyword">package</span><span class="hljs-number">_n</span>ame要显示软件包的依赖树<br>whoneeds <span class="hljs-keyword">package</span><span class="hljs-number">_n</span>ame检查一个安装的软件包被那些包依赖pkgtoolsAUR中的whoneeds<br>pactree -r <span class="hljs-keyword">package</span><span class="hljs-number">_n</span>ame检查一个安装的软件包被那些包依赖<br></code></pre></td></tr></table></figure><h5 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h5><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">pacman -S package_name执行 pacman -S firefox 将安装 Firefox（常用）你也可以同时安装多个包，只需以空格分隔包名即<br>pacman -S --needed 软件名<span class="hljs-number">1</span> 软件名<span class="hljs-number">2</span>: 安装软件，但不重新安装已经是最新的软件。<br>pacman -Sy package_name与上面命令不同的是，该命令将在同步包数据库后再执行安装。<br>pacman -Sv package_name在显示一些操作信息后执行安装。<br>pacman -Sw 软件名: 只下载软件包，不安装。<br>pacman -U local_package_name安装本地包，其扩展名为pkg.tar.gz或pkg.tar.xz<br>pacman -U url安装一个远程包（不在 pacman 配置的源里面）例：pacman -U http:<span class="hljs-regexp">//</span>www.example.com<span class="hljs-regexp">/repo/</span>example.pkg.tar.xz<br></code></pre></td></tr></table></figure><h5 id="卸载软件"><a href="#卸载软件" class="headerlink" title="卸载软件"></a>卸载软件</h5><figure class="highlight ldif"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ldif"><span class="hljs-attribute">pacman -R 软件名</span>: 该命令将只删除包，保留其全部已经安装的依赖关系<br><span class="hljs-attribute">pacman -Rv 软件名</span>: 删除软件，并显示详细的信息<br><span class="hljs-attribute">pacman -Rs 软件名</span>: 删除软件，同时删除本机上只有该软件依赖的软件。<br><span class="hljs-attribute">pacman -Rsc 软件名</span>: 删除软件，并删除所有依赖这个软件的程序，慎用<br><span class="hljs-attribute">pacman -Ru 软件名</span>: 删除软件,同时删除不再被任何软件所需要的依赖<br></code></pre></td></tr></table></figure><h5 id="清理缓存"><a href="#清理缓存" class="headerlink" title="清理缓存"></a>清理缓存</h5><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">pacman -Sc 清理未安装的包文件，包文件位于 <span class="hljs-regexp">/var/</span>cache<span class="hljs-regexp">/pacman/</span>pkg/ 目录。<br><br>pacman -Scc 要删除缓存中的全部文件，使用两次-c开关。这是最为激进的方式，将会清空缓存文件夹。<br>注： 应当避免从缓存中删除所有过去版本和卸载的包，除非需要更多磁盘空间。这样会导致无法降级或重新安装包而不再次下载他们<br></code></pre></td></tr></table></figure><h4 id="yay"><a href="#yay" class="headerlink" title="yay"></a>yay</h4><p>Yay 是用 Go 编写的 Arch Linux AUR 包管理工具。AUR 的全称是 Arch User Repository，是  Arch Linux/Manjaro 用户的社区驱动存储库，创建 AUR 的目的是使共享社区包的过程更容易和有条理。使用它可以在 Arch  Linux/Manjaro 系统中安装和更新软件包。这个软件仓库的软件包是相当丰富，可以查看这个网站的统计<a href="https://repology.org/repositories/statistics/total">Repository statistics</a>，它的软件列表可以在<a href="https://aur.archlinux.org/packages/">Archlinux AUR</a>查看。具体可以查看 Arch Wiki</p><blockquote><p>注意：很多教程比较老了，yaourt 目前已经停止维护，用户可以考虑迁移到 aurman 或 yay</p></blockquote><p><strong>安装 yay：</strong></p><p>配置 yay 的 aur 源为清华源 AUR 镜像：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">yay <span class="hljs-params">--aururl</span> <span class="hljs-string">&quot;https://aur.tuna.tsinghua.edu.cn&quot;</span> <span class="hljs-params">--save</span><br></code></pre></td></tr></table></figure><p>修改的配置文件位于 ~/.config/yay/config.json ，还可通过以下命令查看修改过的配置:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">yay -<span class="hljs-selector-tag">P</span> -g<br></code></pre></td></tr></table></figure><p>yay 的常用命令：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs haxe">yay -S <span class="hljs-keyword">package</span> <span class="hljs-meta"># 从 AUR 安装软件包</span><br>yay -Rns <span class="hljs-keyword">package</span> <span class="hljs-meta"># 删除包</span><br>yay -Syu <span class="hljs-meta"># 升级所有已安装的包</span><br>yay -Ps <span class="hljs-meta"># 打印系统统计信息</span><br>yay -Qi <span class="hljs-keyword">package</span> <span class="hljs-meta"># 检查安装的版本</span><br>yay 安装命令不需要加 sudo。<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>manjaro</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ohmyzsh整理</title>
    <link href="/posts/f46218d0/"/>
    <url>/posts/f46218d0/</url>
    
    <content type="html"><![CDATA[<h1 id="手动安装"><a href="#手动安装" class="headerlink" title="手动安装"></a>手动安装</h1><h2 id="github"><a href="#github" class="headerlink" title="github"></a>github</h2><p><code>https://github.com/ohmyzsh/ohmyzsh</code></p><h3 id="1-克隆仓库"><a href="#1-克隆仓库" class="headerlink" title="1 克隆仓库"></a>1 克隆仓库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://github.com/ohmyzsh/ohmyzsh.git ~/.oh-my-zsh<br>或者<br>git clone git@github.com:ohmyzsh/ohmyzsh.git ~/.oh-my-zsh<br></code></pre></td></tr></table></figure><h3 id="2-将原来的～-zshrc备份"><a href="#2-将原来的～-zshrc备份" class="headerlink" title="2 将原来的～/.zshrc备份"></a>2 将原来的<code>～/.zshrc</code>备份</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp ~/.zshrc ~/.zshrc.bak<br></code></pre></td></tr></table></figure><h3 id="3-用新的zsh配置文件"><a href="#3-用新的zsh配置文件" class="headerlink" title="3 用新的zsh配置文件"></a>3 用新的zsh配置文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc<br></code></pre></td></tr></table></figure><h3 id="4-使得zsh变成默认的shell"><a href="#4-使得zsh变成默认的shell" class="headerlink" title="4 使得zsh变成默认的shell"></a>4 使得zsh变成默认的shell</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">nano .bashrc<br>在第一行添加<br>zsh<br></code></pre></td></tr></table></figure><h2 id="5-配置文件"><a href="#5-配置文件" class="headerlink" title="5 配置文件"></a>5 配置文件</h2><p>zsh的配置文件存在当前用户目录中的.zshrc文件，如果你发现切换了shell之后，以前的配置的环境变量不生效了，可以打开 .zshrc文件，找到：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># User configuration</span><br><span class="hljs-built_in">source</span> ~/.bash_profile<br></code></pre></td></tr></table></figure><p>指定配置的环境变量文件，之后运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> .zshrc<br></code></pre></td></tr></table></figure><h1 id="设置主题"><a href="#设置主题" class="headerlink" title="设置主题"></a>设置主题</h1><h2 id="设置固定主题"><a href="#设置固定主题" class="headerlink" title="设置固定主题"></a>设置固定主题</h2><ul><li><strong>安装完毕后，我们就可以使用了，先来简单配置一下，Oh My Zsh 提供了很多主题风格，我们可以根据自己的喜好，设置主题风格</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">open ~/.zshrc<br><br><span class="hljs-comment"># 找到 ZSH_THEME</span><br><span class="hljs-comment"># robbyrussell 是默认的主题</span><br>ZSH_THEME=<span class="hljs-string">&quot;robbyrussell&quot;</span><br><br><span class="hljs-comment"># ZSH_THEME=&quot;样式名称&quot; </span><br></code></pre></td></tr></table></figure><ul><li>保存这个文件文件，重新打开终端。</li></ul><h2 id="设置随机主题"><a href="#设置随机主题" class="headerlink" title="设置随机主题"></a>设置随机主题</h2><ul><li><strong>我们还可以随机设置主题：</strong></li><li>步骤同上</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ZSH_THEME=<span class="hljs-string">&quot;random&quot;</span><br></code></pre></td></tr></table></figure><ul><li>每次打开终端主题是随机的。</li><li>终端输出：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">[oh-my-zsh] Random theme <span class="hljs-string">&#x27;/Users/xxxx/.oh-my-zsh/themes/zhann.zsh-theme&#x27;</span> loaded...<br></code></pre></td></tr></table></figure><ul><li>其中 <strong>zhann.zsh-theme</strong> 是主题的名称， 有喜欢的童鞋可以记录保留.</li></ul><h2 id="查看主题名称"><a href="#查看主题名称" class="headerlink" title="查看主题名称"></a>查看主题名称</h2><ul><li><strong>Oh My Zsh</strong> 默认自带了一些默认主题，存放在 <strong>~/.oh-my-zsh/themes</strong> 目录中。我们可以查看这些主题</li><li>终端输入：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/.oh-my-zsh/themes &amp;&amp; ls<br></code></pre></td></tr></table></figure><h2 id="卸载-Oh-My-Zsh"><a href="#卸载-Oh-My-Zsh" class="headerlink" title="卸载 Oh My Zsh"></a>卸载 Oh My Zsh</h2><ul><li>终端输入 ：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">uninstall_oh_my_zsh<br>Are you sure you want to remove Oh My Zsh? [y/N]  Y<br></code></pre></td></tr></table></figure><ul><li>终端提示信息：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">Removing ~/.oh-my-zsh<br>Looking <span class="hljs-keyword">for</span> original zsh config...<br>Found ~/.zshrc.pre-oh-my-zsh -- Restoring to ~/.zshrc<br>Found ~/.zshrc -- Renaming to ~/.zshrc.omz-uninstalled-20170820200007<br>Your original zsh config was restored. Please restart your session.<br>Thanks <span class="hljs-keyword">for</span> trying out Oh My Zsh. It<span class="hljs-string">&#x27;s been uninstalled.</span><br></code></pre></td></tr></table></figure><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><h3 id="manjaro自带插件"><a href="#manjaro自带插件" class="headerlink" title="manjaro自带插件"></a>manjaro自带插件</h3><p>自己下载的插件放在<code>/home/kiylx/.oh-my-zsh/custom/plugins/</code></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vim">位置/usr/share/zsh/plugins/<br>一共三个<br>zsh-autosuggestions<br>zsh-<span class="hljs-keyword">history</span>-substring-<span class="hljs-built_in">search</span><br>zsh-<span class="hljs-keyword">syntax</span>-highlighting<br><br><span class="hljs-keyword">ps</span>：<br><span class="hljs-number">1</span>.其中zsh-<span class="hljs-keyword">history</span>-substring-<span class="hljs-built_in">search</span>是ohmyzsh自带的，只是名称不同，是<span class="hljs-keyword">history</span>-substring-<span class="hljs-built_in">search</span>。<br><span class="hljs-number">2</span>.zsh-<span class="hljs-keyword">syntax</span>-highligting必须排最后一个<br></code></pre></td></tr></table></figure><h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><p>这个是装好<a href="https://link.zhihu.com/?target=http://ohmyz.sh/">oh-my-zsh</a>就默认已经开启的</p><p>查看所有的git命令<a href="https://link.zhihu.com/?target=http://man.linuxde.net/alias?oqnsle=octhb">alias</a></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">~<span class="hljs-regexp">/.oh-my-zsh/</span>plugins<span class="hljs-regexp">/git/gi</span>t.plugin.zsh<br></code></pre></td></tr></table></figure><h3 id="z"><a href="#z" class="headerlink" title="z"></a>z</h3><p>这个是oh-my-zsh默认就装好的，需要自己开启。还有一个<code>autojump</code>的插件和<code>z</code>功能差不多，<code>autojump</code>需要单独装，</p><p>如果z插件历史记录太多，并且有一些不是自己想要的，可以删除</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">z -<span class="hljs-keyword">x</span> 不要的路径<br></code></pre></td></tr></table></figure><h3 id="auto-suggestions"><a href="#auto-suggestions" class="headerlink" title="auto-suggestions"></a>auto-suggestions</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions<br></code></pre></td></tr></table></figure><h3 id="zsh-syntax-highligting"><a href="#zsh-syntax-highligting" class="headerlink" title="zsh-syntax-highligting"></a>zsh-syntax-highligting</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $ZSH_CUSTOM/plugins/zsh-syntax-highlighting<br></code></pre></td></tr></table></figure><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-meta">## git open 插件</span><br>$ git <span class="hljs-keyword">open</span><br><span class="hljs-meta"># opens https:<span class="hljs-comment">//github.com/TRACKED_REMOTE_USER/CURRENT_REPO/tree/CURRENT_BRANCH</span></span><br><br>$ git <span class="hljs-keyword">open</span> someremote<br><span class="hljs-meta"># opens https:<span class="hljs-comment">//github.com/PROVIDED_REMOTE_USER/CURRENT_REPO/tree/CURRENT_BRANCH</span></span><br><br>$ git <span class="hljs-keyword">open</span> someremote somebranch<br><span class="hljs-meta"># opens https:<span class="hljs-comment">//github.com/PROVIDED_REMOTE_USER/CURRENT_REPO/tree/PROVIDED_BRANCH</span></span><br><br>$ git <span class="hljs-keyword">open</span> --issue<br><span class="hljs-meta"># If branches use naming convention of issues/#123,</span><br><span class="hljs-meta"># opens https:<span class="hljs-comment">//github.com/TRACKED_REMOTE_USER/CURRENT_REPO/issues/123</span></span><br><br>$ git <span class="hljs-keyword">open</span> --<span class="hljs-keyword">print</span><br><span class="hljs-meta"># prints https:<span class="hljs-comment">//github.com/TRACKED_REMOTE_USER/CURRENT_REPO/tree/CURRENT_BRANCH</span></span><br><br>$ git <span class="hljs-keyword">open</span> --suffix pulls<br><span class="hljs-meta"># opens https:<span class="hljs-comment">//github.com/TRACKED_REMOTE_USER/CURRENT_REPO/pulls</span></span><br><br></code></pre></td></tr></table></figure><hr><h3 id="thefuck修正命令"><a href="#thefuck修正命令" class="headerlink" title="thefuck修正命令"></a>thefuck修正命令</h3><p><a href="https://github.com/nvbn/thefuck#manual-installation">github</a></p><ul><li>安装thefuck  使用python的pip</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pip <span class="hljs-keyword">install</span> thefuck<br></code></pre></td></tr></table></figure><ul><li><p>配置</p><p>在<code>.bash_profile</code>, <code>.bashrc</code>, <code>.zshrc</code> or 其他启动脚本文件中添加</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">eval</span> $(thefuck --<span class="hljs-built_in">alias</span>)<br><span class="hljs-comment"># You can use whatever you want as an alias, like for Mondays:</span><br><span class="hljs-comment"># 你可以使用其他名称替代默认的别名，比如：</span><br><span class="hljs-built_in">eval</span> $(thefuck --<span class="hljs-built_in">alias</span> FUCK)<br></code></pre></td></tr></table></figure><p>让配置立即生效，需要重启终端，，或者，输入<code>source ~/.bashrc</code> (或者你的shell配置文件名称 <code>.zshrc</code>).</p></li></ul><h2 id="修改～-zshrc文件"><a href="#修改～-zshrc文件" class="headerlink" title="修改～/.zshrc文件"></a>修改～/.zshrc文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">例子<br>plugins=(<br>git <br>pip<br>extract <br>z <br>wd<br>auto-suggestions<br>zsh-syntax-highligting<br>auto-jumplast-working-dir<br>)<br><br>ZSH_THEME=&quot;robbyrussell&quot;<br></code></pre></td></tr></table></figure><p>如果想要启用某个插件，装好之后直接修改<br>plugins = (插件A 插件B 插件C)<br>git<br>这个是装好<a href="https://link.zhihu.com/?target=http://ohmyz.sh/">oh-my-zsh</a>就默认已经开启的<br>查看所有的git命令<a href="https://link.zhihu.com/?target=http://man.linuxde.net/alias?oqnsle=octhb">alias</a><br>~/.oh-my-zsh/plugins/git/git.plugin.zsh<br>z<br>这个是oh-my-zsh默认就装好的，需要自己开启。还有一个<code>autojump</code>的插件和<code>z</code>功能差不多，<code>autojump</code>需要单独装，<br>如果z插件历史记录太多，并且有一些不是自己想要的，可以删除<br>z -x 不要的路径</p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>终端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>加密方式</title>
    <link href="/posts/1b807d60/"/>
    <url>/posts/1b807d60/</url>
    
    <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9712e36edd5b48f79b42a230969e5a7c~tplv-k3u1fbpfcp-watermark.image" alt="img"></p><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><h4 id="1-1-CIA-三要素"><a href="#1-1-CIA-三要素" class="headerlink" title="1.1 CIA 三要素"></a>1.1 CIA 三要素</h4><p>在讨论今天的主题之前，有必要先搞清楚到底什么是安全？在计算机领域，所谓的 “安全” 其实是指 “信息安全”，它的基本含义可以概括为三个要素，简称 <strong>CIA 三要素</strong>：</p><ul><li><strong>1、机密性（Confidentiality）：</strong> 指确保数据在传输和存储过程中的私密性。主要的手段是加密、权限管理和敏感信息脱敏；</li><li><strong>2、完整性（Integrity）：</strong> 指确保数据内容完成，没有被篡改。主要手段是数字签名；</li><li><strong>3、可用性（Avaliability）：</strong> 指确保服务保持可用状态。例如能够承受 Dos 等网络攻击。</li></ul><h4 id="1-2-非安全信道的风险"><a href="#1-2-非安全信道的风险" class="headerlink" title="1.2 非安全信道的风险"></a>1.2 非安全信道的风险</h4><p>数据需要通过信道进行传输，狭义上的信道是指报纸、有线网络、无线电波等通信媒介，而广义上说，信道可以理解为数据从分发到接收的整个过程。在非安全信道中，主要会面临以下三个安全风险：</p><ul><li><strong>1、窃听风险：</strong> 现代计算机网络建立在 TCP/IP 协议族提供传输能力上，数据在传输线路上的每个环节都可能被窃听，从而导致敏感数据泄露；</li><li><strong>2、篡改风险：</strong> 数据在传输过程中可能被篡改，例如中间人攻击。攻击者可以和通信双方分别建立独立的连接，使得通信双方误以为它们正在进行一个私密连接，但察觉不到数据被篡改；</li><li><strong>3、伪装风险：</strong> 攻击者可以伪装成合法的身份。</li></ul><h4 id="1-3-如何实现传输安全？"><a href="#1-3-如何实现传输安全？" class="headerlink" title="1.3 如何实现传输安全？"></a>1.3 如何实现传输安全？</h4><p>我们今天的主题 “加密 + 签名 + 证书”，本质上就是在非安全信道中实现数据安全传输的解决方案。要实现数据安全传输，其实就是要高效地解决非安全信道中的三个风险：</p><ul><li><strong>1、加密 —— 防窃听 ：</strong> 将明文转换为密文，只有期望的接收方有能力将密文解密为明文，即使密文被攻击者窃取也无法理解数据的内容；</li><li><strong>2、验证完整性 —— 防止篡改：</strong> 对原始数据计算摘要，并将数据和摘要一起交付给通信对方。接收方收到后也对数据计算摘要，并比较是否和接受的摘要一致，借此判断接收的数据是否被篡改。不过，因为收到的摘要也可能被篡改，所以需要使用更安全的手段：数字签名；</li><li><strong>3、认证数据来源 —— 防止伪装：</strong> 数字签名能够验证数据完整性，同时也能认证数据来源，防止伪装。</li></ul><hr><h1 id="2-加密-——-防窃听"><a href="#2-加密-——-防窃听" class="headerlink" title="2. 加密 —— 防窃听"></a>2. 加密 —— 防窃听</h1><h4 id="2-1-什么是加密？"><a href="#2-1-什么是加密？" class="headerlink" title="2.1 什么是加密？"></a>2.1 什么是加密？</h4><p>加密（Encryption）是将明文（Plaintext）转换为密文（Ciphertext）的过程，只有期望的接收方有能力将密文解密为明文，即使密文被攻击者窃取也无法理解数据的内容。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1e9bbe5da27a45faba3826de0675089e~tplv-k3u1fbpfcp-watermark.image" alt="img"></p><p>在古典密码时期，数据保密性取决于算法的保密性，一旦加密算法被破解或泄露，就失去了数据的安全性。而进入现代密码时期，柯克霍夫原则成为加密系统的基本设计原则：<strong>数据的安全性基于密钥而不是算法的保密</strong>。</p><p>根据柯克霍夫原则，现代的保密通信模型是基于密钥的保密模型模型。在这个模型中，加密和解密使用相同密钥，就是 <strong>对称加密密码体制</strong>；反之，加密和解密使用是不同密钥，就是 <strong>非对称密码体制。</strong></p><h4 id="2-2-对称加密和非对称加密的区别？"><a href="#2-2-对称加密和非对称加密的区别？" class="headerlink" title="2.2 对称加密和非对称加密的区别？"></a>2.2 对称加密和非对称加密的区别？</h4><ul><li><strong>1、密钥管理：</strong> 对称加密算法中需要将密钥发送给通信对方，存在密钥泄漏风险；非对称加密公钥是公开的，私钥是保密的，防止了私钥外传；</li><li><strong>2、密钥功能：</strong> 公钥加密的数据，只可使用私钥对其解密。反之，私钥加密的数据，只可使用公钥对其解密（注意：公钥加密的数据无法使用公钥解密，因为公钥是公开的，如果公钥可以解密的话，就失去了加密的安全性）；</li><li><strong>3、计算性能：</strong> 非对称加密算法的计算效率低，因此实际中往往采用两种算法结合的复合算法：先使用非对称加密建立安全信道传输对称密钥，再使用该密钥进行对称加密；</li><li><strong>4、认证功能：</strong> 非对称加密算法中，私钥只有一方持有，具备认证性和抗抵赖性（<strong>第 3 节 数字签名算法</strong> 应用了此特性）。</li></ul><p>考虑到性能的因素，在 HTTPS 协议中采用的是 “对称加密” 和 “非对称加密” 结合的 “混合加密” 方案：<strong>在建立通信时，采用非对称加密的方式来协商 “会话密钥”，在通信过程中基于该密钥进行对称加密通信。</strong></p><h4 id="2-3-数据加密标准-——-DES"><a href="#2-3-数据加密标准-——-DES" class="headerlink" title="2.3 数据加密标准 —— DES"></a>2.3 数据加密标准 —— DES</h4><p>1977 年，数据加密标准（Data Encryption Standard, DES）成为美国联邦信息处理标准，并逐渐成为事实标准，很多主流的对称加密算法都是从 DES 算法发展过来的。</p><p><strong>DES  算法的主要缺点是加密强度和计算性能较差</strong></p><ul><li><strong>1、密钥长度太短：</strong> DES 算法密钥长度只有 56 bit，理论最大加密长度为 256。随着计算机算力的提高，用穷举法可以在较短时间破解密钥；</li><li><strong>2、不能对抗差分和线性密码分析；</strong></li><li><strong>3、计算性能较差：</strong> 增加 DES 密钥长度，加解密的计算开销呈指数增长。</li></ul><h4 id="2-4-高级加密标准-——-AES"><a href="#2-4-高级加密标准-——-AES" class="headerlink" title="2.4 高级加密标准 —— AES"></a>2.4 高级加密标准 —— AES</h4><p>高级加密标准（Advanced Encryption Standard, AES），又称 Rijndael [rain-dahl]加密法，是目前最流行的对称加密算法之一。</p><p>相对于 DES 算法，AES 算法的主要优点如下：</p><ul><li><strong>1、密钥长度更大：</strong> 密钥长度最小为 12 bit，最大为 256 bit。用穷举法难以破解；</li><li><strong>2、使用 WTS 设计策略，可对抗差分和线性密码分析；</strong></li><li><strong>3、计算性能高：</strong> 计算和内存开销低，适用于受限设备。</li></ul><h4 id="2-5-RSA-算法"><a href="#2-5-RSA-算法" class="headerlink" title="2.5 RSA 算法"></a>2.5 RSA 算法</h4><p>1977 年，麻省理工学院的三位教授 Rivest、Shamir 和 Adleman 共同提出了 RSA 加密算法，其中 RSA 分别是他们姓氏的首字母。RSA 是经典的非对称加密算法，同时也是经典的数字签名算法。</p><p>RSA 算法的安全性依赖于一个数学难题 —— <strong>“大数因式分解”：两个大素数相乘非常容易，但对一个极大整数做因式分解的复杂度极高</strong>。如果存在某种快速因素分解的算法，那么 RSA 算法的可靠性将会大大折扣。RSA 算法存在一个系统性风险：<strong>“不支持前向加密”</strong>。在 RSA 算法中，服务端公钥是相对固定的，一但服务端私钥被破解，则之前所有发送过得加密数据都会被破解。</p><p>关于 RSA 算法的原理解析，可参考：<a href="https://link.juejin.cn/?target=https://zhuanlan.zhihu.com/p/375258787">浅析 RSA 算法</a>。</p><h4 id="2-6-DH-算法"><a href="#2-6-DH-算法" class="headerlink" title="2.6 DH 算法"></a>2.6 DH 算法</h4><p>DH 算法的安全性依赖于一个数学难题 —— <strong>“离散对数”：已知对数计算出真数非常简单，但已知真数求对数的复杂度极高。</strong> 如果存在某种求对数的算法，那么 DH 算法的可靠性将会大大折扣。</p><p>目前，DH 算法有多种实现，主要区别如下：</p><ul><li>static DH 算法：一方的私钥是静态的（通常是服务器私钥固定），不具备前向安全性；</li><li>DHE 算法：双方的私钥都在密钥交换节点随机生成，具备前向安全性；</li><li>ECDHE 算法：利用 ECC 椭圆曲线特性，可以用更少的计算量计算公钥和私钥。</li></ul><p>关于 DH 算法的原理解析，可参考：<a href="https://link.juejin.cn/?target=https://mp.weixin.qq.com/s/pLyR8zuw4l7Z6sdUZ4IL5w">这 HTTPS，真滴牛逼！</a></p><h4 id="2-7-安全系统中为什么要使用随机数？"><a href="#2-7-安全系统中为什么要使用随机数？" class="headerlink" title="2.7 安全系统中为什么要使用随机数？"></a>2.7 安全系统中为什么要使用随机数？</h4><p>在 RSA 算法生成密钥对的过程中，我们需要随机生成两个大素数。事实上，除了在 RSA 算法中，很多安全系统中都需要一个随机数，为什么呢？—— <strong>关键在于随机数不可预测性，可以提高破解和报文重放攻击难度。</strong></p><h4 id="2-8-计算机如何生成随机数？"><a href="#2-8-计算机如何生成随机数？" class="headerlink" title="2.8 计算机如何生成随机数？"></a>2.8 计算机如何生成随机数？</h4><p>随机数是计算机安全领域中非常重要的一个点，很多场景中都需要一个随机数来生成随机事件，比如密钥的生成、文件名、sessionId/orderId/token 等。现代的随机数生成模型依然采用的是 1946 年冯·诺依曼设计的随机数模型：</p><p>1、输入任意一个数作为 “种子”，通过随机数算法得到一个随机数； 2、将生成的随机数作为新的种子，代入下一轮计算； 3、重复 1、2 步骤，就可以生成多个具有统计意义的随机数。</p><p><strong>然而，通过这种模型生成的随机数并不是绝对随机的</strong>。只要取样范围足够大，随机结果一定会陷入循环，因此这种模型生成的随机数只能称为 <strong>“伪随机数”</strong>，而随机结果陷入循环的周期称为 <strong>“随机周期”</strong>。</p><p>要得到真正意义的随机数，需要硬件层面支持。1999 年 Intel 在其 i810 芯片组上集成了世界上第一款真随机数生成器，它的方案是将电路的热噪声（分子的不规则运动）作为数据来源，缺点是效率太低，因此目前计算机中采用的随机数依旧是软件实现的伪随机数。虽然软件无法做到真随机，但可以提高生成器的随机性。比如采用更强壮的随机算法（Java#SecurityRandom）、采用更复杂的种子（系统时间、鼠标位置、网络速度、硬盘读写速度）、扩大随机数的取值范围、组合多个随机算法等。</p><hr><h1 id="3-数字签名-——-验证完整性-amp-认证数据来源"><a href="#3-数字签名-——-验证完整性-amp-认证数据来源" class="headerlink" title="3. 数字签名 —— 验证完整性 &amp; 认证数据来源"></a>3. 数字签名 —— 验证完整性 &amp; 认证数据来源</h1><h4 id="3-1-什么是数字签名？"><a href="#3-1-什么是数字签名？" class="headerlink" title="3.1 什么是数字签名？"></a>3.1 什么是数字签名？</h4><p><strong>数字签名（Digital Signature）也叫作数字指纹（Digital Fingerprint），它是消息摘要算法和非对称加密算法的结合体，能够验证数据的完整性，并且认证数据的来源</strong>。</p><p>数据签名算法的模型分为两个主要阶段：</p><ul><li><strong>1、签名：</strong> 先计算数据的 [摘要]，再使用私钥对 [摘要] 进行加密生成 [签名]，将 [数据 + 签名] 一并发送给接收方；</li><li><strong>2、验证：</strong> 先使用相同的摘要算法计算接收数据的 [摘要]，再使用预先得到的公钥解密 [签名]，对比 [解密的签名] 和 [计算的摘要] 是否一致。若一致，则说明数据没有被篡改。</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d9d7edc5b6d417e8ebcb142477b1b7f~tplv-k3u1fbpfcp-watermark.image" alt="img"></p><blockquote><p><strong>提示：</strong> 接收方如何安全地预先得到发送方的公钥，见 <strong>第 4 节</strong>。</p></blockquote><h4 id="3-2-为什么数字签名可以验证完整性？"><a href="#3-2-为什么数字签名可以验证完整性？" class="headerlink" title="3.2 为什么数字签名可以验证完整性？"></a>3.2 为什么数字签名可以验证完整性？</h4><p>验证完整性主要依赖于消息摘要算法的特性，摘要算法的原理是根据一定的运算规则提取原始数据中的信息，被提取的信息就是原始数据的消息摘要，也称为数据指纹。著名的摘要算法有 MD5 算法和 SHA 系列算法。</p><p>摘要算法具有以下特点：</p><ul><li><strong>一致性：</strong> 相同数据多次计算的摘要是相同的，不同的数据（在不考虑碰撞时）的摘要是不同的；</li><li><strong>不可逆性：</strong> 只能正向提取原始数据的摘要，无法从摘要反推出原始数据；</li><li><strong>高效性：</strong> 摘要的生成过程高效快速；</li></ul><p>摘要算法的模型分为两个主要步骤：</p><ul><li><strong>生成摘要：</strong> 先计算数据的 [摘要]，再将 [数据 + 摘要] 一并发送给接收方；</li><li><strong>验证摘要：</strong> 使用相同的摘要算法计算接收数据的 [摘要]，对比 [收到的摘要] 与 [计算的摘要]是否一致。若一致，则说明数据是完整的。</li></ul><p>需要注意的是，<strong>单纯依靠摘要算法不能严格地验证数据完整性</strong>。因为在非安全信道中，数据和摘要都存在篡改风险，攻击者在篡改数据时也可以篡改摘要。因此，摘要算法需要配合加密算法才能严格验证完整性。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/69aa7c60a39d4b90a029d37b2d95631f~tplv-k3u1fbpfcp-watermark.image" alt="img"></p><h4 id="3-3-为什么数字签名可以认证数据来源？"><a href="#3-3-为什么数字签名可以认证数据来源？" class="headerlink" title="3.3 为什么数字签名可以认证数据来源？"></a>3.3 为什么数字签名可以认证数据来源？</h4><p>这是因为签名时引入了发送方的私有信息（私钥），只有 ”合法的发送方“ 才能产生其他人无法伪造的一段数字签名（加密字符串），这个数字签名就证明了数据的真实来源。当接收方采用 ”合法途径“ 获得发送方的公有信息是（公钥），并且成功验证数字签名，那么正说明数据来自 ”合法的接收方“。</p><p>另外，在签名时引入发送方私有信息，在验证时使用发送方公有信息，这正好符合 “非对称加密” 的特点。因此签名时引入的私有信息正是私钥，验证时使用的公有信息正式公钥。</p><h4 id="3-4-摘要算法存在碰撞，是不是不安全？"><a href="#3-4-摘要算法存在碰撞，是不是不安全？" class="headerlink" title="3.4 摘要算法存在碰撞，是不是不安全？"></a>3.4 摘要算法存在碰撞，是不是不安全？</h4><p>摘要算法（散列算法）本质上是一种 <strong>压缩映射</strong>，因此一定存在不同原始数据映射到同一个散列值的情况，这就是发生了碰撞（散列冲突，Hash Collision）。事实上，MD5、SHA-1 等散列算法已经陆续被找到快速散列碰撞的的方法，攻击者可以构造内存篡改但摘要一致的文件从而绕过检查。但不代表完全不安全，因为篡改为有价值的伪造内容还有困难？？</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5db3edf0bbf0452fb3380d5217258dde~tplv-k3u1fbpfcp-watermark.image" alt="img"></p><h4 id="3-5-为什么摘要中需要加盐？"><a href="#3-5-为什么摘要中需要加盐？" class="headerlink" title="3.5 为什么摘要中需要加盐？"></a>3.5 为什么摘要中需要加盐？</h4><p>为了提高安全性，在对原始数据生成摘要之前，我们往往会先向原始数据中加盐，再生成摘要。为什么要这么做呢？</p><p>这是为了避免 <strong>“彩虹表（Rainbow tables）” 攻击</strong>，提高简单数据的安全性。因为摘要算法有一致性的特点，相同数据多次计算的摘要是相同的。利用这个特性，攻击者可以预先生成一系列简单数据的摘要，并存储 “摘要 - 数据” 的映射，这个映射关系就是彩虹表。在获取到数据摘要后，如果发现摘要存在彩虹表中，就可以轻易地反推出原始数据。</p><p>用户在设置密码时，也要避免使用 123456 这种简单密码，因为容易被彩虹表攻击破解。为了提高安全性，在传输手机号、密码等敏感信息的过程中，往往会在原始密码中加盐。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b54361d96c8477588c95577bf61bad6~tplv-k3u1fbpfcp-watermark.image" alt="img"></p><h4 id="3-6-可以先使用私钥对原数据签名，再对签名进行摘要吗？"><a href="#3-6-可以先使用私钥对原数据签名，再对签名进行摘要吗？" class="headerlink" title="3.6 可以先使用私钥对原数据签名，再对签名进行摘要吗？"></a>3.6 可以先使用私钥对原数据签名，再对签名进行摘要吗？</h4><p>不可以，主要有两个原因：</p><ul><li><strong>1、可行性：</strong> 接收方需要通过摘要验证数据完整性，然而接收方无法对数据进行签名，因此无法验证数据摘要一致性；</li><li><strong>2、时间效率：</strong> 对原始数据进行签名（加密）时间太长，而摘要算法本身是压缩映射，可以缩短签名消耗的时间。</li></ul><hr><h1 id="4-数字证书-——-安全地发放公钥"><a href="#4-数字证书-——-安全地发放公钥" class="headerlink" title="4. 数字证书 —— 安全地发放公钥"></a>4. 数字证书 —— 安全地发放公钥</h1><p>在 <strong>第 3 节</strong> 中，我们提到接收方需要使用发送方的公钥来验证数据真实性。那么，接收方怎样才能安全地获得发送方公钥呢？这就需要数字证书来保证。</p><h4 id="4-1-什么是数字证书？"><a href="#4-1-什么是数字证书？" class="headerlink" title="4.1 什么是数字证书？"></a>4.1 什么是数字证书？</h4><p>数字签名和数字证书总是成对出现，二者不可分离。<strong>数字签名主要用来验证数据完整性和认证数据来源，而数字证书主要用来安全地发放公钥。</strong> 数字证书主要包含三个部分：<strong>用户的信息、用户的公钥和 CA 对该证书实体信息的签名</strong>。</p><p>数字证书的模型主要分为两个步骤：</p><ul><li><strong>1、颁发证书：</strong><ul><li>1.1 申请者将签名算法、公钥、有效时间等信息发送给 CA 机构；</li><li>1.2 CA 机构验证申请者身份后，将申请者发送的信息打成一个实体，并计算摘要；</li><li>1.3 CA 机构使用自己的私钥对摘要进行加密，生成证书签名（Certificate Signature）；</li><li>1.4 CA 机构将证书签名添加在数字证书上，构成完整的数字生出。</li></ul></li><li><strong>2、验证证书</strong><ul><li>2.1 验证方使用相同的摘要算法计算证书实体的摘要；</li><li>2.2 使用 CA 机构的公钥（浏览器和操作系统中集成了 CA 的公钥信息）解密证书签名；</li><li>2.3 对比解密后的数据与计算的摘要是否一致，如果一致则是可信任的证书。</li></ul></li></ul><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5148e9add67240718f84ddd3cd4b2fd6~tplv-k3u1fbpfcp-watermark.image" alt="img"></p><h4 id="4-2-什么是证书颁发机构-CA？"><a href="#4-2-什么是证书颁发机构-CA？" class="headerlink" title="4.2 什么是证书颁发机构 CA？"></a>4.2 什么是证书颁发机构 CA？</h4><p>证书颁发机构（certifcation authroity, CA）是负责数字证书的审批、颁发、归档和吊销等功能的机构，具有权威性。CA 机构分为 “根 CA” 和 “中间 CA”，原则上要避免根 CA 机构直接颁发最终实体证书，而需要由中间 CA 机构颁发最终实体证书。这是为了避免证书失效的影响范围，一旦根证书失效或被伪造，那么整个证书链都有问题。</p><h4 id="4-3-什么是证书链？"><a href="#4-3-什么是证书链？" class="headerlink" title="4.3 什么是证书链？"></a>4.3 什么是证书链？</h4><p>证书链是多个数字证书建立的的证书验证链条。数字证书主要包含三个部分：用户信息、用户密钥以及 CA 机构对该证书实体的签名。为了验证证书实体的合法性，需要获得颁发该证书的 CA 机构公钥，这个公钥就存在于上一级证书中。因此，为了验证证书的合法性，就需要沿着证书链向上追溯直到根证书为止。</p><p>根证书是自签名证书，用户下载根证书就表示信任该根证书所有签发的证书。在操作系统或浏览器中，已经内置了一部分受信任的根证书。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b84db63d6eb245e1a06d8194432d1e05~tplv-k3u1fbpfcp-watermark.image" alt="img"></p><h4 id="4-4-数字证书的标准"><a href="#4-4-数字证书的标准" class="headerlink" title="4.4 数字证书的标准"></a>4.4 数字证书的标准</h4><p>数字证书主要包含三个部分：<strong>用户的信息、用户的公钥和 CA 对该证书实体信息的签名</strong>。目前的数字证书采用的是公钥基础设施（PKI）制定的 X.509 标准，目前已经有 3 个版本，其中比较常见的是 X.509 第三版的标准。主要格式如下：</p><table><thead><tr><th>字段</th><th>描述</th></tr></thead><tbody><tr><td>版本 (Version)</td><td>证书的版本信息</td></tr><tr><td>序列号 (Serial Number)</td><td>证书的唯一标识</td></tr><tr><td>签名算法标识 (Hash)</td><td>证书签名采用的算法</td></tr><tr><td>有效期 (Validity)</td><td>证书有效期的开始日期和结束日期</td></tr><tr><td>持有者信息 (Subject)</td><td>证书的持有者</td></tr><tr><td>公钥 (Subject Public Key Info)</td><td>持有者构建的公共密钥</td></tr><tr><td>颁布者信息 (Issuer)</td><td>证书颁布者</td></tr><tr><td>签名 (Certificate Signature)</td><td>颁布者对证书实体的签名</td></tr></tbody></table><p>作者：彭丑丑<br>链接：<a href="https://juejin.cn/post/6995549209348816909">https://juejin.cn/post/6995549209348816909</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    
    
    <tags>
      
      <tag>杂谈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>加密方式2</title>
    <link href="/posts/577c5f28/"/>
    <url>/posts/577c5f28/</url>
    
    <content type="html"><![CDATA[<h1 id="des加密："><a href="#des加密：" class="headerlink" title="des加密："></a>des加密：</h1><pre><code>package com.soufun.com;import java.io.IOException;import java.security.SecureRandom;import javax.crypto.Cipher;import javax.crypto.SecretKey;import javax.crypto.SecretKeyFactory;import javax.crypto.spec.DESKeySpec;import sun.misc.BASE64Decoder;import sun.misc.BASE64Encoder;/** *@author WHD *data 2015年8月16日 *即使导入sun.misc这个架包也会报错，这时首先把你的jre架包移除在导入一次就可以了 */public class DesUtil &#123;     private final static String DES = &quot;DES&quot;;        public static void main(String[] args) throws Exception &#123;            String data = &quot;测试des加密方式&quot;;            // 注意：DES加密和解密过程中，密钥长度都必须是8的倍数            String key = &quot;qazwsxed&quot;;            System.err.println(encrypt(data, key));            System.err.println(decrypt(encrypt(data, key), key));        &#125;      /**     * Description 根据键值进行加密     * @param data     * @param key  加密键byte数组     * @return     * @throws Exception     */    public static String encrypt(String data, String key) throws Exception &#123;        byte[] bt = encrypt(data.getBytes(), key.getBytes());        //注意：在加密和解密的时候使用sun的BASE64Encoder（）进行编码和解码不然会有乱码        //网上查看了很多实例，都没有编码和解码，也说没有乱码问题，而我这里出现了乱码，所以使用BASE64Encoder（）进行了编码解码        String strs = new BASE64Encoder().encode(bt);        return strs;    &#125;    /**     * Description 根据键值进行解密     * @param data     * @param key  加密键byte数组     * @return     * @throws IOException     * @throws Exception     */    public static String decrypt(String data, String key) throws IOException,            Exception &#123;        if (data == null)            return null;        //注意：在加密和解密的时候使用sun的BASE64Encoder（）进行编码和解码不然会有乱码        BASE64Decoder decoder = new BASE64Decoder();        byte[] buf = decoder.decodeBuffer(data);        byte[] bt = decrypt(buf,key.getBytes());        return new String(bt);    &#125;    /**     * Description 根据键值进行加密     * @param data     * @param key  加密键byte数组     * @return     * @throws Exception     */    private static byte[] encrypt(byte[] data, byte[] key) throws Exception &#123;        // 生成一个可信任的随机数源        SecureRandom sr = new SecureRandom();        // 从原始密钥数据创建DESKeySpec对象        DESKeySpec dks = new DESKeySpec(key);        // 创建一个密钥工厂，然后用它把DESKeySpec转换成SecretKey对象        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(DES);        SecretKey securekey = keyFactory.generateSecret(dks);        // Cipher对象实际完成加密操作        Cipher cipher = Cipher.getInstance(DES);        // 用密钥初始化Cipher对象        cipher.init(Cipher.ENCRYPT_MODE, securekey, sr);        //正式执行加密操作        return cipher.doFinal(data);    &#125;    /**     * Description 根据键值进行解密     * @param data     * @param key  加密键byte数组     * @return     * @throws Exception     */    private static byte[] decrypt(byte[] data, byte[] key) throws Exception &#123;        // 生成一个可信任的随机数源        SecureRandom sr = new SecureRandom();        // 从原始密钥数据创建DESKeySpec对象        DESKeySpec dks = new DESKeySpec(key);        // 创建一个密钥工厂，然后用它把DESKeySpec转换成SecretKey对象        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(DES);        SecretKey securekey = keyFactory.generateSecret(dks);        // Cipher对象实际完成解密操作        Cipher cipher = Cipher.getInstance(DES);        // 用密钥初始化Cipher对象        cipher.init(Cipher.DECRYPT_MODE, securekey, sr);        // 正式进行解密操作        return cipher.doFinal(data);    &#125;&#125;</code></pre><hr><h1 id="其他叙述"><a href="#其他叙述" class="headerlink" title="其他叙述"></a>其他叙述</h1><p>​        客户端注册和登录的时候：一个可行的方法是，客户端提交 md5(password) 密码（如上所述，此方法只是简单保护了密码，是可能被查表获取密码的）。<br>注册的时候：服务端数据库通过 md5(salt+md5(password)) 的规则存储密码，该 salt 仅存储在服务端，且在每次存储密码时都随机生成。这样即使被拖库，制作字典的成本也非常高。<br>密码被 md5() 提交到服务端之后，可通过 md5(salt + form[‘password’]) 与数据库密码比对。此方法可以在避免明文存储密码的前提下，实现密码加密提交与验证。<br>这里还有防止 replay 攻击（请求被重新发出一次即可能通过验证）的问题，由服务端颁发并验证一个带有时间戳的可信 token （或一次性的）即可。<br>当然，传输过程再有 HTTPS 加持那就更好了。</p><p>​        Android客户端与服务器进行数据传输时，一般会涉及到两类数据的加密情况，一类是只有创建者才能知道的数据，比如密码；另一类是其他比较重要的，但是可以逆向解密的数据。</p><h2 id="第一类："><a href="#第一类：" class="headerlink" title="第一类："></a>第一类：</h2><p>​        密码类的数据，为了让用户放心注册，密码类的数据的加密一般都是经过双重加密的，第一重加密使用不可逆的MD5算法加密，第二重加密是可逆的加密，常见的可逆加密有对称加密和非对称加密。上述不可逆的意思就是一旦加密就不能反向得到密码原文，一般用来加密用户密码，app的服务器端一般存储的也都是密文密码，不然用户就太危险了，app的运营商也承担不起这么大的责任。虽然现在MD5加密生成的密文也可以破解了，但是我们不需要担心，因为我们可以采用多重加密方式来应对。在数据传输的过程中，首先把密码类数据经过MD5加密算法加密，然后再在外面使用可逆的加密方式加密一次，这样在数据传输的过程中，即便数据被截获了，但是想要完全破解，还是很难的（本来就不存在完全不能解密的加密）。</p><h3 id="MD5加密算法："><a href="#MD5加密算法：" class="headerlink" title="MD5加密算法："></a>MD5加密算法：</h3><pre><code>public String getMD5Code(String info) &#123;    try &#123;        MessageDigest md5 = MessageDigest.getInstance(&quot;MD5&quot;);        md5.update(info.getBytes(&quot;UTF-8&quot;));        byte[] encryption = md5.digest();        StringBuffer strBuf = new StringBuffer();        for (int i = 0; i &lt; encryption.length; i++) &#123;            if (Integer.toHexString(0xff &amp; encryption[i]).length() == 1) &#123;                strBuf.append(&quot;0&quot;).append(                        Integer.toHexString(0xff &amp; encryption[i]));            &#125; else &#123;                strBuf.append(Integer.toHexString(0xff &amp; encryption[i]));            &#125;        &#125;        return strBuf.toString();    &#125; catch (Exception e) &#123;        // TODO: handle exception        return &quot;&quot;;    &#125;&#125;</code></pre><h2 id="第二类数据："><a href="#第二类数据：" class="headerlink" title="第二类数据："></a>第二类数据：</h2><p>​        非密码类的数据，虽然这些数据也很重要，但是一般其他人截获了这些数据对他们意义不太大，这些数据我们一般采用可逆的加密方式加密，因为我们在服务器端还是需要这些数据的明文的，常用的可逆加密方法有：对称加密和非对称加密。何为对称加密？在对称加密算法中，数据发信方将明文和加密密钥一起经过特殊的加密算法处理后，使其变成复杂的加密密文发送出去，收信方收到密文后，若想解读出原文，则需要使用加密时用的密钥以及相同加密算法的逆算法对密文进行解密，才能使其回复成可读明文。在对称加密算法中，使用的密钥只有一个，收发双方都使用这个密钥，这就需要解密方事先知道加密密钥。非对称加密算法是一种密钥的保密方法。非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。 非对称加密算法实现机密信息交换的基本过程是：甲方生成一对密钥并将其中的一把作为公用密钥向其它方公开；得到该公用密钥的乙方使用该密钥对机密信息进行加密后再发送给甲方；甲方再用自己保存的另一把专用密钥对加密后的信息进行解密。</p>]]></content>
    
    
    
    <tags>
      
      <tag>杂谈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单例</title>
    <link href="/posts/9a64efc5/"/>
    <url>/posts/9a64efc5/</url>
    
    <content type="html"><![CDATA[<h1 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h1><p>总的来说，实现单例模式有下面几个关键点：</p><ul><li><strong>构造函数私有化，使外部不能直接构造单例对象；</strong></li><li><strong>暴露公共静态方法或枚举，返回单例对象；</strong></li><li><strong>确保线程安全，保证多线程环境下也仅有一个实例对象；</strong></li><li><strong>确保单例对象在反序列化时不会创建新的对象。</strong></li></ul><h2 id="饿汉式单例："><a href="#饿汉式单例：" class="headerlink" title="饿汉式单例："></a>饿汉式单例：</h2><blockquote><p>饿汉式单例就是声明一个静态对象，在类被第一次加载的时候，就完成静态对象的实例化。</p></blockquote><h5 id="Java篇："><a href="#Java篇：" class="headerlink" title="Java篇："></a>Java篇：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonJava</span> </span>&#123;<br>    <span class="hljs-comment">// 在类内部实例化一个私有的实例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> SingletonJava INSTANCE = <span class="hljs-keyword">new</span> SingletonJava();<br><br>    <span class="hljs-comment">// 构造函数私有，外部无法访问</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingletonJava</span><span class="hljs-params">()</span> </span>&#123; &#125;<br><br>    <span class="hljs-comment">// 共有的静态函数，对外暴露获取单例对象的接口</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonJava <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种写法比较容易理解，也应该都有接触过，我们直接看一下如何在Kotlin实现类似效果。</p><h5 id="Kotlin篇"><a href="#Kotlin篇" class="headerlink" title="Kotlin篇:"></a>Kotlin篇:</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">object</span> SingletonKotlin &#123; &#125;<br></code></pre></td></tr></table></figure><p>没开玩笑，这真的是Kotlin的饿汉式单例，爽到难以置信。这种写法在Kotlin中有自己的称呼：<a href="https://links.jianshu.com/go?to=https://www.kotlincn.net/docs/reference/object-declarations.html%23%E5%AF%B9%E8%B1%A1%E5%A3%B0%E6%98%8E">对象声明</a>。</p><ul><li><strong>何为对象声明，我们在<code>object</code>关键字后面跟一个名称，就可以获取一个单例对象；</strong></li><li>像变量声明一样，对象声明不是一个表达式，不能用在赋值语句的右边；</li><li>而且对象声明的初始化过程是线程安全的。</li></ul><p>如此神奇的效果，我们怎么能忍住不一探究竟，所以我们把Kotlin的自节码进行了反编译。<br> 查看Kotlin的字节码：<code>Tools</code> → <code>Kotlin</code> → <code>Show Kotlin Bytecode</code>，然后点击字节码的<code>DECOMPILE</code>进行反编译：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonKotlin</span> </span>&#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> SingletonKotlin INSTANCE;<br><br>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingletonKotlin</span><span class="hljs-params">()</span> </span>&#123; &#125;<br><br>   <span class="hljs-keyword">static</span> &#123;<br>      SingletonKotlin var0 = <span class="hljs-keyword">new</span> SingletonKotlin();<br>      INSTANCE = var0;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>愣了，这分明就是我们饿汉式单例的另一种写法！难怪可以实现相同的单例效果，原来是Kotlin通过语法糖为我们做了简化封装。</p><h2 id="懒汉式单例："><a href="#懒汉式单例：" class="headerlink" title="懒汉式单例："></a>懒汉式单例：</h2><blockquote><p>懒汉式单例就是声明一个静态对象，并且在用户第一次调用的时进行初始化。</p></blockquote><h4 id="Java篇"><a href="#Java篇" class="headerlink" title="Java篇:"></a>Java篇:</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SingletonJava</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SingletonJava INSTANCE;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingletonJava</span>(<span class="hljs-params"></span>)</span> &#123; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonJava <span class="hljs-title">getInstance</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-literal">null</span>) &#123;<br>            INSTANCE = <span class="hljs-keyword">new</span> SingletonJava();<br>        &#125;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Kotlin篇："><a href="#Kotlin篇：" class="headerlink" title="Kotlin篇："></a>Kotlin篇：</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 构造函数私有化</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonKotlin</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">constructor</span></span>() &#123;<br><br>    <span class="hljs-comment">// 伴生对象，类似于Java的静态代码块</span><br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> &#123;<br>        <span class="hljs-comment">// 声明私有对象，并重写get方法</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> mInstance: SingletonKotlin? = <span class="hljs-literal">null</span><br>            <span class="hljs-keyword">get</span>() &#123;<br>                <span class="hljs-comment">// 如果对象为空，则进行实例化</span><br>                field = field ?: SingletonKotlin()<br>                <span class="hljs-keyword">return</span> field<br>            &#125;<br><br>        <span class="hljs-comment">// 对外暴露获取单例对象的接口</span><br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>: SingletonKotlin = mInstance!!<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Java的写法大家都应该很熟悉了，而Kotlin的写法则有些不同，毕竟Kotlin也有它自己的语言特性：</p><p><strong>被<code>companion</code>标记的这块代码，在Kotlin中被称为<a href="https://links.jianshu.com/go?to=https://www.kotlincn.net/docs/reference/object-declarations.html%23%E4%BC%B4%E7%94%9F%E5%AF%B9%E8%B1%A1">伴生对象</a>：类似于Java的静态代码块，这样它就与外部类关联在一起，我们可以直接通过外部类访问到对象的内部元素。</strong></p><p>而用过Kotlin的都知道，Kotlin的属性自带<code>Getter</code>和<code>Setter</code>（对于var属性，下同）。</p><p>所以我们在内部声明一个私有的<code>mInstance</code>，自定义它的<code>Getter</code>；当对象为空是进行实例化，当对象不为空时，直接返回实例对象。这样我们既满足了构造函数的私有化，有对外暴露了对象的获取方法。</p><h5 id="小结一下："><a href="#小结一下：" class="headerlink" title="小结一下："></a>小结一下：</h5><ul><li>懒汉式单例只有在使用时才会进行实例化，在一定程度上节约了资源；</li><li>但第一次加载时需要及时进行实例化，反应稍慢；</li><li>而且这种写法是非线程安全的，适用于单线程环境，不推荐使用。</li></ul><hr><h2 id="线程安全的懒汉式："><a href="#线程安全的懒汉式：" class="headerlink" title="线程安全的懒汉式："></a>线程安全的懒汉式：</h2><blockquote><p>为了解决上述线程安全性的问题，我们使用同步锁适应多线程的环境。</p></blockquote><h4 id="Java篇：-1"><a href="#Java篇：-1" class="headerlink" title="Java篇："></a>Java篇：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonJava</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SingletonJava INSTANCE;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingletonJava</span><span class="hljs-params">()</span> </span>&#123; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> SingletonJava <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-keyword">null</span>) &#123;<br>            INSTANCE = <span class="hljs-keyword">new</span> SingletonJava();<br>        &#125;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Kotlin篇-1"><a href="#Kotlin篇-1" class="headerlink" title="Kotlin篇:"></a>Kotlin篇:</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonKotlin</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">constructor</span></span>() &#123;<br><br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> mInstance: SingletonKotlin? = <span class="hljs-literal">null</span><br>            <span class="hljs-keyword">get</span>() &#123;<br>                field = field ?: SingletonKotlin()<br>                <span class="hljs-keyword">return</span> field<br>            &#125;<br><br>        <span class="hljs-meta">@Synchronized</span><br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>: SingletonKotlin = mInstance!!<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种写法和上面的懒汉式写法类似，仅仅是多了一层同步锁，从而保证在多线程环境下的线程安全。由于每次对象的获取都会对整个类进行加锁，所以运行效率不高，实际使用中并不推荐。</p><p>作者：呱呱_<br>链接：<a href="https://www.jianshu.com/p/4e9dda5b486a">https://www.jianshu.com/p/4e9dda5b486a</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h2 id="双检锁"><a href="#双检锁" class="headerlink" title="双检锁"></a>双检锁</h2><h3 id="kotlin版"><a href="#kotlin版" class="headerlink" title="kotlin版"></a>kotlin版</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SomeSingleton</span></span>(context: Context) &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> mContext: Context = context<br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> &#123;<br>        <span class="hljs-meta">@Volatile</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> instance: SomeSingleton? = <span class="hljs-literal">null</span><br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getInstance</span><span class="hljs-params">(context: <span class="hljs-type">Context</span>)</span></span>: SomeSingleton &#123;<br>            <span class="hljs-keyword">val</span> i = instance<br>            <span class="hljs-keyword">if</span> (i != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> i<br>            &#125;<br><br>            <span class="hljs-keyword">return</span> synchronized(<span class="hljs-keyword">this</span>) &#123;<br>                <span class="hljs-keyword">val</span> i2 = instance<br>                <span class="hljs-keyword">if</span> (i2 != <span class="hljs-literal">null</span>) &#123;<br>                    i2<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">val</span> created = SomeSingleton(context)<br>                    instance = created<br>                    created<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br>或者：<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonKotlin</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">constructor</span></span>() &#123;<br><br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> &#123;<br>        <span class="hljs-meta">@Volatile</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> mInstance: SingletonKotlin? = <span class="hljs-literal">null</span><br>            <span class="hljs-keyword">get</span>() &#123;<br>                field = field ?: synchronized(<span class="hljs-keyword">this</span>) &#123; field ?: SingletonKotlin() &#125;<br>                <span class="hljs-keyword">return</span> field<br>            &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span> = mInstance!!<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="封装一个带参单例"><a href="#封装一个带参单例" class="headerlink" title="封装一个带参单例"></a>封装一个带参单例</h4><p>支持传参的单例，我们实现了。但为了实现这个单例，写了 20+ 行代码。每次写单例都要把这一堆代码复制一遍，还挺麻烦，为了使用方便，还可以将其再封装一下。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonHolder</span>&lt;<span class="hljs-type">out T, in A</span>&gt;</span>(creator: (A) -&gt; T) &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> creator: ((A) -&gt; T)? = creator<br>    <span class="hljs-meta">@Volatile</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> instance: T? = <span class="hljs-literal">null</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getInstance</span><span class="hljs-params">(arg: <span class="hljs-type">A</span>)</span></span>: T &#123;<br>        <span class="hljs-keyword">val</span> i = instance<br>        <span class="hljs-keyword">if</span> (i != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> i<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> synchronized(<span class="hljs-keyword">this</span>) &#123;<br>            <span class="hljs-keyword">val</span> i2 = instance<br>            <span class="hljs-keyword">if</span> (i2 != <span class="hljs-literal">null</span>) &#123;<br>                i2<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">val</span> created = creator!!(arg)<br>                instance = created<br>                creator = <span class="hljs-literal">null</span><br>                created<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//对上述方法的一种更简洁的写法</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getInstance2</span><span class="hljs-params">(arg: <span class="hljs-type">A</span>)</span></span>: T =<br>        instance ?: synchronized(<span class="hljs-keyword">this</span>) &#123;<br>            instance ?: creator!!(arg).apply &#123;<br>                instance = <span class="hljs-keyword">this</span><br>            &#125;<br>        &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>用一个支持继承的 <code>open class</code> 加上泛型就可以简单的将其进行封装，此封装方式支持一个参数的构造方法，有需要可以继续扩展或者封装。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SomeSingleton</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">constructor</span></span>(context: Context) &#123;<br>    <span class="hljs-keyword">init</span> &#123;<br>        <span class="hljs-comment">// Init using context argument</span><br>        context.getString(R.string.app_name)<br>    &#125;<br><br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> : SingletonHolder&lt;SomeSingleton, Context&gt;(::SomeSingleton)<br>&#125;<br></code></pre></td></tr></table></figure><p>封装成 SingletonHolder 类之后，再想使用单例，关键代码一行就搞定了。</p><ul><li>使用：</li></ul><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">class</span> SomeSingleton <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">constructor</span><span class="hljs-params">(context: Context)</span> <span class="hljs-comment">&#123;</span></span><br><span class="hljs-comment"><span class="hljs-function">init &#123;</span></span><br><span class="hljs-comment"><span class="hljs-function">// Init using context argument</span></span><br><span class="hljs-comment"><span class="hljs-function">context.getString(R.string.app_name)</span></span><br><span class="hljs-comment"><span class="hljs-function">&#125;</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">companion</span> <span class="hljs-title">object</span> :</span> SingletonHolder&lt;SomeSingleton, Context&gt;(::SomeSingleton)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>获取单例</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SomeSingleton</span>.</span></span>get<span class="hljs-constructor">Instance(<span class="hljs-params">context</span>)</span><br></code></pre></td></tr></table></figure><h3 id="java版"><a href="#java版" class="headerlink" title="java版"></a>java版</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DoubleCheckSingleton</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> DoubleCheckSingleton sInstance;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">DoubleCheckSingleton</span><span class="hljs-params">(Context ctx)</span> </span>&#123;<br>          <span class="hljs-comment">// init</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DoubleCheckSingleton <span class="hljs-title">getInstance</span><span class="hljs-params">(Context ctx)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (sInstance == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (DoubleCheckSingleton.class) &#123;<br>                <span class="hljs-keyword">if</span> (sInstance == <span class="hljs-keyword">null</span>) &#123;<br>                    sInstance = <span class="hljs-keyword">new</span> DoubleCheckSingleton(ctx);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sInstance;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这段代码的精髓就是<code>getInstance</code>方法的两层非空判断：</p><ul><li>第一层为了避免不必要的同步，只需在第一次创建实例时同步；</li><li>第二层为了在对象为null的情况下创建实例，防止别的线程抢先初始化了。</li></ul><p>可是仅靠<code>getInstance</code>方法就能解决并发线程安全性的问题吗？<br> 我们一起看下<code>INSTANCE = new SingletonJava()</code>这行代码，这行代码都干了些什么呐，可基本拆分为三个步骤：</p><ol><li>给<code>INSTANCE</code>单例对象分配内存空间；</li><li>调用<code>SingletonJava()</code>构造函数，初始化成员对象；</li><li>将<code>INSTANCE</code>对象指向分配的内存空间（此时<code>INSTANCE</code>不为null）。</li></ol><p><strong>由于Java内存模型（JVM）允许指令重排，执行顺序不一定是<code>1 → 2 → 3</code>，也可能是<code>1 → 3 → 2</code>。<br> 虽然单线程环境下，指令重排并不会影响最终结果，但会影响到多线程并发执行的正确性：</strong></p><ul><li>如果线程A按<code>1 → 3</code>执行，还没有执行到<code>2</code>；</li><li>此时被切换带线程B，由于<code>INSTANCE</code>已经不为null了，会被线程B直接取走；</li><li>而此时<code>INSTANCE</code>是未完全初始化的，线程B直接使用将会出错。</li></ul><p>结合<strong>并发线程安全的三要素：原子性、可见性、有序性。</strong><br> 我们知道这种写法是有缺陷的，可是怎么解决上述问题呐？答案就是我们上述代码用到的<code>volatile</code>关键字。</p><ul><li><code>volatile</code>可以禁止指令重排，保证有序性；</li><li><code>volatile</code>还可以保证可见性，强制<code>INSTANCE</code>对象每次从主存中读取。</li></ul><p>这里为什么不提原子性呐，因为原子性我们已经通过<code>synchronized</code>来保证了。关于<code>volatile</code>的更多内容，大家可以参考：<a href="https://links.jianshu.com/go?to=https://www.cnblogs.com/dolphin0520/p/3920373.html">Java并发编程：volatile关键字解析</a>。</p><h2 id="使用-lazy"><a href="#使用-lazy" class="headerlink" title="使用 lazy"></a>使用 lazy</h2><p>前面在介绍带参单例的时候，也提到了<code>lazy()</code>，它是 Kotlin 的一种标准委托，可以接受一个 lambda 并返回一个实例的函数。</p><p>如果我们想要延迟初始化，可以使用 <code>lazy()</code> 这个代理来实现，它会在第一次调用<code>get()</code> 方法时，执行 <code>lazy()</code> 的 lambda 表达式并记录结果，之后再调用 <code>get()</code>就只会返回之前记录的结果，非常适合延迟初始化的场景。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SomeSingleton</span></span>&#123;<br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> &#123;<br>        <span class="hljs-keyword">val</span> instance: SomeSingleton <span class="hljs-keyword">by</span> lazy &#123; SomeSingleton() &#125;<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p><code>lazy()</code> 默认情况下，内部就是依赖同步锁（synchronized）来实现的，所以它也是线程安全的。</p><p>但是正如我前面提到的，类本身也是按需加载的，调用它的下一步肯定是也需要使用它，所以只要我们正确的使用单例模式，其实没必要使用 <code>lazy()</code>，这里仅做一个介绍，大家知道一下就好了。</p><h2 id="委托属性："><a href="#委托属性：" class="headerlink" title="委托属性："></a>委托属性：</h2><p><strong><code>val/var &lt;属性名&gt;: &lt;类型&gt; by &lt;表达式&gt;</code>， <code>by</code> 后面的表达式就是该属性的委托。</strong></p><p>属性的委托不需要实现接口，但是需要提供一个<code>getValue()</code>函数与 <code>setValue()</code>函数（对于var属性，下同）。<strong>效果类似于自定义的<code>Getter</code>和<code>Setter</code>，因为属性对应的<code>get()</code>、<code>set()</code>方法会被委托给它的<code>getValue()</code>、<code>setValue()</code> 方法。</strong></p><p>百闻不如一见，我们还是写个简单的委托属性，大家一起看下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyStringDelegate</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> value = <span class="hljs-string">&quot;默认值2333...&quot;</span><br><br>    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getValue</span><span class="hljs-params">(thisRef: <span class="hljs-type">Any</span>?, property: <span class="hljs-type">KProperty</span>&lt;*&gt;)</span></span>: String &#123;<br>        <span class="hljs-keyword">return</span> value<br>    &#125;<br><br>    <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setValue</span><span class="hljs-params">(thisRef: <span class="hljs-type">Any</span>?, property: <span class="hljs-type">KProperty</span>&lt;*&gt;, value: <span class="hljs-type">String</span>)</span></span> &#123;<br>        <span class="hljs-keyword">this</span>.value = value<br>        println(<span class="hljs-string">&quot;我被赋值：<span class="hljs-variable">$value</span>&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>getValue()</code>、<code>setValue()</code>方法的参数比较拗口，为了避免手写出现错误，也可以通过继承<code>ReadWriteProperty</code>实现其中的方法，效果是一样的。</p><ul><li><code>thisRef</code>：为进行委托的类的对象，必须与属性所有者类型（对于扩展属性——指被扩展的类型）相同或者是它的超类型；</li><li><code>property</code>：为进行委托属性的对象本身，必须是类型<code>KProperty&lt;*&gt;</code>或其超类型；</li><li><code>value</code>（setValue）：必须与属性同类型或者是它的子类型。</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>    <span class="hljs-comment">// 将 a 的值委托给 MyStringDelegate</span><br>    <span class="hljs-keyword">var</span> a: String <span class="hljs-keyword">by</span> MyStringDelegate()<br>    println(a)<br>    a = <span class="hljs-string">&quot;Hello World&quot;</span><br>    println(a)<br>&#125;<br></code></pre></td></tr></table></figure><p>运行上面的代码，我们得到了如下结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">默认值2333...<br>我被赋值：Hello World<br>Hello World<br></code></pre></td></tr></table></figure><p>以上结果符合预期，因为<strong>在每个委托属性的实现的背后，Kotlin 编译器都会生成辅助属性并委托给它：取值时将调用<code>getValue()</code>方法，赋值时将调用<code>getValue()</code>方法</strong>，这一点在查看反编译的字节码也可以证实。</p><h2 id="静态内部类模式："><a href="#静态内部类模式：" class="headerlink" title="静态内部类模式："></a>静态内部类模式：</h2><h4 id="Java篇：-2"><a href="#Java篇：-2" class="headerlink" title="Java篇："></a>Java篇：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonJava</span> </span>&#123;<br><br>    <span class="hljs-comment">// 私有的构造方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingletonJava</span><span class="hljs-params">()</span> </span>&#123; &#125;<br><br>    <span class="hljs-comment">// 对外提供获取实例的静态方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonJava <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> SingletonHolder.INSTANCE;<br>    &#125;<br><br>    <span class="hljs-comment">// 在静态内部类中初始化实例对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonHolder</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> SingletonJava INSTANCE = <span class="hljs-keyword">new</span> SingletonJava();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Kotlin篇-2"><a href="#Kotlin篇-2" class="headerlink" title="Kotlin篇:"></a>Kotlin篇:</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonKotlin</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">constructor</span></span>() &#123;<br><br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> &#123;<br>        <span class="hljs-keyword">val</span> instance = SingletonHolder.INSTANCE<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">object</span> SingletonHolder &#123;<br>        <span class="hljs-keyword">val</span> INSTANCE = SingletonKotlin()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>两种写法没什么差别，只是Kotlin看着更精简一些，那这种写法到底有什么好处呐：</p><p>首先，在第一次加载<code>Singleton</code>类时并不会初始化<code>INSTANCE</code>，只有在第一次调用<code>getInstance()</code>方法时才会进行初始化操作。而由于静态内部类的特性，在第一次调用<code>getInstance()</code>方法时，虚拟机会去加载<code>SingletonHolder</code>类；<strong>这种方式不仅能够保证线程安全，也能够保证单例对象的唯一性，同时也延迟了单例的实例化。</strong></p><p>总得来说，静态内部类的写法优点和DCL写法类似；而且不会被反射入侵，因为反射不能从外部类获取内部类的属性。不足就是需要两个类去做到这一点，虽然不会创建静态内部类的对象，但是其Class对象还是会被创建，而且是属于永久的对象。瑕不掩瑜，这种写法依旧是种比较推荐的单例实现方式。</p><hr><h2 id="Enum单例："><a href="#Enum单例：" class="headerlink" title="Enum单例："></a>Enum单例：</h2><h4 id="Java篇：-3"><a href="#Java篇：-3" class="headerlink" title="Java篇："></a>Java篇：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BusCore</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">BusCore</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-comment">//构造函数私有</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> BusCore <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Singleton.INSTANCE.getInstance();<br>    &#125;<br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>        INSTANCE;<br>        <span class="hljs-keyword">private</span> BusCore classInstance;<br><br>        Singleton() &#123;<br>            classInstance = <span class="hljs-keyword">new</span> BusCore();<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> BusCore <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> classInstance;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Kotlin篇：-1"><a href="#Kotlin篇：-1" class="headerlink" title="Kotlin篇："></a>Kotlin篇：</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">enum</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonEnumKotlin</span> </span>&#123;<br><br>    INSTANCE;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span> &#123;<br>        println(<span class="hljs-string">&quot;doSomething: Kotlin&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用枚举来实现单例效果，确实是一种很骚的操作。枚举类与普通的类一样，也可以有自己的字段、方法，甚至实现一个或多个接口（<code>Interface</code>）。但枚举类不能作为子类继承其他类，也不能被继承，因为枚举反编译是<code>final</code>类型的。</p><p>使用枚举的究竟有何种优势呐，<strong>首先写法简单算一个；重要的是枚举实例的创建是线程安全的；而且在任何情况下它都是一个单例，即使反序列化也不会创建新的对象，而且JVM 还会阻止通过反射获取枚举类的私有构造方法。</strong></p><hr><h2 id="容器单例模式："><a href="#容器单例模式：" class="headerlink" title="容器单例模式："></a>容器单例模式：</h2><h4 id="Java篇：-4"><a href="#Java篇：-4" class="headerlink" title="Java篇："></a>Java篇：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonManagerJava</span> &#123;</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SingletonManagerJava</span><span class="hljs-params">()</span> </span>&#123; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerService</span><span class="hljs-params">(String key, Object instance)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!map.<span class="hljs-built_in">containsKey</span>(key)) &#123;<br>            map.<span class="hljs-built_in">put</span>(key, instance);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">getService</span><span class="hljs-params">(String key)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> map.<span class="hljs-built_in">get</span>(key);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Kotlin篇：-2"><a href="#Kotlin篇：-2" class="headerlink" title="Kotlin篇："></a>Kotlin篇：</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonManagerKotlin</span></span>() &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> map = mutableMapOf&lt;String, Any&gt;()<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">registerService</span><span class="hljs-params">(key: <span class="hljs-type">String</span>, instance: <span class="hljs-type">Any</span>)</span></span> &#123;<br>        <span class="hljs-keyword">if</span> (!map.containsKey(key)) &#123;<br>            map[key] = instance<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getService</span><span class="hljs-params">(key: <span class="hljs-type">String</span>)</span></span> = map[key]<br>&#125;<br></code></pre></td></tr></table></figure><p>在程序的初始，将多种单例类型注入到统一的管理类中，使用时根据key值获取对应的单例对象。使用这种方式我们可以管理多种类型的单例，并且可以通过统一的接口进行获取操作，降低了用户的使用成本，也对用户隐藏了具体实现，降低了耦合度。</p><p>此种方式一般用于系统层面，如Android的系统服务就是通过此种方式进行管理，使用时可以通过<code>getSystemService()</code>方法获取具体的服务对象。</p>]]></content>
    
    
    
    <tags>
      
      <tag>kotlin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>屏幕像素换算</title>
    <link href="/posts/523150ee/"/>
    <url>/posts/523150ee/</url>
    
    <content type="html"><![CDATA[<h1 id="Android中的dp、sp与px换算关系"><a href="#Android中的dp、sp与px换算关系" class="headerlink" title="Android中的dp、sp与px换算关系"></a>Android中的dp、sp与px换算关系</h1><p>Posted by Gityuan on September 2, 2015</p><blockquote><p>相信有不少开发者对于dp/sp/px，这些概念比较模糊，本文将讲解其含义和用途。</p></blockquote><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><ul><li><strong>px：</strong> 像素（pixel），设备上的物理像素点。</li><li><strong>dp：</strong>跟dip是同一个概念，与屏幕物理像素点无关，而是基于屏幕密度抽象单位，被称作“设备独立像素”,会随着屏幕的密度进行自动的大小调整。</li><li><strong>sp：</strong> 专用于文字大小的设置，可根据字体大小首选项进行缩放。</li><li><strong>inch：</strong> 英寸，1英寸 = 2.54厘米。</li><li><strong>dpi：</strong> 屏幕像素密度, 单位英寸上像素点的数量。</li><li><strong>分辨率：</strong> 是指横纵方向上的像素点数，单位是px。一般是纵向像素*横向像素，比如1920 * 1080</li><li><strong>屏幕尺寸：</strong> 屏幕对角线的长度，单位是inch。比如我们平时常说的5寸手机，是指手机屏幕的对角线长度为5英寸。</li></ul><hr><h3 id="2-换算关系"><a href="#2-换算关系" class="headerlink" title="2. 换算关系"></a>2. 换算关系</h3><p><strong>以下常见尺寸表：</strong></p><table><thead><tr><th>level</th><th>dpi</th><th>scale</th><th>resolution</th></tr></thead><tbody><tr><td>ldpi</td><td>120</td><td>0.75</td><td>320*240</td></tr><tr><td>mdpi</td><td>160</td><td>1</td><td>480*320</td></tr><tr><td>hdpi</td><td>240</td><td>1.5</td><td>800*480</td></tr><tr><td>xhdpi</td><td>320</td><td>2</td><td>1280*720</td></tr><tr><td>xxhdpi</td><td>480</td><td>3</td><td>1920*1080</td></tr><tr><td>xxxhdpi</td><td>640</td><td>4</td><td>2560*1440</td></tr></tbody></table><p><strong>说明：</strong></p><ul><li>google官方用的词是approximately，比如ldpi是值近似等于120dpi；</li><li>分辨率列只是比较有代表性的而已，但设备的dpi，还需要根据相应的设备尺寸来计算。同一分辨率，设备尺寸越大，那么dpi就越小，单位英寸上像素点越稀疏。</li></ul><p><strong>换算关系：</strong></p><p>android.util.TypedValue类提供了一个函数，提供所有单位与px的换算关系。</p><ul><li><strong>dpi如何计算</strong>？ dpi，英文全称dot per inch，是指每英寸上的像素点个数。 计算公式：dpi=√(X²+Y²)/Z (其中 X：纵向的像素个数；Y：横向的像素个数；Z：屏幕尺寸)</li><li><strong>scale是如何计算的</strong>？ 定义以160dpi作为基准，当前设备的dpi/160dpi = scale值。也就是当设备的dpi为160时1dp=1px.</li><li><strong>dp与px如何转换</strong>？ 计算公式：pxs = dps * (dpi/160)， 比如：320dpi的设备，10dp转换为px为 10 *（320/160）px = 20 px，即320dpi下10dp=20px.</li><li><strong>1dp到底等于多长呢</strong>？ 假设设备的dpi=320, 是指320px对应的长度为1英寸, 那么1px=1/320 英寸。再根据前面的公式， 1dp = （320/160） px = 2px。故1dp对应的长度为2 * (1/320)英寸，即1/160英寸。 同理，假设设备的dpi =N，那么1dp = (N/160) px = (N/160) * (1/N) inch = 1/160 inch，再加上前面提到的近似，可以得出结论为<strong>1dp约等于1/160英寸</strong>。</li></ul><h3 id="3-UI适配"><a href="#3-UI适配" class="headerlink" title="3. UI适配"></a>3. UI适配</h3><ul><li>layout中，最好采用wap_content, fill_parent，dp，可保证在屏幕上有合适的大小;</li><li>像素单位使用dp, 文字单位使用sp；</li><li>程序代码中不要出现具体的px;</li><li>图片应多使用.9.png；</li><li>使用百分比布局；</li><li>查看不同分辨率的设备市场占有率，分析出需要支持的设备分辨率：    <ul><li><a href="http://screensiz.es/">http://screensiz.es</a></li><li><a href="http://opensignal.com/reports/2015/08/android-fragmentation">http://opensignal.com/reports/2015/08/android-fragmentation</a></li></ul></li><li>对不同大小的屏幕提供不同的layout；</li><li>对不同密度的屏幕提供不同的图片；</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打包aar</title>
    <link href="/posts/5e9164d5/"/>
    <url>/posts/5e9164d5/</url>
    
    <content type="html"><![CDATA[<p><code>maven</code>插件已经过时，官方推荐使用这个插件来实现将我们的代码发布到 Apache Maven仓库的功能。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs groovy">plugins &#123;<br>    id <span class="hljs-string">&#x27;maven-publish&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="任务-Tasks"><a href="#任务-Tasks" class="headerlink" title="任务 Tasks"></a>任务 Tasks</h2><p>所有以下任务都归在名为<code>publishing</code>类型为<code>PublishingExtension</code>的扩展下。</p><p><strong>generatePomFileForPubNamePublication</strong></p><p>为名为<code>PubName</code>的发布创建一个POM文件，填充已知元数据，如项目名称、项目版本和依赖项。生成的POM文件默认放在<code>*build/publications/$pubName/pom-default.xml*.</code></p><p><strong>publishPubNamePublicationToRepoNameRepository</strong> </p><p>将名为<code>PubName</code>的发布发布到名为<code>RepoName</code>的存储库中。如果您有一个没有显式名称的存储库定义，那么<code>RepoName</code>将是<code>Maven</code>。</p><p><strong>publishPubNamePublicationToMavenLocal</strong> </p><p>将<code>PubName</code>发布复制到本地Maven缓存—通常是<code>*$USER_HOME/.m2/repository*</code>——连同发布的POM文件和其他元数据一起。</p><p><strong>publish</strong></p><p>依赖于所有<code>publishPubNamePublicationToRepoNameRepository</code>任务</p><p>将所有已定义的发布发布到所有已定义存储库的聚合任务。它不包括将发布复制到本地Maven缓存。</p><p><strong>publishToMavenLocal</strong></p><p>依赖于所有<code>publishPubNamePublicationToMavenLocal</code>任务</p><p>将所有已定义的发布复制到本地Maven缓存，包括它们的元数据(POM文件等)。</p><h2 id="发布-Publications"><a href="#发布-Publications" class="headerlink" title="发布 Publications"></a>发布 Publications</h2><p>Maven 发布中的配置主要有四种：</p><ul><li>一个component - 通过 <a href="https://link.zhihu.com/?target=https://docs.gradle.org/current/dsl/org.gradle.api.publish.maven.MavenPublication.html%23org.gradle.api.publish.maven.MavenPublication:from(org.gradle.api.component.SoftwareComponent)">MavenPublication.from(org.gradle.api.component.SoftwareComponent)</a>.</li><li><a href="https://link.zhihu.com/?target=https://docs.gradle.org/current/userguide/publishing_customization.html%23sec:publishing_custom_artifacts_to_maven">Custom artifacts</a> — 通过 <a href="https://link.zhihu.com/?target=https://docs.gradle.org/current/dsl/org.gradle.api.publish.maven.MavenPublication.html%23org.gradle.api.publish.maven.MavenPublication:artifact(java.lang.Object)">MavenPublication.artifact(java.lang.Object)</a> 方法. 查看<a href="https://link.zhihu.com/?target=https://docs.gradle.org/current/dsl/org.gradle.api.publish.maven.MavenArtifact.html">MavenArtifact</a> 获取所有可配置选项。</li><li>标准元数据，例如<code>artifactId</code>, <code>groupId</code> and <code>version</code>.</li><li>POM文件的其他内容 — 通过 <a href="https://link.zhihu.com/?target=https://docs.gradle.org/current/dsl/org.gradle.api.publish.maven.MavenPublication.html%23org.gradle.api.publish.maven.MavenPublication:pom(org.gradle.api.Action)">MavenPublication.pom(org.gradle.api.Action)</a>.</li></ul><h2 id="仓库-Repositories"><a href="#仓库-Repositories" class="headerlink" title="仓库 Repositories"></a>仓库 Repositories</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs groovy">publishing &#123;<br>    repositories &#123;<br>        maven &#123;<br>            <span class="hljs-comment">// 基于版本名称选择不同的仓库地址</span><br>            <span class="hljs-keyword">def</span> releasesRepoUrl = <span class="hljs-string">&quot;$buildDir/repos/releases&quot;</span><br>            <span class="hljs-keyword">def</span> snapshotsRepoUrl = <span class="hljs-string">&quot;$buildDir/repos/snapshots&quot;</span><br>            <span class="hljs-comment">// url是必须要配置的</span><br>            url = version.endsWith(<span class="hljs-string">&#x27;SNAPSHOT&#x27;</span>) ? snapshotsRepoUrl : releasesRepoUrl<br>            <span class="hljs-comment">// 仓库用户名密码</span><br>            credentials &#123;<br>                username = <span class="hljs-string">&quot;root&quot;</span><br>                password = <span class="hljs-string">&quot;root&quot;</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="完整例子"><a href="#完整例子" class="headerlink" title="完整例子"></a>完整例子</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs groovy">apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;maven-publish&#x27;</span><br><br>task generateSourcesJar(<span class="hljs-attr">type:</span> Jar) &#123;<br>    from android.sourceSets.main.java.srcDirs<br>    classifier <span class="hljs-string">&#x27;sources&#x27;</span><br>&#125;<br><br><span class="hljs-keyword">def</span> versionName = <span class="hljs-string">&quot;2.7.0-SNAPSHOT&quot;</span><br><br>publishing &#123;<br>    publications &#123;<br>        <span class="hljs-comment">// 定义一个名为 Production 的发布</span><br>        Production(MavenPublication) &#123;<br>            <span class="hljs-comment">// 使用方引用 implementation &#x27;cn.com.jack:mavendemo:2.7.0-SNAPSHOT&#x27;</span><br>            groupId = <span class="hljs-string">&quot;cn.com.jack&quot;</span><br>            artifactId = <span class="hljs-string">&quot;mavendemo&quot;</span><br>            version = versionName<br>            <span class="hljs-comment">// 必须有这个 否则不会上传AAR包</span><br>            afterEvaluate &#123; artifact(tasks.getByName(<span class="hljs-string">&quot;bundleReleaseAar&quot;</span>)) &#125;<br>            <span class="hljs-comment">// 上传source，这样使用方可以看到方法注释</span><br>            artifact generateSourcesJar<br>        &#125;<br>    &#125;<br>    repositories &#123;<br>        <span class="hljs-comment">// 定义一个 maven 仓库</span><br>        maven &#123;<br>            <span class="hljs-comment">// 可以有且仅有一个仓库不指定 name 属性，会隐式设置为 Maven</span><br>            <span class="hljs-comment">// 根据 versionName 来判断仓库地址</span><br>            url = versionName.endsWith(<span class="hljs-string">&#x27;SNAPSHOT&#x27;</span>) ? SNAPSHOT_REPOSITORY_URL : RELEASE_REPOSITORY_URL<br>            <span class="hljs-comment">// 仓库用户名密码</span><br>            credentials &#123;<br>                username = <span class="hljs-string">&quot;root&quot;</span><br>                password = <span class="hljs-string">&quot;root&quot;</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 定义第二个 maven 仓库，名为 Nexus</span><br>        maven &#123;<br>            <span class="hljs-comment">// 必须显示指定 name</span><br>            name = <span class="hljs-string">&quot;nexus&quot;</span><br>            url = versionName.endsWith(<span class="hljs-string">&#x27;SNAPSHOT&#x27;</span>) ? SNAPSHOT_REPOSITORY_URL : RELEASE_REPOSITORY_URL<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>Gradle Tool Window</code>中可以看到生成对应的任务。</p><blockquote><p><a href="https://link.zhihu.com/?target=https://docs.gradle.org/current/userguide/publishing_maven.html">官方文档 Maven Publish Plugin</a></p></blockquote><ul><li><code>./gradlew publishToMavenLocal</code>打包并发布到本地的maven库</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>gradle</tag>
      
      <tag>打包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kotlin 泛型协变</title>
    <link href="/posts/8c7f1459/"/>
    <url>/posts/8c7f1459/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>协变，逆变，抗变等概念是从数学中来的，在编程语言<code>Java/Kotlin/C#</code>中主要在泛型中使用。其描述的是两个类型集合之间的继承关系。有兴趣可以阅读这篇文章 <a href="https://typealias.com/guides/illustrated-guide-covariance-contravariance/">An Illustrated Guide to Covariance and Contravariance in Kotlin</a>。本文应该属于进阶知识，一般小白程序员不是没听说过就是听说过但是完全搞不明白其中的奥妙。看到即赚到，这又将是你进阶的一个台阶。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>首先让我们搞明白这三个名词的概念吧：</p><p>假设我们有如下两个类型集合</p><p>第一个集合为： <code>Animal</code>和<code>Dog</code> , <code>Dog</code>是<code>Animal</code>的子类</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">open <span class="hljs-keyword">class</span> <span class="hljs-symbol">Animal</span> <br><span class="hljs-symbol">class</span> <span class="hljs-symbol">Dog</span> : <span class="hljs-symbol">Animal</span>()<br></code></pre></td></tr></table></figure><p>第二个集合为 <code>List&lt;Animal&gt;</code> <code>List&lt;Dog&gt;</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">List<span class="hljs-tag">&lt;<span class="hljs-name">Animal</span>&gt;</span><br>List<span class="hljs-tag">&lt;<span class="hljs-name">Dog</span>&gt;</span><br></code></pre></td></tr></table></figure><p>现在问题来了：由于<code>Dog</code>是<code>Animal</code>的子类，那么<code>List&lt;Dog&gt;</code>就是<code>List&lt;Animal&gt;</code>的子类这句话在Kotlin/Java中对吗？</p><p>相信有一定<code>Java/Kotlin</code>编程经验的都可以回答的出来，答案是<strong>否定</strong>的。我们这里要说的协变，逆变，抗变就是描述上面两个类型集合的关系的。</p><ul><li>协变(Covariance)：<code>List&lt;Dog&gt;</code> 是<code>List&lt;Animal&gt;</code>的子类型</li><li>逆变(Contravariance): <code>List&lt;Animal&gt;</code> 是<code>List&lt;Dog&gt;</code>的子类型</li><li>抗变(Invariant): <code>List&lt;Animal&gt;</code> 与<code>List&lt;Dog&gt;</code>没有任何继承关系</li></ul><blockquote><p>A subtype must <strong>accept at least</strong> the same range of types as its supertype declares.<br> A subtype must <strong>return at most</strong> the same range of types as its supertype declares.</p></blockquote><h1 id="Java中的情形"><a href="#Java中的情形" class="headerlink" title="Java中的情形"></a>Java中的情形</h1><p>由于Kotlin是尝试对Java的改进，所以我们先来看Java的情况：</p><h2 id="抗变"><a href="#抗变" class="headerlink" title="抗变"></a>抗变</h2><p>Java中泛型是<strong>抗变</strong>的，那就意味着<code>List&lt;String&gt;</code>不是<code>List&lt;Object&gt;</code>的子类型。因为如果不这样的话就会产生类型不安全问题。</p><p>例如下面代码可以通过编译的话，就会在运行时抛出异常</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">List</span><span class="hljs-operator">&lt;</span><span class="hljs-built_in">String</span><span class="hljs-operator">&gt;</span> <span class="hljs-variable">strs</span> <span class="hljs-operator">=</span> <span class="hljs-variable">new</span> <span class="hljs-variable">ArrayList</span><span class="hljs-operator">&lt;</span><span class="hljs-built_in">String</span><span class="hljs-operator">&gt;</span><span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span><span class="hljs-operator">;</span><br><span class="hljs-built_in">List</span><span class="hljs-operator">&lt;</span><span class="hljs-variable">Object</span><span class="hljs-operator">&gt;</span> <span class="hljs-variable">objs</span> <span class="hljs-operator">=</span> <span class="hljs-variable">strs</span><span class="hljs-operator">;</span> <br><span class="hljs-variable">objs</span><span class="hljs-operator">.</span><span class="hljs-variable">add</span><span class="hljs-punctuation">(</span><span class="hljs-number">1</span><span class="hljs-punctuation">)</span><span class="hljs-operator">;</span> <br> <span class="hljs-operator">//</span> 尝试将<span class="hljs-built_in">Integer</span> 转换为<span class="hljs-built_in">String</span><span class="hljs-operator">,</span>发生运行时异常 <span class="hljs-variable">ClassCastException</span><span class="hljs-operator">:</span> <span class="hljs-variable">Cannot</span> <span class="hljs-variable">cast</span> <span class="hljs-built_in">Integer</span> <span class="hljs-variable">to</span> <span class="hljs-built_in">String</span><br><span class="hljs-built_in">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-variable">strs</span><span class="hljs-operator">.</span><span class="hljs-variable">get</span><span class="hljs-punctuation">(</span><span class="hljs-number">0</span><span class="hljs-punctuation">)</span><span class="hljs-operator">;</span><br></code></pre></td></tr></table></figure><p>所以上面的代码在编译时就会报错，这就保证了类型安全。</p><p>但值得注意的是Java中的<strong>数组是协变的</strong>，所以数组真的会遇到上面的问题，编译可以正常通过，但会发生运行时异常，所以在Java中要优先使用泛型集合。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">String</span>[] strs= <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>[]&#123;<span class="hljs-string">&quot;ss007&quot;</span>&#125;;<br><span class="hljs-built_in">Object</span>[] objs= strs;<br>objs[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h2 id="协变"><a href="#协变" class="headerlink" title="协变"></a>协变</h2><p><strong>抗变性</strong>会严重制约程序的灵活性，例如有如下方法<code>copyAll</code>,将一个<code>String</code>集合的内容<strong>copy</strong>到一个<code>Object</code>集合中，这是顺理成章的事。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// Java</span><br><span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">copyAll</span>(<span class="hljs-params">Collection&lt;<span class="hljs-built_in">Object</span>&gt; to, Collection&lt;<span class="hljs-built_in">String</span>&gt; <span class="hljs-keyword">from</span></span>)</span> &#123;<br>     to.addAll(<span class="hljs-keyword">from</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>但是如果<code>Collection&lt;E&gt;</code>中的<code>addAll</code>方法签名如下的话，<code>copyAll</code>方法就通不过编译，因为通过上面的讲解，我们知道由于抗变性，<code>Collection&lt;String&gt; </code>不是<code>Collection&lt;Object&gt;</code>的子类，所以编译通不过。 </p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">addAll</span><span class="hljs-params">(Collection&lt;E&gt; c)</span></span>;<br></code></pre></td></tr></table></figure><p>那怎么办呢？</p><p>Java通过<strong>通配符参数</strong>(wildcard type argument)来解决, 把<code>addAll </code>的签名改成如下即可：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">addAll</span><span class="hljs-params">(Collection&lt;? <span class="hljs-keyword">extends</span> E&gt; c)</span></span>;<br></code></pre></td></tr></table></figure><p><code>? extends E</code> 表示此方法可以接收<code>E</code>或者<code>E</code>的子类的集合。此通配符使得泛型类型<strong>协变</strong>了。</p><h2 id="逆变"><a href="#逆变" class="headerlink" title="逆变"></a>逆变</h2><p>同理有时我们需要将<code>Collection&lt;Object&gt;</code>传递给<code>Collection&lt;String&gt; </code>就使用<code>? super E</code>，其 表示可以接收<code>E</code>或者<code>E</code>的父类，子类的位置却可以接收父类的实例，这就使得泛型类型发生了<strong>逆变</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">m</span> <span class="hljs-params">(List&lt;? super <span class="hljs-keyword">String</span>)</span></span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="协变与逆变的特性"><a href="#协变与逆变的特性" class="headerlink" title="协变与逆变的特性"></a>协变与逆变的特性</h2><p>当使用<code>? extends E</code> 时，只能调用传入参数的<strong>读取</strong>方法而无法调用其<strong>修改</strong>方法。<br> 当使用<code>? super E</code>时，可以调用输入参数的<strong>修改</strong>方法，但调用<strong>读取</strong>方法的话返回值类型永远是Object，几乎没有用处。</p><p>是不是感觉不好理解，确实不好理解！让我们一起看下<code>code</code>吧，理解了Java的这块，Kotlin的<code>In</code>和<code>out</code>关键字就手到擒来了。</p><p>例如有如下一接口，其有两个方法，一个修改，一个读取。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">interface</span> <span class="hljs-title">BoxJ</span>&lt;<span class="hljs-title">T</span>&gt; &#123;<br>      <span class="hljs-function">T <span class="hljs-title">getAnimal</span>(<span class="hljs-params"></span>)</span>;<br>      <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">putAnimal</span>(<span class="hljs-params">T a</span>)</span>;<br>  &#125;<br></code></pre></td></tr></table></figure><p>下面是两个使用通配符的方法，注意看注释</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-comment">//协变，可以接受BoxJ&lt;Dog&gt;类型的参数</span><br> <span class="hljs-keyword">private</span> Animal getOutAnimalFromBox(BoxJ&lt;? extends Animal&gt; <span class="hljs-built_in">box</span>) &#123;<br>       Animal animal = <span class="hljs-built_in">box</span>.getAnimal();<br>      <span class="hljs-comment">// box.putAnimal(某个类型) 无法调用该修改方法，因为无法确定 ？究竟是一个什么类型，没办法传入</span><br>       <span class="hljs-keyword">return</span> animal;<br>  &#125;<br><br><span class="hljs-comment">//逆变，可以接受BoxJ&lt;Animal&gt;类型的参数</span><br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> putAnimalInBox(BoxJ&lt;? <span class="hljs-keyword">super</span> Dog&gt; <span class="hljs-built_in">box</span>)&#123;<br>        <span class="hljs-built_in">box</span>.putAnimal(<span class="hljs-keyword">new</span> Dog());<br>        <span class="hljs-comment">// 虽然可以调用读取方法，但返回的类型却是Object，因为我们只能确定 ？的最顶层基类是Object</span><br>        <span class="hljs-keyword">Object</span> animal= <span class="hljs-built_in">box</span>.getAnimal();<br>  &#125;<br></code></pre></td></tr></table></figure><p>关于Java的通配符如何使用，<a href="http://www.oracle.com/technetwork/java/effectivejava-136174.html"> Effective Java, 3rd Edition</a> 的作者将其总结为：<strong>PECS</strong> : stands for Producer-Extends, Consumer-Super. 结合上面代码分析是不是觉得很精辟。 </p><ul><li>Producer-Extends 只能调用读取方法，向外提供数据，无法调用修改方法</li><li>Consumer-Super  一般只调用修改方法，消费从外面获取的数据，调用读取方法几乎没什么用，拿到的类型永远是<code>Object</code></li></ul><p>建议自己动手尝试一下,不然还是会有点懵</p><p>那Java这种方式有没有弊端呢？Kotlin官方认为有，但是我却没怎么领会，请原谅我。其大概的意思就是说：增加了复杂性，但却没有获得相应的好处。</p><h1 id="Kotlin中的情形"><a href="#Kotlin中的情形" class="headerlink" title="Kotlin中的情形"></a>Kotlin中的情形</h1><h1 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h1><p>本文承接于上一篇：秒懂Kotlin之协变(Covariance)逆变(Contravariance)与抗变(Invariant)，<strong>一定要先阅读这一篇文章</strong>，再阅读本文，不然看不懂！</p><p>上篇讲到Java中泛型是<strong>抗变</strong>的，但是数组却是<strong>协变</strong>的。Kotlin做的更彻底，不仅泛型是抗变的就连数组也变成抗变的了。</p><p>下面的代码是编译不过的</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">val</span> strArray:Array&lt;String&gt; = <span class="hljs-built_in">array</span><span class="hljs-constructor">Of(<span class="hljs-string">&quot;shu&quot;</span>,<span class="hljs-string">&quot;sheng&quot;</span>,<span class="hljs-string">&quot;007&quot;</span>)</span><br><span class="hljs-keyword">val</span> <span class="hljs-built_in">array</span>:Array&lt;Any&gt; = strArray<br></code></pre></td></tr></table></figure><p>报错：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">Type</span> <span class="hljs-type">mismatch: </span>inferred <span class="hljs-keyword">type</span> <span class="hljs-type">is </span><span class="hljs-keyword">Array</span>&lt;String&gt; but <span class="hljs-keyword">Array</span>&lt;Any&gt; was expected<br></code></pre></td></tr></table></figure><h1 id="泛型型变"><a href="#泛型型变" class="headerlink" title="泛型型变"></a>泛型型变</h1><p>官方文档见：<a href="https://kotlinlang.org/docs/reference/generics.html#variance">Variance</a></p><p>Kotlin中没有通配符，取而代之的是 <strong>Declaration-site variance</strong>和<strong>Use-site variance</strong> 。其通过两个关键字<code>out</code>和<code>in</code>来实现Java中的<code>? extends</code> 与<code>? super </code>的功能.</p><p>假设我们有如下两个类和一个接口</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span></span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> : <span class="hljs-type">Animal</span></span>()<br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Box</span>&lt;<span class="hljs-type">T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getAnimal</span><span class="hljs-params">()</span></span>: T<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">putAnimal</span><span class="hljs-params">(a: <span class="hljs-type">T</span>)</span></span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="协变（out）"><a href="#协变（out）" class="headerlink" title="协变（out）"></a>协变（out）</h2><p>我们要定义一个方法，参数类型为<code>Box&lt;Animal&gt;</code>，但是我们希望可以传入<code>Box&lt;Dog&gt;</code>即希望可以发生<strong>协变</strong>。</p><p>Java实现</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> Animal get<span class="hljs-constructor">OutAnimalFromBox(Box&lt;? <span class="hljs-params">extends</span> Animal&gt; <span class="hljs-params">box</span>)</span> &#123;<br>   Animal animal = box.get<span class="hljs-constructor">Animal()</span>;<br><span class="hljs-comment">//       box.putAnimal(？ ) 没有办法调用修改方法，因为我们不知道？究竟是一个什么类型，没办法传入</span><br>   return animal;<br>&#125;<br></code></pre></td></tr></table></figure><p>Kotlin对应的实现为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getAnimalFromBox</span><span class="hljs-params">(b: <span class="hljs-type">Box</span>&lt;<span class="hljs-type">out</span> <span class="hljs-type">Animal</span>&gt;)</span></span> : Animal &#123;<br>    <span class="hljs-keyword">val</span> animal: Animal = b.getAnimal()<br><span class="hljs-comment">//    b.putAnimal(Nothing) 无法调用，因为方法需要一个Nothing类型的对象，但是在kotlin中无法获取</span><br>    <span class="hljs-keyword">return</span> animal<br>&#125;<br></code></pre></td></tr></table></figure><p>此方法可以接受<code>Box&lt;Dog&gt;</code>类型的参数了。</p><p>可见此处使用<code>out</code> 代替了<code>? extends</code>。从结果来看确实更合适一点，因为传入的参数只能提供值，而不能消费值。由于<code>out</code>是在方法调用的参数中标记的，处于使用端，所以叫<strong>Use-site variance</strong>与<strong>Use-site variance</strong>对应的就是<strong>Declaration-site variance</strong>了。</p><p>我们发现接口<code> Box&lt;T&gt;</code>中既有消费值的方法<code>fun putAnimal(a: T)</code>，又有提供值的方法<code>fun getAnimal(): T</code>,导致我们必须在使用侧告诉编译器我们要使用哪一类方法。那我们可以在声明接口的时候告诉编译器吗？答案是肯定的，但是就需要将接口拆分为只包含提供值的方法的接口<strong>producer</strong>与只包含消费值的方法的接口<strong>consumer</strong>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//producer</span><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ReadableBox</span>&lt;<span class="hljs-type">out T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getAnimal</span><span class="hljs-params">()</span></span>: T<br>&#125;<br><span class="hljs-comment">//consumer</span><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">WritableBox</span>&lt;<span class="hljs-type">in T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">putAnimal</span><span class="hljs-params">(a: <span class="hljs-type">T</span>)</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>拆分完接口并做了相应的声明后，就可以不在使用端使用<code>out</code>或者<code>in</code>了。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getAnimalFromReadableBox</span><span class="hljs-params">(b: <span class="hljs-type">ReadableBox</span>&lt;<span class="hljs-type">Animal</span>&gt;)</span></span>&#123;<br>    <span class="hljs-keyword">val</span> a: Animal = b.getAnimal()<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的方法可以直接接受<code>ReadableBox&lt;Dog&gt;</code>类型的参数，给人的感觉好像是Kotlin使得泛型协变了。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">getAnimalFromReadableBox(<span class="hljs-keyword">object</span> :ReadableBox&lt;Dog&gt;&#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getAnimal</span><span class="hljs-params">()</span></span>: Dog &#123;<br>        <span class="hljs-keyword">return</span> Dog()<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>此种情况下<code>out</code>和<code>in</code>是在声明时候使用的，所以叫<strong>Declaration-site variance</strong>了。</p><h2 id="逆变（in）"><a href="#逆变（in）" class="headerlink" title="逆变（in）"></a>逆变（in）</h2><p>我们要定义一个方法，参数类型为<code>Box&lt;Dog&gt;</code>，但是我们希望可以传入<code>Box&lt;Animal&gt;</code>，即希望可以发生<strong>逆变</strong>。</p><p>Java实现</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> putAnimalInBox(BoxJ&lt;? <span class="hljs-keyword">super</span> Dog&gt; <span class="hljs-built_in">box</span>)&#123;<br>    <span class="hljs-built_in">box</span>.putAnimal(<span class="hljs-keyword">new</span> Dog());<br>    <span class="hljs-keyword">Object</span> animal= <span class="hljs-built_in">box</span>.getAnimal();<span class="hljs-comment">// 可以调用读取方法，但是返回的类型确实Object，因为我们只能确定？的大基类是Object</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Kotlin对应实现</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">putAnimalInBox</span><span class="hljs-params">(b: <span class="hljs-type">Box</span>&lt;<span class="hljs-type">in</span> <span class="hljs-type">Dog</span>&gt;)</span></span>&#123;<br>    b.putAnimal(Dog())<br>    <span class="hljs-keyword">val</span> animal:Any? = b.getAnimal()<span class="hljs-comment">// 可以调用读取方法，但是返回的类型确实Any?，因为我们只能确定？的大基类是Any?</span><br>&#125;<br></code></pre></td></tr></table></figure><p>此方法可以接受<code>Box&lt;Animal&gt;</code>类型的参数了</p><p>可见此处使用<code>in</code> 代替了<code>? super</code>,从结果来看确实更合适一点，因为传入的参数只适合消费值，而不适合获取值，获取到的值失去了有用的类型信息。由于<code>in</code>是在方法调用的参数中标记的，处于使用端，所以叫<strong>Use-site variance</strong></p><p>让我们来看一下使用<strong>Declaration-site variance</strong>实现逆变</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">putAnimalToWritableBox</span><span class="hljs-params">(b:<span class="hljs-type">WritableBox</span>&lt;<span class="hljs-type">Dog</span>&gt;)</span></span>&#123;<br>    b.putAnimal(Dog())<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的方法可以直接接受<code>WritableBox&lt;Animal&gt;</code>类型的参数，给人的感觉好像是Kotlin使得泛型逆变了。  </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">putAnimalToWritableBox(<span class="hljs-keyword">object</span> :WritableBox&lt;Animal&gt;&#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">putAnimal</span><span class="hljs-params">(a: <span class="hljs-type">Animal</span>)</span></span> &#123;<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h1 id="in-amp-out-怎么记？"><a href="#in-amp-out-怎么记？" class="headerlink" title="in &amp; out 怎么记？"></a>in &amp; out 怎么记？</h1><ul><li>out 相当于java里面<T extends Type>，in相当于 <T super Type></li></ul><p><strong>Out (协变)</strong></p><p>如果你的类是将泛型作为内部方法的返回，那么可以用 out：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Production</span>&lt;<span class="hljs-type">out T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">produce</span><span class="hljs-params">()</span></span>: T<br>&#125;<br></code></pre></td></tr></table></figure><p>可以称其为 production class/interface，因为其主要是产生（produce）指定泛型对象。因此，可以这样来记：<em>produce = output = out</em>。</p><p><strong>In(逆变)</strong></p><p>如果你的类是将泛型对象作为函数的参数，那么可以用 in：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Consumer</span>&lt;<span class="hljs-type">in T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">consume</span><span class="hljs-params">(item: <span class="hljs-type">T</span>)</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以称其为 consumer class/interface，因为其主要是消费指定泛型对象。因此，可以这样来记：<em>consume = input = in。</em></p><p><strong>Invariant(不变)</strong></p><p>如果既将泛型作为函数参数，又将泛型作为函数的输出，那就既不用 in 或 out。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ProductionConsumer</span>&lt;<span class="hljs-type">T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">produce</span><span class="hljs-params">()</span></span>: T<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">consume</span><span class="hljs-params">(item: <span class="hljs-type">T</span>)</span></span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h2><p>假设我们有一个汉堡（burger）对象，它是一种快餐，当然更是一种食物</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Food</span></span><br><span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FastFood</span> : <span class="hljs-type">Food</span></span>() <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Burger</span> : <span class="hljs-type">FastFood</span></span>()<br></code></pre></td></tr></table></figure><p><strong>1. 汉堡提供者</strong></p><p>根据上面定义的类和接口来设计提供 <em>food, fastfood</em> 和 <em>burger</em> 的类：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FoodStore</span> : <span class="hljs-type">Production</span>&lt;<span class="hljs-type">Food</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">produce</span><span class="hljs-params">()</span></span>: Food &#123;<br>        println(<span class="hljs-string">&quot;Produce food&quot;</span>)<br>        <span class="hljs-keyword">return</span> Food()<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FastFoodStore</span> : <span class="hljs-type">Production</span>&lt;<span class="hljs-type">FastFood</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">produce</span><span class="hljs-params">()</span></span>: FastFood &#123;<br>        println(<span class="hljs-string">&quot;Produce food&quot;</span>)<br>        <span class="hljs-keyword">return</span> FastFood()<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InOutBurger</span> : <span class="hljs-type">Production</span>&lt;<span class="hljs-type">Burger</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">produce</span><span class="hljs-params">()</span></span>: Burger &#123;<br>        println(<span class="hljs-string">&quot;Produce burger&quot;</span>)<br>        <span class="hljs-keyword">return</span> Burger()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在，我们可以这样赋值：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> production1 : Production&lt;Food&gt; = FoodStore()<br><span class="hljs-keyword">val</span> production2 : Production&lt;Food&gt; = FastFoodStore()<br><span class="hljs-keyword">val</span> production3 : Production&lt;Food&gt; = InOutBurger()<br></code></pre></td></tr></table></figure><p>很显然，汉堡商店属于是快餐商店，当然也属于食品商店。</p><blockquote><p><strong>因此，对于 out 泛型，我们能够将使用子类泛型的对象赋值给使用父类泛型的对象。</strong></p></blockquote><p>而如果像下面这样反过来使用子类 - Burger 泛型，就会出现错误，因为快餐（fastfood）和食品（food）商店不仅仅提供汉堡（burger）。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> production1 : Production&lt;Burger&gt; = FoodStore()  <span class="hljs-comment">// Error</span><br><span class="hljs-keyword">val</span> production2 : Production&lt;Burger&gt; = FastFoodStore()  <span class="hljs-comment">// Error</span><br><span class="hljs-keyword">val</span> production3 : Production&lt;Burger&gt; = InOutBurger()<br></code></pre></td></tr></table></figure><p><strong>2. 汉堡消费者</strong></p><p>再让我们根据上面的类和接口来定义汉堡消费者类：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Everybody</span> : <span class="hljs-type">Consumer</span>&lt;<span class="hljs-type">Food</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">consume</span><span class="hljs-params">(item: <span class="hljs-type">Food</span>)</span></span> &#123;<br>        println(<span class="hljs-string">&quot;Eat food&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ModernPeople</span> : <span class="hljs-type">Consumer</span>&lt;<span class="hljs-type">FastFood</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">consume</span><span class="hljs-params">(item: <span class="hljs-type">FastFood</span>)</span></span> &#123;<br>        println(<span class="hljs-string">&quot;Eat fast food&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">American</span> : <span class="hljs-type">Consumer</span>&lt;<span class="hljs-type">Burger</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">consume</span><span class="hljs-params">(item: <span class="hljs-type">Burger</span>)</span></span> &#123;<br>        println(<span class="hljs-string">&quot;Eat burger&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在，我们能够将 <em>Everybody, ModernPeople</em> 和 American 都指定给汉堡消费者（Consumer<Burger>）：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> consumer1 : Consumer&lt;Burger&gt; = Everybody()<br><span class="hljs-keyword">val</span> consumer2 : Consumer&lt;Burger&gt; = ModernPeople()<br><span class="hljs-keyword">val</span> consumer3 : Consumer&lt;Burger&gt; = American()<br></code></pre></td></tr></table></figure><p>很显然这里美国的汉堡的消费者既是现代人，更是人类。</p><blockquote><p><strong>因此，对于 in 泛型，我们可以将使用父类泛型的对象赋值给使用子类泛型的对象。</strong></p></blockquote><p>同样，如果这里反过来使用父类 - Food 泛型，就会报错：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> consumer1 : Consumer&lt;Food&gt; = Everybody()<br><span class="hljs-keyword">val</span> consumer2 : Consumer&lt;Food&gt; = ModernPeople()  <span class="hljs-comment">// Error</span><br><span class="hljs-keyword">val</span> consumer3 : Consumer&lt;Food&gt; = American()  <span class="hljs-comment">// Error</span><br></code></pre></td></tr></table></figure><p>根据以上的内容，我们还可以这样来理解什么时候用 in 和 out：</p><ul><li>父类泛型对象可以赋值给子类泛型对象，用 in；</li><li>子类泛型对象可以赋值给父类泛型对象，用 out。</li></ul><p>作者：极小光<br>链接：<a href="https://www.jianshu.com/p/c5ef8b30d768">https://www.jianshu.com/p/c5ef8b30d768</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    
    
    <tags>
      
      <tag>kotlin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kotlin 技巧-写Intent的扩展</title>
    <link href="/posts/6b676e55/"/>
    <url>/posts/6b676e55/</url>
    
    <content type="html"><![CDATA[<h1 id="记一次写Intent的扩展"><a href="#记一次写Intent的扩展" class="headerlink" title="记一次写Intent的扩展"></a>记一次写Intent的扩展</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>写项目的时候经常会写到跳转Activiey，写到跳转Activit就一定会写到putExtra，就像下面那样</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><br>intent.put<span class="hljs-constructor">Extra(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-params">item</span>.<span class="hljs-params">a</span>)</span><br>intent.put<span class="hljs-constructor">Extra(<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-params">item</span>.<span class="hljs-params">b</span>)</span><br>intent.put<span class="hljs-constructor">Extra(<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-params">item</span>.<span class="hljs-params">c</span>)</span><br></code></pre></td></tr></table></figure><p>挺多哈，每次都要重复前面相同的内容，所以就想着能不能写个扩展来简写。</p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>我们最终实现是这样的：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><br>Intent(context, TestActivity::<span class="hljs-built_in">class</span>.java)<br>  .putExtraVararg(<br>    <span class="hljs-string">&quot;a&quot;</span> <span class="hljs-keyword">to</span> <span class="hljs-built_in">item</span>.a, <br>    <span class="hljs-string">&quot;b&quot;</span> <span class="hljs-keyword">to</span> <span class="hljs-built_in">item</span>.b, <br>    <span class="hljs-string">&quot;c&quot;</span> <span class="hljs-keyword">to</span> <span class="hljs-built_in">item</span>.c<br>  )<br></code></pre></td></tr></table></figure><h3 id="仿mapOf"><a href="#仿mapOf" class="headerlink" title="仿mapOf"></a>仿mapOf</h3><p>经常用到<code>mapOf()</code>或者<code>mutableMapOf()</code>就会知道，里面是用了<code>Pair</code>类来生成Map的，所以受此启发，打算用<code>Pair</code>来作为参数实现，那么写的时候就应该是这样写，参数为可变参数类型：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><br><span class="hljs-comment">// 作为Intent的扩展</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> Intent.<span class="hljs-title">putExtraVararg</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">vararg</span> extras: <span class="hljs-type">Pair</span>&lt;<span class="hljs-type">String</span>, Any?&gt;</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>: Intent &#123;<br>    <span class="hljs-comment">// 先省略</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>putExtra</code>的第一个参数类型肯定是<code>String</code>类型，第二个参数的类型包括<code>Bundle, Boolean, BooleanArray, Byte, ByteArray, Char, CharArray, String</code>等等，所以就用<code>Any</code>类型，因为是可空的，所以加上<code>?</code>。</p><p>那么调用的时候，就是这样子的</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><br>Intent(context, TestActivity::<span class="hljs-built_in">class</span>.java)<br>    .putExtraVararg(<br>        <span class="hljs-string">&quot;a&quot;</span> <span class="hljs-keyword">to</span> <span class="hljs-built_in">item</span>.a, <br>        <span class="hljs-string">&quot;b&quot;</span> <span class="hljs-keyword">to</span> <span class="hljs-built_in">item</span>.b, <br>        <span class="hljs-string">&quot;c&quot;</span> <span class="hljs-keyword">to</span> <span class="hljs-built_in">item</span>.c<br>    )<br></code></pre></td></tr></table></figure><p>是不是就是一开始说的那样，对比平常写的是不是简单了很多。</p><h3 id="参数类型匹配"><a href="#参数类型匹配" class="headerlink" title="参数类型匹配"></a>参数类型匹配</h3><p>写好了参数，那么就要进行对参数类型的匹配进行对应的<code>putExtra</code>。</p><p><code>vararg</code>参数可以用<code>forEach</code>来循环对每个参数类型进行匹配：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><br><span class="hljs-function"><span class="hljs-keyword">fun</span> Intent.<span class="hljs-title">putExtraVararg</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">vararg</span> extras: <span class="hljs-type">Pair</span>&lt;<span class="hljs-type">String</span>, Any?&gt;</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>: Intent &#123;<br>    <span class="hljs-keyword">if</span> (extras.isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span><br>    extras.forEach &#123; (key, value) -&gt;<br>        value ?: let &#123;<br>            it.putExtra(key, it.toString())<br>            <span class="hljs-keyword">return</span><span class="hljs-symbol">@forEach</span><br>        &#125;<br>        <span class="hljs-keyword">when</span> (value) &#123;<br>            <span class="hljs-keyword">is</span> Bundle -&gt; <span class="hljs-keyword">this</span>.putExtra(key, value)<br>            <span class="hljs-keyword">is</span> <span class="hljs-built_in">Boolean</span> -&gt; <span class="hljs-keyword">this</span>.putExtra(key, value)<br>            <span class="hljs-keyword">is</span> BooleanArray -&gt; <span class="hljs-keyword">this</span>.putExtra(key, value)<br>            <span class="hljs-keyword">is</span> <span class="hljs-built_in">Byte</span> -&gt; <span class="hljs-keyword">this</span>.putExtra(key, value)<br>            <span class="hljs-keyword">is</span> ByteArray -&gt; <span class="hljs-keyword">this</span>.putExtra(key, value)<br>            <span class="hljs-keyword">is</span> <span class="hljs-built_in">Char</span> -&gt; <span class="hljs-keyword">this</span>.putExtra(key, value)<br>            <span class="hljs-keyword">is</span> CharArray -&gt; <span class="hljs-keyword">this</span>.putExtra(key, value)<br>            <span class="hljs-keyword">is</span> String -&gt; <span class="hljs-keyword">this</span>.putExtra(key, value)<br>            <span class="hljs-keyword">is</span> CharSequence -&gt; <span class="hljs-keyword">this</span>.putExtra(key, value)<br>            <span class="hljs-keyword">is</span> <span class="hljs-built_in">Double</span> -&gt; <span class="hljs-keyword">this</span>.putExtra(key, value)<br>            <span class="hljs-keyword">is</span> DoubleArray -&gt; <span class="hljs-keyword">this</span>.putExtra(key, value)<br>            <span class="hljs-keyword">is</span> <span class="hljs-built_in">Float</span> -&gt; <span class="hljs-keyword">this</span>.putExtra(key, value)<br>            <span class="hljs-keyword">is</span> FloatArray -&gt; <span class="hljs-keyword">this</span>.putExtra(key, value)<br>            <span class="hljs-keyword">is</span> <span class="hljs-built_in">Int</span> -&gt; <span class="hljs-keyword">this</span>.putExtra(key, value)<br>            <span class="hljs-keyword">is</span> IntArray -&gt; <span class="hljs-keyword">this</span>.putExtra(key, value)<br>            <span class="hljs-keyword">is</span> <span class="hljs-built_in">Long</span> -&gt; <span class="hljs-keyword">this</span>.putExtra(key, value)<br>            <span class="hljs-keyword">is</span> LongArray -&gt; <span class="hljs-keyword">this</span>.putExtra(key, value)<br>            <span class="hljs-keyword">is</span> <span class="hljs-built_in">Short</span> -&gt; <span class="hljs-keyword">this</span>.putExtra(key, value)<br>            <span class="hljs-keyword">is</span> ShortArray -&gt; <span class="hljs-keyword">this</span>.putExtra(key, value)<br>            <span class="hljs-keyword">is</span> Parcelable -&gt; <span class="hljs-keyword">this</span>.putExtra(key, value)<br>            <span class="hljs-keyword">is</span> Serializable -&gt; <span class="hljs-keyword">this</span>.putExtra(key, value)<br>            <span class="hljs-keyword">else</span> -&gt; &#123;<br>                <span class="hljs-keyword">throw</span> IllegalArgumentException(<span class="hljs-string">&quot;Not support <span class="hljs-variable">$value</span> type <span class="hljs-subst">$&#123;value.javaClass&#125;</span>..&quot;</span>)<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span><br>&#125;<br></code></pre></td></tr></table></figure><p>发现没有，还少了<code>ArrayList&lt;String&gt;</code>、<code>ArrayList&lt;CharSequence&gt;</code>、<code>ArrayList&lt;? extends Parcelable&gt;</code>这三个List的参数类型匹配，因为不能直接<code>is</code>来匹配对应的Array类型，在群里问过之后，才得出最终的方法，Array里面有一个匹配对应类型的扩展函数<code>isArrayOf()</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Checks if array can contain element of type [T].</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Suppress(<span class="hljs-meta-string">&quot;REIFIED_TYPE_PARAMETER_NO_INLINE&quot;</span>)</span><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;<span class="hljs-keyword">reified</span> T : Any&gt;</span> Array<span class="hljs-type">&lt;*&gt;</span>.<span class="hljs-title">isArrayOf</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Boolean</span> =<br>    T::<span class="hljs-keyword">class</span>.java.isAssignableFrom(<span class="hljs-keyword">this</span>::<span class="hljs-keyword">class</span>.java.componentType)<br></code></pre></td></tr></table></figure><p>so，这样就简单了，我们先匹配<code>Array</code>，然后在匹配对应的<code>ArrayList&lt;String&gt;</code>、<code>ArrayList&lt;CharSequence&gt;</code>、<code>ArrayList&lt;? extends Parcelable&gt;</code>，最后在对应put方法那里用<code>as</code>：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><br><span class="hljs-keyword">is</span> <span class="hljs-built_in">Array</span>&lt;*&gt; -&gt; &#123;<br>    @Suppress(<span class="hljs-string">&quot;UNCHECKED_CAST&quot;</span>)<br>    <span class="hljs-keyword">when</span> &#123;<br>        value.isArrayOf&lt;<span class="hljs-built_in">String</span>&gt;<span class="hljs-function"><span class="hljs-params">()</span> -&gt;</span> &#123;<br>            <span class="hljs-built_in">this</span>.putStringArrayListExtra(key, value <span class="hljs-keyword">as</span> ArrayList&lt;<span class="hljs-built_in">String</span>?&gt;)<br>        &#125;<br>        value.isArrayOf&lt;CharSequence&gt;<span class="hljs-function"><span class="hljs-params">()</span> -&gt;</span> &#123;<br>            <span class="hljs-built_in">this</span>.putCharSequenceArrayListExtra(key, value <span class="hljs-keyword">as</span> ArrayList&lt;CharSequence?&gt;)<br>        &#125;<br>        value.isArrayOf&lt;Parcelable&gt;<span class="hljs-function"><span class="hljs-params">()</span> -&gt;</span> &#123;<br>            <span class="hljs-built_in">this</span>.putParcelableArrayListExtra(key, value <span class="hljs-keyword">as</span> ArrayList&lt;out Parcelable?&gt;)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就实现了不同<code>Array</code>类型的<code>putExtra</code>。</p><h2 id="最终"><a href="#最终" class="headerlink" title="最终"></a>最终</h2><p>最后完整的代码为</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><br><span class="hljs-function"><span class="hljs-keyword">fun</span> Intent.<span class="hljs-title">putExtraVararg</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">vararg</span> extras: <span class="hljs-type">Pair</span>&lt;<span class="hljs-type">String</span>, Any?&gt;</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>: Intent &#123;<br>    <span class="hljs-keyword">if</span> (extras.isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span><br>    extras.forEach &#123;<br>        <span class="hljs-keyword">val</span> key = it.first<br>        <span class="hljs-keyword">val</span> value = it.second ?: let &#123;<br>            it.putExtra(key, it.toString())<br>        &#125;<br>    &#125;<br>    extras.forEach &#123; (key, value) -&gt;<br>        value ?: let &#123;<br>            it.putExtra(key, it.toString())<br>            <span class="hljs-keyword">return</span><span class="hljs-symbol">@forEach</span><br>        &#125;<br>        <span class="hljs-keyword">when</span> (value) &#123;<br>            <span class="hljs-keyword">is</span> Bundle -&gt; <span class="hljs-keyword">this</span>.putExtra(key, value)<br>            <span class="hljs-keyword">is</span> <span class="hljs-built_in">Boolean</span> -&gt; <span class="hljs-keyword">this</span>.putExtra(key, value)<br>            <span class="hljs-keyword">is</span> BooleanArray -&gt; <span class="hljs-keyword">this</span>.putExtra(key, value)<br>            <span class="hljs-keyword">is</span> <span class="hljs-built_in">Byte</span> -&gt; <span class="hljs-keyword">this</span>.putExtra(key, value)<br>            <span class="hljs-keyword">is</span> ByteArray -&gt; <span class="hljs-keyword">this</span>.putExtra(key, value)<br>            <span class="hljs-keyword">is</span> <span class="hljs-built_in">Char</span> -&gt; <span class="hljs-keyword">this</span>.putExtra(key, value)<br>            <span class="hljs-keyword">is</span> CharArray -&gt; <span class="hljs-keyword">this</span>.putExtra(key, value)<br>            <span class="hljs-keyword">is</span> String -&gt; <span class="hljs-keyword">this</span>.putExtra(key, value)<br>            <span class="hljs-keyword">is</span> CharSequence -&gt; <span class="hljs-keyword">this</span>.putExtra(key, value)<br>            <span class="hljs-keyword">is</span> <span class="hljs-built_in">Double</span> -&gt; <span class="hljs-keyword">this</span>.putExtra(key, value)<br>            <span class="hljs-keyword">is</span> DoubleArray -&gt; <span class="hljs-keyword">this</span>.putExtra(key, value)<br>            <span class="hljs-keyword">is</span> <span class="hljs-built_in">Float</span> -&gt; <span class="hljs-keyword">this</span>.putExtra(key, value)<br>            <span class="hljs-keyword">is</span> FloatArray -&gt; <span class="hljs-keyword">this</span>.putExtra(key, value)<br>            <span class="hljs-keyword">is</span> <span class="hljs-built_in">Int</span> -&gt; <span class="hljs-keyword">this</span>.putExtra(key, value)<br>            <span class="hljs-keyword">is</span> IntArray -&gt; <span class="hljs-keyword">this</span>.putExtra(key, value)<br>            <span class="hljs-keyword">is</span> <span class="hljs-built_in">Long</span> -&gt; <span class="hljs-keyword">this</span>.putExtra(key, value)<br>            <span class="hljs-keyword">is</span> LongArray -&gt; <span class="hljs-keyword">this</span>.putExtra(key, value)<br>            <span class="hljs-keyword">is</span> <span class="hljs-built_in">Short</span> -&gt; <span class="hljs-keyword">this</span>.putExtra(key, value)<br>            <span class="hljs-keyword">is</span> ShortArray -&gt; <span class="hljs-keyword">this</span>.putExtra(key, value)<br>            <span class="hljs-keyword">is</span> Array&lt;*&gt; -&gt; &#123;<br>                <span class="hljs-meta">@Suppress(<span class="hljs-meta-string">&quot;UNCHECKED_CAST&quot;</span>)</span><br>                <span class="hljs-keyword">when</span> &#123;<br>                    value.isArrayOf&lt;String&gt;() -&gt; &#123;<br>                        <span class="hljs-keyword">this</span>.putStringArrayListExtra(key, value <span class="hljs-keyword">as</span> ArrayList&lt;String?&gt;)<br>                    &#125;<br>                    value.isArrayOf&lt;CharSequence&gt;() -&gt; &#123;<br>                        <span class="hljs-keyword">this</span>.putCharSequenceArrayListExtra(key, value <span class="hljs-keyword">as</span> ArrayList&lt;CharSequence?&gt;)<br>                    &#125;<br>                    value.isArrayOf&lt;Parcelable&gt;() -&gt; &#123;<br>                        <span class="hljs-keyword">this</span>.putParcelableArrayListExtra(key, value <span class="hljs-keyword">as</span> ArrayList&lt;<span class="hljs-keyword">out</span> Parcelable?&gt;)<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">is</span> Parcelable -&gt; <span class="hljs-keyword">this</span>.putExtra(key, value)<br>            <span class="hljs-keyword">is</span> Serializable -&gt; <span class="hljs-keyword">this</span>.putExtra(key, value)<br>            <span class="hljs-keyword">else</span> -&gt; &#123;<br>                <span class="hljs-keyword">throw</span> IllegalArgumentException(<span class="hljs-string">&quot;Not support <span class="hljs-variable">$value</span> type <span class="hljs-subst">$&#123;value.javaClass&#125;</span>..&quot;</span>)<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span><br>&#125;<br></code></pre></td></tr></table></figure><p>转成Java是这样的：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs php"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntentExtKt</span> </span>&#123;<br>   @NotNull<br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">static</span> <span class="hljs-keyword">final</span> Intent putExtraVararg(@NotNull Intent <span class="hljs-variable">$receiver</span>, @NotNull Pair... extras) &#123;<br>      Intrinsics.checkParameterIsNotNull(<span class="hljs-variable">$receiver</span>, <span class="hljs-string">&quot;receiver<span class="hljs-subst">$0</span>&quot;</span>);<br>      Intrinsics.checkParameterIsNotNull(extras, <span class="hljs-string">&quot;extras&quot;</span>);<br>      <span class="hljs-keyword">if</span> (extras.length == <span class="hljs-number">0</span>) &#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-variable">$receiver</span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>         Pair[] var3 = extras;<br>         <span class="hljs-keyword">int</span> var4 = extras.length;<br><br>         <span class="hljs-keyword">int</span> var5;<br>         Pair element<span class="hljs-variable">$iv</span>;<br>         <span class="hljs-keyword">boolean</span> var8;<br>         <span class="hljs-keyword">String</span> key;<br>         <span class="hljs-keyword">for</span>(var5 = <span class="hljs-number">0</span>; var5 &lt; var4; ++var5) &#123;<br>            element<span class="hljs-variable">$iv</span> = var3[var5];<br>            var8 = <span class="hljs-literal">false</span>;<br>            key = (<span class="hljs-keyword">String</span>)element<span class="hljs-variable">$iv</span>.getFirst();<br>            <span class="hljs-keyword">if</span> (element<span class="hljs-variable">$iv</span>.getSecond() == <span class="hljs-literal">null</span>) &#123;<br>               <span class="hljs-keyword">int</span> var12 = <span class="hljs-literal">false</span>;<br>               <span class="hljs-variable">$receiver</span>.putExtra(key, <span class="hljs-variable">$receiver</span>.toString());<br>            &#125;<br>         &#125;<br><br>         var3 = extras;<br>         var4 = extras.length;<br><br>         <span class="hljs-keyword">for</span>(var5 = <span class="hljs-number">0</span>; var5 &lt; var4; ++var5) &#123;<br>            element<span class="hljs-variable">$iv</span> = var3[var5];<br>            var8 = <span class="hljs-literal">false</span>;<br>            key = (<span class="hljs-keyword">String</span>)element<span class="hljs-variable">$iv</span>.component1();<br>            <span class="hljs-keyword">Object</span> value = element<span class="hljs-variable">$iv</span>.component2();<br>            <span class="hljs-keyword">if</span> (value != <span class="hljs-literal">null</span>) &#123;<br>               <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> Bundle) &#123;<br>                  <span class="hljs-variable">$receiver</span>.putExtra(key, (Bundle)value);<br>               &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> <span class="hljs-keyword">Boolean</span>) &#123;<br>                  <span class="hljs-variable">$receiver</span>.putExtra(key, (<span class="hljs-keyword">Boolean</span>)value);<br>               &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> <span class="hljs-keyword">boolean</span>[]) &#123;<br>                  <span class="hljs-variable">$receiver</span>.putExtra(key, (<span class="hljs-keyword">boolean</span>[])value);<br>               &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> Byte) &#123;<br>                  <span class="hljs-variable">$receiver</span>.putExtra(key, ((Number)value).byteValue());<br>               &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> byte[]) &#123;<br>                  <span class="hljs-variable">$receiver</span>.putExtra(key, (byte[])value);<br>               &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> Character) &#123;<br>                  <span class="hljs-variable">$receiver</span>.putExtra(key, (Character)value);<br>               &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> char[]) &#123;<br>                  <span class="hljs-variable">$receiver</span>.putExtra(key, (char[])value);<br>               &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> <span class="hljs-keyword">String</span>) &#123;<br>                  <span class="hljs-variable">$receiver</span>.putExtra(key, (<span class="hljs-keyword">String</span>)value);<br>               &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> CharSequence) &#123;<br>                  <span class="hljs-variable">$receiver</span>.putExtra(key, (CharSequence)value);<br>               &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> <span class="hljs-keyword">Double</span>) &#123;<br>                  <span class="hljs-variable">$receiver</span>.putExtra(key, ((Number)value).doubleValue());<br>               &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> <span class="hljs-keyword">double</span>[]) &#123;<br>                  <span class="hljs-variable">$receiver</span>.putExtra(key, (<span class="hljs-keyword">double</span>[])value);<br>               &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> <span class="hljs-keyword">Float</span>) &#123;<br>                  <span class="hljs-variable">$receiver</span>.putExtra(key, ((Number)value).floatValue());<br>               &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> <span class="hljs-keyword">float</span>[]) &#123;<br>                  <span class="hljs-variable">$receiver</span>.putExtra(key, (<span class="hljs-keyword">float</span>[])value);<br>               &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> <span class="hljs-keyword">Integer</span>) &#123;<br>                  <span class="hljs-variable">$receiver</span>.putExtra(key, ((Number)value).intValue());<br>               &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> <span class="hljs-keyword">int</span>[]) &#123;<br>                  <span class="hljs-variable">$receiver</span>.putExtra(key, (<span class="hljs-keyword">int</span>[])value);<br>               &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> Long) &#123;<br>                  <span class="hljs-variable">$receiver</span>.putExtra(key, ((Number)value).longValue());<br>               &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> long[]) &#123;<br>                  <span class="hljs-variable">$receiver</span>.putExtra(key, (long[])value);<br>               &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> Short) &#123;<br>                  <span class="hljs-variable">$receiver</span>.putExtra(key, ((Number)value).shortValue());<br>               &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> short[]) &#123;<br>                  <span class="hljs-variable">$receiver</span>.putExtra(key, (short[])value);<br>               &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> <span class="hljs-keyword">Object</span>[]) &#123;<br>                  <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">Object</span>[])value <span class="hljs-keyword">instanceof</span> <span class="hljs-keyword">String</span>[]) &#123;<br>                     <span class="hljs-variable">$receiver</span>.putStringArrayListExtra(key, (ArrayList)value);<br>                  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">Object</span>[])value <span class="hljs-keyword">instanceof</span> CharSequence[]) &#123;<br>                     <span class="hljs-variable">$receiver</span>.putCharSequenceArrayListExtra(key, (ArrayList)value);<br>                  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">Object</span>[])value <span class="hljs-keyword">instanceof</span> Parcelable[]) &#123;<br>                     <span class="hljs-variable">$receiver</span>.putParcelableArrayListExtra(key, (ArrayList)value);<br>                  &#125;<br>               &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> Parcelable) &#123;<br>                  <span class="hljs-variable">$receiver</span>.putExtra(key, (Parcelable)value);<br>               &#125; <span class="hljs-keyword">else</span> &#123;<br>                  <span class="hljs-keyword">if</span> (!(value <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Serializable</span>)) &#123;<br>                     <span class="hljs-keyword">throw</span> (<span class="hljs-built_in">Throwable</span>)(<span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Not support &quot;</span> + value + <span class="hljs-string">&quot; type &quot;</span> + value.getClass() + <span class="hljs-string">&quot;..&quot;</span>));<br>                  &#125;<br><br>                  <span class="hljs-variable">$receiver</span>.putExtra(key, (<span class="hljs-built_in">Serializable</span>)value);<br>               &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>               <span class="hljs-keyword">int</span> var13 = <span class="hljs-literal">false</span>;<br>               <span class="hljs-variable">$receiver</span>.putExtra(key, <span class="hljs-variable">$receiver</span>.toString());<br>            &#125;<br>         &#125;<br><br>         <span class="hljs-keyword">return</span> <span class="hljs-variable">$receiver</span>;<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="顺手写别的扩展"><a href="#顺手写别的扩展" class="headerlink" title="顺手写别的扩展"></a>顺手写别的扩展</h3><p>既然用到Intent的扩展，那么就顺手写下Activity的startActivity的扩展</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 同Context的startActivity</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">fun</span> <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Context</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">Activity(<span class="hljs-params">packageContext</span>: Context?, <span class="hljs-params">cls</span>: Class&lt;<span class="hljs-operator">*</span>&gt;, <span class="hljs-params">vararg</span> <span class="hljs-params">extras</span>: Pair&lt;String, Any?&gt;)</span> &#123;<br>    start<span class="hljs-constructor">Activity(Intent(<span class="hljs-params">packageContext</span>, <span class="hljs-params">cls</span>)</span>.put<span class="hljs-constructor">ExtraVararg(<span class="hljs-operator">*</span><span class="hljs-params">extras</span>)</span>)<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 同Context的startActivity</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">fun</span> <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Context</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">Activity(<span class="hljs-params">intent</span>: Intent)</span> &#123;<br>    start<span class="hljs-constructor">Activity(<span class="hljs-params">intent</span>)</span><br>&#125;<br></code></pre></td></tr></table></figure><p>调用的时候就是这样子的</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><br><span class="hljs-keyword">context</span>.toActivity(<br>    <span class="hljs-keyword">context</span>,<br>    SearchActivity::class.java,<br>    SearchActivity.SEARCH_TYPE <span class="hljs-keyword">to</span> <span class="hljs-type">item</span>.type,<br>    SearchActivity.SEARCH_UID <span class="hljs-keyword">to</span> <span class="hljs-type">item</span>.uid,<br>    SearchActivity.SEARCH_NAME <span class="hljs-keyword">to</span> <span class="hljs-type">item</span><span class="hljs-built_in">.name</span>,<br>    SearchActivity.SEARCH_KEY <span class="hljs-keyword">to</span> <span class="hljs-type">item</span><span class="hljs-built_in">.key</span>,<br>    SearchActivity.SEARCH_GROUP <span class="hljs-keyword">to</span> <span class="hljs-type">item</span>.<span class="hljs-keyword">group</span><br>)<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过这次的扩展，也学到了关于<code>Array</code>的一些扩展函数，可以说是很美好了。</p><hr><h1 id="借助Kotlin特性打造一个有Kotlin味道的Activity跳转工具类库"><a href="#借助Kotlin特性打造一个有Kotlin味道的Activity跳转工具类库" class="headerlink" title="借助Kotlin特性打造一个有Kotlin味道的Activity跳转工具类库"></a>借助Kotlin特性打造一个有Kotlin味道的Activity跳转工具类库</h1><h3 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h3><p>相信同学们都有过这种感受：在日常开发中，每次使用<code>startActivityForResult</code>时，要做的事情都好多，好麻烦：</p><ol><li>定义一个<code>requestCode</code>；</li><li>重写<code>onActivityResult</code>方法并在里面去判断<code>requestCode</code>和<code>resultCode</code>；</li><li>如果有携带参数，还要一个个通过<code>putExtra</code>方法<code>put</code>进<em>Intent</em>里；</li><li>目标<em>Activity</em>处理完成后还要把数据一个个<code>put</code>进<em>Intent</em>中，<code>setResult</code>然后<code>finish</code>；</li><li>如果参数是可序列化的泛型类对象(如<em>ArrayList<Model></em>)，取出来的时候不但要显式强制转型，还要把 <em><strong>UNCHECKED_CAST</strong></em> 警告抑制；</li></ol><p>当然了，在Github上已经有好几个开源库把 <em>“需要重写<code>onActivityResult</code>方法来接收处理结果”</em> 的问题解决了（其中的原理相信很多同学都已经了解过了，这个我们等下也会详细讲解的）。<br> 但如果有<strong>携带参数</strong>的话，依然很麻烦：<strong>有多少个参数，就要调用多少次<code>putExtra</code>方法</strong>。<br> 而且最烦的是第5点，转成泛型类对象时，一块黄色的警告在那里，看着挺难受。</p><p>不过还好，随着<em>Kotlin</em>越来越普及，越来越多的开发者都体验到了它的魅力，也许我们可以借助它的一些特性，来做一些事情。。。</p><h3 id="简化Intent-putExtra操作"><a href="#简化Intent-putExtra操作" class="headerlink" title="简化Intent.putExtra操作"></a>简化Intent.putExtra操作</h3><blockquote><p>这个思路我是直接CV了大佬旺的代码，原文链接：<a href="https://www.jowanxu.top/2019/02/11/Android-Intent-Extension/">https://www.jowanxu.top/2019/02/11/Android-Intent-Extension/</a></p></blockquote><p>在<em>Kotlin</em>的项目中，当我们初始化<em>Map</em>的时候，通常会这样写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> map = mapOf(<br>    <span class="hljs-string">&quot;key0&quot;</span> to <span class="hljs-string">&quot;value0&quot;</span>, <br>    <span class="hljs-string">&quot;key1&quot;</span> to <span class="hljs-string">&quot;value1&quot;</span>, <br>    <span class="hljs-string">&quot;key2&quot;</span> to <span class="hljs-string">&quot;value2&quot;</span><br>)<br><br></code></pre></td></tr></table></figure><p><code>Key</code>和<code>Value</code>之间的<code>to</code>，是一个<strong>中缀函数</strong>，它返回一个<em>Pair</em>对象。<br> <code>mapOf</code>方法接收一个类型为<em>Pair</em>的可变参数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;K, V&gt;</span> <span class="hljs-title">mapOf</span><span class="hljs-params">(<span class="hljs-keyword">vararg</span> pairs: <span class="hljs-type">Pair</span>&lt;<span class="hljs-type">K</span>, V&gt;)</span></span><br><br></code></pre></td></tr></table></figure><p>最终的实现，它会遍历这个数组<code>pairs</code>，并依次把这些<code>键值对</code>put到一个<em>LinkedHashMap</em>中。</p><p>那么我们也可以参照这个<code>mapOf</code>，来为<em>Intent</em>写一个扩展方法<code>putExtras</code>，让它在使用的时候，就像创建<em>Map</em>对象那样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> Intent.<span class="hljs-title">putExtras</span><span class="hljs-params">(<span class="hljs-keyword">vararg</span> params: <span class="hljs-type">Pair</span>&lt;<span class="hljs-type">String</span>, Any&gt;)</span></span>: Intent &#123;<br>    <span class="hljs-keyword">if</span> (params.isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span><br>    params.forEach &#123; (key, value) -&gt;<br>        <span class="hljs-keyword">when</span> (value) &#123;<br>            <span class="hljs-keyword">is</span> <span class="hljs-built_in">Int</span> -&gt; putExtra(key, value)<br>            <span class="hljs-keyword">is</span> <span class="hljs-built_in">Byte</span> -&gt; putExtra(key, value)<br>            <span class="hljs-keyword">is</span> <span class="hljs-built_in">Char</span> -&gt; putExtra(key, value)<br>            <span class="hljs-keyword">is</span> <span class="hljs-built_in">Long</span> -&gt; putExtra(key, value)<br>            <span class="hljs-keyword">is</span> <span class="hljs-built_in">Float</span> -&gt; putExtra(key, value)<br>            <span class="hljs-keyword">is</span> <span class="hljs-built_in">Short</span> -&gt; putExtra(key, value)<br>            <span class="hljs-keyword">is</span> <span class="hljs-built_in">Double</span> -&gt; putExtra(key, value)<br>            <span class="hljs-keyword">is</span> <span class="hljs-built_in">Boolean</span> -&gt; putExtra(key, value)<br>            <span class="hljs-keyword">is</span> Bundle -&gt; putExtra(key, value)<br>            <span class="hljs-keyword">is</span> String -&gt; putExtra(key, value)<br>            <span class="hljs-keyword">is</span> IntArray -&gt; putExtra(key, value)<br>            <span class="hljs-keyword">is</span> ByteArray -&gt; putExtra(key, value)<br>            <span class="hljs-keyword">is</span> CharArray -&gt; putExtra(key, value)<br>            <span class="hljs-keyword">is</span> LongArray -&gt; putExtra(key, value)<br>            <span class="hljs-keyword">is</span> FloatArray -&gt; putExtra(key, value)<br>            <span class="hljs-keyword">is</span> Parcelable -&gt; putExtra(key, value)<br>            <span class="hljs-keyword">is</span> ShortArray -&gt; putExtra(key, value)<br>            <span class="hljs-keyword">is</span> DoubleArray -&gt; putExtra(key, value)<br>            <span class="hljs-keyword">is</span> BooleanArray -&gt; putExtra(key, value)<br>            <span class="hljs-keyword">is</span> CharSequence -&gt; putExtra(key, value)<br>            <span class="hljs-keyword">is</span> Array&lt;*&gt; -&gt; &#123;<br>                <span class="hljs-keyword">when</span> &#123;<br>                    value.isArrayOf&lt;String&gt;() -&gt;<br>                        putExtra(key, value <span class="hljs-keyword">as</span> Array&lt;String?&gt;)<br>                    value.isArrayOf&lt;Parcelable&gt;() -&gt;<br>                        putExtra(key, value <span class="hljs-keyword">as</span> Array&lt;Parcelable?&gt;)<br>                    value.isArrayOf&lt;CharSequence&gt;() -&gt;<br>                        putExtra(key, value <span class="hljs-keyword">as</span> Array&lt;CharSequence?&gt;)<br>                    <span class="hljs-keyword">else</span> -&gt; putExtra(key, value)<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">is</span> Serializable -&gt; putExtra(key, value)<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>因为<em>Intent</em>的<code>putExtra</code>方法只接受<em>String</em>类型的Key，所以我们也直接指定的<em>Pair</em>的第一个值的类型为<em>String</em>了。<br> 总体的逻辑很简单，就像<code>mapOf</code>方法那样：遍历<em>Pair</em>数组，判断每一个参数值的类型(<em>不同于Java的是，在Kotlin中用is关键字检查类型符合之后，会自动转换成对应的类型，无须显式转换</em>)，并通过<em>Intent</em>的<code>putExtra</code>方法把参数put进去。</p><p>那么现在给<em>Intent</em>设置多个参数的时候，就可以写成这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> intent = Intent()<br>intent.putExtras(<br>    <span class="hljs-string">&quot;key0&quot;</span> to <span class="hljs-literal">true</span>,<br>    <span class="hljs-string">&quot;key1&quot;</span> to <span class="hljs-number">1.23F</span>,<br>    <span class="hljs-string">&quot;key2&quot;</span> to listOf(<span class="hljs-string">&quot;1&quot;</span>,  <span class="hljs-string">&quot;2&quot;</span>)<br>)<br><br></code></pre></td></tr></table></figure><p>哈哈，的确方便又好看了好多。</p><h3 id="简化startActivity操作"><a href="#简化startActivity操作" class="headerlink" title="简化startActivity操作"></a>简化startActivity操作</h3><p>虽然说，在没有工具类的帮助下，<code>startActivity</code>一样也可以一句代码搞定，如果不携带参数的话。<br> 但如果要携带参数，就至少要三句了：</p><ol><li>创建<em>Intent</em>对象；</li><li>把参数put进<em>Intent</em>中；</li><li>调用<code>startActivity</code>方法；</li></ol><p>这种情况我们完全可以借助刚刚的扩展方法<code>putExtras</code>，来把它简化成一行，就像这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">startActivity(<span class="hljs-keyword">this</span>, TestActivity::<span class="hljs-class"><span class="hljs-keyword">class</span>, <span class="hljs-type">&quot;key0&quot; to &quot;value0&quot;</span>, <span class="hljs-type">&quot;key1&quot; to &quot;value1&quot;)</span></span><br><br></code></pre></td></tr></table></figure><p><strong>内部是怎么写的呢？</strong> 其实超简单：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">startActivity</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    starter: <span class="hljs-type">Activity</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">    target: <span class="hljs-type">KClass</span>&lt;<span class="hljs-type">out</span> <span class="hljs-type">Activity</span>&gt;,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">vararg</span> params: <span class="hljs-type">Pair</span>&lt;<span class="hljs-type">String</span>, Any&gt;</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span> = starter.startActivity(Intent(starter, target.java).putExtras(*params))<br><br></code></pre></td></tr></table></figure><p>我们封装的<code>startActivity</code>方法接收三个参数，分别是：<code>发起的Activity</code>、<code>要启动的Activity</code>、<code>可变参数键值对</code>。<br> <code>target</code>的类型<code>KClass</code>后面的<code>&lt;out Activity&gt;</code>，在<em>Java</em>中等同于<code>&lt;T extends Activity&gt;</code>。<br> <code>params</code>前面的<code>vararg</code>，就是定义成可变参数的意思，等同于<em>Java</em>中的<code>Pair&lt;String, Any&gt;... params</code><br> 最后可以看到，也是直接调用了<em>Activity</em>的<code>startActivity</code>方法，并把调用<code>putExtras</code>扩展方法后的<em>Intent</em>传进去。</p><p>就这么简单。</p><h3 id="简化startActivityForResult操作"><a href="#简化startActivityForResult操作" class="headerlink" title="简化startActivityForResult操作"></a>简化startActivityForResult操作</h3><p>相信很多同学在Java项目上也有用过一些类似的库，就是把重写<code>onActivityResult</code>改成<code>匿名内部类</code>。<br> 不过我们现在用了<em>Kotlin</em>，就可以把<code>匿名内部类</code>改成<code>Lambda</code>了，就像这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">startActivityForResult(<span class="hljs-keyword">this</span>, TestActivity::<span class="hljs-class"><span class="hljs-keyword">class</span>,</span><br><span class="hljs-class">    <span class="hljs-type">&quot;key0&quot; to &quot;value0&quot;</span>,</span><br><span class="hljs-class">    <span class="hljs-type">&quot;key1&quot; to 1.23F</span>,</span><br><span class="hljs-class">    <span class="hljs-type">&quot;key2&quot; to listOf</span></span>(<span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>)<br>) &#123;<br>    <span class="hljs-keyword">if</span> (it == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">//未成功处理，即（ResultCode != RESULT_OK）</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//处理成功，这里可以操作返回的intent</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>当目标<em>Activity</em>处理完成之后，就会回调到后面的<em>Lambda</em>中。</p><p>其中的原理很简单，就是<strong>临时附加一个无界面的*Fragment*，当这个*Fragment*附加成功之后，调用<code>startActivityForResult</code>方法，并在重写的<code>onActivityResult</code>方法里面去回调外面传进来的<code>Lambda</code>。</strong><br> 来看看代码怎么写：<br> 先是<em>Fragment</em>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GhostFragment</span> : <span class="hljs-type">Fragment</span></span>() &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> requestCode = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> intent: Intent? = <span class="hljs-literal">null</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> callback: ((result: Intent?) -&gt; <span class="hljs-built_in">Unit</span>)? = <span class="hljs-literal">null</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">init</span><span class="hljs-params">(requestCode: <span class="hljs-type">Int</span>, intent: <span class="hljs-type">Intent</span>, callback: ((<span class="hljs-type">result</span>: <span class="hljs-type">Intent</span>?) -&gt; <span class="hljs-type">Unit</span>))</span></span> &#123;<br>        <span class="hljs-keyword">this</span>.requestCode = requestCode<br>        <span class="hljs-keyword">this</span>.intent = intent<br>        <span class="hljs-keyword">this</span>.callback = callback<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onAttach</span><span class="hljs-params">(context: <span class="hljs-type">Context</span>)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onAttach(context)<br>        <span class="hljs-comment">//附加到Activity之后马上startActivityForResult</span><br>        intent?.let &#123; startActivityForResult(it, requestCode) &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onActivityResult</span><span class="hljs-params">(requestCode: <span class="hljs-type">Int</span>, resultCode: <span class="hljs-type">Int</span>, <span class="hljs-keyword">data</span>: <span class="hljs-type">Intent</span>?)</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onActivityResult(requestCode, resultCode, <span class="hljs-keyword">data</span>)<br>        <span class="hljs-comment">//检查requestCode</span><br>        <span class="hljs-keyword">if</span> (requestCode == <span class="hljs-keyword">this</span>.requestCode) &#123;<br>            <span class="hljs-comment">//检查resultCode，如果不OK的话，那就直接回传个null</span><br>            <span class="hljs-keyword">val</span> result = <span class="hljs-keyword">if</span> (resultCode == Activity.RESULT_OK &amp;&amp; <span class="hljs-keyword">data</span> != <span class="hljs-literal">null</span>) <span class="hljs-keyword">data</span> <span class="hljs-keyword">else</span> <span class="hljs-literal">null</span><br>            <span class="hljs-comment">//执行回调</span><br>            callback?.let &#123; it(result) &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDetach</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">super</span>.onDetach()<br>        intent = <span class="hljs-literal">null</span><br>        callback = <span class="hljs-literal">null</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>可以看到有一个<code>init</code>方法，它用来接收外面传进来的<code>requestCode</code>,<code>intent</code>和<code>callback</code>。<br> <strong>那<code>requestCode</code>怎么定义好呢？</strong><br> 为了避免相同的<code>requestCode</code>，我们可以定义一个静态的<em>Int</em>变量，在每次<code>startActivityForResult</code>之后<strong>自增</strong>，如果次数多到要溢出时，重新设置为1就OK了，看代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> sRequestCode = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">set</span>(value) &#123;<br>            field = <span class="hljs-keyword">if</span> (value &gt;= Integer.MAX_VALUE) <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> value<br>        &#125;<br><span class="hljs-number">1234</span><br></code></pre></td></tr></table></figure><p>好，现在来创建一个<code>startActivityForResult</code>方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">startActivityForResult</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    starter: <span class="hljs-type">Activity</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">    target: <span class="hljs-type">KClass</span>&lt;<span class="hljs-type">out</span> <span class="hljs-type">Activity</span>&gt;,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">vararg</span> params: <span class="hljs-type">Pair</span>&lt;<span class="hljs-type">String</span>, Any&gt;,</span></span><br><span class="hljs-params"><span class="hljs-function">    callback: ((<span class="hljs-type">result</span>: <span class="hljs-type">Intent</span>?) -&gt; <span class="hljs-type">Unit</span>)</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span> &#123;<br>    <span class="hljs-comment">//初始化intent</span><br>    <span class="hljs-keyword">val</span> intent = Intent(starter, target.java).putExtras(*params)<br>    <span class="hljs-keyword">val</span> fm = starter.supportFragmentManager<br>    <span class="hljs-comment">//无界面的Fragment</span><br>    <span class="hljs-keyword">val</span> fragment = GhostFragment()<br>    fragment.<span class="hljs-keyword">init</span>(++sRequestCode<span class="hljs-comment">/*先让requestCode自增*/</span>, intent) &#123; result -&gt;<br>        <span class="hljs-comment">//包装一层：在回调执行完成之后把对应的Fragment移除掉</span><br>        callback(result)<br>        fm.beginTransaction().remove(fragment).commitAllowingStateLoss()<br>    &#125;<br>    <span class="hljs-comment">//把Fragment添加进去</span><br>    fm.beginTransaction().add(fragment, GhostFragment::<span class="hljs-keyword">class</span>.java.simpleName).commitAllowingStateLoss()<br>&#125;<br><br></code></pre></td></tr></table></figure><p>emmm，这个<code>startActivityForResult</code>，就比刚刚的<code>startActivity</code>多了一个<code>callback</code>参数。<br> 可以看到我们并没有直接把这个<code>callback</code>传进fragment里面，而是在外面包装了一层。当这个<code>callback</code>执行完成之后，还会把对应的<em>Fragment</em>从<em>FragmentManager</em>中移除掉，就是为了能让这个<code>Fragment</code>的<code>onDetach</code>方法尽快回调（把<code>callback</code>的引用置空），一定程度上避免内存泄漏（因为外部的<code>callback</code>可能持有生命周期比较短的对象引用）。<br> 在最后，会把<em>Fragment</em>附加到<em>Activity</em>中，当<em>Fragment</em>的<code>onAttach</code>回调时，就会启动目标<em>Activity</em>了。</p><h3 id="简化finish操作"><a href="#简化finish操作" class="headerlink" title="简化finish操作"></a>简化finish操作</h3><p>当<code>startActivityForResult</code>方法启动的<em>Activity</em>处理任务完成之后，通常要把一些数据传回给启动者，这个操作我们也是可以优化的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">finish</span><span class="hljs-params">(src: <span class="hljs-type">Activity</span>, <span class="hljs-keyword">vararg</span> params: <span class="hljs-type">Pair</span>&lt;<span class="hljs-type">String</span>, Any&gt;)</span></span> = with(src) &#123;<br>    setResult(Activity.RESULT_OK, Intent().putExtras(*params))<br>    finish()<br>&#125;<br><br></code></pre></td></tr></table></figure><p>可以看到，把参数<code>put</code>进<em>Intent</em>之后，就调用了<code>setResult</code>方法把<em>Intent</em>放进去，并<code>finish</code>。<br> 那么在使用的时候，就可以这样写了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">finish(<span class="hljs-keyword">this</span>, <span class="hljs-string">&quot;key0&quot;</span> to <span class="hljs-string">&quot;value0&quot;</span>, <span class="hljs-string">&quot;key1&quot;</span> to <span class="hljs-string">&quot;value1&quot;</span>)<br><br></code></pre></td></tr></table></figure><p>哈哈，是不是简洁了许多。</p><h3 id="优化Intent-getExtra操作"><a href="#优化Intent-getExtra操作" class="headerlink" title="优化Intent.getExtra操作"></a>优化Intent.getExtra操作</h3><p><strong>还记不记得<code>findViewById</code>？</strong><br> 哈哈哈哈，在<code>compileSdkVersion</code>为26之前，通过<code>findViewById</code>取得的<em>View</em>子类实例时都要进行强制类型转换，26之后，才换成了泛型方法。<br> 现在的<code>getSerializableExtra</code>也存在同样的问题，如果取出来的是一个泛型类的实例，比如<code>List&lt;String&gt;</code>，强制转换后还会出一个 <em><strong>UNCHECKED_CAST</strong></em> 警告，黄色的一块，看着很难受。</p><p>那么现在我们也可以参照<code>findViewById</code>，给<em>Intent</em>创建一个扩展方法：<br> 想一下：<em>Intent</em>的<code>getStringExtra</code>、<code>getIntExtra</code>、<code>getBooleanExtra</code>等一系列方法，内部都是借助<em>Bundle</em>来实现的，CTRL点进去会看到，<em>Bundle</em>是通过一个<em>Map</em>来储存这些键值对的，比如这个<code>getStringExtra</code>方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> String getString(String key) &#123;<br>    unparcel();<br>    <span class="hljs-keyword">final</span> Object o = mMap.<span class="hljs-keyword">get</span>(key);<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> (String) o;<br>    &#125; <span class="hljs-keyword">catch</span> (ClassCastException e) &#123;<br>        typeWarning(key, o, <span class="hljs-string">&quot;String&quot;</span>, e);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>可以看到，它从<code>mMap</code>中取出值之后，还是会显式地进行强制类型转换的，<strong>那等我们给*Intent*加了泛型的扩展方法之后，除了可代替<code>getSerializableExtra</code>之外，剩下的那些<code>getXXXExtra</code>，是不是也一样可以代替掉呢？</strong><br> 答案是肯定的。因为这些键值对，都是存放在同一个<em>Map</em>的实例里面，如果拿到了这个实例。。。就可以为所欲为了 ，哈哈哈。<br> <strong>那怎么拿到这个存放键值对的实例呢？</strong><br> 用反射。先拿到<em>Intent</em>里面的<code>mExtras</code>(Bundle的实例)，再通过这个<code>mExtras</code>来获取到<code>mMap</code>(存放键值对的Map实例)。</p><p>不过，我看了不同版本的<em>Bundle</em>代码，发现在5.0之后，<em>Bundle</em>的主要逻辑被抽取到一个叫<em>BaseBundle</em>的类里面了，而在此之前，是没有<em>BaseBundle</em>这个类的，所以等下在获取<code>mMap</code>的<em>Field</em>之前要做一下版本判断。<br> 还有，当我直接用反射拿到<code>mMap</code>的对象引用之后，却发现是<code>null</code>的，再次翻源码后才注意到：<strong>Bundle里面的每一个<code>getXXX</code>方法中，第一句都是会调用<code>unparcel</code>方法的，这个方法里面会调用一个叫<code>initializeFromParcelLocked</code>的方法，没错，<code>mMap</code>正是在这个方法里面初始化的，然后通过*Parcel*的<code>readArrayMapInternal</code>方法来填充键值对</strong> 。所以等下在获取<code>mMap</code>实例之前，还要先调用一下<code>unparcel</code>方法(也是通过反射)。<br> 那现在要用到的内部属性和方法一共有3个了（<code>mExtras</code>、<code>mMap</code>、<code>unparcel</code>），我们可以把它缓存起来，这样就不用每次都重新获取，可以提升运行效率：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">object</span> IntentFieldMethod &#123;<br>    <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> mExtras: Field<br>    <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> mMap: Field<br>    <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> unparcel: Method<br><br>    <span class="hljs-keyword">init</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            mExtras = Intent::<span class="hljs-keyword">class</span>.java.getDeclaredField(<span class="hljs-string">&quot;mExtras&quot;</span>)<br>            <span class="hljs-keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;<br>                mMap = BaseBundle::<span class="hljs-keyword">class</span>.java.getDeclaredField(<span class="hljs-string">&quot;mMap&quot;</span>)<br>                unparcel = BaseBundle::<span class="hljs-keyword">class</span>.java.getDeclaredMethod(<span class="hljs-string">&quot;unparcel&quot;</span>)<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                mMap = Bundle::<span class="hljs-keyword">class</span>.java.getDeclaredField(<span class="hljs-string">&quot;mMap&quot;</span>)<br>                unparcel = Bundle::<span class="hljs-keyword">class</span>.java.getDeclaredMethod(<span class="hljs-string">&quot;unparcel&quot;</span>)<br>            &#125;<br>            mExtras.isAccessible = <span class="hljs-literal">true</span><br>            mMap.isAccessible = <span class="hljs-literal">true</span><br>            unparcel.isAccessible = <span class="hljs-literal">true</span><br>        &#125; <span class="hljs-keyword">catch</span> (e: Exception) &#123;<br>            e.printStackTrace()<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>然后在扩展方法中直接引用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;O&gt;</span> Intent.<span class="hljs-title">get</span><span class="hljs-params">(key: <span class="hljs-type">String</span>)</span></span>: O? &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//获取Intent.mExtras实例</span><br>        <span class="hljs-keyword">val</span> extras = IntentFieldMethod.mExtras.<span class="hljs-keyword">get</span>(<span class="hljs-keyword">this</span>) <span class="hljs-keyword">as</span> Bundle<br>        <span class="hljs-comment">//调用unparcel方法来初始化mMap</span><br>        IntentFieldMethod.unparcel.invoke(extras)<br>        <span class="hljs-comment">//获取Bundle.mMap实例</span><br>        <span class="hljs-keyword">val</span> map = IntentFieldMethod.mMap.<span class="hljs-keyword">get</span>(extras) <span class="hljs-keyword">as</span> Map&lt;String, Any&gt;<br>        <span class="hljs-comment">//取出对应的key</span><br>        <span class="hljs-keyword">return</span> map[key] <span class="hljs-keyword">as</span> O<br>    &#125; <span class="hljs-keyword">catch</span> (e: Exception) &#123;<br>        <span class="hljs-comment">//Ignore</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>emmm，有了这个扩展方法之后，在获取Intent参数时就可以写成这样了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//预先声明好类型</span><br><span class="hljs-keyword">var</span> mData: List&lt;String&gt;? = <span class="hljs-literal">null</span><br>mData = intent.<span class="hljs-keyword">get</span>(<span class="hljs-string">&quot;Key1&quot;</span>)<br><br></code></pre></td></tr></table></figure><p>或者这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//取出时再决定类型</span><br><span class="hljs-keyword">val</span> result = intent.<span class="hljs-keyword">get</span>&lt;<span class="hljs-built_in">Int</span>&gt;(<span class="hljs-string">&quot;Key2&quot;</span>)<br><br></code></pre></td></tr></table></figure><p>因为我们定义的是泛型的方法，所以无论取出来什么类型的值都好，都不用显式地强制转换了，也没有 <em><strong>UNCHECKED_CAST</strong></em> 警告了，哈哈，是不是很棒。</p><blockquote><p>上面所提到的内部属性和方法，都是没有被标记@hide的，可放心使用。</p></blockquote><p><strong>刚刚说到把那些*Field*和*Method*缓存起来，可以提高效率，那究竟比没有缓存的情况下提高了多少呢？</strong><br> 我分别对以下操作进行了耗时统计：</p><ol><li>直接调用<em>Intent</em>的<code>getXXExtra</code>来获取值；</li><li>重用<em>Field</em>和<em>Method</em>，每次先通过反射获取<code>mMap</code>，然后调用<code>mMap.get</code>方法来获取值；</li><li>不重用，每次都先通过<em>Class</em>取得对应的<em>Field</em>和<em>Method</em>，然后通过反射获取<code>mMap</code>，再通过<code>mMap.get</code>方法来获取值；</li></ol><p>以下是分别循环10W次的总耗时(单位: ms)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">第一次：<br><span class="hljs-number">15</span><br><span class="hljs-number">182</span><br><span class="hljs-number">1242</span><br>第二次：<br><span class="hljs-number">8</span><br><span class="hljs-number">100</span><br><span class="hljs-number">1145</span><br>第三次：<br><span class="hljs-number">8</span><br><span class="hljs-number">96</span><br><span class="hljs-number">1143</span><br>第四次：<br><span class="hljs-number">8</span><br><span class="hljs-number">104</span><br><span class="hljs-number">1206</span><br>第五次：<br><span class="hljs-number">10</span><br><span class="hljs-number">115</span><br><span class="hljs-number">1365</span><br><br></code></pre></td></tr></table></figure><p>可以看到，重用<em>Field</em>和<em>Method</em>的话，效率会提升10倍左右，虽然远没有不使用反射的效率高，但是，重复10W次才100毫秒左右，也就是平均每次才花费0.001ms左右，牺牲这点微不足道的效率给我们带来方便，是非常划算的。</p><h3 id="Kotlin内联函数不为人知的一面"><a href="#Kotlin内联函数不为人知的一面" class="headerlink" title="Kotlin内联函数不为人知的一面"></a>Kotlin内联函数不为人知的一面</h3><p>我们在学习<em>Kotlin</em>的过程中，都会了解到<strong>内联函数</strong>，适当地使用可以提高性能，节省资源。如果一个方法它被标记成了内联函数，那么在编译时，会将它的方法体，替换到调用它的地方，这时候就不算是正常的方法调用了。</p><p>当我写完这个工具类之后，把它发给大佬旺看，他说可以在<code>startActivity</code>和<code>startActivityForResult</code>上面加个具体化的泛型，就像这样：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;<span class="hljs-keyword">reified</span> TARGET : Activity&gt;</span> <span class="hljs-title">startActivity</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    starter: <span class="hljs-type">Activity</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">vararg</span> params: <span class="hljs-type">Pair</span>&lt;<span class="hljs-type">String</span>, Any&gt;</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span> = starter.startActivity(Intent(starter, TARGET::<span class="hljs-keyword">class</span>.java).putExtras(*params))<br><br></code></pre></td></tr></table></figure><p>跟原来的代码区别就是把<code>target: KClass&lt;out Activity&gt;</code>换成了<code>&lt;reified TARGET : Activity&gt;</code>。<br> 用<code>reified</code>关键字修饰的泛型与普通的泛型区别就是：前者可以获取到泛型的类型信息，而后者不行。<br> 但是<code>reified</code>依赖内联函数，也就是说，如果使用具体化泛型的话，方法必须用<code>inline</code>修饰。</p><p>改完之后，就可以这样来使用了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">startActivity&lt;TestActivity&gt;(<span class="hljs-keyword">this</span>, <span class="hljs-string">&quot;key0&quot;</span> to <span class="hljs-string">&quot;value0&quot;</span>, <span class="hljs-string">&quot;key1&quot;</span> to <span class="hljs-string">&quot;value1&quot;</span>)<br><br></code></pre></td></tr></table></figure><p>哈哈，可读性是不是更高了。</p><p>当一个方法用<code>inline</code>修饰了之后，表示该方法为内联函数，此时无法访问<em>访问权限</em>比自己低的成员，比如一个内联函数为<em>public</em>，那就不能访问该类用<em>private</em>修饰的成员。<br> 我们接下来要修改的<code>startActivityForResult</code>方法就碰上这个问题了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> sRequestCode = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">set</span>(value) &#123;<br>        field = <span class="hljs-keyword">if</span> (value &gt;= Integer.MAX_VALUE) <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> value<br>    &#125;<br>    <br><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;<span class="hljs-keyword">reified</span> TARGET : Activity&gt;</span> <span class="hljs-title">startActivityForResult</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    starter: <span class="hljs-type">Activity</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">vararg</span> params: <span class="hljs-type">Pair</span>&lt;<span class="hljs-type">String</span>, Any&gt;,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">crossinline</span> callback: ((<span class="hljs-type">result</span>: <span class="hljs-type">Intent</span>?) -&gt; <span class="hljs-type">Unit</span>)</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span> &#123;<br>    ......<br>    fragment.<span class="hljs-keyword">init</span>(++sRequestCode, intent) &#123;<br>        ......<br>    &#125;<br>    ......<br>&#125;<br><br></code></pre></td></tr></table></figure><p>上面这段代码AS会报错，因为<code>fragment</code>的<code>init</code>方法需要传<code>sRequestCode</code>进去，而这个<code>sRequestCode</code>是<em>private</em>的，内联函数是<em>public</em>。<br> <strong>那应该怎么做呢？难道说就没有办法可以解决吗？</strong><br> 大佬旺给出的解决方案是：把<code>private</code>改成<code>@PublishedApi internal</code>。<br> 这样做虽然可以正常编译运行，但是，加了<code>@PublishedApi</code>注解之后的<code>sRequestCode</code>，却可以在任何地方访问和修改！这显然违背了开闭原则。虽然说没有人会手贱去修改它，但每次出代码提示的时候，这个<code>sRequestCode</code>就会显示出来。。。很碍眼。</p><p><strong>除了加PublishedApi注解之外，还有别的办法吗？</strong><br> 大佬旺翻了一下资料后说：在方法前加个<code>@Suppress(&quot;NON_PUBLIC_CALL_FROM_PUBLIC_INLINE&quot;)</code>把它抑制了就能编译通过并正常运行了。。。<br> 试了一下果然可以。但是，为什么呢？</p><p><strong>为什么加了Suppress之后就能正常编译和运行？</strong><br> 我看了一下编译成<em>class</em>之后反编译的代码，发现<code>sRequestCode</code>多了个<em>setter</em>和<em>getter</em>方法！<br> 也就是说，在编译过程中，会自动帮我们生成<em>public</em>的<em>setter</em>和<em>getter</em>方法！<br> 这两个<em>public</em>的静态方法，在编译前是没有的，所以也就不会出代码提示了。<br> 我们刚刚的<em>Kotlin</em>代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">......<br>fragment.<span class="hljs-keyword">init</span>(++sRequestCode, intent)<br>......<br><br></code></pre></td></tr></table></figure><p>在反编译后，看到的<em>Java</em>代码是这样的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">access$setSRequestCode$p(access$getSRequestCode$p() + <span class="hljs-number">1</span>);<br>fragment.<span class="hljs-keyword">init</span>(access$getSRequestCode$p(), intent);<br><br></code></pre></td></tr></table></figure><p>自动生成的<em>setter</em>和<em>getter</em>如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// $FF: synthetic method</span><br><span class="hljs-keyword">public</span> static <span class="hljs-keyword">final</span> int access$getSRequestCode$p() &#123;<br>   <span class="hljs-keyword">return</span> sRequestCode;<br>&#125;<br><br><span class="hljs-comment">// $FF: synthetic method</span><br><span class="hljs-keyword">public</span> static <span class="hljs-keyword">final</span> void access$setSRequestCode$p(int var0) &#123;<br>   sRequestCode = var0;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>哈哈哈，看来加<em>Suppress</em>的这个做法，是完全可行的。<br> 查了一下源码，发现我们常用的<code>synchronized</code>方法(在<em>Kotlin</em>中不是关键字)，也是使用了这个抑制的。<br> 以后在项目中的其他地方有类似的需求，相信同学们已经知道要怎么做了吧~</p><h3 id="好啦，本篇文章到此结束，有错误的地方请指出，谢谢大家！"><a href="#好啦，本篇文章到此结束，有错误的地方请指出，谢谢大家！" class="headerlink" title="好啦，本篇文章到此结束，有错误的地方请指出，谢谢大家！"></a>好啦，本篇文章到此结束，有错误的地方请指出，谢谢大家！</h3><h3 id="Github地址：https-github-com-wuyr-ActivityMessenger-欢迎Star"><a href="#Github地址：https-github-com-wuyr-ActivityMessenger-欢迎Star" class="headerlink" title="Github地址：https://github.com/wuyr/ActivityMessenger 欢迎Star"></a>Github地址：<a href="https://github.com/wuyr/ActivityMessenger">https://github.com/wuyr/ActivityMessenger</a> 欢迎Star</h3>]]></content>
    
    
    
    <tags>
      
      <tag>android</tag>
      
      <tag>kotlin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件整理</title>
    <link href="/posts/c43f5235/"/>
    <url>/posts/c43f5235/</url>
    
    <content type="html"><![CDATA[<h3 id="wps"><a href="#wps" class="headerlink" title="wps"></a>wps</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">yay -S wps-office wps-office-mui-zh-cn<br><br>安装完后启动WPS，可能会弹出窗口，提示「系统缺失字体」。问题原因是wps for 没有自带Windows的字体。<br>在终端中输入以下命令进入tmp目录<br><span class="hljs-keyword">cd</span> <span class="hljs-string">/tmp</span><br>将字体库克隆下来<br>git clone git@github.com<span class="hljs-function">:IamDH4</span>/ttf-wps-fonts.git<br>进入下面的目录<br><span class="hljs-keyword">cd</span> ttf-wps-fonts<br>使用安装脚本安装字体<br>sudo bash install.sh<br>清理tmp目录<br>rm -rf <span class="hljs-string">/tmp/ttf-wps-fonts</span><br>完成<br><br>如果需要修改WPS的界面语言，先打开WPS Writer，新建一个文件，界面的右上方有个A字符的按钮，点进去后，取消勾选「跟随系统语言」选项，然后选择你想要的语言即可。<br> <br> 注：使用wps的用户还需要编辑~<span class="hljs-string">/.xprofile</span>添加以下内容（在新版中bug被修复了，但是如果有问题的话，可以尝试此方法）<br>export QT_IM_MODULE=fcitx5<br><br></code></pre></td></tr></table></figure><p>解决无法输入中文问题：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo vim /usr/bin/wps，在第一行（#!/bin/bash）下面添加：<br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">XMODIFIERS</span>=<span class="hljs-string">&quot;@im=fcitx&quot;</span><br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">QT_IM_MODULE</span>=<span class="hljs-string">&quot;fcitx&quot;</span><br><span class="hljs-attribute">gOpt</span>=gTemplateExt=(&quot;wpt&quot; <span class="hljs-string">&quot;dot&quot;</span> <span class="hljs-string">&quot;dotx&quot;</span>)<br></code></pre></td></tr></table></figure><hr><h3 id="使用timeshift备份系统"><a href="#使用timeshift备份系统" class="headerlink" title="使用timeshift备份系统"></a>使用timeshift备份系统</h3><p>安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">yay -S timeshift<br></code></pre></td></tr></table></figure><p>打开软件，保持默认。</p><p>在【用户】选项内设置需要备份的分区，</p><ul><li>root选择【包含一切】或者【排除一切】</li><li>home选择【排除一切】</li></ul><p>注： <strong>root</strong>默认就是全备份的，经测试更改也是无效的，也就是<strong>root</strong>必须备份。</p><p>在【筛选】选项内可以自定义备份文件或文件夹</p><p>建议这样配置：</p><ul><li><p>先将home整个目录排除，添加<code>/home/用户名/**</code></p></li><li><p>home目录下比较重要的如：<code>.local</code>、<code>.config</code>等，需要加入，切记要加上<code>***</code>三个星</p></li><li><p>创建快照</p><p>此时timeshift会根据时间生成一个带有时间戳的快照，此过程需要等待一段时间，并且期间不要对电脑执行任何操作。</p></li></ul><h5 id="如果只能进入登录界面"><a href="#如果只能进入登录界面" class="headerlink" title="如果只能进入登录界面"></a>如果只能进入登录界面</h5><p>一般系统崩溃后不能进入桌面，但是能够进入登录界面，现象就是在登录界面输入密码后不会进入桌面，那么就要通过命令行的方式进行还原。</p><ol><li><p>通过<code>Ctrl+Alt+F1</code>（一般是F1-F6都可）进入tty终端：</p></li><li><p>输入用户和密码登录</p></li><li><p>执行下面命令获取系统当前可以还原的节点：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">sudo timeshift <span class="hljs-comment">--list</span><br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>输出内容：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs subunit">Device : /dev/sdb4<br>UUID   : 197c4161-abc6<span class="hljs-string">-4069</span><span class="hljs-string">-8544</span>-d86594211f04<br>Path   : /home<br>Mode   : RSYNC<br>Device is OK<br>12 snapshots, 92.5 GB free<br><br>Num     Name                 Tags  Description  <br>------------------------------------------------------------------------------<br>0    &gt;  2018<span class="hljs-string">-08</span><span class="hljs-string">-08</span>_11<span class="hljs-string">-49</span><span class="hljs-string">-26</span>  O D                <br>1    &gt;  2018<span class="hljs-string">-08</span><span class="hljs-string">-13</span>_23<span class="hljs-string">-02</span><span class="hljs-string">-06</span>  O                  <br>2    &gt;  2018<span class="hljs-string">-08</span><span class="hljs-string">-15</span>_22<span class="hljs-string">-53</span><span class="hljs-string">-24</span>  O                  <br>3    &gt;  2018<span class="hljs-string">-08</span><span class="hljs-string">-21</span>_09<span class="hljs-string">-37</span><span class="hljs-string">-29</span>  O                  <br>4    &gt;  2018<span class="hljs-string">-11</span><span class="hljs-string">-19</span>_17<span class="hljs-string">-43</span><span class="hljs-string">-59</span>  O                  <br>5    &gt;  2019<span class="hljs-string">-01</span><span class="hljs-string">-20</span>_19<span class="hljs-string">-36</span><span class="hljs-string">-34</span>  O                  <br>6    &gt;  2019<span class="hljs-string">-03</span><span class="hljs-string">-01</span>_11<span class="hljs-string">-18</span><span class="hljs-string">-09</span>  O                  <br>7    &gt;  2019<span class="hljs-string">-03</span><span class="hljs-string">-01</span>_14<span class="hljs-string">-54</span><span class="hljs-string">-37</span>  O                  <br>8    &gt;  2019<span class="hljs-string">-03</span><span class="hljs-string">-04</span>_14<span class="hljs-string">-48</span><span class="hljs-string">-57</span>  O                  <br>9    &gt;  2019<span class="hljs-string">-03</span><span class="hljs-string">-10</span>_20<span class="hljs-string">-50</span><span class="hljs-string">-00</span>  O                  <br>10   &gt;  2019<span class="hljs-string">-03</span><span class="hljs-string">-14</span>_11<span class="hljs-string">-51</span><span class="hljs-string">-54</span>  O                  <br>11   &gt;  2019<span class="hljs-string">-07</span><span class="hljs-string">-16</span>_16<span class="hljs-string">-35</span><span class="hljs-string">-42</span>  O<br>123456789101112131415161718192021<br></code></pre></td></tr></table></figure></li><li><p>选择一个节点进行还原</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> timeshift --restore --snapshot &#x27;<span class="hljs-number">2019</span>-<span class="hljs-number">07</span>-<span class="hljs-number">16</span>_<span class="hljs-number">16</span>-<span class="hljs-number">35</span>-<span class="hljs-number">42</span>&#x27; --skip-grub<br><span class="hljs-attribute">1</span><br></code></pre></td></tr></table></figure><blockquote><p>–skip-grub 选项为跳过grub安装，一般来说grub不需要重新安装，除非bios启动无法找到正确的grub启动项，才需要安装。</p></blockquote><p>在输出的内容中依次输入【Enter】键和【y】键。</p><p>当然也可以直接输入下面的命令，忽略交互式的安装界面：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> timeshift --restore --snapshot &#x27;<span class="hljs-number">2019</span>-<span class="hljs-number">07</span>-<span class="hljs-number">16</span>_<span class="hljs-number">16</span>-<span class="hljs-number">35</span>-<span class="hljs-number">42</span>&#x27; --skip-grub --scripted<br><span class="hljs-attribute">1</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="无法进入系统，通过U盘启动系统"><a href="#无法进入系统，通过U盘启动系统" class="headerlink" title="无法进入系统，通过U盘启动系统"></a>无法进入系统，通过U盘启动系统</h3><p>当登录界面和桌面环境都无法进入时，一般系统已经彻底崩溃，此时只能通过Linux live CD进行还原。</p><ol><li><p>制作Linux Mint 启动盘，制作过程略。</p></li><li><p>进入Live系统后打开 <strong>Timeshift</strong> 软件，点击设置按钮，设置快照的存储位置：</p></li><li><blockquote><p>快照的存储位置是<strong>Timeshift</strong>在做备份的时候就已经设置好的。</p></blockquote></li><li><p>后续步骤和【如果能够进入系统】内的还原方式一样。</p></li></ol><p>其实此时还可以通过命令行的方式进行还原，但是首先需要设置快照存储的位置：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo timeshift --snapshot-device <span class="hljs-regexp">/dev/</span>sdb4<br><br></code></pre></td></tr></table></figure><p>后续步骤和【如果只能进入登录界面】内的还原方式一样。</p><hr><h5 id="错误：-Cannot-find-the-fakeroot-binary-gt-错误：-Cannot-find-the-strip-binary-required-for-object-fil…"><a href="#错误：-Cannot-find-the-fakeroot-binary-gt-错误：-Cannot-find-the-strip-binary-required-for-object-fil…" class="headerlink" title="错误： Cannot find the fakeroot binary. ==&gt; 错误： Cannot find the strip binary required for object fil…"></a>错误： Cannot find the fakeroot binary. ==&gt; 错误： Cannot find the strip binary required for object fil…</h5><p>解决方法：因为没安装 fakeroot、binutils 等打包基本工具，所以<code> sudo pacman -S base-devel</code> 装一下。(<code>sudo pacman -S -needed base-devel</code>安装包，且不重新安装已安装的包)</p><hr><h3 id="imwheel-调整鼠标滚轮速度"><a href="#imwheel-调整鼠标滚轮速度" class="headerlink" title="imwheel 调整鼠标滚轮速度"></a>imwheel 调整鼠标滚轮速度</h3><p><a href="https://wiki.archlinux.org/index.php/IMWheel#Run_IMWheel_on_startup_using_a_service">Arch Wiki上的方法</a></p><p>Arch：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo pacman -S imwheel<br></code></pre></td></tr></table></figure><h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a><strong>配置</strong></h5><p>创建<code>~/.imwheelrc</code>文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">nano ~/.imwheelrc<br></code></pre></td></tr></table></figure><p>编辑内容：</p><p>后面的数字就是速度的倍数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">&quot;.*&quot;<br>None,      Up,   Button4, 4<br>None,      Down, Button5, 4<br>Control_L, Up,   Control_L|Button4<br>Control_L, Down, Control_L|Button5<br>Shift_L,   Up,   Shift_L|Button4<br>Shift_L,   Down, Shift_L|Button5<br></code></pre></td></tr></table></figure><h5 id="运行"><a href="#运行" class="headerlink" title="运行"></a><strong>运行</strong></h5><p>运行测试一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">imwheel<br></code></pre></td></tr></table></figure><p>重新运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">imwheel kill<br></code></pre></td></tr></table></figure><p>看到提示就成功了。</p><p>使用systemed服务或者shell脚本在系统启动后自动调用<code>imwheel</code>，参照wiki.</p><h5 id="Run-IMWheel-on-startup-using-a-service"><a href="#Run-IMWheel-on-startup-using-a-service" class="headerlink" title="Run IMWheel on startup using a service"></a>Run IMWheel on startup using a service</h5><p>To avoid starting IMWheel manually, you can run it as part of your systemd startup.</p><p>Example:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs routeros">~/.config/systemd/user/imwheel.service<br>[Unit]<br><span class="hljs-attribute">Description</span>=IMWheel<br><span class="hljs-attribute">Wants</span>=display-manager.service<br><span class="hljs-attribute">After</span>=display-manager.service<br><br>[Service]<br><span class="hljs-attribute">Type</span>=simple<br><span class="hljs-attribute">Environment</span>=XAUTHORITY=%h/.Xauthority<br><span class="hljs-attribute">ExecStart</span>=/usr/bin/imwheel -d<br><span class="hljs-attribute">ExecStop</span>=/usr/bin/pkill imwheel<br><span class="hljs-attribute">RemainAfterExit</span>=<span class="hljs-literal">yes</span><br><br>[Install]<br><span class="hljs-attribute">WantedBy</span>=graphical-session.target<br></code></pre></td></tr></table></figure><p>After installing the above:</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">systemctl --<span class="hljs-keyword">user</span> <span class="hljs-title">daemon-reload</span><br>systemctl --<span class="hljs-keyword">user</span> <span class="hljs-title">enable</span> --now imwheel<br>journalctl --<span class="hljs-keyword">user</span> <span class="hljs-title">--unit</span> imwheel<br></code></pre></td></tr></table></figure><h5 id="Run-IMWheel-on-startup-using-a-shell-script"><a href="#Run-IMWheel-on-startup-using-a-shell-script" class="headerlink" title="Run IMWheel on startup using a shell script"></a>Run IMWheel on startup using a shell script</h5><p>Alternatively, you can create a startup.sh script in /etc/profile.d</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh</span><br><br>imwheel<br></code></pre></td></tr></table></figure><p>And then, on restart, it will automatically read and run the file. Always test your script manually before putting it in /etc/profile.d</p><hr><h3 id="安装配置vmware-workstation"><a href="#安装配置vmware-workstation" class="headerlink" title="安装配置vmware workstation"></a>安装配置vmware workstation</h3><h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>在manjaro的安装配置中，关于vmware的安装着实让我头疼;新建虚拟机打开出现错误</p><blockquote><p>could not open /dev/vmmon:?????? please make sure that the kernel moduel vmmon is load</p></blockquote><p>google、baidu搜索有遇到同样问题的，但是没有一个能够解决！！！前后折腾了许久，还选择安装了VirtulBox但是使用不习惯，后来突然醒悟可以去<code>manjaro</code>的论坛找找，这才找到解决方法。<br> 感慨：</p><ul><li>使用linux真的可以很好锻炼自我解决问题的能力。</li><li>找资料要有的放矢，不能盲目,否则就是浪费时间，要缩小查找范围。</li></ul><h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><ul><li>使用manjaro提供的方法Install vmware-workstation</li></ul><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">pamac build vmware-workstation</span><br></code></pre></td></tr></table></figure><ul><li>安装之后，重启你的设备，执行下面命令加载vmmon模块</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">sudo modprobe -<span class="hljs-selector-tag">a</span> vmw_vmci vmmon<br></code></pre></td></tr></table></figure><ul><li>Start and enable services（开启以及自启动服务）</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">sudo systemctl <span class="hljs-keyword">enable</span> <span class="hljs-comment">--now vmware-networks.service</span><br>sudo systemctl <span class="hljs-keyword">enable</span> <span class="hljs-comment">--now vmware-usbarbitrator.service</span><br>sudo systemctl <span class="hljs-keyword">enable</span> <span class="hljs-comment">--now vmware-hostd.service</span><br></code></pre></td></tr></table></figure><blockquote><p>上述服务的用处：<br>vmware-networks.service: Provides network access inside VMs, most people will want this enabled<br>vmware-usbarbitrator.service: Allows USB devices to be connected inside VMs<br>vmware-hostd.service: Enables sharing of VMs on the network</p></blockquote><p><em>至此，vmmon的问题应该完美解决了;如果你的问题还没有解决可以参考以下链接或者到manjaro frum提出问题</em><br> <a href="https://wiki.manjaro.org/index.php?title=VMware#Installing_VMWare_Workstation_on_Manjaro">Installing VMWare Workstation on Manjaro</a></p><h3 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">sudo pacman -S netease-cloud-music <span class="hljs-comment">#安装网易云音乐</span><br>高分屏缩放 可以通过 env QT_SCREEN_SCALE_FACTORS=<span class="hljs-number">1.25</span> netease-cloud-music 启动来解决,也就是在启动文件里添加。<br><br>如果应用商店下载时遇到下面错误<br>错误：未知下载协议：<span class="hljs-keyword">https</span><br>问题的解决办法是，修改一下 PKGBUILD 的第 <span class="hljs-number">18</span> 行，把 <span class="hljs-keyword">http</span> 改成 <span class="hljs-keyword">https</span> 就可以了。<br>DLAGENTS=(<span class="hljs-string">&quot;https::/usr/bin/curl -A &#x27;Mozilla&#x27; -fLC - --retry 3 --retry-delay 3 -o %o %u&quot;</span>)<br><br></code></pre></td></tr></table></figure><p>可能无法输入中文</p><p><a href="https://gitee.com/ForMat1/netease-cloud-music_For_Arch">这里有个解决bug的</a></p><ul><li>高颜值、开发活跃的第三方客户端：<code>yay -S yesplaymusic</code></li><li>qq音乐 <code>yay -S qqmusic-bin</code></li><li>一个支持全平台听歌的软件：FeelUown <code>yay -S feeluown</code></li></ul><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><ul><li><p>为知笔记：全平台通用、有云端同步、支持md的笔记 ： <code>yay -S wiznote</code></p></li><li><p>如果你更喜欢开源软件，这里还有个很好的选择： joplin <code>yay -S joplin</code></p></li><li><p>还有个选择：notion ： <code>yay -S notion-app</code></p></li><li><p>mkdown编辑器Typora： <code>yay -S typora</code></p></li><li><p>LaTeX是学术出版的标准排版软件。可以直接从软件仓库中安装，不需要完全安装，安装基础组件以及中文语言包即可：<code>sudo pacman -S texlive-most texlive-langchinese</code></p><p>编辑器TexStudio也是必备的：<code>sudo pacman -S texstudio</code></p></li></ul><h3 id="Android反编译"><a href="#Android反编译" class="headerlink" title="Android反编译"></a>Android反编译</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim">sudo pacman -S jadx<br>#官网：http<span class="hljs-variable">s:</span>//github.<span class="hljs-keyword">com</span>/skylot/jadx<br>打开<span class="hljs-keyword">gui</span>界面：jadx-<span class="hljs-keyword">gui</span><br></code></pre></td></tr></table></figure><h3 id="腾讯软件"><a href="#腾讯软件" class="headerlink" title="腾讯软件"></a>腾讯软件</h3><ul><li><p>安装qq</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">yay -S com<span class="hljs-selector-class">.qq</span><span class="hljs-selector-class">.im</span><span class="hljs-selector-class">.deepin</span><br>这个使用的是deepin-wine5<br>调整qq的缩放<br>WINEPREFIX=~/.deepinwine/Deepin-QQ deepin-wine5 winecfg<br></code></pre></td></tr></table></figure></li><li><p>安装Tim</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">yay -S deepin-wine-tim<br></code></pre></td></tr></table></figure><p>安装过程中出现选择输入n就好</p><p>切换deepin-wine环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">sh /opt/deepinwine/apps/Deepin-Tim/run.sh -d<br></code></pre></td></tr></table></figure><p>如果这个版本的卡或者有其他问题，建议安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">yay -S deepin.com.qq.office<br></code></pre></td></tr></table></figure><p>如果这个也没办法装，则使用linuxqq</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">yay -S linuxqq<br></code></pre></td></tr></table></figure><ul><li>安装微信</li></ul><p>deepin-wine版：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">yay -S deepin-wine-wechat<br></code></pre></td></tr></table></figure><p>切换到deepin-wine环境：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">/opt/apps/com.qq.weixin.deepin/files/run.sh -d<br></code></pre></td></tr></table></figure><p>关于字体发虚问题：</p><p>在切换到deepin-wine环境后，在terminal输入下面的指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">env WINEPREFIX=<span class="hljs-string">&quot;<span class="hljs-variable">$HOME</span>/.deepinwine/Deepin-TIM&quot;</span> /usr/bin/deepin-wine winecfg<br></code></pre></td></tr></table></figure><p>在弹出的窗口中选择windows xp，将DPI调大（默认是96），我调成了120</p><p>微信的同样，只需要将命令改为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">env WINEPREFIX=<span class="hljs-string">&quot;<span class="hljs-variable">$HOME</span>/.deepinwine/Deepin-WeChat&quot;</span> /usr/bin/deepin-wine winecfg<br></code></pre></td></tr></table></figure><p>electron版：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">yay -S electron-wechat<br></code></pre></td></tr></table></figure><hr><h5 id="隔离应用"><a href="#隔离应用" class="headerlink" title="隔离应用"></a>隔离应用</h5><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">firejail或者他的<span class="hljs-keyword">gui</span>版本风传讹<br></code></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><p><a href="https://github.com/Swordfish90/cool-retro-term">复古的终端</a></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">wget https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/Swordfish90/</span>cool-retro-term<span class="hljs-regexp">/releases/</span>download<span class="hljs-regexp">/1.1.1/</span>Cool-Retro-Term-<span class="hljs-number">1.1</span>.<span class="hljs-number">1</span>-x86_64.AppImage<br>chmod a+x Cool-Retro-Term-<span class="hljs-number">1.1</span>.<span class="hljs-number">1</span>-x86_64.AppImage<br>./Cool-Retro-Term-<span class="hljs-number">1.1</span>.<span class="hljs-number">1</span>-x86_64.AppImage<br></code></pre></td></tr></table></figure></li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># deepin 系的软件</span><br>sudo pacman -S deepin-picker <span class="hljs-comment"># 深度取色器</span><br>sudo pacman -S deepin-screen-recorder <span class="hljs-comment"># 录屏软件，可以录制 Gif 或者 MP4 格式</span><br>sudo pacman -S deepin-screenshot <span class="hljs-comment"># 深度截图</span><br>sudo pacman -S deepin-system-monitor <span class="hljs-comment"># 系统状态监控</span><br>yay -s deepin-wine-wechat<br>yay -S deepin-wine-tim<br>yay -S deepin-wine-baidupan<br>yay -S deepin.com.thunderspeed<br><br><span class="hljs-comment"># 开发软件</span><br>sudo pacman -S jdk8-openjdk<br>sudo pacman -S make<br>sudo pacman -S cmake<br>sudo pacman -S clang<br>sudo pacman -S nodejs<br>sudo pacman -S npm<br>sudo pacman -S goland<br>sudo pacman -S vim<br>sudo pacman -S maven<br>sudo pacman -S pycharm-professional <span class="hljs-comment"># Python IDE</span><br>sudo pacman -S intellij-idea-ultimate-edition <span class="hljs-comment"># JAVA IDE</span><br>yay -S pycharm pycharm-jre <span class="hljs-comment">#pycharm</span><br>sudo pacman -S goland <span class="hljs-comment"># Go IDE</span><br>sudo pacman -S visual-studio-code-bin <span class="hljs-comment"># vscode</span><br>sudo pacman -S qtcreator <span class="hljs-comment"># 一款QT开发软件</span><br>sudo pacman -S postman-bin<br>sudo pacman -S insomnia <span class="hljs-comment"># REST模拟工具</span><br>sudo pacman -S gitkraken <span class="hljs-comment"># GIT管理工具</span><br>sudo pacman -S wireshark-qt <span class="hljs-comment"># 抓包</span><br>sudo pacman -S zeal<br>sudo pacman -S gitkraken <span class="hljs-comment"># Git 管理工具</span><br><br><span class="hljs-comment"># 办公&amp;文本</span><br>yay -S youdao-dict <span class="hljs-comment">#安装有道词典安装 </span><br>yay -S foxitreader <span class="hljs-comment">#福昕pdf阅读器 </span><br>sudo pacman -S bookworm <span class="hljs-comment"># 电子书阅读</span><br>sudo pacman -S unrar unzip p7zip<br>sudo pacman -S goldendict <span class="hljs-comment"># 翻译、取词</span><br>yay -S typora <span class="hljs-comment"># markdown 编辑</span><br>yay -S electron-ssr <span class="hljs-comment"># 缺少我需要的加密算法</span><br>yay -S xmind-<span class="hljs-number">2020</span>  <span class="hljs-comment">#xmind-2020</span><br>yay -S calibre <span class="hljs-comment"># calibre：电子书管理</span><br><br><span class="hljs-comment"># 设计</span><br>sudo pacman -S pencil <span class="hljs-comment"># 免费开源界面原型图绘制工具</span><br><br><span class="hljs-comment"># 娱乐软件</span><br>sudo pacman -S netease-cloud-music     <span class="hljs-comment"># 网易云音乐</span><br>（注：直接安装完Wireshark后启动软件，会提示<span class="hljs-regexp">/usr/</span>bin/dumpcap无权限，运行下面的命令即可解决问题： sudo gpasswd -a username wireshark  <span class="hljs-comment"># username是用户名）</span><br><br><span class="hljs-comment"># 下载软件&amp;网络浏览</span><br>sudo pacman -S aria2<br>sudo pacman -S filezilla  <span class="hljs-comment"># filezilla 强大的FTP工具</span><br>yay -Sy filezilla <span class="hljs-comment"># filezilla 强大的FTP工具</span><br><br>yay -S baidunetdisk-bin <span class="hljs-comment">#百度云</span><br>yay -S xunlei-bin <span class="hljs-comment">#迅雷</span><br>sudo pacman -S google-chrome<br>yay -S microsoft-edge-dev-bin <span class="hljs-comment">#edge浏览器</span><br>sudo pacman -S you-get <span class="hljs-comment">#强大的Web内容（视频，音频，图片）下载工具</span><br>yay -S nutstore <span class="hljs-comment">#坚果云</span><br>注： yay -S python-gobject <span class="hljs-comment">#如果出现坚果云打不开或者没有登录页面的情况，安装坚果云相关依赖</span><br><br><br><span class="hljs-comment"># 图形</span><br>sudo pacman -S gimp <span class="hljs-comment"># 修图</span><br>sudo pacman -Sy obs-studio <span class="hljs-comment"># OBS</span><br><br><span class="hljs-comment"># 系统工具</span><br>sudo pacman -S albert <span class="hljs-comment">#类似Mac Spotlight，另外一款https://cerebroapp.com/</span><br>yay -S copyq <span class="hljs-comment">#  剪贴板工具，类似 Windows 上的 Ditto</span><br>sudo pacman -S gufw<span class="hljs-comment">#安装防火墙Linux 世界中最简单的防火墙之一</span><br>sudo pacman -S yay                     <span class="hljs-comment"># AUR助手</span><br>yay -S latte-dock <span class="hljs-comment"># 安装latte-dock</span><br><br><span class="hljs-comment"># 终端</span><br>sudo pacman -S screenfetch <span class="hljs-comment"># 终端打印出你的系统信息，screenfetch -A &#x27;Arch Linux&#x27;</span><br>sudo pacman -S htop     <span class="hljs-comment">#可以在终端中直接管理进程</span><br>sudo pacman -S bat<br>sudo pacman -S yakuake <span class="hljs-comment"># 堪称 KDE 下的终端神器，KDE 已经自带，F12 可以唤醒</span><br>sudo pacman -S net-tools <span class="hljs-comment"># 这样可以使用 ifconfig 和 netstat</span><br>yay -S tldr<br>yay -S tig <span class="hljs-comment"># 命令行下的 git 历史查看工具</span><br>yay -S tree<br>yay -S ncdu <span class="hljs-comment"># 命令行下的磁盘分析器，支持Vim操作</span><br>yay -S mosh <span class="hljs-comment"># 一款速度更快的 ssh 工具，网络不稳定时使用有奇效</span><br>sudo pacman -S thefuck <span class="hljs-comment">#自动纠正上一个控制台命令</span><br>sudo pacman -S tmux<span class="hljs-comment">#强大的终端复用工具</span><br>yay -S lolcat <span class="hljs-comment">#终端渐变色工具</span><br>yay -S ranger <span class="hljs-comment">#终端文件浏览器</span><br><br>其他：<br>sudo pacman -S clang make cmake gdb    <span class="hljs-comment"># 编译调试环境</span><br>sudo pacman -S visual-studio-code-bin  <span class="hljs-comment"># 牛逼的编辑器</span><br>sudo pacman -S vim                     <span class="hljs-comment"># 命令行下的编辑器</span><br>sudo pacman -S qtcreator               <span class="hljs-comment"># IDE for Qt</span><br>sudo pacman -S wireshark-qt            <span class="hljs-comment"># 抓包工具</span><br>sudo pacman -S git                     <span class="hljs-comment"># 版本管理工具</span><br>sudo pacman -S octave                  <span class="hljs-comment"># Matlab的开源替代</span><br><br><span class="hljs-comment"># zsh</span><br>zsh以默认安装在系统中，F12中输入zsh即可使用，输入<span class="hljs-keyword">exit</span>退出zsh<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件</tag>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>scroller</title>
    <link href="/posts/3697a639/"/>
    <url>/posts/3697a639/</url>
    
    <content type="html"><![CDATA[<p>Scroller的总结<br>内容来自各个博客</p><ul><li>本质及作用：<br>Scroller本质就是一个Helper类，里面保存了目标对象要移动的距离，时间等属性！     </li></ul><p>Android ViewGroup中的Scroller与computeScroll的有什么关系？</p><p>答：没有直接的关系</p><p>1.Scroller到底是什么？</p><p>答：Scroller只是个计算器，提供插值计算，让滚动过程具有动画属性，但它并不是UI，也不是辅助UI滑动，反而是单纯地为滑动提供计算。</p><p>无论从构造方法还是其他方法，以及Scroller的属性可知，其并不会持有View，辅助ViewGroup滑动</p><p>2.Scroller只是提供计算，那谁来调用computeScroll使得ViewGroup滑动</p><p>答：computeScroll也不是来让ViewGroup滑动的，真正让ViewGroup滑动的是scrollTo,scrollBy。computeScroll的作用是计算ViewGroup如何滑动。而computeScroll是通过draw来调用的。</p><p>3.computeScroll和Scroller都是计算，两者有啥关系？</p><p>答：文章开始已作答，没有直接的关系。computeScroll和Scroller要是飞得拉关系的话，那就是computeScroll可以参考Scroller计算结果来影响scrollTo,scrollBy,从而使得滑动发生改变。也就是Scroller不会调用computeScroll，反而是computeScroll调用Scroller。</p><p>4.滑动时连续的，如何让Scroller的计算也是连续的？</p><p>这个就问到了什么时候调用computeScroll了，如上所说computeScroll调用Scroller，只要computeScroll调用连续，Scroller也会连续，实质上computeScroll的连续性又invalidate方法控制，scrollTo,scrollBy都会调用invalidate，而invalidate回去触发draw,从而computeScroll被连续调用，综上，Scroller也会被连续调用，除非invalidate停止调用。</p><p>5.computeScroll如何和Scroller的调用过程保持一致。</p><p>computeScroll参考Scroller影响scrollTo,scrollBy，实质上，为了不重复影响scrollTo,scrollBy，那么Scroller必须终止计算currX，currY。要知道计算有没有终止，需要通过mScroller.computeScrollOffset()</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">computeScroll</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">super</span>.computeScroll();<br><span class="hljs-keyword">if</span>(!mScroll.computeScrollOffset())&#123;<br><span class="hljs-comment">//计算currX,currY,并检测是否已完成&quot;滚动&quot;</span><br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">int</span> tempX=mScroll.getCurrX();<br>scrollTo(tempX,<span class="hljs-number">0</span>);<span class="hljs-comment">//会重复调用invalidate</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>注意：在移动平台中，要明确知道“滑动”与“滚动”的不同，具体来说，滑动和滚动的方向总是相反的。</code></p><p>再来看一下scrollTo,scrollBy这两个方法的区别, scrollTo()方法是让View相对于初始的位置滚动某段距离，由于View的初始位置是不变的，因此不管我们点击多少次scrollTo按钮滚动到的都将是同一个位置。而scrollBy()方法则是让View相对于当前的位置滚动某段距离，那每当我们点击一次scrollBy按钮，View的当前位置都进行了变动，因此不停点击会一直移动。</p><p>通过这个例子来理解，相信大家已经把scrollTo()和scrollBy()这两个方法的区别搞清楚了，但是现在还有一个问题，目前使用这两个方法完成的滚动效果是跳跃式的，没有任何平滑滚动的效果。没错，只靠scrollTo()和scrollBy()这两个方法是很难完成ViewPager这样的效果的，因此我们还需要借助另外一个关键性的工具，也就我们今天的主角Scroller。<br>Scroller的基本用法其实还是比较简单的，主要可以分为以下几个步骤：</p><p>1.创建Scroller的实例<br>2.调用startScroll()方法来初始化滚动数据并刷新界面<br>3.重写computeScroll()方法，并在其内部完成平滑滚动的逻辑<br>那么下面我们就按照上述的步骤，通过一个模仿ViewPager的简易例子来学习和理解一下Scroller的用法。<br>新建一个ScrollerLayout并让它继承自ViewGroup来作为我们的简易ViewPager布局，代码如下所示：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Created by guolin on 16/1/12.</span><br><span class="hljs-comment"> */</span><br>public <span class="hljs-keyword">class</span> ScrollerLayout extends ViewGroup &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用于完成滚动操作的实例</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Scroller mScroller;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判定为拖动的最小移动像素数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> mTouchSlop;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 手机按下时的屏幕坐标</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span> mXDown;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 手机当时所处的屏幕坐标</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span> mXMove;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 上次触发ACTION_MOVE事件时的屏幕坐标</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span> mXLastMove;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 界面可滚动的左边界</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> leftBorder;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 界面可滚动的右边界</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> rightBorder;<br><br>    public <span class="hljs-constructor">ScrollerLayout(Context <span class="hljs-params">context</span>, AttributeSet <span class="hljs-params">attrs</span>)</span> &#123;<br>        super(context, attrs);<br>        <span class="hljs-comment">// 第一步，创建Scroller的实例</span><br>        mScroller = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Scroller(<span class="hljs-params">context</span>)</span>;<br>        ViewConfiguration configuration = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ViewConfiguration</span>.</span></span>get(context);<br>        <span class="hljs-comment">// 获取TouchSlop值</span><br>        mTouchSlop = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ViewConfigurationCompat</span>.</span></span>get<span class="hljs-constructor">ScaledPagingTouchSlop(<span class="hljs-params">configuration</span>)</span>;<br>    &#125;<br><br>    @Override<br>    protected void on<span class="hljs-constructor">Measure(<span class="hljs-params">int</span> <span class="hljs-params">widthMeasureSpec</span>, <span class="hljs-params">int</span> <span class="hljs-params">heightMeasureSpec</span>)</span> &#123;<br>        super.on<span class="hljs-constructor">Measure(<span class="hljs-params">widthMeasureSpec</span>, <span class="hljs-params">heightMeasureSpec</span>)</span>;<br>        <span class="hljs-built_in">int</span> childCount = get<span class="hljs-constructor">ChildCount()</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; childCount; i++) &#123;<br>            View childView = get<span class="hljs-constructor">ChildAt(<span class="hljs-params">i</span>)</span>;<br>            <span class="hljs-comment">// 为ScrollerLayout中的每一个子控件测量大小</span><br>            measure<span class="hljs-constructor">Child(<span class="hljs-params">childView</span>, <span class="hljs-params">widthMeasureSpec</span>, <span class="hljs-params">heightMeasureSpec</span>)</span>;<br>        &#125;<br>    &#125;<br><br>    @Override<br>    protected void on<span class="hljs-constructor">Layout(<span class="hljs-params">boolean</span> <span class="hljs-params">changed</span>, <span class="hljs-params">int</span> <span class="hljs-params">l</span>, <span class="hljs-params">int</span> <span class="hljs-params">t</span>, <span class="hljs-params">int</span> <span class="hljs-params">r</span>, <span class="hljs-params">int</span> <span class="hljs-params">b</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (changed) &#123;<br>            <span class="hljs-built_in">int</span> childCount = get<span class="hljs-constructor">ChildCount()</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; childCount; i++) &#123;<br>                View childView = get<span class="hljs-constructor">ChildAt(<span class="hljs-params">i</span>)</span>;<br>                <span class="hljs-comment">// 为ScrollerLayout中的每一个子控件在水平方向上进行布局</span><br>                childView.layout(i<span class="hljs-operator"> * </span>childView.get<span class="hljs-constructor">MeasuredWidth()</span>, <span class="hljs-number">0</span>, (i + <span class="hljs-number">1</span>)<span class="hljs-operator"> * </span>childView.get<span class="hljs-constructor">MeasuredWidth()</span>, childView.get<span class="hljs-constructor">MeasuredHeight()</span>);<br>            &#125;<br>            <span class="hljs-comment">// 初始化左右边界值</span><br>            leftBorder = get<span class="hljs-constructor">ChildAt(0)</span>.get<span class="hljs-constructor">Left()</span>;<br>            rightBorder = get<span class="hljs-constructor">ChildAt(<span class="hljs-params">getChildCount</span>()</span> - <span class="hljs-number">1</span>).get<span class="hljs-constructor">Right()</span>;<br>        &#125;<br>    &#125;<br><br>    @Override<br>    public boolean on<span class="hljs-constructor">InterceptTouchEvent(MotionEvent <span class="hljs-params">ev</span>)</span> &#123;<br>        switch (ev.get<span class="hljs-constructor">Action()</span>) &#123;<br>            case MotionEvent.ACTION_DOWN:<br>                mXDown = ev.get<span class="hljs-constructor">RawX()</span>;<br>                mXLastMove = mXDown;<br>                break;<br>            case MotionEvent.ACTION_MOVE:<br>                mXMove = ev.get<span class="hljs-constructor">RawX()</span>;<br>                <span class="hljs-built_in">float</span> diff = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>abs(mXMove - mXDown);<br>                mXLastMove = mXMove;<br>                <span class="hljs-comment">// 当手指拖动值大于TouchSlop值时，认为应该进行滚动，拦截子控件的事件</span><br>                <span class="hljs-keyword">if</span> (diff &gt; mTouchSlop) &#123;<br>                    return <span class="hljs-literal">true</span>;<br>                &#125;<br>                break;<br>        &#125;<br>        return super.on<span class="hljs-constructor">InterceptTouchEvent(<span class="hljs-params">ev</span>)</span>;<br>    &#125;<br><br>    @Override<br>    public boolean on<span class="hljs-constructor">TouchEvent(MotionEvent <span class="hljs-params">event</span>)</span> &#123;<br>        switch (event.get<span class="hljs-constructor">Action()</span>) &#123;<br>            case MotionEvent.ACTION_MOVE:<br>                mXMove = event.get<span class="hljs-constructor">RawX()</span>;<br>                <span class="hljs-built_in">int</span> scrolledX = (<span class="hljs-built_in">int</span>) (mXLastMove - mXMove);<br>                <span class="hljs-keyword">if</span> (get<span class="hljs-constructor">ScrollX()</span> + scrolledX &lt; leftBorder) &#123;<br>                    scroll<span class="hljs-constructor">To(<span class="hljs-params">leftBorder</span>, 0)</span>;<br>                    return <span class="hljs-literal">true</span>;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (get<span class="hljs-constructor">ScrollX()</span> + get<span class="hljs-constructor">Width()</span> + scrolledX &gt; rightBorder) &#123;<br>                    scroll<span class="hljs-constructor">To(<span class="hljs-params">rightBorder</span> - <span class="hljs-params">getWidth</span>()</span>, <span class="hljs-number">0</span>);<br>                    return <span class="hljs-literal">true</span>;<br>                &#125;<br>                scroll<span class="hljs-constructor">By(<span class="hljs-params">scrolledX</span>, 0)</span>;<br>                mXLastMove = mXMove;<br>                break;<br>            case MotionEvent.ACTION_UP:<br>                <span class="hljs-comment">// 当手指抬起时，根据当前的滚动值来判定应该滚动到哪个子控件的界面</span><br>                <span class="hljs-built_in">int</span> targetIndex = (get<span class="hljs-constructor">ScrollX()</span> + get<span class="hljs-constructor">Width()</span><span class="hljs-operator"> / </span><span class="hljs-number">2</span>)<span class="hljs-operator"> / </span>get<span class="hljs-constructor">Width()</span>;<br>                <span class="hljs-built_in">int</span> dx = targetIndex<span class="hljs-operator"> * </span>get<span class="hljs-constructor">Width()</span> - get<span class="hljs-constructor">ScrollX()</span>;<br>                <span class="hljs-comment">// 第二步，调用startScroll()方法来初始化滚动数据并刷新界面</span><br>                mScroller.start<span class="hljs-constructor">Scroll(<span class="hljs-params">getScrollX</span>()</span>, <span class="hljs-number">0</span>, dx, <span class="hljs-number">0</span>);<br>                invalidate<span class="hljs-literal">()</span>;<br>                break;<br>        &#125;<br>        return super.on<span class="hljs-constructor">TouchEvent(<span class="hljs-params">event</span>)</span>;<br>    &#125;<br><br>    @Override<br>    public void compute<span class="hljs-constructor">Scroll()</span> &#123;<br>        <span class="hljs-comment">// 第三步，重写computeScroll()方法，并在其内部完成平滑滚动的逻辑</span><br>        <span class="hljs-keyword">if</span> (mScroller.compute<span class="hljs-constructor">ScrollOffset()</span>) &#123;<br>            scroll<span class="hljs-constructor">To(<span class="hljs-params">mScroller</span>.<span class="hljs-params">getCurrX</span>()</span>, mScroller.get<span class="hljs-constructor">CurrY()</span>);<br>            invalidate<span class="hljs-literal">()</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>整个Scroller用法的代码都在这里了，代码并不长，一共才100多行，我们一点点来看。<br>首先在ScrollerLayout的构造函数里面我们进行了上述步骤中的第一步操作，即创建Scroller的实例，由于Scroller的实例只需创建一次，因此我们把它放到构造函数里面执行。另外在构建函数中我们还初始化的TouchSlop的值，这个值在后面将用于判断当前用户的操作是否是拖动。</p><p>接着重写onMeasure()方法和onLayout()方法，在onMeasure()方法中测量ScrollerLayout里的每一个子控件的大小，在onLayout()方法中为ScrollerLayout里的每一个子控件在水平方向上进行布局。</p><p>接着重写onInterceptTouchEvent()方法， 在这个方法中我们记录了用户手指按下时的X坐标位置，以及用户手指在屏幕上拖动时的X坐标位置，当两者之间的距离大于TouchSlop值时，就认为用户正在拖动布局，然后我们就将事件在这里拦截掉，阻止事件传递到子控件当中。</p><p>那么当我们把事件拦截掉之后，就会将事件交给ScrollerLayout的onTouchEvent()方法来处理。如果当前事件是ACTION_MOVE，说明用户正在拖动布局，那么我们就应该对布局内容进行滚动从而影响拖动事件，实现的方式就是使用我们刚刚所学的scrollBy()方法，用户拖动了多少这里就scrollBy多少。另外为了防止用户拖出边界这里还专门做了边界保护，当拖出边界时就调用scrollTo()方法来回到边界位置。</p><p>如果当前事件是ACTION_UP时，说明用户手指抬起来了，但是目前很有可能用户只是将布局拖动到了中间，我们不可能让布局就这么停留在中间的位置，因此接下来就需要借助Scroller来完成后续的滚动操作。首先这里我们先根据当前的滚动位置来计算布局应该继续滚动到哪一个子控件的页面，然后计算出距离该页面还需滚动多少距离。接下来我们就该进行上述步骤中的第二步操作，调用startScroll()方法来初始化滚动数据并调用invalidate()来刷新界面。startScroll()方法接收四个参数，第一个参数是滚动开始时X的坐标，第二个参数是滚动开始时Y的坐标，第三个参数是横向滚动的距离，正值表示向左滚动，第四个参数是纵向滚动的距离，正值表示向上滚动。紧接着调用invalidate()方法来刷新界面。</p><p>现在前两步都已经完成了，最后我们还需要进行第三步操作，即重写computeScroll()方法，并在其内部完成平滑滚动的逻辑 。在整个后续的平滑滚动过程中，computeScroll()方法是会一直被调用的，因此我们需要不断调用Scroller的computeScrollOffset()方法来进行判断滚动操作是否已经完成了，如果还没完成的话，那就继续调用scrollTo()方法，并把Scroller的curX和curY坐标传入，然后刷新界面从而完成平滑滚动的操作。</p><hr><p>实现惯性滚动 (Scroller的妙用)<br><a href="%22https://blog.csdn.net/u011387817/article/details/80313184%22">Android实现圆弧滑动效果之ArcSlidingHelper篇</a><br>说到Scroller，相信大家第一时间想到要配合View中的computeScroll方法来使用对吧，但是呢，我们这篇文章的主题是辅助类，并不打算继承View，而且不持有Context引用，这个时候，可能有同学就会有以下疑问了：</p><ul><li>这种情况下，Scroller还能正常工作吗？</li><li>调用它的startScroll或fling方法后，不是还要调用View中的invalidate方法来触发的吗？</li><li>不继承View，哪来的 invalidate方法？  </li><li>不继承View，怎么重写computeScroll方法？在哪里处理惯性滚动？  </li><li>哈哈，其实Scroller是完全可以脱离View来使用的，既然说是妙用，妙在哪里呢？在开始之前，我们先来了解一下Scroller：  </li></ul><p>1.它看上去更像是一个ValueAnimator，但它跟ValueAnimator有个明显的区别就是：它不会主动更新动画的值。我们在获取最新值之前，总是要先调用computeScrollOffset方法来刷新内部的mCurrX、mCurrY的值，如果是惯性滚动模式(调用fling方法)，还会刷新mCurrVelocity的值。  </p><p>2.在这里先分享大家一个理解源码调用顺序的方法：<br>比如我们想知道是哪个方法调用了computeScroll：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">@Override<br>public void compute<span class="hljs-constructor">Scroll()</span> &#123;<br>    StackTraceElement<span class="hljs-literal">[]</span> elements = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">StackTrace()</span>;<br>    <span class="hljs-keyword">for</span> (StackTraceElement element : elements) &#123;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>i(<span class="hljs-string">&quot;computeScroll&quot;</span>, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">String</span>.</span></span>format(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Locale</span>.</span></span>get<span class="hljs-constructor">Default()</span>, <span class="hljs-string">&quot;%s-----&gt;%s\tline: %d&quot;</span>,<br>                element.get<span class="hljs-constructor">ClassName()</span>, element.get<span class="hljs-constructor">MethodName()</span>, element.get<span class="hljs-constructor">LineNumber()</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>日志输出：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">com.wuyr.testview.MyView<span class="hljs-comment">-----&gt;computeScrollline: 141</span><br>android.<span class="hljs-keyword">view</span>.<span class="hljs-keyword">View</span><span class="hljs-comment">-----&gt;updateDisplayListIfDirtyline: 15361</span><br>android.<span class="hljs-keyword">view</span>.<span class="hljs-keyword">View</span><span class="hljs-comment">-----&gt;drawline: 16182</span><br>android.<span class="hljs-keyword">view</span>.ViewGroup<span class="hljs-comment">-----&gt;drawChildline: 3777</span><br>android.<span class="hljs-keyword">view</span>.ViewGroup<span class="hljs-comment">-----&gt;dispatchDrawline: 3567</span><br>android.<span class="hljs-keyword">view</span>.<span class="hljs-keyword">View</span><span class="hljs-comment">-----&gt;updateDisplayListIfDirtyline: 15373</span><br>android.<span class="hljs-keyword">view</span>.<span class="hljs-keyword">View</span><span class="hljs-comment">-----&gt;drawline: 16182</span><br>android.<span class="hljs-keyword">view</span>.ViewGroup<span class="hljs-comment">-----&gt;drawChildline: 3777</span><br>android.<span class="hljs-keyword">view</span>.ViewGroup<span class="hljs-comment">-----&gt;dispatchDrawline: 3567</span><br>android.<span class="hljs-keyword">view</span>.<span class="hljs-keyword">View</span><span class="hljs-comment">-----&gt;updateDisplayListIfDirtyline: 15373</span><br>android.<span class="hljs-keyword">view</span>.<span class="hljs-keyword">View</span><span class="hljs-comment">-----&gt;drawline: 16182</span><br></code></pre></td></tr></table></figure><p>这样我们就能够很清晰的看到它的调用链了。</p><p>回到正题，所谓的调用invalidate方法来触发，是这样的：我们都知道，调用了这个方法之后，onDraw方法就会回调，而调用onDraw的那个方法，是draw(Canvas canvas)，再上一级，是draw(Canvas canvas, ViewGroup parent, long drawingTime)，重点来了：<br>computeScroll也是在这个方法中回调的，现在可以得出一个结论：<br>我们在View中调用invalidate方法，也就是间接地调用computeScroll，而computeScroll中，是我们处理滚动的方法，在使用Scroller时，我们都会重写这个方法，并在里面调用Scroller的computeScrollOffset方法，然后调用getCurrX或getCurrY来获取到最新的值。(好像我前面说的都是多余的) 但是！有没有发现，这个过程，我们完全可以不依赖View来做到的？</p><p>3.现在思路就很清晰了，invalidate方法？对于Scroller来说，它的作用只是回调computeScroll从而更新x和y的值而已。</p><p>4.所以完全可以自己写两个方法来实现Scroller在View中的效果，我们这次打算利用Hanlder来帮我们处理异步的问题，这样的话，我们就不用自己新开线程去不断的调用方法啦。</p><p>好了，现在我们所遇到的问题，都已经有解决方案了，可以动手咯！</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"> <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 处理触摸事件</span><br><span class="hljs-comment">     */</span><br>    public void handle<span class="hljs-constructor">Movement(MotionEvent <span class="hljs-params">event</span>)</span> &#123;<br>     .....<br>        mVelocityTracker.add<span class="hljs-constructor">Movement(<span class="hljs-params">event</span>)</span>;<br>        switch (event.get<span class="hljs-constructor">Action()</span>) &#123;<br>            case MotionEvent.ACTION_DOWN:<br>             .....<br>                break;<br>            case MotionEvent.ACTION_MOVE:<br>                handle<span class="hljs-constructor">ActionMove(<span class="hljs-params">x</span>, <span class="hljs-params">y</span>)</span>;<br>                break;<br>            case MotionEvent.ACTION_UP:<br>            case MotionEvent.ACTION_CANCEL:<br>            case MotionEvent.ACTION_OUTSIDE:<br>                <span class="hljs-keyword">if</span> (isInertialSlidingEnable) &#123;<br>                    mVelocityTracker.compute<span class="hljs-constructor">CurrentVelocity(1000)</span>;<br>                    mScroller.fling(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, (<span class="hljs-built_in">int</span>) mVelocityTracker.get<span class="hljs-constructor">XVelocity()</span>, (<span class="hljs-built_in">int</span>) mVelocityTracker.get<span class="hljs-constructor">YVelocity()</span>,Integer.MIN_VALUE, Integer.MAX_VALUE, Integer.MIN_VALUE, Integer.MAX_VALUE); <br>                    <span class="hljs-comment">//我们在调用Scroller的fling方法之后，并没有调用invalidate方法，而是我们自定义的startFling方法. </span><br>                    start<span class="hljs-constructor">Fling()</span>;<br>                &#125;<br>                break;<br>           .....<br>        &#125;<br> .....<br>    &#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 处理惯性滚动</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> void compute<span class="hljs-constructor">InertialSliding()</span> &#123;<br>        check<span class="hljs-constructor">IsRecycled()</span>;<br>        <span class="hljs-keyword">if</span> (mScroller.compute<span class="hljs-constructor">ScrollOffset()</span>) &#123;<br>            <span class="hljs-built_in">float</span> y = ((isShouldBeGetY ? mScroller.get<span class="hljs-constructor">CurrY()</span> : mScroller.get<span class="hljs-constructor">CurrX()</span>)<span class="hljs-operator"> * </span>mScrollAvailabilityRatio);<br>            <span class="hljs-keyword">if</span> (mLastScrollOffset != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-built_in">float</span> offset = fix<span class="hljs-constructor">Angle(Math.<span class="hljs-params">abs</span>(<span class="hljs-params">y</span> - <span class="hljs-params">mLastScrollOffset</span>)</span>);<br>                mSlidingListener.on<span class="hljs-constructor">Sliding(<span class="hljs-params">isClockwiseScrolling</span> ? <span class="hljs-params">offset</span> : -<span class="hljs-params">offset</span>)</span>;<br>            &#125;<br>            mLastScrollOffset = y;<br>            start<span class="hljs-constructor">Fling()</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mScroller.is<span class="hljs-constructor">Finished()</span>) &#123;<br>            mLastScrollOffset = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (mSlideFinishListener != null) &#123;<br>                mSlideFinishListener.on<span class="hljs-constructor">SlideFinished()</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 开始惯性滚动</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> void start<span class="hljs-constructor">Fling()</span> &#123;<br>        mHandler.send<span class="hljs-constructor">EmptyMessage(0)</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 主线程回调惯性滚动</span><br><span class="hljs-comment">     *Handler来处理异步的问题，这样就不用自己去新开线程了。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> static <span class="hljs-keyword">class</span> InertialSlidingHandler extends Handler &#123;<br><br>        ArcSlidingHelper mHelper;<br><br>        <span class="hljs-constructor">InertialSlidingHandler(ArcSlidingHelper <span class="hljs-params">helper</span>)</span> &#123;<br>            mHelper = helper;<br>        &#125;<br><br>        @Override<br>        public void handle<span class="hljs-constructor">Message(Message <span class="hljs-params">msg</span>)</span> &#123;<br>            mHelper.compute<span class="hljs-constructor">InertialSliding()</span>;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>我们用computeInertialSliding来代替了View中的computeScroll方法，用startFling代替了invalidate，可以说是完全脱离了View来使用Scroller，妙就妙在这里啦，嘻嘻。</p><hr><p>Scroller主要使用的滚动方法有：startScroll、fling。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">start<span class="hljs-constructor">Scroll(<span class="hljs-params">int</span> <span class="hljs-params">startX</span>, <span class="hljs-params">int</span> <span class="hljs-params">startY</span>, <span class="hljs-params">int</span> <span class="hljs-params">dx</span>, <span class="hljs-params">int</span> <span class="hljs-params">dy</span>, <span class="hljs-params">int</span> <span class="hljs-params">duration</span>)</span>：<br>指定起点（startX，startY），从起点平滑变化（dx，dy），耗时duration，通常用于：知道起点与需要改变的距离的平滑滚动等。<br><br>fling(<span class="hljs-built_in">int</span> startX, <span class="hljs-built_in">int</span> startY, <span class="hljs-built_in">int</span> velocityX, <span class="hljs-built_in">int</span> velocityY, <span class="hljs-built_in">int</span> minX, <span class="hljs-built_in">int</span> maxX, <span class="hljs-built_in">int</span> minY, <span class="hljs-built_in">int</span> maxY)：<br>惯性滑动。  给定一个初始速度（ velocityX， velocityY ），该方法内部会根据这个速度去计算需要滑动的距离以及需要耗费的时间。通常用于：界面的惯性滑动等。<br></code></pre></td></tr></table></figure><p>scroller的实例化：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Scroller mScroller = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Scroller(Context <span class="hljs-params">mContext</span>)</span>&#123;&#125;; :采用默认插值器<br>Scroller mScroller = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Scroller(Context <span class="hljs-params">mContext</span>，Interpolator <span class="hljs-params">interpolator</span>)</span>&#123;&#125;;采用指定的插值器<br></code></pre></td></tr></table></figure><p>调用过程：</p><pre><code>   public void startScroll( int startX, int startY, int dx,int dy)&#123;&#125;;</code></pre><p>这方法并不是真正意义上的开始Scroll，它的作用是为Scroller做一些准备工作,比如设置移动的初始位置，滑动的位移以及持续时间等。</p><pre><code>   public boolean computeScrollOffset()&#123;&#125;</code></pre><p>这方法用于判断移动过程是否完成</p><pre><code>   getCurrX、getCurrY、getFinalX、getFinalY、</code></pre><p>这些方法用于获取scroll的一些位置信息</p><ul><li>Scroller与View结合使用：</li></ul><p>首先需要在自定义的View中定义一个私有成员 mScroller，用于记录view滚动的位置，然后再重写View的<code>computeScroll（）</code>方法来实现具体移动</p><p>注意：Scroller的作用只是保存一些信息，以及判断是否移动完成，所以我们得知道<code>computeScroll（）</code>这个方法的调用流程，在查看Android源码时发现<br>View.java中的<code>computeScroll（）</code>方法是一个空函数，所以我们需要在自定义的View中重写这个方法来实现我们想要的功能，那么<code>computeScroll（）</code>是怎么样被调用的呢？</p><p>调用<code>invalidate()</code>（UI线程）或者<code>postInvalidate（）</code>使View（Viewgroup）树重绘.<br>重绘分成两种情况：</p><p>1、Viewgroup的重绘<br><code>ViewGroup的绘制流程：onDraw（）--&gt;dispatchDraw()--&gt;drawChild()--&gt;child.computeScroll()</code></p><p>2、View的重绘：</p><p>View没有子view所以在View的源码中看到<code>dispatchDraw（）</code>方法是一个空方法，那么其调用流程就和ViewGroup是不一样的，那么View是怎样调用<code>computeScroll（）</code>的呢？</p><p>我们注意到invalidate是重绘整个View树或者ViewGroup树，所以当View重绘时其所在父容器也会重绘，so，父容器就会经历<code>onDraw（）--&gt;dispatchDraw()--&gt;drawChild() --&gt;child.computeScroll()</code>流程，这时候自定义View中重写的computeScroll（）方法就会被调用。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"> <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ViewGroup</span>.</span></span>java：<br><br>@Override  <br>protected void dispatch<span class="hljs-constructor">Draw(Canvas <span class="hljs-params">canvas</span>)</span>&#123; <br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;  <br>            final View child = children<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>;  <br>            <span class="hljs-keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK)<span class="hljs-operator"> == </span>VISIBLE<span class="hljs-operator"> || </span>child.get<span class="hljs-constructor">Animation()</span> != null)  <br>  <br>            &#123;  <br>                more <span class="hljs-pattern-match">|= draw<span class="hljs-constructor">Child(<span class="hljs-params">canvas</span>, <span class="hljs-params">child</span>, <span class="hljs-params">drawingTime</span>)</span>;  </span><br><span class="hljs-pattern-match">            &#125;  </span><br><span class="hljs-pattern-match">draw<span class="hljs-constructor">Child</span>函数：</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">protected boolean draw<span class="hljs-constructor">Child(Canvas <span class="hljs-params">canvas</span>, View <span class="hljs-params">child</span>, <span class="hljs-params">long</span> <span class="hljs-params">drawingTime</span>)</span> &#123;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">                  ----------</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">child.compute<span class="hljs-constructor">Scroll()</span>;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">              -----------------</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match"> <span class="hljs-keyword">if</span> ((child.m<span class="hljs-constructor">PrivateFlags</span> &amp; <span class="hljs-constructor">SKIP_DRAW</span>) <span class="hljs-operator">==</span> <span class="hljs-constructor">SKIP_DRAW</span>) &#123;</span><br><span class="hljs-pattern-match">        <span class="hljs-keyword">if</span> (<span class="hljs-constructor">ViewDebug</span>.<span class="hljs-constructor">TRACE_HIERARCHY</span>) &#123;</span><br><span class="hljs-pattern-match">            <span class="hljs-constructor">ViewDebug</span>.trace(this, <span class="hljs-constructor">ViewDebug</span>.<span class="hljs-constructor">HierarchyTraceType</span>.<span class="hljs-constructor">DRAW</span>);</span><br><span class="hljs-pattern-match">        &#125;</span><br><span class="hljs-pattern-match">        child.dispatch<span class="hljs-constructor">Draw(<span class="hljs-params">canvas</span>)</span>;</span><br><span class="hljs-pattern-match">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="hljs-pattern-match">        child.draw(canvas);</span><br><span class="hljs-pattern-match">    &#125;</span><br></code></pre></td></tr></table></figure><ul><li>自定义View：</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> CustomView extends View &#123;  <br>  <br>    <span class="hljs-keyword">private</span> Scroller mScroller;  <br> <br>    public <span class="hljs-constructor">CustomView(Context <span class="hljs-params">context</span>, AttributeSet <span class="hljs-params">attrs</span>)</span> &#123;  <br>        super(context, attrs);  <br>        mScroller = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Scroller(<span class="hljs-params">context</span>)</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//调用此方法滚动到目标位置  </span><br>    public void smooth<span class="hljs-constructor">ScrollTo(<span class="hljs-params">int</span> <span class="hljs-params">fx</span>, <span class="hljs-params">int</span> <span class="hljs-params">fy</span>)</span> &#123;  <br>        <span class="hljs-built_in">int</span> dx = fx - mScroller.get<span class="hljs-constructor">FinalX()</span>;  <br>        <span class="hljs-built_in">int</span> dy = fy - mScroller.get<span class="hljs-constructor">FinalY()</span>;  <br>        smooth<span class="hljs-constructor">ScrollBy(<span class="hljs-params">dx</span>, <span class="hljs-params">dy</span>)</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//调用此方法设置滚动的相对偏移  </span><br>    public void smooth<span class="hljs-constructor">ScrollBy(<span class="hljs-params">int</span> <span class="hljs-params">dx</span>, <span class="hljs-params">int</span> <span class="hljs-params">dy</span>)</span> &#123;  <br>        <span class="hljs-comment">//设置mScroller的滚动偏移量  </span><br>        mScroller.start<span class="hljs-constructor">Scroll(<span class="hljs-params">mScroller</span>.<span class="hljs-params">getFinalX</span>()</span>, mScroller.get<span class="hljs-constructor">FinalY()</span>, dx, dy);  <br>        invalidate<span class="hljs-literal">()</span>;<span class="hljs-comment">//这里必须调用invalidate()才能保证computeScroll()会被调用，否则不一定会刷新界面，看不到滚动效果  </span><br>    &#125;  <br>      <br>    @Override  <br>    public void compute<span class="hljs-constructor">Scroll()</span> &#123;  <br>        <span class="hljs-comment">//先判断mScroller滚动是否完成  </span><br>        <span class="hljs-keyword">if</span> (mScroller.compute<span class="hljs-constructor">ScrollOffset()</span>) &#123;  <br>            <span class="hljs-comment">//这里调用View的scrollTo()完成实际的滚动  </span><br>            scroll<span class="hljs-constructor">To(<span class="hljs-params">mScroller</span>.<span class="hljs-params">getCurrX</span>()</span>, mScroller.get<span class="hljs-constructor">CurrY()</span>);  <br>              <br>            <span class="hljs-comment">//必须调用该方法，否则不一定能看到滚动效果  </span><br>            post<span class="hljs-constructor">Invalidate()</span>;  <br>        &#125;  <br>        super.compute<span class="hljs-constructor">Scroll()</span>;  <br>    &#125;  <br>&#125;  <br></code></pre></td></tr></table></figure><hr><p>android.view.VelocityTracker主要用跟踪触摸屏事件（flinging事件和其他gestures手势事件）的速率。用addMovement(MotionEvent)函数将Motion event加入到VelocityTracker类实例中.你可以使用getXVelocity() 或getXVelocity()获得横向和竖向的速率到速率时，但是使用它们之前请先调用computeCurrentVelocity(int)来初始化速率的单位 。  </p><p>示例： </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> VelocityTracker mVelocityTracker;<span class="hljs-comment">//生命变量 </span><br><span class="hljs-comment">//在onTouchEvent(MotionEvent ev)中 </span><br><span class="hljs-keyword">if</span> (mVelocityTracker<span class="hljs-operator"> == </span>null) &#123; <br>        mVelocityTracker = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">VelocityTracker</span>.</span></span>obtain<span class="hljs-literal">()</span>;<span class="hljs-comment">//获得VelocityTracker类实例 </span><br>&#125; <br>mVelocityTracker.add<span class="hljs-constructor">Movement(<span class="hljs-params">ev</span>)</span>;<span class="hljs-comment">//将事件加入到VelocityTracker类实例中 </span><br><span class="hljs-comment">//判断当ev事件是MotionEvent.ACTION_UP时：计算速率 </span><br>final VelocityTracker velocityTracker = mVelocityTracker; <br><span class="hljs-comment">// 1000 provides pixels per second </span><br>velocityTracker.compute<span class="hljs-constructor">CurrentVelocity(1, (<span class="hljs-params">float</span>)</span><span class="hljs-number">0.01</span>); <span class="hljs-comment">//设置maxVelocity值为0.1时，速率大于0.01时，显示的速率都是0.01,速率小于0.01时，显示正常 </span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>i(<span class="hljs-string">&quot;test&quot;</span>,<span class="hljs-string">&quot;velocityTraker&quot;</span>+velocityTracker.get<span class="hljs-constructor">XVelocity()</span>);                     <br>velocityTracker.compute<span class="hljs-constructor">CurrentVelocity(1000)</span>; <span class="hljs-comment">//设置units的值为1000，意思为一秒时间内运动了多少个像素 </span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>i(<span class="hljs-string">&quot;test&quot;</span>,<span class="hljs-string">&quot;velocityTraker&quot;</span>+velocityTracker.get<span class="hljs-constructor">XVelocity()</span>); <br></code></pre></td></tr></table></figure><p>大体的使用是这样的：<br>当你需要跟踪触摸屏事件的速度的时候,使用obtain()方法来获得VelocityTracker类的一个实例对象<br>在onTouchEvent回调函数中，使用addMovement(MotionEvent)函数将当前的移动事件传递给VelocityTracker对象<br>使用computeCurrentVelocity  (int units)函数来计算当前的速度，使用 getXVelocity  ()、 getYVelocity  ()函数来获得当前的速度</p>]]></content>
    
    
    <categories>
      
      <category>android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>android</tag>
      
      <tag>scroll</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
