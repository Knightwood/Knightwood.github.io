<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>idea配置java注解处理器</title>
    <link href="/2021/12/25/idea%20%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8/"/>
    <url>/2021/12/25/idea%20%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="IntelliJ-IDEA-和-Gradle：为什么每个子模块有-3-个模块？"><a href="#IntelliJ-IDEA-和-Gradle：为什么每个子模块有-3-个模块？" class="headerlink" title="IntelliJ IDEA 和 Gradle：为什么每个子模块有 3 个模块？"></a><a href="https://stackoverflow.com/questions/36372571/intellij-idea-and-gradle-why-there-are-3-modules-per-sub-module">IntelliJ IDEA 和 Gradle：为什么每个子模块有 3 个模块？</a></h1><p>如果您只想为之前导入的项目禁用此选项，您可以通过编辑位于**.idea/gradle.xml 中的** idea gradle 配置文件来实现 。</p><p>添加将<strong>resolveModulePerSourceSet</strong>设置为<strong>false 的</strong>这一行：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;4&quot;</span>&gt;</span><br>  ...<br>  <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;GradleSettings&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;linkedExternalProjectsSettings&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">GradleProjectSettings</span>&gt;</span><br>        ...<br>        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;resolveModulePerSourceSet&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span> /&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">GradleProjectSettings</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后刷新gradle项目。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>在idea+gradle的环境中使用annotation processor生成代码，但是代码生成在了build文件夹下的classes里，且程序无法引用生成的类，若强行使用则报错找不到类。</p><h2 id="第一步-配置idea"><a href="#第一步-配置idea" class="headerlink" title="第一步 配置idea"></a>第一步 配置idea</h2><p>file -&gt; settting -&gt; Build,Execution,Deployment -&gt; compiler -&gt; annotation processor 进入此界面，然后：</p><ol><li>勾上<code>启用注解处理器</code></li><li>选中<code>从项目类路径获取处理器</code></li><li>选中<code>模块项目根</code></li><li><code>生产源目录</code>输入<code>../main/src/generated/java</code></li></ol><h2 id="第二步-配置gradle"><a href="#第二步-配置gradle" class="headerlink" title="第二步 配置gradle"></a>第二步 配置gradle</h2><p>这个项目有三个module：</p><p>一个是main 测试ProcessorLib库</p><p>一个是ProcessorLib 处理注解</p><p>一个是AnnotationsLib 定义注解</p><ul><li>ProcessorLib 的gradle</li></ul><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">//使编译时将文件生成到指定目录</span><br>compileJava &#123;<br><span class="hljs-comment">//配置编译时生成代码的目录</span><br>        <span class="hljs-keyword">options</span>.compilerArgs &lt;&lt; <span class="hljs-string">&quot;-s&quot;</span><br>        <span class="hljs-keyword">options</span>.compilerArgs &lt;&lt; <span class="hljs-string">&quot;$projectDir/src/main/generated/java&quot;</span><br><span class="hljs-comment">//确保文件夹存在</span><br>        <span class="hljs-keyword">doFirst</span> &#123;<br>            <span class="hljs-keyword">file</span>(<span class="hljs-keyword">new</span> <span class="hljs-keyword">File</span>(projectDir, <span class="hljs-string">&quot;/src/main/generated/java&quot;</span>)).mkdirs()<br>        &#125;<br>    &#125;<br><span class="hljs-comment">//在clean时删除编译生成的代码</span><br>    clean.<span class="hljs-keyword">doLast</span> &#123;<br>        <span class="hljs-comment">// clean-up directory when necessary</span><br>        <span class="hljs-keyword">file</span>(<span class="hljs-keyword">new</span> <span class="hljs-keyword">File</span>(projectDir, <span class="hljs-string">&quot;/src/main/generated&quot;</span>)).deleteDir()<br>    &#125;<br><span class="hljs-comment">//依赖  </span><br><span class="hljs-keyword">dependencies</span> &#123;<br>    implementation <span class="hljs-keyword">project</span>(path: <span class="hljs-string">&#x27;:AnnotationsLib&#x27;</span>)<span class="hljs-comment">//自己的注解定义module</span><br>    implementation <span class="hljs-string">&#x27;com.google.auto.service:auto-service-annotations:1.0.1&#x27;</span><span class="hljs-comment">//autoservice</span><br>    annotationProcessor <span class="hljs-string">&#x27;com.google.auto.service:auto-service:1.0.1&#x27;</span><span class="hljs-comment">//autoservice</span><br>    implementation <span class="hljs-string">&#x27;com.squareup:javapoet:1.13.0&#x27;</span><br>    testImplementation <span class="hljs-string">&#x27;org.junit.jupiter:junit-jupiter-api:5.7.2&#x27;</span><br>    testRuntimeOnly <span class="hljs-string">&#x27;org.junit.jupiter:junit-jupiter-engine:5.7.2&#x27;</span><br>&#125;<br><br><span class="hljs-comment">//详细日志打印，没有调用处理器，可能是跳过了，直接进行编译了</span><br><span class="hljs-comment">// 参数可选，重点是 -verbose -XprintRounds -XprintProcessorInfo</span><br><span class="hljs-keyword">allprojects</span> &#123;<br>    gradle.projectsEvaluated &#123;<br>        tasks.withType(JavaCompile) &#123;<br>            <span class="hljs-keyword">options</span>.compilerArgs &lt;&lt; <span class="hljs-string">&quot;-Xlint&quot;</span> &lt;&lt; <span class="hljs-string">&quot;-verbose&quot;</span> &lt;&lt; <span class="hljs-string">&quot;-XprintRounds&quot;</span> &lt;&lt; <span class="hljs-string">&quot;-XprintProcessorInfo&quot;</span> &lt;&lt; <span class="hljs-string">&quot;-Xmaxerrs&quot;</span> &lt;&lt; <span class="hljs-string">&quot;100000&quot;</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在main module的gradle中</li></ul><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs puppet"><span class="hljs-keyword">dependencies</span> &#123;<br>    implementation <span class="hljs-literal">project</span>(<span class="hljs-built_in">path</span>: <span class="hljs-string">&#x27;:ProcessorLib&#x27;</span>)<br>    annotationProcessor <span class="hljs-literal">project</span>(<span class="hljs-built_in">path</span>: <span class="hljs-string">&#x27;:ProcessorLib&#x27;</span>)<br>    implementation <span class="hljs-literal">project</span>(<span class="hljs-built_in">path</span>: <span class="hljs-string">&#x27;:AnnotationsLib&#x27;</span>)<br>    testImplementation <span class="hljs-string">&#x27;org.junit.jupiter:junit-jupiter-api:5.7.2&#x27;</span><br>    testRuntimeOnly <span class="hljs-string">&#x27;org.junit.jupiter:junit-jupiter-engine:5.7.2&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第三步-配置文件夹类型"><a href="#第三步-配置文件夹类型" class="headerlink" title="第三步 配置文件夹类型"></a>第三步 配置文件夹类型</h2><p>在执行gradle的build任务后，会在src/main下生成指定目录以及代码，但是在我们的源文件中依然没有提示，那么我们需要指定其文件夹类型。</p><p>前面用gradle生成的目录：<code>src/main/generated/java</code></p><p>把这个目录右键，将目录标记为<code>“生成文件夹的根目录”</code>。</p><h1 id="需要注意的细节"><a href="#需要注意的细节" class="headerlink" title="需要注意的细节"></a>需要注意的细节</h1><ul><li>在编写自定义Processor可能会出现处理器不起作用的情况<br>答:其很有可能是你将Processor.class写成了Process.class</li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">//正确的写法</span><br><span class="hljs-variable">@AutoService</span>(Processor.class)<br><span class="hljs-comment">//错误的写法</span><br><span class="hljs-variable">@AutoService</span>(Process.class)<br></code></pre></td></tr></table></figure><p>即使是按照上面的步骤配置，但仍然无法引用生成的代码(删除线即当时认知错误，在第4点会讲原因)<br>答:可能是由于你生成代码的文件夹与你的源文件不在一个module中，由于idea中使用gradle创建一个module，他会识别为三个module。</p><p>两种解决方式：</p><p>1.开头部分。</p><p>2.在创建项目时取消 <code>create separate per source set</code> 。</p><ul><li>annotation processor 生成类时报异常:错误: <strong>类重复: com.cxyz.test.Test</strong><br>答:其实annotation processor只能生成额外的类，而不能在原先类的基础上做改动</li></ul><hr><p>写过自定义注解处理器的老司机们乍一看这个问题觉得挺简单，是的，因为网上基本通篇都在教你怎么打日志，但是你有没有想过如果连日志都打印不出来的时候你怎么定位呢？譬如如下代码：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 确认 META-INF/services/javax.annotation.processing.Processor 没问题</span><br><span class="hljs-comment">// 确认构建脚本没问题，确认注解 Bridge 有被使用且有参与构建</span><br><span class="hljs-meta">@AutoService</span>(Processor.class)<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestAnnotationProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractProcessor</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">TestAnnotationProcessor</span>(<span class="hljs-params"></span>)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;TestAnnotationProcessor constrator&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> synchronized <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">init</span>(<span class="hljs-params">ProcessingEnvironment processingEnvironment</span>)</span> &#123;<br>        <span class="hljs-built_in">super</span>.init(processingEnvironment);<br>        System.out.println(<span class="hljs-string">&quot;TestAnnotationProcessor init&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">Set</span>&lt;<span class="hljs-built_in">String</span>&gt; <span class="hljs-function"><span class="hljs-title">getSupportedAnnotationTypes</span>(<span class="hljs-params"></span>)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;TestAnnotationProcessor getSupportedAnnotationTypes&quot;</span>);<br>        <span class="hljs-built_in">Set</span>&lt;<span class="hljs-built_in">String</span>&gt; supported = <span class="hljs-keyword">new</span> HashSet&lt;<span class="hljs-built_in">String</span>&gt;();<br>        supported.add(Bridge.class.getCanonicalName());<br>        <span class="hljs-keyword">return</span> supported;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-function"><span class="hljs-title">process</span>(<span class="hljs-params"><span class="hljs-built_in">Set</span>&lt;? <span class="hljs-keyword">extends</span> TypeElement&gt; set, RoundEnvironment roundEnvironment</span>)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;TestAnnotationProcessor process&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行构建后compileReleaseJavaWithJavac过程中没有先吐我 Annotation Processor 的任意一行日志，直接报错找不到我注解处理器产物类引用（即直接进行了 compile class 环节）。</p><p>你懵逼吗？反正我懵逼了！打印日志不好使了，哈哈，环境确认没问题，什么鬼，直接越过 Annotation Processor 进行 compile 了。</p><p>这时候就需要你稍微深入定位分析（撸javac源码的巨佬请自行飘过），前提就是你需要熟悉下 Annotation Processor 基本原理，然后我们通过一些额外的javac详细日志进行举例分析。</p><p>Annotation Processor 机制<br>注解和注解处理器是 JDK5 引入的机制，主要用来为类、方法、字段和参数等 Java 结构提供额外的信息。譬如常见的@Override就是仅仅对 Java 编译器生效的一个注解。Java 允许我们自定义注解，自定义的注解处理器就是用来处理这些自定义注解的（废话），注解处理器触发时机是由javac来处理的，所以整个javac过程的简要步骤如下图：</p><p>![在这里插入图片描述](TyporaRaw/idea 注解处理器.assets/20210111193442602.png)</p><p>可以看到，javac编译概要图主要分为如下几步：</p><p>把源文件解析为抽象语法树。<br>调用已注册的注解处理器。<br>如果注解处理器处理过程中生成了新的源文件，编译器重复第 1、2 步，当注解处理器不再生成新的源文件则进入最后一轮。<br>进入真正的 compile 字节码环节生成字节码。<br>如上就是注解处理器的核心机制，有了这个核心机制的认识我们就继续往下探索。</p><p>构建工具下 Annotation Processor 的本质<br>我们日常开发中（无论是 Java 后端还是 Android 移动端）总是多多少少会用到 JDK 提供的annotation processor能力，无论是什么构建工具（Gradle 或者 Maven 等）本质都是通过javac -processorpath命令参数显式指定哪些 Processer，或者显式声明META-INF/services/javax.annotation.processing.Processor来被javac发现并调用的（参见 google 的 AutoService 框架）。</p><p>正常情况下我们开发中使用及构建 Annotation Processor 技术都是上面几步走的方案，而且大多数照着网络上抄的都能正常工作，每次只用自己处理 process 就挺香的，因为只要按照规则声明放置，其他的 javac都能自己完美调用。</p><p>增强 javac 过程打印暴露问题<br>要解决一开始说的 Annotation Processor 中自己加的日志都不打印场景问题，我们需要获取一些额外的信息辅助定位。由于直接使用命令行javac的方式是最原始的操作，我们构建一般采用 Gradle，而 Gradle 的本质还是调用javac，所以下面我们以 Gradle 为例来分析如何定位 Annotation Processor 问题。</p><p>下面简单粗暴点就是直接在根目录的build.gradle中给所有模块添加参数：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><br><span class="hljs-comment">// 参数可选，重点是 -verbose -XprintRounds -XprintProcessorInfo</span><br>allprojects &#123;<br>    gradle<span class="hljs-selector-class">.projectsEvaluated</span> &#123;<br>        tasks<span class="hljs-selector-class">.withType</span>(JavaCompile) &#123;<br>            options<span class="hljs-selector-class">.compilerArgs</span> &lt;&lt; <span class="hljs-string">&quot;-Xlint&quot;</span> &lt;&lt; <span class="hljs-string">&quot;-verbose&quot;</span> &lt;&lt; <span class="hljs-string">&quot;-XprintRounds&quot;</span> &lt;&lt; <span class="hljs-string">&quot;-XprintProcessorInfo&quot;</span> &lt;&lt; <span class="hljs-string">&quot;-Xmaxerrs&quot;</span> &lt;&lt; <span class="hljs-string">&quot;100000&quot;</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>你也可以仅仅在自己有注解处理器的模块中添加，与上面一样，只要加给JavaCompile的参数就行。这里的参数其实就是我们平时命令行javac是否的参数，不懂的可以去命令行执行下javac -help观摩下含义吧，如下（JDK8，不同版本 JDK 略有差异）：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">yan@yanDeMackbookPro:~$ javac -help<br>用法: javac &lt;options&gt; &lt;source files&gt;<br>其中, 可能的选项包括:<br>-g                         生成所有调试信息<br><span class="hljs-code">......</span><br><span class="hljs-code">-verbose                   输出有关编译器正在执行的操作的消息</span><br><span class="hljs-code">......</span><br>-processor &lt;class1&gt;[,&lt;class2&gt;,&lt;class3&gt;...] 要运行的注释处理程序的名称; 绕过默认的搜索进程<br>-processorpath &lt;路径&gt;        指定查找注释处理程序的位置<br>......<br></code></pre></td></tr></table></figure><p>至于脚本中其他几个在javac -help中没有的参数可以看下官方文档<a href="https://docs.oracle.com/en/java/javase/11/tools/javac.html">https://docs.oracle.com/en/java/javase/11/tools/javac.html</a> ，里面详细解释了参数含义。</p><p>添加上面参数后一定要将你的构建日志追加到一个磁盘文件中，因为日志会变得非常庞大，同时也变得很容易定位问题。</p><p>通过构建日志分析定位问题<br>执行你的构建任务，完毕后分析定位主要分为如下几个步骤，每一步都是一种场景的定位，循序渐进定位分析即可。</p><p>在你的日志中搜索你的 Processor 类名，譬如TestAnnotationProcessor.class，看到的日志会是如下。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 如果你的注解处理器在项目中是源码形式的日志<br>[loading RegularFileObject[<span class="hljs-regexp">/home/u</span>ser<span class="hljs-regexp">/yan/</span>test<span class="hljs-regexp">/target/</span>classes<span class="hljs-regexp">/cn/y</span>an<span class="hljs-regexp">/test/</span>TestAnnotationProcessor.class]]<br><br><span class="hljs-regexp">//</span> 如果你的注解处理器在项目中是依赖 jar 形式的日志<br>[loading ZipFileIndexFileObject[......<span class="hljs-regexp">/test.jar(cn/y</span>an<span class="hljs-regexp">/test/</span>TestAnnotationProcessor.class)]]<br></code></pre></td></tr></table></figure><p>分析： 如果你的日志中搜不到上面信息，说明你的注解处理器没有被添加到javac的 classpath 中。一般问题就是你的META-INF/services/javax.annotation.processing.Processor声明有问题，javac无法找到你的注解处理器。有些同学可能是通过 google 的 AutoService 来生成META-INF/services/javax.annotation.processing.Processor的，这种情况下也要自己检查是否 OK（譬如之前安卓中 AGP 有一段时间的中间过渡版本就修改了 classpath，需要手动将 compile 改成 annotationProcessor 才行）。</p><p>在你的日志中搜索Round关键字，建议直接搜Round 1:这样的格式容易点，看到的日志会是如下。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vim">Round <span class="hljs-number">1</span>:<br>        <span class="hljs-built_in">input</span> <span class="hljs-keyword">file</span><span class="hljs-variable">s:</span> &#123;<span class="hljs-keyword">cn</span>.yan.test.Application, ......, <span class="hljs-keyword">cn</span>.yan.test.UseMarkedAnnotation&#125;<br>                annotation<span class="hljs-variable">s:</span> [java.lang.Override, <span class="hljs-keyword">cn</span>.yan.annotation.Bridge]<br>                <span class="hljs-keyword">last</span> <span class="hljs-built_in">round</span>: false<br></code></pre></td></tr></table></figure><p>上面日志中的input files:部分是扫到的你的源码，annotations:部分就是扫到你代码中使用了哪些注解，如果你注解处理器声明了要处理这种注解（譬如@cn.yan.annotation.Bridge），则日志如上才是正常的。</p><p>分析： 如果你日志中没搜到上面的Round，则说明javac没有触发调用任何注解处理器（无论是你写的还是依赖三方框架的），最大的可疑点就是检查下自己有没有禁用javac注解处理器，也就是确认javac执行时没有-proc:none参数。如果你的日志中有Round，但是input files:和annotations:没有你的注解类和使用类，则说明你没有在代码中使用你注解处理器要处理的注解。</p><p>在你的日志中搜索Loaded cn.yan.test.TestAnnotationProcessor关键字，看到的日志会是如下。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">[Loaded cn.yan.test.TestAnnotationProcessor <span class="hljs-keyword">from</span> <span class="hljs-keyword">file</span>:<span class="hljs-regexp">/home/u</span>ser<span class="hljs-regexp">/yan/</span>test<span class="hljs-regexp">/target/</span>classes<span class="hljs-regexp">/cn/y</span>an<span class="hljs-regexp">/test/</span>TestAnnotationProcessor.<span class="hljs-keyword">class</span>]<br></code></pre></td></tr></table></figure><p>分析： 如果你看不到上面这行日志，说明你的注解处理器类自己没有被加载成功，为什么没有我也不知道怎么分析了，但是至少说明没加载成功，你可能需要仔细核对哪里不规范或者不合法导致的了。</p><p>上面都排查完了，如果还是找不到问题原因，不妨换个思路，去仔细检查下你参与构建的普通 java 文件，是否存在语法错误或者什么问题（譬如常量没声明等）；如果有，解决完了再试试，别问我为什么，我也没有深入研究javac这块源码，只是我遇到过，且也没有异常堆栈信息，最终发现是合并解决冲突后代码少了一个变量声明，就是单纯的越过了 Annotation Processor 过程直接进行 compile to class 流程了）。<br>这个技能有什么鸟用？<br>不瞒你说，我也算是老司机了，好些年前 Annotation Processor 就玩的很 6 了，但是最近项目升级构建和 Java8 及 androidX 支持后 merge 了下代码，然后项目中的注解处理器、dataBinding 全部都不工作了，更可气的是，这个不工作是真的很吝啬，什么错误堆栈都没有，大致如下奇葩构建日志：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">FAILURE: Build failed <span class="hljs-keyword">with</span> an <span class="hljs-keyword">exception</span>.<span class="hljs-operator"></span><br><span class="hljs-operator"></span><br><span class="hljs-operator">* </span>What went wrong:<br>Execution failed <span class="hljs-keyword">for</span> task &#x27;:test:compileReleaseJavaWithJavac&#x27;.<br><span class="hljs-comment">// 本来这里该先吐我注解处理器内部的日志，然后才继续 javac 编译，实际什么都没吐</span><br>&gt; Compilation failed; see the compiler error output <span class="hljs-keyword">for</span> details.<span class="hljs-operator"></span><br><span class="hljs-operator">* </span>Exception is:<br>org.gradle.api.tasks.TaskExecutionException: Execution failed <span class="hljs-keyword">for</span> task &#x27;:moffice:compileReleaseJavaWithJavac&#x27;.<br>at org.gradle.api.internal.tasks.execution.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ExecuteActionsTaskExecuter</span>.</span></span>lambda<span class="hljs-constructor">$executeIfValid$1(ExecuteActionsTaskExecuter.<span class="hljs-params">java</span>:200)</span><br>......<br>Caused by: org.gradle.api.internal.tasks.compile.CompilationFailedException: Compilation failed; see the compiler error output <span class="hljs-keyword">for</span> details.<br>at org.gradle.api.internal.tasks.compile.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JdkJavaCompiler</span>.</span></span>execute(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JdkJavaCompiler</span>.</span></span>java:<span class="hljs-number">57</span>)<br><br></code></pre></td></tr></table></figure><p>Gradle 构建命令已经添加了各种详细参数供查看堆栈和详细日志，但奇妙的事情就是他走到compileReleaseJavaWithJavac就直接出错了，前后没有任何错误提示（有的只是一坨 Gradle 自己的 task 调用链）。我特么大意了，我就同步了下代码，编不过就编不过啊，你倒是提示下问题啊！啥也不提示直接干到 compile class 环节了，跳过了 Annotation Processor 流程，这就很恼火了。好在按照上面方式定位修复了，哈哈。</p><hr><p><a href="https://blog.csdn.net/qq_40985294/article/details/90041296#t4">引用</a></p><p><a href="https://blog.csdn.net/yanbober/article/details/112487959">引用</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Manjaro文档</title>
    <link href="/2021/12/23/Manjaro%E6%96%87%E6%A1%A3/"/>
    <url>/2021/12/23/Manjaro%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="更换国内源（可以在软件商店设置里修改）"><a href="#更换国内源（可以在软件商店设置里修改）" class="headerlink" title="更换国内源（可以在软件商店设置里修改）"></a>更换国内源（可以在软件商店设置里修改）</h1><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">sudo pacman-mirrors -<span class="hljs-selector-tag">i</span> -c China -m rank<br></code></pre></td></tr></table></figure><h1 id="fcitx5"><a href="#fcitx5" class="headerlink" title="fcitx5"></a>fcitx5</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> pacman -S fcitx<span class="hljs-number">5</span>-im fcitx<span class="hljs-number">5</span>-chinese-addons<br></code></pre></td></tr></table></figure><ul><li><p>其他一些软件包</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">fcitx5:</span> <span class="hljs-string">输入法基础框架主程序</span><br>   <span class="hljs-attr">fcitx5-chinese-addons:</span> <span class="hljs-string">简体中文输入的支持，云拼音</span><br>   <span class="hljs-attr">fcitx5-gtk:</span> <span class="hljs-string">GTK程序的支持</span><br>   <span class="hljs-attr">fcitx5-qt:</span> <span class="hljs-string">QT5程序的支持</span><br>   <span class="hljs-attr">fcitx5-pinyin-zhwiki:</span> <span class="hljs-string">肥猫制作的维基百万词库，没有版权风险,</span> <span class="hljs-string">放心使用</span><br>   <span class="hljs-attr">fcitx5-configtool:</span> <span class="hljs-string">图形化配置工具</span><br>   <span class="hljs-attr">kcm-fcitx5:</span> <span class="hljs-string">KDE桌面环境的支持</span><br></code></pre></td></tr></table></figure></li></ul><p>打开系统设置在 设置–区域设置—输入法—添加输入法—拼音—配置—-在程序中显示与编辑文本——启用云拼音 返回 配置附加组件 Classic User Interface 选择主题</p><p>配置fcitx5的环境变量：</p><p> <strong>不要在 fcitx 运行时修改, 因为进程退出后会覆写所有配置文件 (大字才能醒目)</strong></p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">nano ~<span class="hljs-string">/.pam_environment</span><br></code></pre></td></tr></table></figure><p>写入以下内容（内容来自manjaro的wiki）</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">GTK_IM_MODULE <span class="hljs-attribute">DEFAULT</span>=fcitx<br>QT_IM_MODULE  <span class="hljs-attribute">DEFAULT</span>=fcitx<br>XMODIFIERS    <span class="hljs-attribute">DEFAULT</span>=\@im=fcitx<br>SDL_IM_MODULE <span class="hljs-attribute">DEFAULT</span>=fcitx<br>最后那行 SDL_IM_MODULE 是为了让一些使用特定版本 SDL2 库的游戏，比如 Dota2 能正常使用输入法。 <br></code></pre></td></tr></table></figure><p>使用wps的用户还需要编辑~/.xprofile添加以下内容（在新版中bug被修复了，但是如果有问题的话，可以尝试此方法）</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">QT_IM_MODULE</span>=fcitx5<br></code></pre></td></tr></table></figure><p>自启动<br>在设置的开机里设置fcitx5自启动</p><p>输入法的默认设置：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dos">Ctrl + Space 激活输入法<br>左<span class="hljs-built_in">Shift</span> 临时切换到英文<br>Ctrl + <span class="hljs-built_in">Shift</span> 输入法间切换<br>-/= 向前/向后翻页<br><span class="hljs-built_in">Shift</span> + Space 全角、半角切换<br></code></pre></td></tr></table></figure><h2 id="全自动配置"><a href="#全自动配置" class="headerlink" title="全自动配置"></a>全自动配置</h2><p>manjaro的源里的<code>manjaro-asian-input-support</code></p><h2 id="fcitx5主题文件"><a href="#fcitx5主题文件" class="headerlink" title="fcitx5主题文件"></a>fcitx5主题文件</h2><h3 id="fcitx5-material-color-主题"><a href="#fcitx5-material-color-主题" class="headerlink" title="fcitx5-material-color 主题"></a>fcitx5-material-color 主题</h3><ul><li>安装</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">yay</span> -S fcitx<span class="hljs-number">5</span>-material-color<br></code></pre></td></tr></table></figure><p>然后修改配置文件 ~/.config/fcitx5/conf/classicui.conf</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 横向候选列表</span><br>Vertical Candidate <span class="hljs-attribute">List</span>=<span class="hljs-literal">False</span><br><br><span class="hljs-comment"># 禁止字体随着DPI缩放，避免界面太大</span><br><span class="hljs-attribute">PerScreenDPI</span>=<span class="hljs-literal">False</span><br><br><span class="hljs-comment"># 字体和大小，可以用 fc-list 命令来查看使用</span><br><span class="hljs-attribute">Font</span>=<span class="hljs-string">&quot;Noto Sans Mono 13&quot;</span><br><br><span class="hljs-comment"># 默认蓝色主题</span><br><span class="hljs-attribute">Theme</span>=Material-Color-Blue<br></code></pre></td></tr></table></figure><h1 id="pacman常用命令"><a href="#pacman常用命令" class="headerlink" title="pacman常用命令"></a>pacman常用命令</h1><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs applescript">pacman -Ss <span class="hljs-built_in">string</span>             <span class="hljs-comment"># 在包数据库中查询软件</span><br>pacman -S package_name        <span class="hljs-comment"># 安装软件</span><br><br>pacman -S extra/package_name  <span class="hljs-comment"># 安装不同仓库中的版本</span><br>pacman -Syu                   <span class="hljs-comment"># 升级整个系统，y是更新数据库，yy是强制更新，u是升级软件</span><br>pacman -Si package_name       <span class="hljs-comment"># 显示软件的详细信息</span><br>pacman -Sc                    <span class="hljs-comment"># 清除软件缓存，即/var/cache/pacman/pkg目录下的文件</span><br>pacman -R package_name        <span class="hljs-comment"># 删除单个软件</span><br>pacman -Rs package_name       <span class="hljs-comment"># 删除指定软件及其没有被其他已安装软件使用的依赖关系</span><br>pacman -Qs <span class="hljs-built_in">string</span>             <span class="hljs-comment"># 查询已安装的软件包</span><br>pacman -Qi package_name       <span class="hljs-comment"># 查询本地安装包的详细信息</span><br>pacman -Ql package_name       <span class="hljs-comment"># 获取已安装软件所包含的文件的列表</span><br>pacman -U package.tar.zx      <span class="hljs-comment"># 从本地文件安装</span><br>pactree package_name          <span class="hljs-comment"># 显示软件的依赖树</span><br></code></pre></td></tr></table></figure><h1 id="manjaro的pamac命令"><a href="#manjaro的pamac命令" class="headerlink" title="manjaro的pamac命令"></a>manjaro的pamac命令</h1><p>他是软件商店的命令版本，也是manjaro自己的包管理命令。类似于ubuntu的apt命令。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs applescript">pamac search <span class="hljs-built_in">name</span> <span class="hljs-comment">#搜索</span><br>pamac info <span class="hljs-built_in">name</span>  <span class="hljs-comment">#详细信息</span><br>pamac install <span class="hljs-built_in">name</span> <span class="hljs-comment">#安装软件</span><br>pamac remove <span class="hljs-built_in">name</span> <span class="hljs-comment">#卸载软件</span><br>pamac checkupdates <span class="hljs-comment">#检查更新</span><br>pamac upgrade <span class="hljs-comment">#安装更新</span><br></code></pre></td></tr></table></figure><h1 id="安装字体（废弃）"><a href="#安装字体（废弃）" class="headerlink" title="安装字体（废弃）"></a>安装字体（废弃）</h1><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gauss">sudo pacman -S ttf-roboto noto-<span class="hljs-built_in">fonts</span> ttf-dejavu<br>文泉驿<br>sudo pacman -S wqy-bitmapfont wqy-microhei wqy-microhei-lite wqy-zenhei <br>思源字体<br>sudo pacman -S noto-<span class="hljs-built_in">fonts</span>-cjk adobe-source-han-sans-cn-<span class="hljs-built_in">fonts</span> adobe-source-han-serif-cn-<span class="hljs-built_in">fonts</span><br></code></pre></td></tr></table></figure><h1 id="修改火狐滚轮速度"><a href="#修改火狐滚轮速度" class="headerlink" title="修改火狐滚轮速度"></a>修改火狐滚轮速度</h1><ul><li><p>输入在火狐浏览器地址栏输入</p><p>about:config<br>搜索mousewheel<br>其中<code> mousewheel.defalut.delta_multiplier_y</code>越大，每次滚动一下<br>滚轮，屏幕就滑动地越大。<br>除此之外，推测<code>durationMaxMs和durationMinMs</code>参数是<br>完成滚动的时间间隔，以毫秒计算，数值越小，单次滚动越快。factor<br>和鼠标滚轮滚动时，屏幕滚动的加速度有关。</p></li></ul><h1 id="设置界面缩放"><a href="#设置界面缩放" class="headerlink" title="设置界面缩放"></a>设置界面缩放</h1><pre><code>高分屏缩放，比如netease-cloud-music软件：可以通过 env QT_SCREEN_SCALE_FACTORS=1.25 netease-cloud-music 启动来解决,也就是在启动文件里添加。</code></pre><h1 id="设置快捷键启动的方式："><a href="#设置快捷键启动的方式：" class="headerlink" title="设置快捷键启动的方式："></a>设置快捷键启动的方式：</h1><p>设置 -&gt; 快捷键 -&gt; 自定义快捷键 -&gt; 编辑 -&gt; 新建 -&gt; 全局快捷键 -&gt; 命令/URL</p><p>设置触发器：设置为你习惯的快捷键 -&gt; 动作：命令/URL这填：/usr/bin/flameshot gui</p><h1 id="网络启停"><a href="#网络启停" class="headerlink" title="网络启停"></a>网络启停</h1><p>开机后显示wifi不可用，鼠标放在网络图标上显示<code>Networkmanager未运行</code>，解决方法是在终端执行以下命令</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">systemctl restart <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">NetworkManager</span>.</span></span>service<br>systemctl enable <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">NetworkManager</span>.</span></span>service<br></code></pre></td></tr></table></figure><hr><h1 id="ZSH"><a href="#ZSH" class="headerlink" title="ZSH"></a>ZSH</h1><ul><li><strong>替换shell</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">yay -Sy zsh  #安装zsh  manjaro现在默认就已经安装了zsh<br>chsh -l  #列出现在安装的shell<br>chsh -s /bin/zsh # 设置zsh为默认  重启生效<br></code></pre></td></tr></table></figure><ul><li><strong>备注</strong>： <strong>manjaro已经内置zsh,直接在kde设置里修改即可，ohmyzsh在manjaro也内置了，所以如果自己想折腾，可以直接去github把ohmyzsh克隆到任意位置使用。</strong></li></ul><h2 id="PART-1-→-oh-my-zsh"><a href="#PART-1-→-oh-my-zsh" class="headerlink" title="PART 1 → oh-my-zsh"></a>PART 1 → oh-my-zsh</h2><p>默认的 Zsh 配置有点麻烦。因此一个叫 robbyrussel 的用户在 GitHub 上制作了一个配置文件 oh-my-zsh，这是目前为止最流行的 Zsh 配置：</p><p><a href="https://link.zhihu.com/?target=https://github.com/robbyrussell/oh-my-zsh">oh-my-zsh 项目地址（不要吝啬你的 Star）</a></p><p>如果你不想看官方的安装说明，请看这里：</p><p><strong>第一步 → 把 oh-my-zsh 项目 Clone 下来：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh<br></code></pre></td></tr></table></figure><p><strong>第二步 → 复制 .zshrc</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc<br></code></pre></td></tr></table></figure><p><strong>第三步 → 更改你的默认 Shell</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">chsh -s /bin/zsh<br></code></pre></td></tr></table></figure><p>现在，你会看到你的命令提示符变了：</p><p>前往 <a href="https://link.zhihu.com/?target=https://github.com/robbyrussell/oh-my-zsh/wiki/Themes">oh-my-zsh 的 Wiki</a> 就可以看到大多数 oh-my-zsh 的内置主题以及它们的截图。如果你看中的其中的一款，可以重复上面的步骤，编辑~/.zshrc，并更改ZSH_THEME=”xxx”。</p><p>比如你看中了 ys 主题（我的最爱），你可以把 ZSH_THEME 改成 “ys”，然后回到终端，执行 source ~/.zshrc 命令。</p><p>P.S. 这些主题都保存在 “~/.oh-my-zsh/themes” 目录中</p><ul><li><h1 id="powerlevel10k主题"><a href="#powerlevel10k主题" class="headerlink" title="powerlevel10k主题"></a>powerlevel10k主题</h1><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-number">1</span>. 安装 <br>git clone --depth=<span class="hljs-number">1</span> https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/romkatv/</span>powerlevel10k.git <span class="hljs-variable">$&#123;ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom&#125;</span><span class="hljs-regexp">/themes/</span>powerlevel10k<br><span class="hljs-number">2</span>. 傻瓜式配置 终端中输入 p10k configure<br></code></pre></td></tr></table></figure><ul><li>安装完 powerlevel10k 后你可能会发现有乱码，这是因为你终端字体不支持那么多的字符，这就需要使用扩展字体了。</li></ul></li></ul><h2 id="PART-3-→-插件"><a href="#PART-3-→-插件" class="headerlink" title="PART 3 → 插件"></a>PART 3 → 插件</h2><pre><code>oh-my-zsh 的自带插件都储存在 &quot;~/.oh-my-zsh/plugins&quot; 目录中，如果你希望安装一个插件，可以在 &quot;~/.zshrc&quot; 的 plugins=(xxx, xxx, ...) 这一行里加入插件名称如果你需要安装第三方插件和主题，你可以在 &quot;~/.zshrc&quot; 的某一行（比如末尾）加入 source /path/to/plugin比如你希望添加一个 zsh-syntax-highlighting 插件 ↓</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> ~/.zsh-syntax-highlighting/zsh-syntax-highlighting.zsh<br><span class="hljs-comment"># 这里要根据你自己的输入目录，而不是抄我的，否则然并卵</span><br></code></pre></td></tr></table></figure><p>​    kde主题文件位置</p><p>要么在根目录的usr目录下，要么就在home的.config目录下。</p><p>要删除主题，先把当前使用的主题换成默认的主题，然后根据下面的目录删除即可。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs awk">  AURORAE_DIR=<span class="hljs-string">&quot;/usr/share/aurorae/themes&quot;</span><br>  SCHEMES_DIR=<span class="hljs-string">&quot;/usr/share/color-schemes&quot;</span><br>  PLASMA_DIR=<span class="hljs-string">&quot;/usr/share/plasma/desktoptheme&quot;</span><br>  LOOKFEEL_DIR=<span class="hljs-string">&quot;/usr/share/plasma/look-and-feel&quot;</span><br>  KVANTUM_DIR=<span class="hljs-string">&quot;/usr/share/Kvantum&quot;</span><br>  WALLPAPER_DIR=<span class="hljs-string">&quot;/usr/share/wallpapers&quot;</span><br>或者<br>  AURORAE_DIR=<span class="hljs-string">&quot;$HOME/.local/share/aurorae/themes&quot;</span><br>  SCHEMES_DIR=<span class="hljs-string">&quot;$HOME/.local/share/color-schemes&quot;</span><br>  PLASMA_DIR=<span class="hljs-string">&quot;$HOME/.local/share/plasma/desktoptheme&quot;</span><br>  LOOKFEEL_DIR=<span class="hljs-string">&quot;$HOME/.local/share/plasma/look-and-feel&quot;</span><br>  KVANTUM_DIR=<span class="hljs-string">&quot;$HOME/.config/Kvantum&quot;</span><br>  WALLPAPER_DIR=<span class="hljs-string">&quot;$HOME/.local/share/wallpapers&quot;</span> <br><br>注：<br><span class="hljs-regexp">/home/</span>hzt<span class="hljs-regexp">/.local/</span>share<span class="hljs-regexp">/plasma/</span>desktoptheme 这是存放plasma主题<br><span class="hljs-regexp">/home/</span>hzt<span class="hljs-regexp">/.local/</span>share<span class="hljs-regexp">/plasma/</span>look-and-feel/ 存放全局主题<br><span class="hljs-regexp">/home/</span>hzt<span class="hljs-regexp">/.local/</span>share<span class="hljs-regexp">/plasma/</span>plasmoids/ 存放插件<br><span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/sddm/</span> sddm主题位置<br></code></pre></td></tr></table></figure><hr><h2 id="重启桌面"><a href="#重启桌面" class="headerlink" title="重启桌面"></a>重启桌面</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">kquitapp5 plasmashell    <span class="hljs-comment"># 退出kde桌面</span><br>kstart5 plasmashell<br></code></pre></td></tr></table></figure><h1 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h1><h2 id="错误：-Cannot-find-the-fakeroot-binary-gt-错误：-Cannot-find-the-strip-binary"><a href="#错误：-Cannot-find-the-fakeroot-binary-gt-错误：-Cannot-find-the-strip-binary" class="headerlink" title="错误： Cannot find the fakeroot binary. ==&gt; 错误： Cannot find the strip binary"></a>错误： Cannot find the fakeroot binary. ==&gt; 错误： Cannot find the strip binary</h2><p>解决方法：因为没安装 fakeroot、binutils 等打包基本工具，所以<code>sudo pacman -S --needed base-devel</code> 装一下。</p><hr><h2 id="使用数位板"><a href="#使用数位板" class="headerlink" title="使用数位板"></a>使用数位板</h2><p>1.查看系统信息中的内核版本，根据内核版本安装linux-header</p><p>2.安装aur源中的驱动：yay -S digimend-drivers-git-dkms  </p><hr><h2 id="关闭watchdog"><a href="#关闭watchdog" class="headerlink" title="关闭watchdog"></a>关闭watchdog</h2><p>根据 <a href="https://en.wikipedia.org/wiki/Watchdog_timer">维基百科：看门狗定时器 </a>： </p><p>由于系统的关键任务（即服务器）或缺少电源重置（即嵌入式设备），许多用户需要此功能。  因此，在某些情况下，此功能是良好操作所必需的。  另一方面，普通用户（例如台式机和笔记本电脑）不需要此功能，可以将其禁用。 </p><p>要禁用看门狗定时器（包括软件和硬件），请附加  <code>nowatchdog</code> 到您的启动参数。 </p><p>要检查新配置，请执行以下操作： </p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"># cat <span class="hljs-regexp">/proc/</span>sys<span class="hljs-regexp">/kernel/</span>watchdog<br></code></pre></td></tr></table></figure><p>或使用： </p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># wdctl</span><br></code></pre></td></tr></table></figure><ul><li><p>附加启动参数到grub</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs gradle">如果要禁用watchdog，需要在内核启动选项里面添加一个参数：<br><br>nowatchdog<br><br>添加的方法是修改 <span class="hljs-regexp">/etc/</span><span class="hljs-keyword">default</span>/grub 文件加上这个参数（用什么编辑器都可以，只要有root权限修改）<br><br>sudo nano <span class="hljs-regexp">/etc/</span><span class="hljs-keyword">default</span>/grub<br><br>找到其中包含 GRUB_CMDLINE_LINUX_DEFAULT 的一行，等号后面的字符串里面加个空格，加上nowatchdog就行了，比如：<br><br>本来是<br><br>GRUB_CMDLINE_LINUX_DEFAULT=<span class="hljs-string">&quot;quiet splash foo=bar&quot;</span><br><br>改成<br><br>GRUB_CMDLINE_LINUX_DEFAULT=<span class="hljs-string">&quot;quiet splash foo=bar nowatchdog&quot;</span><br><br>修改完毕之后<br>在终端中调用 update-grub<br><br></code></pre></td></tr></table></figure></li></ul><p>禁用看门狗后，您也可以 <em>选择</em> 避免加载负责硬件看门狗的模块。 通过 <a href="https://wiki.archlinux.org/index.php/Blacklisting">列入黑名单 </a>将相关模块 ，例如 <code>iTCO_wdt</code>. </p><p><strong>注意：</strong> 一些用户 <a href="https://bbs.archlinux.org/viewtopic.php?id=221239">报告 </a>了 <code>nowatchdog</code> 参数不能按预期工作，但是他们已通过将上述模块列入黑名单而成功禁用了看门狗（至少是硬件之一）。 </p><p>这两种操作都会加快启动和关闭的速度，因为只加载了一个模块。 另外，禁用看门狗定时器可以提高性能并 <a href="https://wiki.archlinux.org/index.php/Power_management#Disabling_NMI_watchdog">降低功耗 </a>。 </p><p>有关 请参见 [<a href="https://bbs.archlinux.org/viewtopic.php?id=163768">3] </a>， ， [<a href="https://bbs.archlinux.org/viewtopic.php?id=165834">4] </a>， [<a href="http://0pointer.de/blog/projects/watchdog.html">5] </a>和 [<a href="https://www.kernel.org/doc/html/latest/watchdog/watchdog-parameters.html">6] </a>更多信息 。 </p><h3 id="将硬件列入黑名单"><a href="#将硬件列入黑名单" class="headerlink" title="将硬件列入黑名单"></a>将硬件列入黑名单</h3><p>在内核模块的上下文中，黑名单是一种防止内核模块加载的机制。  例如，如果不需要关联的硬件，或者如果加载该模块会导致问题，这可能会很有用：例如，可能有两个内核模块试图控制同一硬件，然后将它们一起加载会导致冲突。 </p><p>有些模块作为 <a href="https://wiki.archlinux.org/index.php/Initramfs">initramfs</a> 的一部分装入。</p><p><code>mkinitcpio -M</code> 会显示所有自动检测到到模块：要阻止 initramfs 装入某些模块，可以在 <code>/etc/modprobe.d</code>中将它们加入黑名单。并应在映像生成过程中通过<code>modconf</code>挂钩将其添加。 </p><p>运行 <code>mkinitcpio -v</code> 会显示各种钩子(例如 filesystem 钩子, SCSI 钩子等)装入的模块。如果您的<code>HOOKS</code> 数组中没有 <code>modconf</code> 钩子（例如，和默认配置不同）则请将该”.conf”文件添加到<code>/etc/mkinitcpio.conf</code>中的FILES数组中。一旦您将其列入黑名单，请重新生成 <a href="https://wiki.archlinux.org/index.php/Initramfs">initramfs</a>，然后重新启动。 </p><h4 id="使用-etc-modprobe-d-中的文件"><a href="#使用-etc-modprobe-d-中的文件" class="headerlink" title="使用/etc/modprobe.d/中的文件"></a>使用/etc/modprobe.d/中的文件</h4><p>在 <code>/etc/modprobe.d/</code> 中创建 <code>.conf</code> 文件，使用 <code>blacklist</code> 关键字屏蔽不需要的模块，例如如果不想装入 <code>pcspkr</code> 模块：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/etc/m</span>odprobe.d/nobeep.conf<br><span class="hljs-comment"># Do not load the &#x27;pcspkr&#x27; module on boot.</span><br>blacklist pcspkr<br></code></pre></td></tr></table></figure><p><strong>注：</strong> 该 <code>blacklist</code> 该命令会将一个模块列入黑名单，因此不会自动加载该模块，但是如果另一个未列入黑名单的模块依赖该模块或手动加载该模块，则可能会加载该模块。 </p><p>要避免这个行为，可以让 modprobe 使用自定义的 <code>install</code> 命令，而不是像往常一样将模块插入内核，因此您可以通过以下方式强制模块始终无法加载：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-regexp">/etc/m</span>odprobe.d/blacklist.conf<br>...<br>install MODULE <span class="hljs-regexp">/bin/</span><span class="hljs-keyword">true</span><br>...<br></code></pre></td></tr></table></figure><p>这样就可以 “屏蔽” 模块及所有依赖它的模块。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">也就是在<span class="hljs-regexp">/etc/m</span>odprobe.d我创建watchdog.conf文件，写入下面两行<br>blacklist iTCO_wdt <br>blacklist iTCO_vendor_support<br></code></pre></td></tr></table></figure><h2 id="停用-watchdog"><a href="#停用-watchdog" class="headerlink" title="停用 watchdog"></a>停用 watchdog</h2><p>关机时提示：watchdog: watchdog0: watchdog did not stop! 在台式机和笔记本上安装 Manjaro 时可以停用 watchdog 模块<br><a href="https://wiki.archlinux.org/index.php/Improving_performance#Watchdogs">提高性能#Watchdogs </a></p><blockquote><p>许多用户由于其系统的关键任务角色（即服务器）或缺乏电源重置（即嵌入式设备）而需要此功能。  因此，在某些情况下，良好的操作需要此功能。  另一方面，普通用户（即台式机和笔记本电脑）不需要此功能，可以禁用它。 </p></blockquote><p>按照 archlinux wiki 上的方法，在启动参数中添加  <code>nowatchdog</code> 不能停用 watchdog </p><blockquote><p>注意：一些用户报告 nowatchdog 参数没有按预期工作，但他们通过将上述模块列入黑名单，成功禁用了看门狗（至少是硬件）。 </p></blockquote><p>另一种方法是在内核启动参数中添加  <code>modprobe.blacklist=iTCO_wdt</code> 来禁用  <code>watchdog</code> 模块。<br>编辑  <code>/etc/default/grub</code> 在  <code>GRUB_CMDLINE_LINUX_DEFAULT</code> 后添加  <code>modprobe.blacklist=iTCO_wdt</code> 保存退出后执行  <code>sudo update-grub</code> 来应用配置。   </p><blockquote><p>编辑 <code>/etc/default/grub</code>并附加 <code>modprobe.blacklist=iTCO_wdt</code>到 <code>GRUB_CMDLINE_LINUX_DEFAULT</code>线 </p></blockquote><p><a href="https://wiki.archlinux.org/index.php/Kernel_parameters#GRUB">内核参数#GRUB </a><br><a href="https://bbs.archlinux.org/viewtopic.php?id=221239">静音关机。  看门狗：看门狗0：看门狗没有停止！ </a></p><h2 id="开关机显示-dev-nvme0n1p5-clean-…-files-…blocks"><a href="#开关机显示-dev-nvme0n1p5-clean-…-files-…blocks" class="headerlink" title="开关机显示/dev/nvme0n1p5: clean, … files, …blocks"></a>开关机显示/dev/nvme0n1p5: clean, … files, …blocks</h2><p>1.在论坛里有提及这个问题</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">这两条命令显示一些日志信息<br><span class="hljs-keyword">journalctl </span>-<span class="hljs-keyword">b </span>-g nvme0n1p <br><span class="hljs-keyword">journalctl </span>-<span class="hljs-keyword">b </span>-u <span class="hljs-string">&#x27;systemd-fsck*&#x27;</span><br></code></pre></td></tr></table></figure><p>2.实际上根据</p><p>得到结论：系统在检查硬盘有没有问题，显示<code>/dev/nvme0n1p5: clean</code>就表示没有问题，所以没必要理会这条信息</p><h2 id="调整swap分区使用率"><a href="#调整swap分区使用率" class="headerlink" title="调整swap分区使用率"></a>调整swap分区使用率</h2><p>在内核版本为5.8之前，swappiness范围在0-100，内核大于5.8，范围是0-200。</p><p>总的说来，swappiness值越小，越尽可能的使用内存而不是交换分区。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sysctl</span> -q vm.swappiness 显示当前设置<br><span class="hljs-attribute">sudo</span> sysctl -w vm.swappiness=<span class="hljs-number">10</span> 临时设置为<span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>To set the swappiness value permanently, create a <a href="https://man.archlinux.org/man/sysctl.d.5">sysctl.d(5)</a> configuration file. For example:</p><p>永久的调整该设置，创建下面的配置文件</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/etc/</span>sysctl.d/<span class="hljs-number">99</span>-swappiness.conf<br>vm.swappiness=<span class="hljs-number">10</span>                              <br></code></pre></td></tr></table></figure><h2 id="failed-to-start-pkgfile-database-update"><a href="#failed-to-start-pkgfile-database-update" class="headerlink" title="failed to start pkgfile database update"></a>failed to start pkgfile database update</h2><p>查看<code>pkgfile-update.service</code>和<code>pkgfile-update.timer</code>，我猜测这个任务会每天相隔6小时执行，开机和关机时会因为错过任务而补偿执行，但是开机和关机时没有网络，所以执行失败。在系统设置面板的systemed里找到并修改<code>pkgfile-update.timer</code>，修改为开机后15分钟执行，相隔1天重复执行，就不会看到错误信息了。<br> 这是修改后的<code>pkgfile-update.timer</code>文件。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Unit]</span><br><span class="hljs-attr">Description</span>=pkgfile database update timer<br><br><span class="hljs-section">[Timer]</span><br><span class="hljs-attr">OnBootSec</span>=<span class="hljs-number">15</span>min<br><span class="hljs-attr">OnUnitActiveSec</span>=<span class="hljs-number">1</span>d<br><span class="hljs-attr">Persistent</span>=<span class="hljs-literal">no</span><br><br><span class="hljs-section">[Install]</span><br><span class="hljs-attr">WantedBy</span>=multi-user.target<br></code></pre></td></tr></table></figure><h2 id="软件源里没有grub-customer"><a href="#软件源里没有grub-customer" class="headerlink" title="软件源里没有grub-customer"></a>软件源里没有grub-customer</h2><p>去官网下载</p><h1 id="释放内存"><a href="#释放内存" class="headerlink" title="释放内存"></a>释放内存</h1><p>Kernels 2.6.16  and newer provide a mechanism to have the kernel drop the page cache  and/or inode and dentry caches on command, which can help free up a lot  of memory.  Now you can throw away that script that allocated a ton of  memory just to get rid of the cache… </p><p>To use <code>/proc/sys/vm/drop_caches</code>, just echo a number to it. </p><p>To free pagecache: </p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"># echo <span class="hljs-number">1</span> &gt; <span class="hljs-regexp">/proc/</span>sys<span class="hljs-regexp">/vm/</span>drop_caches<br></code></pre></td></tr></table></figure><p>To free dentries and inodes: </p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"># echo <span class="hljs-number">2</span> &gt; <span class="hljs-regexp">/proc/</span>sys<span class="hljs-regexp">/vm/</span>drop_caches<br></code></pre></td></tr></table></figure><p>To free pagecache, dentries and inodes: </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">echo <span class="hljs-number">3</span> &gt; <span class="hljs-regexp">/proc/</span>sys<span class="hljs-regexp">/vm/</span>drop_caches<br>echo <span class="hljs-number">3</span> | sudo tee <span class="hljs-regexp">/proc/</span>sys<span class="hljs-regexp">/vm/</span>drop_caches <span class="hljs-regexp">//</span>与上面一个作用<br></code></pre></td></tr></table></figure><p>This is a non-destructive operation and will only free things that are  completely unused.  Dirty objects will continue to be in use until  written out to disk and are not freeable.  If you run “sync” first to  flush them out to disk, these drop operations will tend to free more  memory. </p><h1 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a>日志管理</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo journalctl --disk-usage                #查看日志大小<br>sudo journalctl --vacuum-time=5d                  #超过5天的自动删除<br>sudo journalctl --vacuum-size=500M                #超过500M的自动删除<br>sudo rm /var/lib/systemd/coredump/*             #崩溃日志，文件不多，也不大，删不删随你<br></code></pre></td></tr></table></figure><h2 id="清空-var-log-journal-文件的方法"><a href="#清空-var-log-journal-文件的方法" class="headerlink" title="清空 /var/log/journal 文件的方法"></a>清空 /var/log/journal 文件的方法</h2><p>1、用echo命令，将空字符串内容重定向到指定文件中</p><p>echo “” &gt; system.journal</p><p>说明：此方法只会清空一次，一段时间后还要再次手动清空很麻烦，这里可以用以下命令让journalctl 自动维护空间</p><p>2、journalctl 命令自动维护文件大小</p><p>1）只保留近一周的日志</p><p>journalctl –vacuum-time=1w</p><p>2）只保留500MB的日志</p><p>journalctl –vacuum-size=500M</p><p>3）直接删除 <strong>/var/log/journal/</strong> 目录下的日志文件</p><p>rm -rf /var/log/journal/f9d400c5e1e8c3a8209e990d887d4ac1</p><h2 id="问题与分析解决"><a href="#问题与分析解决" class="headerlink" title="问题与分析解决"></a>问题与分析解决</h2><p>执行 journalctl 命令时报错：Error was encountered while opening journal files: Input/output error</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># journalctl --vacuum-time=1w<br><span class="hljs-built_in">Error</span> was encountered <span class="hljs-keyword">while</span> opening journal files: Input/output error<br></code></pre></td></tr></table></figure><p>问题分析：日志文件损坏</p><p>解决方法：删除之前的日志，并重启 journalctl 服务</p><p>mv journal/f9d400c5e1e8c3a8209e990d887d4ac1 journal/f9d400c5e1e8c3a8209e990d887d4ac1_bk_20190122</p><p>systemctl restart systemd-journald.service</p><p>查看 /var/log/journal/ 日志目录如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">#ll /<span class="hljs-keyword">var</span>/log/journal/<br>drwxr-sr-x  <span class="hljs-number">2</span> root systemd-journal  <span class="hljs-number">4096</span> Jan <span class="hljs-number">22</span> <span class="hljs-number">11</span>:<span class="hljs-number">26</span> f9d400c5e1e8c3a8209e990d887d4ac1<br>drwxr-sr-x+ <span class="hljs-number">2</span> root systemd-journal <span class="hljs-number">12288</span> Jan <span class="hljs-number">14</span> <span class="hljs-number">15</span>:<span class="hljs-number">37</span> f9d400c5e1e8c3a8209e990d887d4ac1_bk_20190122<br></code></pre></td></tr></table></figure><p>然后，再执行 journalctl 限制日志的命令：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># journalctl --vacuum-time=1w<br>Vacuuming done, freed 0B <span class="hljs-keyword">of</span> archived journals on disk.<br># journalctl --vacuum-size=500M<br>Vacuuming done, freed 0B <span class="hljs-keyword">of</span> archived journals on disk.<br></code></pre></td></tr></table></figure><h1 id="plasmashell"><a href="#plasmashell" class="headerlink" title="plasmashell"></a>plasmashell</h1><p><strong>可以直接在<code>krunner</code>中运行按 <code>alt+F2 </code>打开<code> krunner</code>。</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># kde4</span><br>killall plasmashell &amp;&amp; kstart plasmashell<br>kquitapp5 plasmashell &amp;&amp; kstart plasmashell<br><span class="hljs-comment"># kde5</span><br>killall plasmashell &amp;&amp; kstart5 plasmashell<br>kquitapp5 plasmashell &amp;&amp; kstart5 plasmashell<br></code></pre></td></tr></table></figure><h2 id="重启plasmashell脚本"><a href="#重启plasmashell脚本" class="headerlink" title="重启plasmashell脚本"></a>重启plasmashell脚本</h2><h3 id="脚本文件内容"><a href="#脚本文件内容" class="headerlink" title="脚本文件内容"></a>脚本文件内容</h3><p>具体内容：</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs d">#bash<br><br><span class="hljs-meta">#! /bin/bash</span><br>kquitapp5 plasmashell &amp;&amp; kstart5 plasmashell<br></code></pre></td></tr></table></figure><ul><li>命名：restart_kde，注意，没有后缀名</li></ul><hr><h1 id="脚本放进环境变量（以上面kde-restart为例）"><a href="#脚本放进环境变量（以上面kde-restart为例）" class="headerlink" title="脚本放进环境变量（以上面kde_restart为例）"></a>脚本放进环境变量（以上面kde_restart为例）</h1><h2 id="赋权"><a href="#赋权" class="headerlink" title="赋权"></a>赋权</h2><p>使用文本工具或者<code>vim</code>进行编写，编写完成后对其进行运行权限的赋权：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">sudo chmod +<span class="hljs-keyword">x</span> restart_kde<br></code></pre></td></tr></table></figure><h2 id="复制至bin文件夹"><a href="#复制至bin文件夹" class="headerlink" title="复制至bin文件夹"></a>复制至bin文件夹</h2><p>将脚本文件移至<code>path</code>中指定的系统变量路径，可放至<code>/usr/local/sbin</code>、<code>/usr/local/bin</code>，<code>/usr/bin</code>中。</p><p>移动命令：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo cp restart_kde <span class="hljs-regexp">/usr/</span>bin<br></code></pre></td></tr></table></figure><h2 id="除了系统目录，也可以自己创建存放脚本的目录"><a href="#除了系统目录，也可以自己创建存放脚本的目录" class="headerlink" title="除了系统目录，也可以自己创建存放脚本的目录"></a><strong>除了系统目录，也可以自己创建存放脚本的目录</strong></h2><h3 id="复制至自定义目录"><a href="#复制至自定义目录" class="headerlink" title="复制至自定义目录"></a>复制至自定义目录</h3><p>1.在任意位置创建任意目录：比如<code>~/存档/Linux/bin </code></p><p>2.然后修改环境变量<code>export PATH=$PATH:路径</code></p><ul><li><p>bash</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#m打开.bashrc文件</span><br>nano ~/.bashrc<br>添加下面一行<br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">PATH</span>=<span class="hljs-variable">$PATH</span>:~/存档/Linux/bin<br></code></pre></td></tr></table></figure></li><li><p>zsh</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#打开.zshrc文件</span><br>nano ~/.zshrc<br>添加下面一行<br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">PATH</span>=<span class="hljs-variable">$PATH</span>:~/存档/Linux/bin<br></code></pre></td></tr></table></figure></li></ul><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><ul><li>用<code>KRunner</code>，<code>Alt</code>+<code>Space</code>唤醒，确保<code>KRunner</code>拥有执行命令的功能</li><li>输入<code>restart_kde</code>即可</li></ul><h1 id="安装多个JDK时"><a href="#安装多个JDK时" class="headerlink" title="安装多个JDK时"></a>安装多个<code>JDK</code>时</h1><p>我这里先安装的 <code>jdk8-openjdk</code>，后安装 <code>jdk16</code></p><p><code>sudo pacman -S jdk-openjdk </code>默认就是16版本</p><p>安装 <code>jdk16</code>时提示：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Default</span> Java environment <span class="hljs-keyword">is</span> already <span class="hljs-keyword">set</span> <span class="hljs-keyword">to</span> <span class="hljs-string">&#x27;java-8-openjdk&#x27;</span><br>See <span class="hljs-string">&#x27;archlinux-java help&#x27;</span> <span class="hljs-keyword">to</span> change it<br><span class="hljs-keyword">when</span> you use a non-reparenting <span class="hljs-keyword">window</span> manager,<br><span class="hljs-keyword">set</span> _JAVA_AWT_WM_NONREPARENTING=<span class="hljs-number">1</span> <span class="hljs-keyword">in</span> /etc/profile.d/jre.sh<br></code></pre></td></tr></table></figure><h2 id="切换-JDK-版本"><a href="#切换-JDK-版本" class="headerlink" title="切换 JDK 版本"></a>切换 <code>JDK</code> 版本</h2><h2 id="使用archlinux-java命令切换JDK-版本"><a href="#使用archlinux-java命令切换JDK-版本" class="headerlink" title="使用archlinux-java命令切换JDK 版本"></a>使用<code>archlinux-java</code>命令切换<code>JDK</code> 版本</h2><p><code>archlinux-java help</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">archlinux-java &lt;COMMAND&gt;<br><br>COMMAND:<br>    status      List installed Java environments and enabled one<br>    get     Return the short name of the Java environment <span class="hljs-built_in">set</span> as default<br>    <span class="hljs-built_in">set</span> &lt;JAVA_ENV&gt;  Force &lt;JAVA_ENV&gt; as default<br>    <span class="hljs-built_in">unset</span>       Unset current default Java environment<br>    fix     Fix an invalid/broken default Java environment configuration<br></code></pre></td></tr></table></figure><h3 id="set-lt-JAVA-ENV-gt-就是设置默认环境的方法"><a href="#set-lt-JAVA-ENV-gt-就是设置默认环境的方法" class="headerlink" title="set &lt;JAVA_ENV&gt; 就是设置默认环境的方法"></a><code>set &lt;JAVA_ENV&gt;</code> 就是设置默认环境的方法</h3><ul><li>set 之前</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -version                                                                            1 ↵ ──(六,10月09)─┘<br>openjdk version <span class="hljs-string">&quot;1.8.0_292&quot;</span><br>OpenJDK Runtime Environment (build 1.8.0_292-b10)<br>OpenJDK 64-Bit Server VM (build 25.292-b10, mixed mode)<br></code></pre></td></tr></table></figure><ul><li>set之后</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -version                                                                                ──(六,10月09)─┘<br>openjdk version <span class="hljs-string">&quot;16.0.2&quot;</span> 2021-07-20<br>OpenJDK Runtime Environment (build 16.0.2+7)<br>OpenJDK 64-Bit Server VM (build 16.0.2+7, mixed mode)<br></code></pre></td></tr></table></figure><h1 id="ranger"><a href="#ranger" class="headerlink" title="ranger"></a>ranger</h1><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ol><li><p>配置文件</p><p>首先复制配置文件到主目录:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs none">ranger --copy-config=all<br></code></pre></td></tr></table></figure></li></ol><p>然后自己到~/.config/ranger中配置各种选项即可</p><ol start="2"><li><p>配置ranger<br>在～/.config/ranger中有ranger的配置文件.<br>找到文件<code>scope.sh</code>中, 在externsions部分注释掉不想预览的文件类型, 在那行上面添加”#”注释掉即可. ranger在预览rar等压缩包时会运行得比较慢.<br><code>rc.conf</code>保存着快捷键的说明</p></li><li><p>自动挂载U盘等外部存储位置,需要安装usbmount:</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs none">sudo apt-get install usbmount<br>sudo vim /etc/usbmount/usbmount.conf<br></code></pre></td></tr></table></figure><p>在<code>MOUNTOPTIONS</code>那行添加<code>user</code>即可使普通用户也对挂载的U盘拥有写权限, 如下:<br><code>MOUNTOPTIOS=&quot;rw,user,noatime,nodiratime&quot; </code></p><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p>下面列出常用操作的快捷键</p><p>?  查看帮助</p><h3 id="浏览"><a href="#浏览" class="headerlink" title="浏览:"></a>浏览:</h3><p>H   后退<br>L   前进<br>gg  跳到顶端<br>G   跳到底端<br>gh  go home<br>gn  新建标签<br>f   查找<br>/   搜素<br>g   快速进入目录</p><h3 id="编辑"><a href="#编辑" class="headerlink" title="编辑:"></a>编辑:</h3><p>space   选择<br>uv      取消选择</p><p>yy      复制<br>dd      剪切<br>pp      粘贴<br>delete  删除<br>cw      重命名<br>A       在当前名称基础上重命名<br>I       类似A, 但是光标会跳到起始位置<br>Ctrl-f  向下翻页<br>Ctrl-b  向上翻页</p><h3 id="书签"><a href="#书签" class="headerlink" title="书签:"></a>书签:</h3><p>m       新建书签<br>`       打开书签<br>um      删除书签</p><h3 id="标签"><a href="#标签" class="headerlink" title="标签:"></a>标签:</h3><p>gn / C-n        新建标签<br>TAB / S-TAB     切换标签<br>A-Right, A-Left 切换标签<br>gc / C-w        关闭标签</p><h3 id="排序"><a href="#排序" class="headerlink" title="排序:"></a>排序:</h3><p>on/ob   根据文件名进行排序(natural/basename)<br>oc      根据改变时间进行排序 (Change Time 文件的权限组别和文件自身数据被修改的时间)<br>os      根据文件大小进行排序(Size)<br>ot      根据后缀名进行排序 (Type)</p><p>oa      根据访问时间进行排序 (Access Time 访问文件自身数据的时间)<br>om      根据修改进行排序 (Modify time 文件自身内容被修改的时间)</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他:"></a>其他:</h3><p>zh      显示隐藏文件</p><p>zp      打开/关闭文件预览功能<br>zP      打开目录预览功能</p><h3 id="链接-Link"><a href="#链接-Link" class="headerlink" title="链接(Link):"></a>链接(Link):</h3><p>pl      粘贴绝对路径的链接<br>pL      粘贴相对路径的链接<br>phl     硬链接</p><h3 id="批量改名"><a href="#批量改名" class="headerlink" title="批量改名:"></a>批量改名:</h3><p>批量选择文件后, 键入命令:bulkname, 会打开编辑器, 其中的文件名编辑后保存退出, 再次打开操作确认编辑, 然后就批量改名了, 如果想取消批量改名, 在确认时把文件内容删除即可.</p><h3 id="任务管理"><a href="#任务管理" class="headerlink" title="任务管理:"></a>任务管理:</h3><p>在执行某些操作(比如复制一个大文件)时不能立即完成, 这在 ranger 中就是一个任务. 你可以停止, 启动某个任务, 也可以对某个任务设置优先级.</p><p>w: 打开/关闭任务视图. 在w打开的任务视图中:<br>    dd: 终止一个任务<br>    J: 降低当前任务的优先级<br>    K: 提升当前任务的优先级</p><h3 id="其他-1"><a href="#其他-1" class="headerlink" title="其他:"></a>其他:</h3><ul><li><p>zf      过滤器(如过滤pdf文件, zf+pdf,回车) S       在当前目录打开终端 z(*)    改变设置, <em>表示在弹出选项中的选择 o(</em>)    改变排序方式 ! / s   使用shell命令(！shell -w ls -hl %s,%s代表当前被选中的文件)</p><p>使用ranger命令(3? 查看可用命令) :set colorscheme snow 设置颜色模式</p></li></ul><h2 id="快速预览"><a href="#快速预览" class="headerlink" title="快速预览"></a>快速预览</h2><p>安装一下程序可以实现快速预览:</p><p>elinks, html<br>highlight,text/code<br>img2txt,image<br>atool,压缩包<br>pdf2text,pdf<br>medinfo,audio/video</p><hr><h1 id="字体调整"><a href="#字体调整" class="headerlink" title="字体调整"></a>字体调整</h1><p><strong>提示：</strong> 中文用户在安装思源cjk全集或者noto-cjk全集后，部分文字显示为日文异形字体，可参看<a href="https://wiki.archlinux.org/title/Arch_Linux_Localization_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E4%BF%AE%E6%AD%A3%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%E6%98%BE%E7%A4%BA%E4%B8%BA%E5%BC%82%E4%BD%93%EF%BC%88%E6%97%A5%E6%96%87%EF%BC%89%E5%AD%97%E5%BD%A2">Arch Linux Localization (简体中文)#修正简体中文显示为异体（日文）字形</a> 进行解决。</p><h2 id="字体安装和配置"><a href="#字体安装和配置" class="headerlink" title="字体安装和配置"></a>字体安装和配置</h2><p><code>noto-fonts-cjk</code>-Google Noto CJK 字体， 提供简体中文、繁体中文、日文、韩文一致的设计和外观。它是基于是<code>adobe-source-han-sans-otc-fonts</code>重贴的商标。所以选择一个安装。</p><h2 id="安装的字体"><a href="#安装的字体" class="headerlink" title="安装的字体"></a>安装的字体</h2><ul><li><p>思源字体（不安装cjk版本，仅安装cn版本，避免火狐异体字问题）：</p><ul><li><code>adobe-source-han-serif-cn-fonts</code></li><li><code>adobe-source-han-sans-cn-fonts</code></li></ul></li><li><p>文泉驿正黑</p><ul><li><a href="https://archlinux.org/packages/?name=wqy-zenhei">wqy-zenhei</a> - 文泉驿正黑体，黑体 (无衬线) 的中文轮廓字体，附带文泉驿点阵宋体 (也支持部分日韩字符)。</li><li><a href="https://archlinux.org/packages/?name=wqy-bitmapfont">wqy-bitmapfont</a> - 文泉驿点阵宋体 (衬线) 中文字体。</li></ul></li><li><p>文泉驿微米黑</p><ul><li><a href="https://archlinux.org/packages/?name=wqy-microhei">wqy-microhei</a> - 文泉驿微米黑，无衬线形式字体。</li><li><a href="https://archlinux.org/packages/?name=wqy-microhei-lite">wqy-microhei-lite</a> - 文泉驿微米黑light版（笔画更细）。</li></ul></li><li><p>windows字体</p></li></ul><p>​        把windows的字体复制到<code>~/.local/share/fonts/WindowsFonts</code>目录下</p><h2 id="配置font"><a href="#配置font" class="headerlink" title="配置font"></a>配置font</h2><ul><li>修改<code>~/.config/fontconfig/fonts.conf</code>配置文件</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><code class="hljs xml">原理就是把某些符合条件的字体请求映射到我们定义的字体<br><span class="hljs-meta">&lt;?xml version=&#x27;1.0&#x27;?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">fontconfig</span> <span class="hljs-meta-keyword">SYSTEM</span> <span class="hljs-meta-string">&#x27;urn:fontconfig:fonts.dtd&#x27;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">fontconfig</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">dir</span>&gt;</span>~/.fonts<span class="hljs-tag">&lt;/<span class="hljs-name">dir</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">dir</span>&gt;</span>~/.local/share/fonts/<span class="hljs-tag">&lt;/<span class="hljs-name">dir</span>&gt;</span><br> <span class="hljs-comment">&lt;!-- </span><br><span class="hljs-comment"> Artificial oblique for fonts without an italic or oblique version</span><br><span class="hljs-comment"> --&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">match</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;font&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- check to see if the font is roman --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">test</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;slant&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">const</span>&gt;</span>roman<span class="hljs-tag">&lt;/<span class="hljs-name">const</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">test</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- check to see if the pattern requested non-roman --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">test</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;pattern&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;slant&quot;</span> <span class="hljs-attr">compare</span>=<span class="hljs-string">&quot;not_eq&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">const</span>&gt;</span>roman<span class="hljs-tag">&lt;/<span class="hljs-name">const</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">test</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- multiply the matrix to slant the font --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">edit</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;matrix&quot;</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">&quot;assign&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">times</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>matrix<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">matrix</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">double</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">double</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">double</span>&gt;</span>0.2<span class="hljs-tag">&lt;/<span class="hljs-name">double</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">double</span>&gt;</span>0<span class="hljs-tag">&lt;/<span class="hljs-name">double</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">double</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">double</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">matrix</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">times</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">edit</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- pretend the font is oblique now --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">edit</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;slant&quot;</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">&quot;assign&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">const</span>&gt;</span>oblique<span class="hljs-tag">&lt;/<span class="hljs-name">const</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">edit</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- and disable embedded bitmaps for artificial oblique --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">edit</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;embeddedbitmap&quot;</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">&quot;assign&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">bool</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">bool</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">edit</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">match</span>&gt;</span><br> <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment"> Synthetic emboldening for fonts that do not have bold face available</span><br><span class="hljs-comment"> --&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">match</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;font&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- check to see if the weight in the font is less than medium which possibly need emboldening --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">test</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;weight&quot;</span> <span class="hljs-attr">compare</span>=<span class="hljs-string">&quot;less_eq&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">const</span>&gt;</span>medium<span class="hljs-tag">&lt;/<span class="hljs-name">const</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">test</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- check to see if the pattern requests bold --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">test</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;pattern&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;weight&quot;</span> <span class="hljs-attr">compare</span>=<span class="hljs-string">&quot;more_eq&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">const</span>&gt;</span>bold<span class="hljs-tag">&lt;/<span class="hljs-name">const</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">test</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">  set the embolden flag</span><br><span class="hljs-comment">  needed for applications using cairo, e.g. gucharmap, gedit, ...</span><br><span class="hljs-comment">--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">edit</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;embolden&quot;</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">&quot;assign&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">bool</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">bool</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">edit</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment"> set weight to bold</span><br><span class="hljs-comment"> needed for applications using Xft directly, e.g. Firefox, ...</span><br><span class="hljs-comment">--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">edit</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;weight&quot;</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">&quot;assign&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">const</span>&gt;</span>bold<span class="hljs-tag">&lt;/<span class="hljs-name">const</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">edit</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">match</span>&gt;</span><br> <span class="hljs-comment">&lt;!--   自定义开始--&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">match</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;font&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">edit</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;embeddedbitmap&quot;</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">&quot;assign&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">bool</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">bool</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">edit</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">match</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">match</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">test</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;family&quot;</span> <span class="hljs-attr">qual</span>=<span class="hljs-string">&quot;any&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>serif<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">test</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">edit</span> <span class="hljs-attr">binding</span>=<span class="hljs-string">&quot;strong&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;family&quot;</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">&quot;prepend&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>Noto Serif<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">edit</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">match</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">match</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;pattern&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">test</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;family&quot;</span> <span class="hljs-attr">qual</span>=<span class="hljs-string">&quot;any&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>sans-serif<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">test</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">edit</span> <span class="hljs-attr">binding</span>=<span class="hljs-string">&quot;strong&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;family&quot;</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">&quot;prepend&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>Roboto<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">edit</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">match</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">match</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;pattern&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">test</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;family&quot;</span> <span class="hljs-attr">qual</span>=<span class="hljs-string">&quot;any&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>monospace<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">test</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">edit</span> <span class="hljs-attr">binding</span>=<span class="hljs-string">&quot;strong&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;family&quot;</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">&quot;prepend&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>DejaVu Sans Mono<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">edit</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">match</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">match</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">test</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lang&quot;</span> <span class="hljs-attr">compare</span>=<span class="hljs-string">&quot;contains&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>zh<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">test</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">test</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;family&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>serif<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">test</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">edit</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;family&quot;</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">&quot;prepend&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>Source Han Serif CN<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">edit</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">match</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">match</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">test</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lang&quot;</span> <span class="hljs-attr">compare</span>=<span class="hljs-string">&quot;contains&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>zh<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">test</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">test</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;family&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>sans-serif<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">test</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">edit</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;family&quot;</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">&quot;prepend&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>Source Han Sans CN<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">edit</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">match</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">match</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">test</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lang&quot;</span> <span class="hljs-attr">compare</span>=<span class="hljs-string">&quot;contains&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>zh<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">test</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">test</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;family&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>monospace<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">test</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">edit</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;family&quot;</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">&quot;prepend&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>WenQuanYi Micro Hei Mono<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">edit</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">match</span>&gt;</span><br> <span class="hljs-comment">&lt;!--WenQuanYi Zen Hei -&gt; WenQuanYi Micro Hei --&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">match</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;pattern&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">test</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;family&quot;</span> <span class="hljs-attr">qual</span>=<span class="hljs-string">&quot;any&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>WenQuanYi Zen Hei<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">test</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">edit</span> <span class="hljs-attr">binding</span>=<span class="hljs-string">&quot;same&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;family&quot;</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">&quot;assign&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>WenQuanYi Micro Hei<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">edit</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">match</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">match</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;pattern&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">test</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;family&quot;</span> <span class="hljs-attr">qual</span>=<span class="hljs-string">&quot;any&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>WenQuanYi Zen Hei Lite<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">test</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">edit</span> <span class="hljs-attr">binding</span>=<span class="hljs-string">&quot;same&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;family&quot;</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">&quot;assign&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>WenQuanYi Micro Hei Lite<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">edit</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">match</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">match</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;pattern&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">test</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;family&quot;</span> <span class="hljs-attr">qual</span>=<span class="hljs-string">&quot;any&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>WenQuanYi Zen Hei Mono<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">test</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">edit</span> <span class="hljs-attr">binding</span>=<span class="hljs-string">&quot;same&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;family&quot;</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">&quot;assign&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>WenQuanYi Micro Hei Mono<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">edit</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">match</span>&gt;</span><br> <span class="hljs-comment">&lt;!--   自定义结束--&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">match</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;font&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">edit</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hinting&quot;</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">&quot;assign&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">bool</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">bool</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">edit</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">match</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">match</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;font&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">edit</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hintstyle&quot;</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">&quot;assign&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">const</span>&gt;</span>hintslight<span class="hljs-tag">&lt;/<span class="hljs-name">const</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">edit</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">match</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">fontconfig</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h2 id="修正简体中文显示为异体（日文）字形"><a href="#修正简体中文显示为异体（日文）字形" class="headerlink" title="修正简体中文显示为异体（日文）字形"></a>修正简体中文显示为异体（日文）字形</h2><ul><li><p>上面安装了windows字体，要禁用或删除windows字体中的<code>Candara</code>字体，因为它会显示异体字。</p><hr></li></ul><p>安装的 Noto Sans CJK 或 <a href="https://archlinux.org/packages/?name=adobe-source-han-sans-otc-fonts">adobe-source-han-sans-otc-fonts</a>（思源黑体）或 <a href="https://archlinux.org/packages/?name=adobe-source-han-serif-otc-fonts">adobe-source-han-serif-otc-fonts</a>（思源宋体）后，在某些情况下（框架未定义地区）汉字字形与标准形态不符，例如门、关、复等字字形与规范中文不符。</p><p>这是因为每个程序中可以设置不同的默认字体，比如 Arial 或者 Tohamo，而这些字体的属性由 <a href="https://wiki.archlinux.org/title/Fontconfig_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">fontconfig</a> 控制，其使用顺序是据地区代码以 A-Z 字母表顺序成默认排序，由于 <code>ja-JP</code> 在 <code>zh_&#123;CN,HK,SG,TW&#125;</code> 之前，故优先显示日文字形。</p><p><strong>提示：</strong> Chromium/Chrome/Firefox 浏览器的设置中可单独设置字体，例如将字体选项调成 Noto xxx CJK SC。</p><p>可选用以下方法解决（以简体中文为例）：</p><ul><li><p>只安装 cjk 中的简体中文字体，例如思源黑体简体中文包 <a href="https://archlinux.org/packages/?name=adobe-source-han-sans-cn-fonts">adobe-source-han-sans-cn-fonts</a>、<a href="https://archlinux.org/packages/?name=adobe-source-han-serif-cn-fonts">adobe-source-han-serif-cn-fonts</a> 或者 <a href="https://aur.archlinux.org/packages/noto-fonts-sc/">noto-fonts-sc</a>AUR。</p></li><li><p>在 <code>locale.conf</code> 中添加 <code>LANG=zh_CN.UTF-8</code>，以将简体中文设置为默认语言。由于对 <a href="https://wiki.archlinux.org/title/Locale_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">Locale</a> 定义了框架内地区（即 CJK 优先度），使得默认的优先级被忽略。</p></li><li><p>手动调整优先级，将中文字形调整到日文字形之前。[<a href="https://tieba.baidu.com/p/4879946717">3]</a>在 <code>/etc/fonts/conf.d/</code> 或 <code>/etc/fonts/conf.avail/</code> 下创建文件，例如 <code>64-language-selector-prefer.conf</code>，也可以修改或创建 <code>~/.fonts.conf</code>或在<code>~/.config/fontconfig/conf.d/</code>创建后缀为.conf的文件（仅对该用户生效）。例如针对<a href="https://archlinux.org/packages/?name=noto-fonts-cjk">noto-fonts-cjk</a>的规则，写入：</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">fontconfig</span> <span class="hljs-meta-keyword">SYSTEM</span> <span class="hljs-meta-string">&quot;fonts.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">fontconfig</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">alias</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">family</span>&gt;</span>sans-serif<span class="hljs-tag">&lt;/<span class="hljs-name">family</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">prefer</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">family</span>&gt;</span>Noto Sans CJK SC<span class="hljs-tag">&lt;/<span class="hljs-name">family</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">family</span>&gt;</span>Noto Sans CJK TC<span class="hljs-tag">&lt;/<span class="hljs-name">family</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">family</span>&gt;</span>Noto Sans CJK JP<span class="hljs-tag">&lt;/<span class="hljs-name">family</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">prefer</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">alias</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">alias</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">family</span>&gt;</span>monospace<span class="hljs-tag">&lt;/<span class="hljs-name">family</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">prefer</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">family</span>&gt;</span>Noto Sans Mono CJK SC<span class="hljs-tag">&lt;/<span class="hljs-name">family</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">family</span>&gt;</span>Noto Sans Mono CJK TC<span class="hljs-tag">&lt;/<span class="hljs-name">family</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">family</span>&gt;</span>Noto Sans Mono CJK JP<span class="hljs-tag">&lt;/<span class="hljs-name">family</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">prefer</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">alias</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">fontconfig</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果安装的是 <a href="https://archlinux.org/packages/?name=adobe-source-han-sans-otc-fonts">adobe-source-han-sans-otc-fonts</a>，写入：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">fontconfig</span> <span class="hljs-meta-keyword">SYSTEM</span> <span class="hljs-meta-string">&quot;fonts.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">fontconfig</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">alias</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">family</span>&gt;</span>sans-serif<span class="hljs-tag">&lt;/<span class="hljs-name">family</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">prefer</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">family</span>&gt;</span>Source Han Sans SC<span class="hljs-tag">&lt;/<span class="hljs-name">family</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">family</span>&gt;</span>Source Han Sans TC<span class="hljs-tag">&lt;/<span class="hljs-name">family</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">family</span>&gt;</span>Source Han Sans HW<span class="hljs-tag">&lt;/<span class="hljs-name">family</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">family</span>&gt;</span>Source Han Sans K<span class="hljs-tag">&lt;/<span class="hljs-name">family</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">prefer</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">alias</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">alias</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">family</span>&gt;</span>monospace<span class="hljs-tag">&lt;/<span class="hljs-name">family</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">prefer</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">family</span>&gt;</span>Source Han Sans SC<span class="hljs-tag">&lt;/<span class="hljs-name">family</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">family</span>&gt;</span>Source Han Sans TC<span class="hljs-tag">&lt;/<span class="hljs-name">family</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">family</span>&gt;</span>Source Han Sans HW<span class="hljs-tag">&lt;/<span class="hljs-name">family</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">family</span>&gt;</span>Source Han Sans K<span class="hljs-tag">&lt;/<span class="hljs-name">family</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">prefer</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">alias</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">fontconfig</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注意，如果你是在 <code>/etc/fonts/conf.avail</code> 目录下创建的 xml 文件，则将该 xml 文件软链接到 <code>/etc/fonts/conf.d</code> 下，例如：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"># ln -s <span class="hljs-regexp">/etc/</span>fonts<span class="hljs-regexp">/conf.avail/</span><span class="hljs-number">64</span>-language-selector-prefer.conf <span class="hljs-regexp">/etc/</span>fonts<span class="hljs-regexp">/conf.d/</span><span class="hljs-number">64</span>-language-selector-prefer.conf<br></code></pre></td></tr></table></figure><p>然后更新字体缓存即可生效：</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># fc-cache -fv</span><br></code></pre></td></tr></table></figure><p>执行以下命令检查，如果出现 <code>NotoSansCJK-Regular.ttc: &quot;Noto Sans CJK SC&quot; &quot;Regular&quot;</code> 则表示设置成功：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"># fc-<span class="hljs-keyword">match</span> -s | <span class="hljs-keyword">grep</span> <span class="hljs-string">&#x27;Noto Sans CJK&#x27;</span><br></code></pre></td></tr></table></figure><h1 id="kde-美化"><a href="#kde-美化" class="headerlink" title="kde 美化"></a>kde 美化</h1><h2 id="安装主题管理"><a href="#安装主题管理" class="headerlink" title="安装主题管理"></a>安装主题管理</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> pacman -S kvantum-qt<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h2 id="主题位置"><a href="#主题位置" class="headerlink" title="主题位置"></a>主题位置</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs awk">AURORAE_DIR=<span class="hljs-string">&quot;$HOME/.local/share/aurorae/themes&quot;</span><span class="hljs-regexp">//</span>窗口装饰元素<br>PLASMA_DIR=<span class="hljs-string">&quot;$HOME/.local/share/plasma/desktoptheme&quot;</span><span class="hljs-regexp">//</span>plasma样式<br>LAYOUT_DIR=<span class="hljs-string">&quot;$HOME/.local/share/plasma/layout-templates&quot;</span><span class="hljs-regexp">//</span>无<br>LOOKFEEL_DIR=<span class="hljs-string">&quot;$HOME/.local/share/plasma/look-and-feel&quot;</span>总体的预览/全局主题<br>SCHEMES_DIR=<span class="hljs-string">&quot;$HOME/.local/share/color-schemes&quot;</span><span class="hljs-regexp">//</span>颜色<br>KVANTUM_DIR=<span class="hljs-string">&quot;$HOME/.config/Kvantum&quot;</span><br>WALLPAPER_DIR=<span class="hljs-string">&quot;$HOME/.local/share/wallpapers&quot;</span><br>   <span class="hljs-variable">$HOME</span><span class="hljs-regexp">/.local/</span>share<span class="hljs-regexp">/icons/</span> <span class="hljs-regexp">//</span>存放鼠标或图标<br><span class="hljs-variable">$HOME</span><span class="hljs-regexp">/.local/</span>share<span class="hljs-regexp">/plasma/</span>plasmoids/ 存放插件<br>以上目录如果没有就自行创建。<br><br>壁纸位置在<span class="hljs-regexp">/home/</span>kiylx<span class="hljs-regexp">/.local/</span>share/wallpapers 更改为此文件夹下的文件就可以改壁纸<br><span class="hljs-number">1</span>.更换登录壁纸 :菜单-系统设置-工作区-工作空间行为-锁屏-外观-接下来选取你喜欢的图片即可<br><span class="hljs-number">2</span>.更换锁屏壁纸 :菜单-系统设置-工作区-工作空间行为-锁屏-外观-接下来选取你喜欢的图片即可<br><span class="hljs-number">3</span>.更换登录屏幕的壁纸：菜单-系统设置-工作区-开机和关机-登录屏幕-接下来选取你喜欢的动画即可<br><span class="hljs-number">4</span>.更换开机动画：菜单-系统设置-工作区-开机和关机-欢迎屏幕<br><span class="hljs-number">5</span>.设置双击打开文件夹，单击选择：菜单-系统设置-工作区-工作空间行为-常规行为-点击行为<br></code></pre></td></tr></table></figure><h2 id="重启plasmashell"><a href="#重启plasmashell" class="headerlink" title="重启plasmashell"></a>重启plasmashell</h2><h3 id="直接杀死并重启"><a href="#直接杀死并重启" class="headerlink" title="直接杀死并重启"></a>直接杀死并重启</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">killall plasmashell    <span class="hljs-comment"># 杀死 kde plasma 的进程</span><br><span class="hljs-comment"># kde4</span><br>kstart plasmashell    <span class="hljs-comment"># 重新启动 plasma 桌面会话</span><br><span class="hljs-comment"># kde5</span><br>kstart5 plasmashell    <span class="hljs-comment"># 重新启动 plasma 桌面会话</span><br></code></pre></td></tr></table></figure><h3 id="退出并重启"><a href="#退出并重启" class="headerlink" title="退出并重启"></a>退出并重启</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">kquitapp5 plasmashell    <span class="hljs-comment"># 退出kde桌面</span><br><span class="hljs-comment"># kde4</span><br>kstart plasmashell    <span class="hljs-comment"># 重新启动 plasma 桌面会话</span><br><span class="hljs-comment"># kde5</span><br>kstart5 plasmashell    <span class="hljs-comment"># 重新启动 plasma 桌面会话</span><br></code></pre></td></tr></table></figure><hr><h2 id="主题推荐"><a href="#主题推荐" class="headerlink" title="主题推荐"></a>主题推荐</h2><h2 id="图标"><a href="#图标" class="headerlink" title="图标"></a>图标</h2><p><a href="https://gitlab.gnome.org/GNOME/adwaita-icon-theme">adwaita</a></p><h2 id="鼠标指针："><a href="#鼠标指针：" class="headerlink" title="鼠标指针："></a>鼠标指针：</h2><h2 id="整体样式"><a href="#整体样式" class="headerlink" title="整体样式"></a>整体样式</h2><ul><li>应用商店搜索：materia-kde</li></ul><ul><li>gtk样式：orchis</li></ul><h2 id="应用程序样式"><a href="#应用程序样式" class="headerlink" title="应用程序样式"></a>应用程序样式</h2><ul><li>更现代化的样式 <a href="https://github.com/Luwx/Lightly">lightly-qt</a></li><li>gnome的样式 <a href="https://github.com/FedoraQt/adwaita-qt">adwaita-qt</a></li></ul><h2 id="dock栏"><a href="#dock栏" class="headerlink" title="dock栏"></a>dock栏</h2><ul><li>latte dock</li></ul><h2 id="顶栏"><a href="#顶栏" class="headerlink" title="顶栏"></a>顶栏</h2><ul><li><p>applet-window-appmenu</p><p>提供了顶栏的全局菜单，比自带的好用</p><p>应用商店搜索<code>plasma5-applets-window-appmenu-git</code></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs subunit">github： https://github.com/psifidotos/applet-window-appmenu<br>调用 sh install.sh安装，安装之前应该查看INSTALLATION.md安装编译环境，但是可以在<br>应用商店查找plasma5-applets-window-appmenu-git，安装别人做好的。<br>构建依赖：<br>[2021<span class="hljs-string">-08</span><span class="hljs-string">-14</span>T22:20:17<span class="hljs-string">+0800</span>] [ALPM] installed plasma5-applets-window-appmenu-git (0.7.1.r0.gcdbc943<span class="hljs-string">-1</span>)<br>[2021<span class="hljs-string">-08</span><span class="hljs-string">-14</span>T22:19:48<span class="hljs-string">+0800</span>] [ALPM] installed extra-cmake-modules (5.84.0<span class="hljs-string">-1</span>)<br>[2021<span class="hljs-string">-08</span><span class="hljs-string">-14</span>T22:19:48<span class="hljs-string">+0800</span>] [ALPM] installed cmake (3.21.1<span class="hljs-string">-1</span>)<br>[2021<span class="hljs-string">-08</span><span class="hljs-string">-14</span>T22:19:47<span class="hljs-string">+0800</span>] [ALPM] installed libuv (1.42.0<span class="hljs-string">-1</span>)<br>[2021<span class="hljs-string">-08</span><span class="hljs-string">-14</span>T22:19:47<span class="hljs-string">+0800</span>] [ALPM] installed jsoncpp (1.9.4<span class="hljs-string">-1</span>)<br>[2021<span class="hljs-string">-08</span><span class="hljs-string">-14</span>T22:19:47<span class="hljs-string">+0800</span>] [ALPM] installed rhash (1.4.2<span class="hljs-string">-1</span>)<br></code></pre></td></tr></table></figure></li><li><p>applet-window-buttons</p><p>提供窗口管理按钮</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">github：https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/psifidotos/</span>applet-window-buttons<br>上面的菜单使用应用商店安装好后，编译环境还没被卸载，可以直接clone这个applet-window-buttons库下来，调用sh install.sh安装这个button插件<br><br></code></pre></td></tr></table></figure></li><li><p>[顶栏显示应用的标题和图标]: <a href="https://github.com/psifidotos/applet-window-title">https://github.com/psifidotos/applet-window-title</a></p></li></ul><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><h3 id="kwin脚本"><a href="#kwin脚本" class="headerlink" title="kwin脚本"></a>kwin脚本</h3><h3 id="applet"><a href="#applet" class="headerlink" title="applet"></a>applet</h3><ul><li>日历插件<code>plasma5-applets-eventcalendar</code>，可直接在应用商店搜索</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>hexo整理</title>
    <link href="/2021/12/23/hexo/"/>
    <url>/2021/12/23/hexo/</url>
    
    <content type="html"><![CDATA[<h1 id="简单安装"><a href="#简单安装" class="headerlink" title="简单安装"></a>简单安装</h1><p><a href="https://hexo.io/zh-cn/docs/">hexo官网</a></p><h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装<code>git</code></h2><p>​    不再赘述</p><h1 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装<code>node.js</code></h1><p>可以通过以下命令查看主机中是否安装了<code>node.js</code>和<code>npm</code></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ <span class="hljs-keyword">node</span> <span class="hljs-title">--version</span>    <span class="hljs-comment">#检查是否安装了node.js</span><br>$ npm --<span class="hljs-keyword">version</span>     <span class="hljs-comment">#检查是否安装了npm</span><br></code></pre></td></tr></table></figure><p>如下所示表示已经安装了<code>node.js</code>和<code>npm</code></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">root</span>@***:~# node --version<br><span class="hljs-attribute">v8</span>.<span class="hljs-number">11</span>.<span class="hljs-number">3</span><br><span class="hljs-attribute">root</span>@***:~# npm --version<br><span class="hljs-attribute">6</span>.<span class="hljs-number">7</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><a href="https://nodejs.org/en/download/package-manager/">没有安装的话查看官方指南</a></p><h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装<code>hexo</code></h2><ul><li>使用<code>npm</code>安装    </li></ul><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">$ npm install -g hexo-<span class="hljs-keyword">cli</span><br></code></pre></td></tr></table></figure><ul><li><p>安装以后，可以使用以下两种方式执行 <code>Hexo</code>：</p><ol><li><code>npx hexo &lt;command&gt;</code></li><li>将 <code>Hexo</code> 所在的目录下的 <code>node_modules</code> 添加到环境变量之中即可直接使用 <code>hexo &lt;command&gt;</code>：</li></ol><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">echo</span> &#x27;PATH=<span class="hljs-string">&quot;$PATH:./node_modules/.bin&quot;</span>&#x27; &gt;&gt; ~<span class="hljs-string">/.profile</span><br>我使用的zsh,所以把<span class="hljs-string">&quot;~/.profile&quot;</span>改为<span class="hljs-string">&quot;~/.zshrc&quot;</span><br><br></code></pre></td></tr></table></figure></li></ul><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><ul><li>初始化hexo（在自己建立的任意文件夹里，如果没有添加环境变量，需要使用<code>npx hexo &lt;command&gt;</code>）</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> hexo init &lt;folder&gt;<br><span class="hljs-variable">$</span> <span class="hljs-built_in">cd</span> &lt;folder&gt;<br><span class="hljs-variable">$</span> npm install<br></code></pre></td></tr></table></figure><ul><li>接下来,输入两条命令</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog">hexo <span class="hljs-keyword">generate</span>  <br>hexo server  <br>或者输入命令的简写:  <br>hexo g<br>hexo s<br></code></pre></td></tr></table></figure><p>解释:<br>首先执行”hexo generate”生成相应的静态网页，生成的静态网页以及相关资源都会在public目录下<br>hexo-server模块的主要命令如下，输入”hexo generate”以启动服务器，您的网站会在 <a href="http://localhost:4000/">http://localhost:4000</a> 下启动。在服务器启动期间，Hexo 会监视文件变动并自动更新，您无须重启服务器。<br>注: 如果您想要更改端口，或是在执行时遇到了 EADDRINUSE 错误，可以在执行时使用 -p 选项指定其他端口，如下:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">hexo</span> server -p <span class="hljs-number">5000</span><br></code></pre></td></tr></table></figure><ul><li>接下来, 将hexo部署到github</li></ul><p>1 .首先将我们的Hexo与GitHub关联起来，打开站点的配置文件_config.yml，翻到最后修改为：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">type:</span> git<br><span class="hljs-symbol">repo:</span> 博客的仓库地址，用ssh的地址，不要用https的地址<br><span class="hljs-symbol">branch:</span> master<br><span class="hljs-symbol">ps:</span>注意缩进<br></code></pre></td></tr></table></figure><p>其实就是给hexo d 这个命令做相应的配置，让hexo知道你要把blog部署在哪个位置，很显然，我们部署在我们GitHub的仓库里。<br>2 .安装Git部署插件，输入命令：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install hexo-deployer-git <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><p>接着，我们分别输入三条命令：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs excel">hexo <span class="hljs-built_in">clean</span> <br>hexo g <br>hexo d  将会部署到github<br></code></pre></td></tr></table></figure><p>全部完成  </p><h1 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h1><ul><li><a href="https://github.com/zthxxx/hexo-theme-Wikitten">wiki样式</a></li><li><a href="https://github.com/jerryc127/hexo-theme-butterfly">md样式<code>hexo-theme-butterfly</code></a></li><li> <a href="https://github.com/bollnh/hexo-theme-material">md样式<code>hexo-theme-material</code></a></li><li><a href="https://github.com/fluid-dev/hexo-theme-fluid">md样式<code>hexo-theme-fluid</code></a></li></ul><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>您可以在 <code>_config.yml</code> 中修改大部分的配置。</p><h2 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h2><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>title</code></td><td align="left">网站标题</td></tr><tr><td align="left"><code>subtitle</code></td><td align="left">网站副标题</td></tr><tr><td align="left"><code>description</code></td><td align="left">网站描述</td></tr><tr><td align="left"><code>keywords</code></td><td align="left">网站的关键词。支持多个关键词。</td></tr><tr><td align="left"><code>author</code></td><td align="left">您的名字</td></tr><tr><td align="left"><code>language</code></td><td align="left">网站使用的语言。对于简体中文用户来说，使用不同的主题可能需要设置成不同的值，请参考你的主题的文档自行设置，常见的有 <code>zh-Hans</code>和 <code>zh-CN</code>。</td></tr><tr><td align="left"><code>timezone</code></td><td align="left">网站时区。Hexo 默认使用您电脑的时区。请参考 <a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones">时区列表</a> 进行设置，如 <code>America/New_York</code>, <code>Japan</code>, 和 <code>UTC</code> 。一般的，对于中国大陆地区可以使用 <code>Asia/Shanghai</code>。</td></tr></tbody></table><p>其中，<code>description</code>主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。<code>author</code>参数用于主题显示文章的作者。</p><h2 id="网址"><a href="#网址" class="headerlink" title="网址"></a>网址</h2><table><thead><tr><th align="left">参数</th><th align="left">描述</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left"><code>url</code></td><td align="left">网址, 必须以 <code>http://</code> 或 <code>https://</code> 开头</td><td align="left"></td></tr><tr><td align="left"><code>root</code></td><td align="left">网站根目录</td><td align="left"><code>url&#39;s pathname</code></td></tr><tr><td align="left"><code>permalink</code></td><td align="left">文章的 <a href="https://hexo.io/zh-cn/docs/permalinks">永久链接</a> 格式</td><td align="left"><code>:year/:month/:day/:title/</code></td></tr><tr><td align="left"><code>permalink_defaults</code></td><td align="left">永久链接中各部分的默认值</td><td align="left"></td></tr><tr><td align="left"><code>pretty_urls</code></td><td align="left">改写 <a href="https://hexo.io/zh-cn/docs/variables"><code>permalink</code></a> 的值来美化 URL</td><td align="left"></td></tr><tr><td align="left"><code>pretty_urls.trailing_index</code></td><td align="left">是否在永久链接中保留尾部的 <code>index.html</code>，设置为 <code>false</code> 时去除</td><td align="left"><code>true</code></td></tr><tr><td align="left"><code>pretty_urls.trailing_html</code></td><td align="left">是否在永久链接中保留尾部的 <code>.html</code>, 设置为 <code>false</code> 时去除 (<em>对尾部的 <code>index.html</code>无效</em>)</td><td align="left"><code>true</code></td></tr></tbody></table><blockquote><p>网站存放在子目录</p><p>如果您的网站存放在子目录中，例如 <code>http://example.com/blog</code>，则请将您的 <code>url</code> 设为 <code>http://example.com/blog</code> 并把 <code>root</code> 设为 <code>/blog/</code>。</p></blockquote><p>例如：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-meta"># 比如，一个页面的永久链接是 http:<span class="hljs-comment">//example.com/foo/bar/index.html</span></span><br><span class="hljs-symbol">pretty_urls:</span><br><span class="hljs-symbol">  trailing_index:</span> false<br><span class="hljs-meta"># 此时页面的永久链接会变为 http:<span class="hljs-comment">//example.com/foo/bar/</span></span><br></code></pre></td></tr></table></figure><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><table><thead><tr><th align="left">参数</th><th align="left">描述</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left"><code>source_dir</code></td><td align="left">资源文件夹，这个文件夹用来存放内容。</td><td align="left"><code>source</code></td></tr><tr><td align="left"><code>public_dir</code></td><td align="left">公共文件夹，这个文件夹用于存放生成的站点文件。</td><td align="left"><code>public</code></td></tr><tr><td align="left"><code>tag_dir</code></td><td align="left">标签文件夹</td><td align="left"><code>tags</code></td></tr><tr><td align="left"><code>archive_dir</code></td><td align="left">归档文件夹</td><td align="left"><code>archives</code></td></tr><tr><td align="left"><code>category_dir</code></td><td align="left">分类文件夹</td><td align="left"><code>categories</code></td></tr><tr><td align="left"><code>code_dir</code></td><td align="left">Include code 文件夹，<code>source_dir</code> 下的子目录</td><td align="left"><code>downloads/code</code></td></tr><tr><td align="left"><code>i18n_dir</code></td><td align="left">国际化（i18n）文件夹</td><td align="left"><code>:lang</code></td></tr><tr><td align="left"><code>skip_render</code></td><td align="left">跳过指定文件的渲染。匹配到的文件将会被不做改动地复制到 <code>public</code> 目录中。您可使用 <a href="https://github.com/micromatch/micromatch#extended-globbing">glob 表达式</a>来匹配路径。</td><td align="left"></td></tr></tbody></table><p>例如：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gradle">skip_render: <span class="hljs-string">&quot;mypage/**/*&quot;</span><br># 将会直接将 `<span class="hljs-keyword">source</span><span class="hljs-regexp">/mypage/i</span>ndex.html` 和 `<span class="hljs-keyword">source</span><span class="hljs-regexp">/mypage/</span>code.js` 不做改动地输出到 <span class="hljs-string">&#x27;public&#x27;</span> 目录<br># 你也可以用这种方法来跳过对指定文章文件的渲染<br>skip_render: <span class="hljs-string">&quot;_posts/test-post.md&quot;</span><br># 这将会忽略对 <span class="hljs-string">&#x27;test-post.md&#x27;</span> 的渲染<br></code></pre></td></tr></table></figure><blockquote><p>提示</p><p>如果您刚刚开始接触 Hexo，通常没有必要修改这一部分的值。</p></blockquote><h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><table><thead><tr><th align="left">参数</th><th align="left">描述</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left"><code>new_post_name</code></td><td align="left">新文章的文件名称</td><td align="left">:title.md</td></tr><tr><td align="left"><code>default_layout</code></td><td align="left">预设布局</td><td align="left">post</td></tr><tr><td align="left"><code>auto_spacing</code></td><td align="left">在中文和英文之间加入空格</td><td align="left">false</td></tr><tr><td align="left"><code>titlecase</code></td><td align="left">把标题转换为 title case</td><td align="left">false</td></tr><tr><td align="left"><code>external_link</code></td><td align="left">在新标签中打开链接</td><td align="left">true</td></tr><tr><td align="left"><code>external_link.enable</code></td><td align="left">在新标签中打开链接</td><td align="left"><code>true</code></td></tr><tr><td align="left"><code>external_link.field</code></td><td align="left">对整个网站（<code>site</code>）生效或仅对文章（<code>post</code>）生效</td><td align="left"><code>site</code></td></tr><tr><td align="left"><code>external_link.exclude</code></td><td align="left">需要排除的域名。主域名和子域名如 <code>www</code> 需分别配置</td><td align="left"><code>[]</code></td></tr><tr><td align="left"><code>filename_case</code></td><td align="left">把文件名称转换为 (1) 小写或 (2) 大写</td><td align="left">0</td></tr><tr><td align="left"><code>render_drafts</code></td><td align="left">显示草稿</td><td align="left">false</td></tr><tr><td align="left"><code>post_asset_folder</code></td><td align="left">启动 <a href="https://hexo.io/zh-cn/docs/asset-folders">Asset 文件夹</a></td><td align="left">false</td></tr><tr><td align="left"><code>relative_link</code></td><td align="left">把链接改为与根目录的相对位址</td><td align="left">false</td></tr><tr><td align="left"><code>future</code></td><td align="left">显示未来的文章</td><td align="left">true</td></tr><tr><td align="left"><code>highlight</code></td><td align="left">代码块的设置, 请参考 <a href="https://hexo.io/docs/syntax-highlight#Highlight-js">Highlight.js</a> 进行设置</td><td align="left"></td></tr><tr><td align="left"><code>prismjs</code></td><td align="left">代码块的设置, 请参考 <a href="https://hexo.io/docs/syntax-highlight#PrismJS">PrismJS</a> 进行设置</td><td align="left"></td></tr></tbody></table><blockquote><p>相对地址</p><p>默认情况下，Hexo 生成的超链接都是绝对地址。例如，如果您的网站域名为 <code>example.com</code>,您有一篇文章名为 <code>hello</code>，那么绝对链接可能像这样：<code>http://example.com/hello.html</code>，它是<strong>绝对</strong>于域名的。相对链接像这样：<code>/hello.html</code>，也就是说，无论用什么域名访问该站点，都没有关系，这在进行反向代理时可能用到。通常情况下，建议使用绝对地址。</p></blockquote><h2 id="分类-amp-标签"><a href="#分类-amp-标签" class="headerlink" title="分类 &amp; 标签"></a>分类 &amp; 标签</h2><table><thead><tr><th align="left">参数</th><th align="left">描述</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left"><code>default_category</code></td><td align="left">默认分类</td><td align="left"><code>uncategorized</code></td></tr><tr><td align="left"><code>category_map</code></td><td align="left">分类别名</td><td align="left"></td></tr><tr><td align="left"><code>tag_map</code></td><td align="left">标签别名</td><td align="left"></td></tr></tbody></table><h2 id="日期-时间格式"><a href="#日期-时间格式" class="headerlink" title="日期 / 时间格式"></a>日期 / 时间格式</h2><p>Hexo 使用 <a href="http://momentjs.com/">Moment.js</a> 来解析和显示时间。</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left"><code>date_format</code></td><td align="left">日期格式</td><td align="left"><code>YYYY-MM-DD</code></td></tr><tr><td align="left"><code>time_format</code></td><td align="left">时间格式</td><td align="left"><code>HH:mm:ss</code></td></tr><tr><td align="left"><code>updated_option</code></td><td align="left">当 Front Matter 中没有指定 <a href="https://hexo.io/zh-cn/docs/variables#%E9%A1%B5%E9%9D%A2%E5%8F%98%E9%87%8F"><code>updated</code></a> 时 <code>updated</code> 的取值</td><td align="left"><code>mtime</code></td></tr></tbody></table><blockquote><p>updated_option</p><p><code>updated_option</code> 控制了当 Front Matter 中没有指定 <code>updated</code> 时，<code>updated</code> 如何取值：</p><ul><li><code>mtime</code>: 使用文件的最后修改时间。这是从 Hexo 3.0.0 开始的默认行为。</li><li><code>date</code>: 使用 <code>date</code> 作为 <code>updated</code> 的值。可被用于 Git 工作流之中，因为使用 Git 管理站点时，文件的最后修改日期常常会发生改变</li><li><code>empty</code>: 直接删除 <code>updated</code>。使用这一选项可能会导致大部分主题和插件无法正常工作。</li></ul><p><code>use_date_for_updated</code> 选项已经被废弃，将会在下个重大版本发布时去除。请改为使用 <code>updated_option: &#39;date&#39;</code>。</p></blockquote><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso">use_date_for_updated<span class="hljs-string">` | 启用以后，如果 Front Matter 中没有指定 `</span>updated<span class="hljs-string">`， [`</span>post.updated<span class="hljs-string">`](https://hexo.io/zh-cn/docs/configuration) 将会使用 `</span><span class="hljs-built_in">date</span><span class="hljs-string">` 的值而不是文件的创建时间。在 Git 工作流中这个选项会很有用 | `</span><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><table><thead><tr><th align="left">参数</th><th align="left">描述</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left"><code>per_page</code></td><td align="left">每页显示的文章量 (0 = 关闭分页功能)</td><td align="left"><code>10</code></td></tr><tr><td align="left"><code>pagination_dir</code></td><td align="left">分页目录</td><td align="left"><code>page</code></td></tr></tbody></table><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>theme</code></td><td align="left">当前主题名称。值为<code>false</code>时禁用主题</td></tr><tr><td align="left"><code>theme_config</code></td><td align="left">主题的配置文件。在这里放置的配置会覆盖主题目录下的 <code>_config.yml</code> 中的配置</td></tr><tr><td align="left"><code>deploy</code></td><td align="left">部署部分的设置</td></tr><tr><td align="left"><code>meta_generator</code></td><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta#%E5%B1%9E%E6%80%A7">Meta generator</a> 标签。 值为 <code>false</code> 时 Hexo 不会在头部插入该标签</td></tr></tbody></table><h3 id="包括或不包括目录和文件"><a href="#包括或不包括目录和文件" class="headerlink" title="包括或不包括目录和文件"></a>包括或不包括目录和文件</h3><p>在 Hexo 配置文件中，通过设置 include/exclude 可以让 Hexo 进行处理或忽略某些目录和文件夹。你可以使用 <a href="https://github.com/isaacs/minimatch">glob 表达式</a> 对目录和文件进行匹配。</p><p><code>include</code> and <code>exclude</code> options only apply to the <code>source/</code> folder, whereas <code>ignore</code> option applies to all folders.</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>include</code></td><td align="left">Hexo 默认会忽略隐藏文件和文件夹（包括名称以下划线和 <code>.</code> 开头的文件和文件夹，Hexo 的 <code>_posts</code> 和 <code>_data</code> 等目录除外）。通过设置此字段将使 Hexo 处理他们并将它们复制到 <code>source</code> 目录下。</td></tr><tr><td align="left"><code>exclude</code></td><td align="left">Hexo 会忽略这些文件和目录</td></tr><tr><td align="left"><code>ignore</code></td><td align="left">Ignore files/folders</td></tr></tbody></table><p>举例：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-meta"># <span class="hljs-meta-keyword">Include</span>/Exclude Files/Folders</span><br>include:<br>  - <span class="hljs-string">&quot;.nojekyll&quot;</span><br>  <span class="hljs-meta"># 包括 <span class="hljs-string">&#x27;source/css/_typing.css&#x27;</span></span><br>  - <span class="hljs-string">&quot;css/_typing.css&quot;</span><br>  <span class="hljs-meta"># 包括 <span class="hljs-string">&#x27;source/_css/&#x27;</span> 中的任何文件，但不包括子目录及其其中的文件。</span><br>  - <span class="hljs-string">&quot;_css/*&quot;</span><br>  <span class="hljs-meta"># 包含 <span class="hljs-string">&#x27;source/_css/&#x27;</span> 中的任何文件和子目录下的任何文件</span><br>  - <span class="hljs-string">&quot;_css/**/*&quot;</span><br><br>exclude:<br>  <span class="hljs-meta"># 不包括 <span class="hljs-string">&#x27;source/js/test.js&#x27;</span></span><br>  - <span class="hljs-string">&quot;js/test.js&quot;</span><br>  <span class="hljs-meta"># 不包括 <span class="hljs-string">&#x27;source/js/&#x27;</span> 中的文件、但包括子目录下的所有目录和文件</span><br>  - <span class="hljs-string">&quot;js/*&quot;</span><br>  <span class="hljs-meta"># 不包括 <span class="hljs-string">&#x27;source/js/&#x27;</span> 中的文件和子目录下的任何文件</span><br>  - <span class="hljs-string">&quot;js/**/*&quot;</span><br>  <span class="hljs-meta"># 不包括 <span class="hljs-string">&#x27;source/js/&#x27;</span> 目录下的所有文件名以 <span class="hljs-string">&#x27;test&#x27;</span> 开头的文件，但包括其它文件和子目录下的单文件</span><br>  - <span class="hljs-string">&quot;js/test*&quot;</span><br>  <span class="hljs-meta"># 不包括 <span class="hljs-string">&#x27;source/js/&#x27;</span> 及其子目录中任何以 <span class="hljs-string">&#x27;test&#x27;</span> 开头的文件</span><br>  - <span class="hljs-string">&quot;js/**/test*&quot;</span><br>  <span class="hljs-meta"># 不要用 exclude 来忽略 <span class="hljs-string">&#x27;source/_posts/&#x27;</span> 中的文件。你应该使用 <span class="hljs-string">&#x27;skip_render&#x27;</span>，或者在要忽略的文件的文件名之前加一个下划线 <span class="hljs-string">&#x27;_&#x27;</span></span><br>  <span class="hljs-meta"># 在这里配置一个 - <span class="hljs-string">&quot;_posts/hello-world.md&quot;</span> 是没有用的。</span><br><br>ignore:<br>  <span class="hljs-meta"># Ignore any folder named <span class="hljs-string">&#x27;foo&#x27;</span>.</span><br>  - <span class="hljs-string">&quot;**/foo&quot;</span><br>  <span class="hljs-meta"># Ignore <span class="hljs-string">&#x27;foo&#x27;</span> folder in <span class="hljs-string">&#x27;themes/&#x27;</span> only.</span><br>  - <span class="hljs-string">&quot;**/themes/*/foo&quot;</span><br>  <span class="hljs-meta"># Same as above, but applies to every subfolders of <span class="hljs-string">&#x27;themes/&#x27;</span>.</span><br>  - <span class="hljs-string">&quot;**/themes/**/foo&quot;</span><br></code></pre></td></tr></table></figure><p>列表中的每一项都必须用单引号或双引号包裹起来。</p><p><code>include</code> 和 <code>exclude</code> 并不适用于 <code>themes/</code> 目录下的文件。如果需要忽略 <code>themes/</code> 目录下的部分文件或文件夹，可以使用 <code>ignore</code> 或在文件名之前添加下划线 <code>_</code>。</p><h3 id="使用代替配置文件"><a href="#使用代替配置文件" class="headerlink" title="使用代替配置文件"></a>使用代替配置文件</h3><p>可以在 hexo-cli 中使用 <code>--config</code> 参数来指定自定义配置文件的路径。你可以使用一个 YAML 或 JSON 文件的路径，也可以使用逗号分隔（无空格）的多个 YAML 或 JSON 文件的路径。例如：</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sml"># use <span class="hljs-symbol">&#x27;custom</span>.yml&#x27; <span class="hljs-keyword">in</span> place <span class="hljs-keyword">of</span> <span class="hljs-symbol">&#x27;_config</span>.yml&#x27;<br>$ hexo server --config custom.yml<br><br># use <span class="hljs-symbol">&#x27;custom</span>.yml&#x27; &amp; <span class="hljs-symbol">&#x27;custom2</span>.json&#x27;, prioritizing <span class="hljs-symbol">&#x27;custom3</span>.yml&#x27;, <span class="hljs-keyword">then</span> <span class="hljs-symbol">&#x27;custom2</span>.json&#x27;<br>$ hexo generate --config custom.yml,custom2.json,custom3.yml<br></code></pre></td></tr></table></figure><p>当你指定了多个配置文件以后，Hexo 会按顺序将这部分配置文件合并成一个 <code>_multiconfig.yml</code>。如果遇到重复的配置，排在后面的文件的配置会覆盖排在前面的文件的配置。这个原则适用于任意数量、任意深度的 YAML 和 JSON 文件。</p><p>例如，使用 <code>--options</code> 指定了两个自定义配置文件：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog">$ hexo <span class="hljs-keyword">generate</span> --<span class="hljs-keyword">config</span> custom<span class="hljs-variable">.yml</span>,custom2<span class="hljs-variable">.json</span><br></code></pre></td></tr></table></figure><p>如果 <code>custom.yml</code> 中指定了 <code>foo: bar</code>，在 custom2.json 中指定了 <code>&quot;foo&quot;: &quot;dinosaur&quot;</code>，那么在 <code>_multiconfig.yml</code> 中你会得到 <code>foo: dinosaur</code>。</p><h3 id="使用代替主题配置文件"><a href="#使用代替主题配置文件" class="headerlink" title="使用代替主题配置文件"></a>使用代替主题配置文件</h3><p>通常情况下，Hexo 主题是一个独立的项目，并拥有一个独立的 <code>_config.yml</code> 配置文件。</p><p>除了自行维护独立的主题配置文件，你也可以在其它地方对主题进行配置。</p><p><strong>配置文件中的 <code>theme_config</code></strong></p><blockquote><p>该特性自 Hexo 2.8.2 起提供</p></blockquote><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-meta"># _config.yml</span><br><span class="hljs-symbol">theme:</span> <span class="hljs-string">&quot;my-theme&quot;</span><br><span class="hljs-symbol">theme_config:</span><br><span class="hljs-symbol">  bio:</span> <span class="hljs-string">&quot;My awesome bio&quot;</span><br><span class="hljs-symbol">  foo:</span><br><span class="hljs-symbol">    bar:</span> <span class="hljs-string">&#x27;a&#x27;</span><br><span class="hljs-meta"># themes/my-theme/_config.yml</span><br><span class="hljs-symbol">bio:</span> <span class="hljs-string">&quot;Some generic bio&quot;</span><br><span class="hljs-symbol">logo:</span> <span class="hljs-string">&quot;a-cool-image.png&quot;</span><br><span class="hljs-symbol">  foo:</span><br><span class="hljs-symbol">    baz:</span> <span class="hljs-string">&#x27;b&#x27;</span><br></code></pre></td></tr></table></figure><p>最终主题配置的输出是：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dts">&#123;<br><span class="hljs-symbol">  bio:</span> <span class="hljs-string">&quot;My awesome bio&quot;</span>,<br><span class="hljs-symbol">  logo:</span> <span class="hljs-string">&quot;a-cool-image.png&quot;</span>,<br><span class="hljs-symbol">  foo:</span> &#123;<br><span class="hljs-symbol">    bar:</span> <span class="hljs-string">&quot;a&quot;</span>,<br><span class="hljs-symbol">    baz:</span> <span class="hljs-string">&quot;b&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>独立的 <code>_config.[theme].yml</code> 文件</strong></p><blockquote><p>该特性自 Hexo 5.0.0 起提供</p></blockquote><p>独立的主题配置文件应放置于站点根目录下，支持 <code>yml</code> 或 <code>json</code> 格式。需要配置站点 <code>_config.yml</code> 文件中的 <code>theme</code> 以供 Hexo 寻找 <code>_config.[theme].yml</code> 文件。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-meta"># _config.yml</span><br><span class="hljs-symbol">theme:</span> <span class="hljs-string">&quot;my-theme&quot;</span><br><span class="hljs-meta"># _config.my-theme.yml</span><br><span class="hljs-symbol">bio:</span> <span class="hljs-string">&quot;My awesome bio&quot;</span><br><span class="hljs-symbol">foo:</span><br><span class="hljs-symbol">  bar:</span> <span class="hljs-string">&#x27;a&#x27;</span><br><span class="hljs-meta"># themes/my-theme/_config.yml</span><br><span class="hljs-symbol">bio:</span> <span class="hljs-string">&quot;Some generic bio&quot;</span><br><span class="hljs-symbol">logo:</span> <span class="hljs-string">&quot;a-cool-image.png&quot;</span><br><span class="hljs-symbol">  foo:</span><br><span class="hljs-symbol">    baz:</span> <span class="hljs-string">&#x27;b&#x27;</span><br></code></pre></td></tr></table></figure><p>最终主题配置的输出是：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dts">&#123;<br><span class="hljs-symbol">  bio:</span> <span class="hljs-string">&quot;My awesome bio&quot;</span>,<br><span class="hljs-symbol">  logo:</span> <span class="hljs-string">&quot;a-cool-image.png&quot;</span>,<br><span class="hljs-symbol">  foo:</span> &#123;<br><span class="hljs-symbol">    bar:</span> <span class="hljs-string">&quot;a&quot;</span>,<br><span class="hljs-symbol">    baz:</span> <span class="hljs-string">&quot;b&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>我们强烈建议你将所有的主题配置集中在一处。如果你不得不在多处配置你的主题，那么这些信息对你将会非常有用：Hexo 在合并主题配置时，Hexo 配置文件中的 <code>theme_config</code> 的优先级最高，其次是 <code>_config.[theme].yml</code> 文件，最后是位于主题目录下的 <code>_config.yml</code> 文件。</p></blockquote><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>安装 <code>Hexo </code>完成后，请执行下列命令，<code>Hexo</code> 将会在指定文件夹中新建所需要的文件。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> hexo init &lt;folder&gt;<br><span class="hljs-variable">$</span> <span class="hljs-built_in">cd</span> &lt;folder&gt;<br><span class="hljs-variable">$</span> npm install<br></code></pre></td></tr></table></figure><p>新建完成后，指定文件夹的目录如下：</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sqf">.<br>├── <span class="hljs-variable">_config</span>.yml<br>├── package.json<br>├── scaffolds<br>├── source<br>|   ├── <span class="hljs-variable">_drafts</span><br>|   └── <span class="hljs-variable">_posts</span><br>└── themes<br></code></pre></td></tr></table></figure><h3 id="config-yml"><a href="#config-yml" class="headerlink" title="_config.yml"></a><code>_config.yml</code></h3><p>网站的 <a href="https://hexo.io/zh-cn/docs/configuration">配置</a> 信息，您可以在此配置大部分的参数。</p><h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a><code>package.json</code></h3><p>应用程序的信息。<a href="https://ejs.co/">EJS</a>, <a href="http://learnboost.github.io/stylus/">Stylus</a> 和 <a href="http://daringfireball.net/projects/markdown/">Markdown</a> renderer 已默认安装，您可以自由移除。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">package</span>.json&#123;<br>  <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;hexo-site&quot;</span>,<br>  <span class="hljs-string">&quot;version&quot;</span>: <span class="hljs-string">&quot;0.0.0&quot;</span>,<br>  <span class="hljs-string">&quot;private&quot;</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-string">&quot;hexo&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;version&quot;</span>: <span class="hljs-string">&quot;&quot;</span><br>  &#125;,<br>  <span class="hljs-string">&quot;dependencies&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;hexo&quot;</span>: <span class="hljs-string">&quot;^3.8.0&quot;</span>,<br>    <span class="hljs-string">&quot;hexo-generator-archive&quot;</span>: <span class="hljs-string">&quot;^0.1.5&quot;</span>,<br>    <span class="hljs-string">&quot;hexo-generator-category&quot;</span>: <span class="hljs-string">&quot;^0.1.3&quot;</span>,<br>    <span class="hljs-string">&quot;hexo-generator-index&quot;</span>: <span class="hljs-string">&quot;^0.2.1&quot;</span>,<br>    <span class="hljs-string">&quot;hexo-generator-tag&quot;</span>: <span class="hljs-string">&quot;^0.2.0&quot;</span>,<br>    <span class="hljs-string">&quot;hexo-renderer-ejs&quot;</span>: <span class="hljs-string">&quot;^0.3.1&quot;</span>,<br>    <span class="hljs-string">&quot;hexo-renderer-stylus&quot;</span>: <span class="hljs-string">&quot;^0.3.3&quot;</span>,<br>    <span class="hljs-string">&quot;hexo-renderer-marked&quot;</span>: <span class="hljs-string">&quot;^0.3.2&quot;</span>,<br>    <span class="hljs-string">&quot;hexo-server&quot;</span>: <span class="hljs-string">&quot;^0.3.3&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="scaffolds"><a href="#scaffolds" class="headerlink" title="scaffolds"></a>scaffolds</h3><p><a href="https://hexo.io/zh-cn/docs/writing">模版</a> 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。</p><p>Hexo的模板是指在新建的文章文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。</p><h3 id="source"><a href="#source" class="headerlink" title="source"></a>source</h3><p>资源文件夹是存放用户资源的地方。除 <code>_posts</code> 文件夹之外，开头命名为 <code>_</code> (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 <code>public</code> 文件夹，而其他文件会被拷贝过去。</p><h3 id="themes"><a href="#themes" class="headerlink" title="themes"></a>themes</h3><p><a href="https://hexo.io/zh-cn/docs/themes">主题</a> 文件夹。Hexo 会根据主题来生成静态页面。</p><h1 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h1><p>可以在命令中指定文章的布局（layout），默认为 <code>post</code>，可以通过修改 <code>_config.yml</code> 中的 <code>default_layout</code> 参数来指定默认布局。</p><h3 id="布局（Layout）"><a href="#布局（Layout）" class="headerlink" title="布局（Layout）"></a>布局（Layout）</h3><p>Hexo 有三种默认布局：<code>post</code>、<code>page</code> 和 <code>draft</code>。在创建这三种不同类型的文件时，它们将会被保存到不同的路径；而您自定义的其他布局和 <code>post</code> 相同，都将储存到 <code>source/_posts</code> 文件夹。</p><table><thead><tr><th align="left">布局</th><th align="left">路径</th></tr></thead><tbody><tr><td align="left"><code>post</code></td><td align="left"><code>source/_posts</code></td></tr><tr><td align="left"><code>page</code></td><td align="left"><code>source</code></td></tr><tr><td align="left"><code>draft</code></td><td align="left"><code>source/_drafts</code></td></tr></tbody></table><blockquote><p>Disabling layout</p><p>If you don’t want an article (post/page) to be processed with a theme, set <code>layout: false</code> in its front-matter. Refer to <a href="https://hexo.io/zh-cn/docs/front-matter#%E5%B8%83%E5%B1%80">this section</a> for more details.</p></blockquote><h3 id="文件名称"><a href="#文件名称" class="headerlink" title="文件名称"></a>文件名称</h3><p>Hexo 默认以标题做为文件名称，但您可编辑 <code>new_post_name</code> 参数来改变默认的文件名称，举例来说，设为 <code>:year-:month-:day-:title.md</code> 可让您更方便的通过日期来管理文章。</p><table><thead><tr><th align="left">变量</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>:title</code></td><td align="left">标题（小写，空格将会被替换为短杠）</td></tr><tr><td align="left"><code>:year</code></td><td align="left">建立的年份，比如， <code>2015</code></td></tr><tr><td align="left"><code>:month</code></td><td align="left">建立的月份（有前导零），比如， <code>04</code></td></tr><tr><td align="left"><code>:i_month</code></td><td align="left">建立的月份（无前导零），比如， <code>4</code></td></tr><tr><td align="left"><code>:day</code></td><td align="left">建立的日期（有前导零），比如， <code>07</code></td></tr><tr><td align="left"><code>:i_day</code></td><td align="left">建立的日期（无前导零），比如， <code>7</code></td></tr></tbody></table><h3 id="草稿"><a href="#草稿" class="headerlink" title="草稿"></a>草稿</h3><p>刚刚提到了 Hexo 的一种特殊布局：<code>draft</code>，这种布局在建立时会被保存到 <code>source/_drafts</code> 文件夹，您可通过 <code>publish</code> 命令将草稿移动到 <code>source/_posts</code> 文件夹，该命令的使用方式与 <code>new</code> 十分类似，您也可在命令中指定 <code>layout</code> 来指定布局。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">$ hexo publish [layout] <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><br></code></pre></td></tr></table></figure><p>草稿默认不会显示在页面中，您可在执行时加上 <code>--draft</code> 参数，或是把 <code>render_drafts</code> 参数设为 <code>true</code> 来预览草稿。</p><h2 id="模版（Scaffold）"><a href="#模版（Scaffold）" class="headerlink" title="模版（Scaffold）"></a>模版（Scaffold）</h2><p>在新建文章时，Hexo 会根据 <code>scaffolds</code> 文件夹内相对应的文件来建立文件，例如：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">$ hexo <span class="hljs-keyword">new</span> <span class="hljs-type">photo</span> <span class="hljs-string">&quot;My Gallery&quot;</span><br></code></pre></td></tr></table></figure><p>在执行这行指令时，Hexo 会尝试在 <code>scaffolds</code> 文件夹中寻找 <code>photo.md</code>，并根据其内容建立文章，以下是您可以在模版中使用的变量：</p><table><thead><tr><th align="left">变量</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>layout</code></td><td align="left">布局</td></tr><tr><td align="left"><code>title</code></td><td align="left">标题</td></tr><tr><td align="left"><code>date</code></td><td align="left">文件建立日期</td></tr></tbody></table><h3 id="支持的格式"><a href="#支持的格式" class="headerlink" title="支持的格式"></a>支持的格式</h3><p>Hexo 支持以任何格式书写文章，只要安装了相应的渲染插件。</p><p>例如，Hexo 默认安装了 <code>hexo-renderer-marked</code> 和 <code>hexo-renderer-ejs</code>，因此你不仅可以用 Markdown 写作，你还可以用 EJS 写作。如果你安装了 <code>hexo-renderer-pug</code>，你甚至可以用 Pug 模板语言书写文章。</p><p>只需要将文章的扩展名从 <code>md</code> 改成 <code>ejs</code>，Hexo 就会使用 <code>hexo-renderer-ejs</code> 渲染这个文件，其他格式同理。</p><h1 id="npm相关问题"><a href="#npm相关问题" class="headerlink" title="npm相关问题"></a><code>npm</code>相关问题</h1><h2 id="1-使用npm命令时报错误Error-EACCES-permission-denied，如何解决？"><a href="#1-使用npm命令时报错误Error-EACCES-permission-denied，如何解决？" class="headerlink" title="1.使用npm命令时报错误Error: EACCES: permission denied，如何解决？"></a>1.使用<code>npm</code>命令时报错误<code>Error: EACCES: permission denied</code>，如何解决？</h2><p>官方的解决方案：<a href="https://docs.npmjs.com/getting-started/fixing-npm-permissions">https://docs.npmjs.com/getting-started/fixing-npm-permissions</a></p><p>官方提供了两种解决方案：</p><ol><li><p>重新安装一个node version manager。（官方推荐）<br>参考地址：<a href="https://docs.npmjs.com/getting-started/installing-node">https://docs.npmjs.com/getting-started/installing-node</a><br>注：这个方法比较繁琐，我选择的是第二种方案。</p></li><li><p>改变<code>npm</code>默认的路径。</p><p>步骤如下：</p></li></ol><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">进入终端，依次输入一下命令<br>（<span class="hljs-number">1</span>）创建<span class="hljs-built_in">global</span>安装任务的目录<br>mkdir ~/.<span class="hljs-built_in">npm</span>-<span class="hljs-built_in">global</span><br>（<span class="hljs-number">2</span>）配置<span class="hljs-built_in">npm</span>使用新的目录<br><span class="hljs-built_in">npm</span> config set prefix <span class="hljs-string">&#x27;~/.npm-global&#x27;</span><br>（<span class="hljs-number">3</span>）在~/.profile文件中增加配置<br><span class="hljs-keyword">export</span> PATH=~/.<span class="hljs-built_in">npm</span>-<span class="hljs-built_in">global</span>/bin:$PATH<br>（<span class="hljs-number">4</span>）配置文件立即生效<br>source ~<span class="hljs-regexp">/.profile 注：我用的zsh,所以命令是（source ~/</span>.zshrc）<br>（<span class="hljs-number">5</span>）重新执行命令<br><span class="hljs-built_in">npm</span> install -g xxxx <br></code></pre></td></tr></table></figure><h2 id="2-通过npm安装主题在哪"><a href="#2-通过npm安装主题在哪" class="headerlink" title="2.通过npm安装主题在哪"></a>2.通过npm安装主题在哪</h2><ul><li>在博客文件夹的node_modules目录下</li></ul><h2 id="3-查看本地安装的所有npm包"><a href="#3-查看本地安装的所有npm包" class="headerlink" title="3. 查看本地安装的所有npm包"></a>3. 查看本地安装的所有npm包</h2><ol><li>查看</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">$ npm list -g --depth 0  // 若需要权限 请加上 sudo 命令<br></code></pre></td></tr></table></figure><ol start="2"><li>更新</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">$ npm update -g xxx<br></code></pre></td></tr></table></figure><ol start="3"><li>删除</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">$ npm uninstall -g xxx<br></code></pre></td></tr></table></figure><h1 id="将-Hexo-部署到-GitHub-Pages"><a href="#将-Hexo-部署到-GitHub-Pages" class="headerlink" title="将 Hexo 部署到 GitHub Pages"></a>将 Hexo 部署到 GitHub Pages</h1><p>Hexo 提供了快速方便的一键部署功能，让您只需一条命令就能将网站部署到服务器上。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>hexo deploy<br></code></pre></td></tr></table></figure><p>在开始之前，您必须先在 <code>_config.yml</code> 中修改参数，一个正确的部署配置中至少要有 <code>type</code> 参数，例如：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br></code></pre></td></tr></table></figure><p>您可同时使用多个 deployer，Hexo 会依照顺序执行每个 deployer。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repo:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">type:</span> <span class="hljs-string">heroku</span><br>  <span class="hljs-attr">repo:</span><br></code></pre></td></tr></table></figure><p>Refer to the <a href="https://hexo.io/plugins/">Plugins</a> list for more deployment plugins.</p><blockquote><p>缩进</p><p>YAML依靠缩进来确定元素间的从属关系。因此，请确保每个deployer的缩进长度相同，并且使用空格缩进。</p></blockquote><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><ol><li>安装 <a href="https://github.com/hexojs/hexo-deployer-git">hexo-deployer-git</a>。</li></ol><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">$ npm install hexo-deployer-git <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><ol><li>修改配置。</li></ol><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repo:</span> <span class="hljs-params">&lt;repository url&gt;</span> <span class="hljs-meta">#https:<span class="hljs-comment">//bitbucket.org/JohnSmith/johnsmith.bitbucket.io</span></span><br><span class="hljs-symbol">  branch:</span> [branch]<br><span class="hljs-symbol">  message:</span> [message]<br></code></pre></td></tr></table></figure><table><thead><tr><th align="left">参数</th><th align="left">描述</th><th align="left">默认</th></tr></thead><tbody><tr><td align="left"><code>repo</code></td><td align="left">库（Repository）地址</td><td align="left"></td></tr><tr><td align="left"><code>branch</code></td><td align="left">分支名称</td><td align="left"><code>gh-pages</code> (GitHub) <code>coding-pages</code> (Coding.net) <code>master</code> (others)</td></tr><tr><td align="left"><code>message</code></td><td align="left">自定义提交信息</td><td align="left"><code>Site updated: &#123;&#123; now('YYYY-MM-DD HH:mm:ss') &#125;&#125;</code>)</td></tr><tr><td align="left"><code>token</code></td><td align="left">Optional token value to authenticate with the repo. Prefix with <code>$</code> to read token from environment variable</td><td align="left"></td></tr></tbody></table><ol><li>生成站点文件并推送至远程库。执行 <code>hexo clean &amp;&amp; hexo deploy</code>。</li></ol><ul><li>You will be prompted with username and password of the target repository, unless you authenticate with a token or ssh key.</li><li>hexo-deployer-git does not store your username and password. Use <a href="https://git-scm.com/docs/git-credential-cache">git-credential-cache</a> to store them temporarily.</li></ul><ol><li>登入 Github/BitBucket/Gitlab，请在库设置（Repository Settings）中将默认分支设置为<code>_config.yml</code>配置中的分支名称。稍等片刻，您的站点就会显示在您的Github Pages中。</li></ol><h3 id="这一切是如何发生的？"><a href="#这一切是如何发生的？" class="headerlink" title="这一切是如何发生的？"></a>这一切是如何发生的？</h3><p>当执行 <code>hexo deploy</code> 时，Hexo 会将 <code>public</code> 目录中的文件和目录推送至 <code>_config.yml</code> 中指定的远端仓库和分支中，并且<strong>完全覆盖</strong>该分支下的已有内容。</p><blockquote><p>For 使用 Git 管理站点目录的用户</p><p>由于 Hexo 的部署默认使用分支 <code>master</code>，所以如果你同时正在使用 Git 管理你的站点目录，你应当注意你的部署分支应当不同于写作分支。<br>一个好的实践是将站点目录和 Pages 分别存放在两个不同的 Git 仓库中，可以有效避免相互覆盖。<br>Hexo 在部署你的站点生成的文件时并不会更新你的站点目录。因此你应该手动提交并推送你的写作分支。</p></blockquote><p>此外，如果您的 Github Pages 需要使用 CNAME 文件<strong>自定义域名</strong>，请将 CNAME 文件置于 <code>source</code> 目录下，只有这样 <code>hexo deploy</code> 才能将 CNAME 文件一并推送至部署分支。</p><h2 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h2><p>Hexo 生成的所有文件都放在 <code>public</code> 文件夹中，您可以将它们复制到您喜欢的地方。</p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><ol><li>安装 <a href="https://github.com/hexojs/hexo-deployer-git">hexo-deployer-git</a>.</li><li>在 <strong>_config.yml</strong>（如果有已存在的请删除）添加如下配置：</li></ol><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repo:</span> https:<span class="hljs-comment">//github.com/&lt;username&gt;/&lt;project&gt;</span><br>  <span class="hljs-meta"># example, https:<span class="hljs-comment">//github.com/hexojs/hexojs.github.io</span></span><br><span class="hljs-symbol">  branch:</span> gh-pages<br></code></pre></td></tr></table></figure><ol><li>运行 <code>hexo clean &amp;&amp; hexo deploy</code> 。</li><li>查看 <em>username</em>.github.io 上的网页是否部署成功。</li></ol><h1 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h1><h2 id="init"><a href="#init" class="headerlink" title="init"></a>init</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">$ hexo <span class="hljs-keyword">init</span> [folder]<br></code></pre></td></tr></table></figure><p>新建一个网站。如果没有设置 <code>folder</code> ，Hexo 默认在目前的文件夹建立网站。</p><p>本命令相当于执行了以下几步：</p><ol><li>Git clone <a href="https://github.com/hexojs/hexo-starter">hexo-starter</a> 和 <a href="https://github.com/hexojs/hexo-theme-landscape">hexo-theme-landscape</a> 主题到当前目录或指定目录。</li><li>使用 <a href="https://classic.yarnpkg.com/lang/en/">Yarn 1</a>、<a href="https://pnpm.js.org/">pnpm</a> 或 <a href="https://docs.npmjs.com/cli/install">npm</a> 包管理器下载依赖（如有已安装多个，则列在前面的优先）。npm 默认随 <a href="https://hexo.io/docs/#Install-Node-js">Node.js</a> 安装。</li></ol><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss">$ hexo <span class="hljs-keyword">new</span> [layout] &lt;<span class="hljs-built_in">title</span>&gt;<br></code></pre></td></tr></table></figure><p>新建一篇文章。如果没有设置 <code>layout</code> 的话，默认使用 <a href="https://hexo.io/zh-cn/docs/configuration">_config.yml</a> 中的 <code>default_layout</code> 参数代替。如果标题包含空格的话，请使用引号括起来。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">$ hexo <span class="hljs-keyword">new</span> <span class="hljs-string">&quot;post title with whitespace&quot;</span><br></code></pre></td></tr></table></figure><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-p</code>, <code>--path</code></td><td align="left">自定义新文章的路径</td></tr><tr><td align="left"><code>-r</code>, <code>--replace</code></td><td align="left">如果存在同名文章，将其替换</td></tr><tr><td align="left"><code>-s</code>, <code>--slug</code></td><td align="left">文章的 Slug，作为新文章的文件名和发布后的 URL</td></tr></tbody></table><p>默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 <code>index.md</code> 文件。你可以使用 <code>--path</code> 参数来覆盖上述行为、自行决定文件的目录：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">hexo <span class="hljs-keyword">new</span> <span class="hljs-type">page</span> --path about/me <span class="hljs-string">&quot;About me&quot;</span><br></code></pre></td></tr></table></figure><p>以上命令会创建一个 <code>source/about/me.md</code> 文件，同时 Front Matter 中的 title 为 <code>&quot;About me&quot;</code></p><p>注意！title 是必须指定的！如果你这么做并不能达到你的目的：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">hexo <span class="hljs-keyword">new</span> page <span class="hljs-comment">--path about/me</span><br></code></pre></td></tr></table></figure><p>此时 Hexo 会创建 <code>source/_posts/about/me.md</code>，同时 <code>me.md</code> 的 Front Matter 中的 title 为 <code>&quot;page&quot;</code>。这是因为在上述命令中，hexo-cli 将 <code>page</code> 视为指定文章的标题、并采用默认的 <code>layout</code>。</p><h2 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h2><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog">$ hexo <span class="hljs-keyword">generate</span><br></code></pre></td></tr></table></figure><p>生成静态文件。</p><table><thead><tr><th align="left">选项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-d</code>, <code>--deploy</code></td><td align="left">文件生成后立即部署网站</td></tr><tr><td align="left"><code>-w</code>, <code>--watch</code></td><td align="left">监视文件变动</td></tr><tr><td align="left"><code>-b</code>, <code>--bail</code></td><td align="left">生成过程中如果发生任何未处理的异常则抛出异常</td></tr><tr><td align="left"><code>-f</code>, <code>--force</code></td><td align="left">强制重新生成文件 Hexo 引入了差分机制，如果 <code>public</code> 目录存在，那么 <code>hexo g</code> 只会重新生成改动的文件。 使用该参数的效果接近 <code>hexo clean &amp;&amp; hexo generate</code></td></tr><tr><td align="left"><code>-c</code>, <code>--concurrency</code></td><td align="left">最大同时生成文件的数量，默认无限制</td></tr></tbody></table><p>该命令可以简写为</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>hexo g<br></code></pre></td></tr></table></figure><h2 id="publish"><a href="#publish" class="headerlink" title="publish"></a>publish</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">$ hexo publish [layout] <span class="hljs-tag">&lt;<span class="hljs-name">filename</span>&gt;</span><br></code></pre></td></tr></table></figure><p>发表草稿。</p><h2 id="server"><a href="#server" class="headerlink" title="server"></a>server</h2><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">$ hexo <span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><p>启动服务器。默认情况下，访问网址为： <code>http://localhost:4000/</code>。</p><table><thead><tr><th align="left">选项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-p</code>, <code>--port</code></td><td align="left">重设端口</td></tr><tr><td align="left"><code>-s</code>, <code>--static</code></td><td align="left">只使用静态文件</td></tr><tr><td align="left"><code>-l</code>, <code>--log</code></td><td align="left">启动日记记录，使用覆盖记录格式</td></tr></tbody></table><h2 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h2><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>hexo deploy<br></code></pre></td></tr></table></figure><p>部署网站。</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-g</code>, <code>--generate</code></td><td align="left">部署之前预先生成静态文件</td></tr></tbody></table><p>该命令可以简写为：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>hexo d<br></code></pre></td></tr></table></figure><h2 id="render"><a href="#render" class="headerlink" title="render"></a>render</h2><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs prolog">$ hexo render &lt;file1&gt; [file2] ...<br></code></pre></td></tr></table></figure><p>渲染文件。</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-o</code>, <code>--output</code></td><td align="left">设置输出路径</td></tr></tbody></table><h2 id="migrate"><a href="#migrate" class="headerlink" title="migrate"></a>migrate</h2><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm">$ hexo migrate &lt;<span class="hljs-keyword">type</span>&gt;<br></code></pre></td></tr></table></figure><p>从其他博客系统 <a href="https://hexo.io/zh-cn/docs/migration">迁移内容</a>。</p><h2 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h2><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>hexo clean<br></code></pre></td></tr></table></figure><p>清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。</p><p>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p><h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm">$ hexo list &lt;<span class="hljs-keyword">type</span>&gt;<br></code></pre></td></tr></table></figure><p>列出网站资料。</p><h2 id="version"><a href="#version" class="headerlink" title="version"></a>version</h2><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">$ hexo <span class="hljs-built_in">version</span><br></code></pre></td></tr></table></figure><p>显示 Hexo 版本。</p><h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><p>其实第三条的 hexo d 就是部署网站命令，d是deploy的缩写。完成后，打开浏览器，在地址栏输入你的放置个人网站的仓库路径，即” <a href="http://xxxx.github.io&quot;,就可以看到你的博客,使用hexo/">http://xxxx.github.io&quot;,就可以看到你的博客,使用Hexo</a> Admin 插件写博客, <a href="%E2%80%9Dhttps://jaredforsyth.com/hexo-admin/%22">官网链接:</a><br>    安装方法<br>    第一步:下载启动</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">npm install --save hexo-admin<br>hexo server -d<br>open http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">4000</span><span class="hljs-regexp">/admin/</span><br></code></pre></td></tr></table></figure><p>第二步：配置<br>在Hexo 全局配置文件_config.yml最后添加类似如下内容</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">admin</span>:<span class="hljs-string"></span><br>  <span class="hljs-attr">username</span>: <span class="hljs-string">AlexLin</span><br>  <span class="hljs-attr">password_hash</span>: <span class="hljs-string">be121740bf988b2225a313fa1f107ca1</span><br>  <span class="hljs-attr">secret</span>: <span class="hljs-string">your admin password</span><br><br><span class="hljs-attr">secret</span> :<span class="hljs-string">你的后台管理密码</span><br><span class="hljs-attr">password_hash</span>: <span class="hljs-string">用密码生成的哈希串.</span><br><span class="hljs-meta">若是部署到github</span> <span class="hljs-string">pages,,是不会上传hexo admin的,没有必要添加密码.</span><br></code></pre></td></tr></table></figure><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ul><li>hexo使用theme出现<code>“ &#123;% extends ‘_layout.swig‘ %&#125; &#123;% import ‘_macro/post.swig‘ as post_template %&#125;“</code>问题：</li></ul><p>​    原因是hexo在5.0之后把swig给删除了需要自己手动安装</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> i hexo-renderer-swig<br></code></pre></td></tr></table></figure><p>​    安装时有可能highlights提示版本过低。（install the latest v10 version of Highlight.js）</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> install highlight.js@latest<br></code></pre></td></tr></table></figure><h6 id="注-常用命令"><a href="#注-常用命令" class="headerlink" title="注: 常用命令"></a>注: 常用命令</h6><ul><li>想要删除hexo</li></ul><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">npm uninstall hexo-<span class="hljs-keyword">cli</span> -g<br></code></pre></td></tr></table></figure><p>文件夹中的blog，手动删除。<br>另外，进行重装之前，如果还是在原来位置，必须手动清理了才能迁移安装。  </p><ul><li>其他常用的Hexo 命令  </li></ul><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs axapta">npm install hexo -g <span class="hljs-meta">#安装Hexo</span><br>npm update hexo -g <span class="hljs-meta">#升级  </span><br>hexo init <span class="hljs-meta">#初始化博客  </span><br>hexo n <span class="hljs-string">&quot;我的博客&quot;</span> == hexo <span class="hljs-keyword">new</span> <span class="hljs-string">&quot;我的博客&quot;</span> <span class="hljs-meta">#新建文章(在/source/_posts文件夹中创建)  </span><br>hexo g == hexo generate <span class="hljs-meta">#生成  </span><br>hexo s == hexo <span class="hljs-keyword">server</span> <span class="hljs-meta">#本地部署, 启动服务预览  </span><br>hexo d == hexo deploy <span class="hljs-meta">#部署,部署到github等  </span><br>hexo <span class="hljs-keyword">server</span> <span class="hljs-meta">#Hexo会监视文件变动并自动更新，无须重启服务器  </span><br>hexo <span class="hljs-keyword">server</span> -s <span class="hljs-meta">#静态模式  </span><br>hexo <span class="hljs-keyword">server</span> -p <span class="hljs-number">5000</span> <span class="hljs-meta">#更改端口  </span><br>hexo <span class="hljs-keyword">server</span> -i <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span> <span class="hljs-meta">#自定义 IP  </span><br>hexo clean <span class="hljs-meta">#清除缓存，若是网页正常情况下可以忽略这条命令,清除缓存文件为了避免不必要的错误，在生成静态文件前，强烈建议先运行此命令.它会清除本地站点文件夹下的缓存文件（db.json）和已有的静态文件（public)  </span><br><br>注: 修改配置后,需要 “hexo g”重新生成 . 若是修改了themes的配置 , 可以不用重新生成,直接F5刷新浏览器页面就可以预览.<br>对于上面的两种常用命令, hexo提供了简写 hexo s -g(生成并预览)和hexo g -d(生成并远程部署)  <br></code></pre></td></tr></table></figure><ul><li>完善配置文件  </li></ul><p><a href="%22https://hexo.io/zh-cn/docs/configuration%22">官网链接</a><br>修改hexo的根文件夹里的_config.yml :  </p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs vbnet">先修改<br><span class="hljs-symbol">title:</span> <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-symbol">subtitle:</span> <span class="hljs-comment">&#x27;&#x27;</span><br><span class="hljs-symbol">description:</span> <span class="hljs-comment">&#x27;&#x27;</span><br><span class="hljs-symbol">keywords:</span><br><span class="hljs-symbol">author:</span>  <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-symbol">language:</span> zh-CN #此项注意, language文件夹里可能没有zh-Han , 但是由zh-CN .  <br><span class="hljs-symbol">url:</span><span class="hljs-string">&quot;此处修改为自己的网址&quot;</span><br>主题  <br><span class="hljs-symbol">theme:</span> 修改为themes文件夹下的主题名称<br></code></pre></td></tr></table></figure><p>使用init命令后,有如下文件夹  </p><pre><code>.├── _config.yml├── package.json├── scaffolds├── source|   ├── _drafts|   └── _posts└── themes</code></pre><ol><li>node_modules 是node.js各种库的目录  </li><li>public是生成的网页文件目录  </li><li>Scaffold(模版文件夹)<br>在新建文章时，Hexo 会根据 scaffolds 文件夹内相对应的文件来建立文件.<br>Hexo的模板是指在新建的markdown文件中默认填充的内容。<br>例如，如果修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。也就是说，通过hexo命令每新建一个文章，都会包含指定模板文件中的内容。  </li><li>Cource<br>资源文件夹是存放用户资源的地方，如markdown文章。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去.<br>注意：除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略.  </li><li>themes<br>主题文件夹。Hexo 会根据主题来解析source目录中的markdown文件生成静态页面。官网主题详述</li><li>package.json<br>应用程序的信息，以及需要安装的模块信息</li></ol><ul><li>写作,可以执行下列命令来创建一篇新文章。  </li></ul><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss">$ hexo <span class="hljs-keyword">new</span> [layout] &lt;<span class="hljs-built_in">title</span>&gt;<br></code></pre></td></tr></table></figure><p>可以在命令中指定文章的布局（layout），不指定默认为 post，也可以通过修改 _config.yml 中的 default_layout 参数来指定默认布局。创建的新文章会自动加上指定布局对应的模板文件中的内容。 </p><ul><li><p>布局<br>Hexo 有三种默认布局（Layout）：post、page 和 draft，它们分别对应不同的路径，而自定义的其他布局和 post 相同，都将储存到 source/_posts 文件夹.<br>如果你不想你的文章被处理，你可以将 Front-Matter 中的layout: 设为 false  </p></li><li><p>模板<br>例如  </p></li></ul><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">$ hexo <span class="hljs-keyword">new</span> <span class="hljs-type">photo</span> <span class="hljs-string">&quot;My Gallery&quot;</span><br></code></pre></td></tr></table></figure><p>在执行这行指令时，Hexo 会尝试在 scaffolds 文件夹中寻找 photo.md，并根据其内容建立文章. 以下是您可以在模版中使用的变量：<br>变量描述 :<br><code>layout</code>布局<br><code>title</code>标题<br><code>date</code>文件建立日期  </p><ul><li>Front-matter<br>Front-matter是文件最上方以 — 分隔的区域，用于指定个别文件的变量，举例来说：</li></ul><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs applescript"> <span class="hljs-comment">---</span><br>title: Hello World<br><span class="hljs-built_in">date</span>: <span class="hljs-number">2013</span>/<span class="hljs-number">7</span>/<span class="hljs-number">13</span> <span class="hljs-number">20</span>:<span class="hljs-number">46</span>:<span class="hljs-number">25</span><br> <span class="hljs-comment">---</span><br></code></pre></td></tr></table></figure><p><code>注意：一般Front-matter使用的yaml语法，yaml语法需要注意空格，如title: Hello World冒号需要有一个空格，当然除YAML 外，你也可以使用 JSON 来编写 Front-matter。</code></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>java注解-网络博客</title>
    <link href="/2021/12/23/java%E6%B3%A8%E8%A7%A3-%E7%BD%91%E7%BB%9C%E5%8D%9A%E5%AE%A2/"/>
    <url>/2021/12/23/java%E6%B3%A8%E8%A7%A3-%E7%BD%91%E7%BB%9C%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a><strong>一、<a href="https://www.baeldung.com/java-annotation-processing-builder">介绍</a></strong></h2><p>本文<strong>介绍了 Java 源代码级别的注释处理，</strong>并提供了使用此技术在编译期间生成其他源文件的示例。</p><h2 id="2-注解处理的应用"><a href="#2-注解处理的应用" class="headerlink" title="2.注解处理的应用"></a><strong>2.注解处理的应用</strong></h2><p>源代码级注释处理首先出现在 Java 5 中。它是一种在编译阶段生成额外源文件的便捷技术。</p><p>源文件不必是 Java 文件——您可以根据源代码中的注释生成任何类型的描述、元数据、文档、资源或任何其他类型的文件。</p><p>注释处理在许多无处不在的 Java 库中被积极使用，例如，在 QueryDSL 和 JPA 中生成元类，在 Lombok 库中使用样板代码扩充类。</p><p>需要注意的重要一点是<strong>注解处理 API 的局限性——它只能用于生成新文件，不能用于更改现有文件</strong>。</p><p>值得注意的例外是<a href="https://projectlombok.org/">Lombok</a>库，它使用注解处理作为引导机制将自身包含到编译过程中并通过一些内部编译器 API 修改 AST。这种 hacky 技术与注释处理的预期目的无关，因此不在本文中讨论。</p><h2 id="3-注解处理API"><a href="#3-注解处理API" class="headerlink" title="3.注解处理API"></a><strong>3.注解处理API</strong></h2><p>注释处理分多轮完成。每一轮都从编译器开始搜索源文件中的注释并选择适合这些注释的注释处理器。依次在相应的源上调用每个注释处理器。</p><p>如果在此过程中生成了任何文件，则以生成的文件作为其输入开始另一轮。这个过程一直持续到在处理阶段没有新文件产生。</p><p>依次在相应的源上调用每个注释处理器。如果在此过程中生成了任何文件，则以生成的文件作为其输入开始另一轮。这个过程一直持续到在处理阶段没有新文件产生。</p><p>注释处理 API 位于<em>javax.annotation.processing</em>包中。您必须实现的主要接口是<em>Processor</em>接口，它具有<em>AbstractProcessor</em>类形式的部分实现。这个类是我们将要扩展以创建我们自己的注释处理器的类。</p><h2 id="4-设置项目"><a href="#4-设置项目" class="headerlink" title="4. 设置项目"></a><strong>4. 设置项目</strong></h2><p>为了演示注释处理的可能性，我们将开发一个简单的处理器来为带注释的类生成流畅的对象构建器。</p><p>我们将把我们的项目分成两个 Maven 模块。其中一个，<em>注释处理器</em>模块，将包含处理器本身和注释，另一个，<em>注释用户</em>模块，将包含被注释的类。这是注释处理的典型用例。</p><p><em>annotation-processor</em>模块的设置如下。我们将使用 Google 的<a href="https://github.com/google/auto/tree/master/service">自动服务</a>库来生成稍后将讨论的处理器元数据文件，以及针对 Java 8 源代码调整的<em>maven-compiler-plugin</em>。这些依赖项的版本被提取到属性部分。</p><p>最新版本的[自动服务](<a href="https://search.maven.org/classic/#search|gav|1|g%3A&quot;com.google.auto.service&quot;">https://search.maven.org/classic/#search|gav|1|g%3A&quot;com.google.auto.service&quot;</a> AND a%3A”auto-service”)库和[maven-compiler-plugin](<a href="https://search.maven.org/classic/#search|gav|1|g%3A&quot;org.apache.maven.plugins&quot;">https://search.maven.org/classic/#search|gav|1|g%3A&quot;org.apache.maven.plugins&quot;</a> AND a%3A”maven-compiler-plugin”)可以在 Maven 中央存储库中找到：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">auto-service.version</span>&gt;</span>1.0-rc2<span class="hljs-tag">&lt;/<span class="hljs-name">auto-service.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">maven-compiler-plugin.version</span>&gt;</span><br>      3.5.1<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">maven-compiler-plugin.version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.auto.service<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>auto-service<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;auto-service.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;maven-compiler-plugin.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><p>带有注释源的<em>annotation-user</em> Maven 模块不需要任何特殊调整，除了在依赖项部分添加对 annotation-processor 模块的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baeldung<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>annotation-processing<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="5-定义注释"><a href="#5-定义注释" class="headerlink" title="5. 定义注释"></a><strong>5. 定义注释</strong></h2><p>假设我们的<em>annotation-user</em>模块中有一个简单的 POJO 类，其中包含几个字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-comment">// getters and setters …</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>我们想创建一个构建器助手类来更流畅地实例化<em>Person</em>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Person person = <span class="hljs-keyword">new</span> PersonBuilder()<br>  .setAge(<span class="hljs-number">25</span>)<br>  .setName(<span class="hljs-string">&quot;John&quot;</span>)<br>  .build();<br></code></pre></td></tr></table></figure><p>这个<em>PersonBuilder</em>类是一代的明显选择，因为它的结构完全由<em>Person</em> setter 方法定义。</p><p>让我们在<em>注释处理器</em>模块中为 setter 方法创建一个*@BuilderProperty<em>注释。它将允许我们为每个注释了 setter 方法的类生成</em>Builder*类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> BuilderProperty &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>带有<em>ElementType.METHOD</em>参数的*@Target*注解确保此注解只能放在一个方法上。</p><p>在<em>SOURCE</em>保留策略的手段，这个注释是唯一可用的源处理过程中，而不是在运行时可用。</p><p>带有*@BuilderProperty<em>注解的属性的</em>Person*类将如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-meta">@BuilderProperty</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-meta">@BuilderProperty</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-comment">// getters …</span><br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-实现-处理器"><a href="#6-实现-处理器" class="headerlink" title="6. 实现*处理器*"></a><strong>6. 实现*处理器*</strong></h2><h3 id="6-1-创建一个-AbstractProcessor-子类"><a href="#6-1-创建一个-AbstractProcessor-子类" class="headerlink" title="6.1. 创建一个*AbstractProcessor*子类"></a><strong>6.1. 创建一个*AbstractProcessor*子类</strong></h3><p>我们将从在<em>注释处理器</em>Maven 模块中扩展<em>AbstractProcessor</em>类开始。</p><p>首先，我们应该指定该处理器能够处理的注释，以及支持的源代码版本。这可以通过实施方法进行<em>getSupportedAnnotationTypes</em>和<em>getSupportedSourceVersion</em>的的<em>处理器</em>接口或通过注释你的类*@SupportedAnnotationTypes<em>和</em>@SupportedSourceVersion*注解。</p><p>所述*@AutoService<em>注释是的一部分</em>自动服务*库，并允许生成，这将在下面的章节进行说明处理器的元数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SupportedAnnotationTypes(</span><br><span class="hljs-meta">  &quot;com.baeldung.annotation.processor.BuilderProperty&quot;)</span><br><span class="hljs-meta">@SupportedSourceVersion(SourceVersion.RELEASE_8)</span><br><span class="hljs-meta">@AutoService(Processor.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BuilderProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractProcessor</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">process</span><span class="hljs-params">(Set&lt;? extends TypeElement&gt; annotations, </span></span><br><span class="hljs-params"><span class="hljs-function">      RoundEnvironment roundEnv)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>您不仅可以指定具体的注释类名称，还可以指定通配符，例如<em>“com.baeldung.annotation.*”</em>来处理<em>com.baeldung.annotation</em>包及其所有子包中的注释，甚至可以<em>“*”</em>来处理所有注释.</p><p>我们必须实现的单一方法是处理本身的<em>process</em>方法。编译器为每个包含匹配注释的源文件调用它。</p><p>注释作为第一个<em>Set&lt;? extends TypeElement&gt; annotations</em>参数，有关当前处理轮次的信息作为<em>RoundEnviroment roundEnv</em>参数传递。</p><p>如果您的注释处理器已经处理了所有传递的注释，并且您不希望它们被传递到列表中的其他注释处理器，则返回<em>布尔</em>值应该为<em>true</em>。</p><h3 id="6-2-收集数据"><a href="#6-2-收集数据" class="headerlink" title="6.2. 收集数据"></a><strong>6.2. 收集数据</strong></h3><p>我们的处理器还没有真正做任何有用的事情，所以让我们用代码填充它。</p><p>首先，我们需要遍历在类中找到的所有注释类型——在我们的例子中，<em>注释</em>集将有一个与*@BuilderProperty*注释相对应的元素，即使这个注释在源文件中多次出现。</p><p>尽管如此，为了完整起见，最好将<em>process</em>方法实现为迭代周期：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">process</span><span class="hljs-params">(Set&lt;? extends TypeElement&gt; annotations, </span></span><br><span class="hljs-params"><span class="hljs-function">  RoundEnvironment roundEnv)</span> </span>&#123;<br><br>    <span class="hljs-keyword">for</span> (TypeElement annotation : annotations) &#123;<br>        Set&lt;? extends Element&gt; annotatedElements <br>          = roundEnv.getElementsAnnotatedWith(annotation);<br>        <br>        <span class="hljs-comment">// …</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在此代码中，我们使用<em>RoundEnvironment</em>实例接收所有使用*@BuilderProperty<em>注释的元素。对于</em>Person<em>类，这些元素对应于</em>setName<em>和</em>setAge*方法。</p><p><em>@BuilderProperty</em>注释的用户可能会错误地注释实际上不是 setter 的方法。setter 方法名称应以<em>set</em>开头，并且该方法应接收单个参数。所以让我们把小麦和谷壳分开。</p><p>在以下代码中，我们使用*Collectors.partitioningBy()*收集器将带注释的方法拆分为两个集合：正确注释的 setter 和其他错误注释的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;Boolean, List&lt;Element&gt;&gt; annotatedMethods = annotatedElements.stream().collect(<br>  Collectors.partitioningBy(element -&gt;<br>    ((ExecutableType) element.asType()).getParameterTypes().size() == <span class="hljs-number">1</span><br>    &amp;&amp; element.getSimpleName().toString().startsWith(<span class="hljs-string">&quot;set&quot;</span>)));<br><br>List&lt;Element&gt; setters = annotatedMethods.get(<span class="hljs-keyword">true</span>);<br>List&lt;Element&gt; otherMethods = annotatedMethods.get(<span class="hljs-keyword">false</span>);<br></code></pre></td></tr></table></figure><p>在这里，我们使用<em>Element.asType()<em>方法来接收</em>TypeMirror</em>类的实例，即使我们仅处于源处理阶段，它也为我们提供了一些内省类型的能力。</p><p>我们应该警告用户有关错误注释的方法，因此让我们使用可从<em>AbstractProcessor.processingEnv</em>保护字段访问的<em>Messager</em>实例。以下几行将在源处理阶段为每个错误注释的元素输出错误：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">otherMethods.forEach(element -&gt;<br>  processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,<br>    <span class="hljs-string">&quot;@BuilderProperty must be applied to a setXxx method &quot;</span> <br>      + <span class="hljs-string">&quot;with a single argument&quot;</span>, element));<br></code></pre></td></tr></table></figure><p>当然，如果正确的 setters 集合为空，则继续当前类型元素集合迭代是没有意义的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (setters.isEmpty()) &#123;<br>    <span class="hljs-keyword">continue</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果 setter 集合至少有一个元素，我们将使用它从封闭元素中获取完全限定的类名，在 setter 方法的情况下，它似乎是源类本身：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">String className = ((TypeElement) setters.get(<span class="hljs-number">0</span>)<br>  .getEnclosingElement()).getQualifiedName().toString();<br></code></pre></td></tr></table></figure><p>生成构建器类所需的最后一点信息是 setter 名称与其参数类型名称之间的映射：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;String, String&gt; setterMap = setters.stream().collect(Collectors.toMap(<br>    setter -&gt; setter.getSimpleName().toString(),<br>    setter -&gt; ((ExecutableType) setter.asType())<br>      .getParameterTypes().get(<span class="hljs-number">0</span>).toString()<br>));<br></code></pre></td></tr></table></figure><h3 id="6-3-生成输出文件"><a href="#6-3-生成输出文件" class="headerlink" title="6.3. 生成输出文件"></a><strong>6.3. 生成输出文件</strong></h3><p>现在我们有了生成构建器类所需的所有信息：源类的名称、它的所有 setter 名称以及它们的参数类型。</p><p>为了生成输出文件，我们将使用<em>AbstractProcessor.processingEnv</em>受保护属性中的对象再次提供的<em>Filer</em>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">JavaFileObject builderFile = processingEnv.getFiler()<br>  .createSourceFile(builderClassName);<br><span class="hljs-keyword">try</span> (PrintWriter out = <span class="hljs-keyword">new</span> PrintWriter(builderFile.openWriter())) &#123;<br>    <span class="hljs-comment">// writing generated file to out …</span><br>&#125;<br></code></pre></td></tr></table></figure><p>下面提供了<em>writeBuilderFile</em>方法的完整代码。我们只需要计算源类和构建器类的包名、完全限定的构建器类名和简单类名。其余的代码非常简单。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeBuilderFile</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  String className, Map&lt;String, String&gt; setterMap)</span> </span><br><span class="hljs-function">  <span class="hljs-keyword">throws</span> IOException </span>&#123;<br><br>    String packageName = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">int</span> lastDot = className.lastIndexOf(<span class="hljs-string">&#x27;.&#x27;</span>);<br>    <span class="hljs-keyword">if</span> (lastDot &gt; <span class="hljs-number">0</span>) &#123;<br>        packageName = className.substring(<span class="hljs-number">0</span>, lastDot);<br>    &#125;<br><br>    String simpleClassName = className.substring(lastDot + <span class="hljs-number">1</span>);<br>    String builderClassName = className + <span class="hljs-string">&quot;Builder&quot;</span>;<br>    String builderSimpleClassName = builderClassName<br>      .substring(lastDot + <span class="hljs-number">1</span>);<br><br>    JavaFileObject builderFile = processingEnv.getFiler()<br>      .createSourceFile(builderClassName);<br>    <br>    <span class="hljs-keyword">try</span> (PrintWriter out = <span class="hljs-keyword">new</span> PrintWriter(builderFile.openWriter())) &#123;<br><br>        <span class="hljs-keyword">if</span> (packageName != <span class="hljs-keyword">null</span>) &#123;<br>            out.print(<span class="hljs-string">&quot;package &quot;</span>);<br>            out.print(packageName);<br>            out.println(<span class="hljs-string">&quot;;&quot;</span>);<br>            out.println();<br>        &#125;<br><br>        out.print(<span class="hljs-string">&quot;public class &quot;</span>);<br>        out.print(builderSimpleClassName);<br>        out.println(<span class="hljs-string">&quot; &#123;&quot;</span>);<br>        out.println();<br><br>        out.print(<span class="hljs-string">&quot;    private &quot;</span>);<br>        out.print(simpleClassName);<br>        out.print(<span class="hljs-string">&quot; object = new &quot;</span>);<br>        out.print(simpleClassName);<br>        out.println(<span class="hljs-string">&quot;();&quot;</span>);<br>        out.println();<br><br>        out.print(<span class="hljs-string">&quot;    public &quot;</span>);<br>        out.print(simpleClassName);<br>        out.println(<span class="hljs-string">&quot; build() &#123;&quot;</span>);<br>        out.println(<span class="hljs-string">&quot;        return object;&quot;</span>);<br>        out.println(<span class="hljs-string">&quot;    &#125;&quot;</span>);<br>        out.println();<br><br>        setterMap.entrySet().forEach(setter -&gt; &#123;<br>            String methodName = setter.getKey();<br>            String argumentType = setter.getValue();<br><br>            out.print(<span class="hljs-string">&quot;    public &quot;</span>);<br>            out.print(builderSimpleClassName);<br>            out.print(<span class="hljs-string">&quot; &quot;</span>);<br>            out.print(methodName);<br><br>            out.print(<span class="hljs-string">&quot;(&quot;</span>);<br><br>            out.print(argumentType);<br>            out.println(<span class="hljs-string">&quot; value) &#123;&quot;</span>);<br>            out.print(<span class="hljs-string">&quot;        object.&quot;</span>);<br>            out.print(methodName);<br>            out.println(<span class="hljs-string">&quot;(value);&quot;</span>);<br>            out.println(<span class="hljs-string">&quot;        return this;&quot;</span>);<br>            out.println(<span class="hljs-string">&quot;    &#125;&quot;</span>);<br>            out.println();<br>        &#125;);<br><br>        out.println(<span class="hljs-string">&quot;&#125;&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-运行示例"><a href="#7-运行示例" class="headerlink" title="7. 运行示例"></a><strong>7. 运行示例</strong></h2><p>要查看代码生成的运行情况，您应该从公共父根编译两个模块，或者首先编译<em>annotation-processor</em>模块，然后编译<em>annotation-user</em>模块。</p><p>生成的<em>PersonBuilder</em>类可以在<em>annotation-user/target/generated-sources/annotations/com/baeldung/annotation/PersonBuilder.java</em>文件中找到，应该如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.baeldung.annotation;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonBuilder</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Person object = <span class="hljs-keyword">new</span> Person();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Person <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> object;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PersonBuilder <span class="hljs-title">setName</span><span class="hljs-params">(java.lang.String value)</span> </span>&#123;<br>        object.setName(value);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PersonBuilder <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        object.setAge(value);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-注册处理器的其他方式"><a href="#8-注册处理器的其他方式" class="headerlink" title="8. 注册处理器的其他方式"></a><strong>8. 注册处理器的其他方式</strong></h2><p>要在编译阶段使用注释处理器，您还有其他几个选项，具体取决于您的用例和您使用的工具。</p><h3 id="8-1-使用注释处理器工具"><a href="#8-1-使用注释处理器工具" class="headerlink" title="8.1. 使用注释处理器工具"></a><strong>8.1. 使用注释处理器工具</strong></h3><p>该<em>贴切</em>工具是用于处理源文件一个特殊的命令行实用程序。它是 Java 5 的一部分，但从 Java 7 开始，它被弃用，取而代之的是其他选项，并在 Java 8 中完全删除。本文不会讨论它。</p><h3 id="8-2-使用编译器密钥"><a href="#8-2-使用编译器密钥" class="headerlink" title="8.2. 使用编译器密钥"></a><strong>8.2. 使用编译器密钥</strong></h3><p>该*-processor*编译器关键是一个标准的JDK设施，以增加编译器的源处理阶段，自己的注释处理器。</p><p>请注意，处理器本身和注释必须已经在单独的编译中编译为类并存在于类路径中，因此您应该做的第一件事是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">javac com/baeldung/annotation/processor/BuilderProcessor<br>javac com/baeldung/annotation/processor/BuilderProperty<br></code></pre></td></tr></table></figure><p>然后，您使用*-processor*键对您的源代码进行实际编译，指定您刚刚编译的注释处理器类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">javac -processor com.baeldung.annotation.processor.MyProcessor Person.java<br></code></pre></td></tr></table></figure><p>要一次性指定多个注释处理器，您可以用逗号分隔它们的类名，如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">javac -processor package1.Processor1,package2.Processor2 SourceFile.java<br></code></pre></td></tr></table></figure><h3 id="8-3-使用-Maven"><a href="#8-3-使用-Maven" class="headerlink" title="8.3. 使用 Maven"></a><strong>8.3. 使用 Maven</strong></h3><p>的<em>Maven的编译器插件</em>允许指定注释处理器作为其结构的一部分。</p><p>这是为编译器插件添加注释处理器的示例。您还可以使用<em>generateSourcesDirectory</em>配置参数指定将生成的源放入的目录。</p><p>请注意，<em>BuilderProcessor</em>类应该已经被编译，例如，从构建依赖项中的另一个 jar 导入：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">encoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">encoding</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">generatedSourcesDirectory</span>&gt;</span>$&#123;project.build.directory&#125;<br>                  /generated-sources/<span class="hljs-tag">&lt;/<span class="hljs-name">generatedSourcesDirectory</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">annotationProcessors</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">annotationProcessor</span>&gt;</span><br>                        com.baeldung.annotation.processor.BuilderProcessor<br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">annotationProcessor</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">annotationProcessors</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="8-4-将处理器-Jar-添加到类路径"><a href="#8-4-将处理器-Jar-添加到类路径" class="headerlink" title="8.4. 将处理器 Jar 添加到类路径"></a><strong>8.4. 将处理器 Jar 添加到类路径</strong></h3><p>您可以简单地将带有处理器类的特殊结构的 jar 添加到编译器的类路径中，而不是在编译器选项中指定注释处理器。</p><p>要自动选择它，编译器必须知道处理器类的名称。因此，您必须在<em>META-INF/services/javax.annotation.processing.Processor</em>文件中将其指定为处理器的完全限定类名：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">com.baeldung.annotation.processor.BuilderProcessor<br></code></pre></td></tr></table></figure><p>您还可以从这个 jar 中指定多个处理器，通过用新行分隔它们来自动拾取：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">package1.Processor1<br>package2.Processor2<br>package3.Processor3<br></code></pre></td></tr></table></figure><p>如果使用Maven构建这个jar，并尝试将这个文件直接放到<em>src/main/resources/META-INF/services</em>目录下，会遇到如下错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">[ERROR] Bad service configuration file, or exception thrown <span class="hljs-keyword">while</span> <br>constructing Processor object: javax.annotation.processing.Processor: <br>Provider com.baeldung.annotation.processor.BuilderProcessor not found<br></code></pre></td></tr></table></figure><p>这是因为当<em>BuilderProcessor</em>文件尚未编译时，编译器会在模块本身的<em>源代码处理</em>阶段尝试使用此文件。在 Maven 构建的资源复制阶段，该文件必须放在另一个资源目录中并复制到<em>META-INF/services</em>目录，或者（甚至更好）在构建期间生成。</p><p>下一节中讨论的 Google<em>自动服务</em>库允许使用简单的注释生成此文件。</p><h3 id="8-5-使用-Google“auto-service”库"><a href="#8-5-使用-Google“auto-service”库" class="headerlink" title="8.5. 使用 Google“auto service”库"></a><strong>8.5. 使用 Google“auto service”库</strong></h3><p>要自动生成注册文件，您可以使用Google 的<em>自动服务</em>库中的*@AutoService*注释，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AutoService(Processor.class)</span><br><span class="hljs-keyword">public</span> BuilderProcessor extends AbstractProcessor &#123;<br>    <span class="hljs-comment">// …</span><br>&#125;<br></code></pre></td></tr></table></figure><p>此注释本身由来自自动服务库的注释处理器处理。该处理器生成包含<em>BuilderProcessor</em>类名的<em>META-INF/services/javax.annotation.processing.Processor</em>文件。</p><h2 id="9-结论"><a href="#9-结论" class="headerlink" title="9. 结论"></a><strong>9. 结论</strong></h2><p>在本文中，我们使用为 POJO 生成 Builder 类的示例演示了源级注释处理。我们还提供了几种在您的项目中注册注释处理器的替代方法。</p><p>本文的源代码可<a href="https://github.com/eugenp/tutorials/tree/master/annotations">在 GitHub 上找到</a>。</p><h1 id="原文："><a href="#原文：" class="headerlink" title="原文："></a>原文：</h1><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a><strong>1. <a href="https://www.baeldung.com/java-annotation-processing-builder">Introduction</a></strong></h2><p>This article is <strong>an intro to Java source-level annotation processing</strong> and provides examples of using this technique for generating additional source files during compilation.</p><h2 id="2-Applications-of-Annotation-Processing"><a href="#2-Applications-of-Annotation-Processing" class="headerlink" title="2. Applications of Annotation Processing"></a><strong>2. Applications of Annotation Processing</strong></h2><p>The source-level annotation processing first appeared in Java 5. It is a handy technique for generating additional source files during the compilation stage.</p><p>The source files don’t have to be Java files — you can generate any kind of description, metadata, documentation, resources, or any other type of files, based on annotations in your source code.</p><p>Annotation processing is actively used in many ubiquitous Java libraries, for instance, to generate metaclasses in QueryDSL and JPA, to augment classes with boilerplate code in Lombok library.</p><p>An important thing to note is <strong>the limitation of the annotation processing API — it can only be used to generate new files, not to change existing ones</strong>.</p><p>The notable exception is the <a href="https://projectlombok.org/">Lombok</a> library which uses annotation processing as a bootstrapping mechanism to include itself into the compilation process and modify the AST via some internal compiler APIs. This hacky technique has nothing to do with the intended purpose of annotation processing and therefore is not discussed in this article.</p><h2 id="3-Annotation-Processing-API"><a href="#3-Annotation-Processing-API" class="headerlink" title="3. Annotation Processing API"></a><strong>3. Annotation Processing API</strong></h2><p>The annotation processing is done in multiple rounds. Each round starts with the compiler searching for the annotations in the source files and choosing the annotation processors suited for these annotations. Each annotation processor, in turn, is called on the corresponding sources.</p><p>If any files are generated during this process, another round is started with the generated files as its input. This process continues until no new files are generated during the processing stage.</p><p>Each annotation processor, in turn, is called on the corresponding sources. If any files are generated during this process, another round is started with the generated files as its input. This process continues until no new files are generated during the processing stage.</p><p>The annotation processing API is located in the <em>javax.annotation.processing</em> package. The main interface that you’ll have to implement is the <em>Processor</em> interface, which has a partial implementation in the form of <em>AbstractProcessor</em> class. This class is the one we’re going to extend to create our own annotation processor.</p><h2 id="4-Setting-Up-the-Project"><a href="#4-Setting-Up-the-Project" class="headerlink" title="4. Setting Up the Project"></a><strong>4. Setting Up the Project</strong></h2><p>To demonstrate the possibilities of annotation processing, we will develop a simple processor for generating fluent object builders for annotated classes.</p><p>We’re going to split our project into two Maven modules. One of them, <em>annotation-processor</em> module, will contain the processor itself together with the annotation, and another, the <em>annotation-user</em> module, will contain the annotated class. This is a typical use case of annotation processing.</p><p>The settings for the <em>annotation-processor</em> module are as follows. We’re going to use the Google’s <a href="https://github.com/google/auto/tree/master/service">auto-service</a> library to generate processor metadata file which will be discussed later, and the <em>maven-compiler-plugin</em> tuned for the Java 8 source code. The versions of these dependencies are extracted to the properties section.</p><p>Latest versions of the [auto-service](<a href="https://search.maven.org/classic/#search|gav|1|g%3A&quot;com.google.auto.service&quot;">https://search.maven.org/classic/#search|gav|1|g%3A&quot;com.google.auto.service&quot;</a> AND a%3A”auto-service”) library and [maven-compiler-plugin](<a href="https://search.maven.org/classic/#search|gav|1|g%3A&quot;org.apache.maven.plugins&quot;">https://search.maven.org/classic/#search|gav|1|g%3A&quot;org.apache.maven.plugins&quot;</a> AND a%3A”maven-compiler-plugin”) can be found in Maven Central repository:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">auto-service.version</span>&gt;</span>1.0-rc2<span class="hljs-tag">&lt;/<span class="hljs-name">auto-service.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">maven-compiler-plugin.version</span>&gt;</span><br>      3.5.1<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">maven-compiler-plugin.version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.auto.service<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>auto-service<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;auto-service.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;maven-compiler-plugin.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><p>The <em>annotation-user</em> Maven module with the annotated sources does not need any special tuning, except adding a dependency on the annotation-processor module in the dependencies section:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baeldung<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>annotation-processing<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="5-Defining-an-Annotation"><a href="#5-Defining-an-Annotation" class="headerlink" title="5. Defining an Annotation"></a><strong>5. Defining an Annotation</strong></h2><p>Suppose we have a simple POJO class in our <em>annotation-user</em> module with several fields:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-comment">// getters and setters …</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>We want to create a builder helper class to instantiate the <em>Person</em> class more fluently:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Person person = <span class="hljs-keyword">new</span> PersonBuilder()<br>  .setAge(<span class="hljs-number">25</span>)<br>  .setName(<span class="hljs-string">&quot;John&quot;</span>)<br>  .build();<br></code></pre></td></tr></table></figure><p>This <em>PersonBuilder</em> class is an obvious choice for a generation, as its structure is completely defined by the <em>Person</em> setter methods.</p><p>Let’s create a <em>@BuilderProperty</em> annotation in the <em>annotation-processor</em> module for the setter methods. It will allow us to generate the <em>Builder</em> class for each class that has its setter methods annotated:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> BuilderProperty &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>The <em>@Target</em> annotation with the <em>ElementType.METHOD</em> parameter ensures that this annotation can be only put on a method.</p><p>The <em>SOURCE</em> retention policy means that this annotation is only available during source processing and is not available at runtime.</p><p>The <em>Person</em> class with properties annotated with the <em>@BuilderProperty</em> annotation will look as follows:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-meta">@BuilderProperty</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-meta">@BuilderProperty</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-comment">// getters …</span><br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-Implementing-a-Processor"><a href="#6-Implementing-a-Processor" class="headerlink" title="6. Implementing a *Processor*"></a><strong>6. Implementing a *Processor*</strong></h2><h3 id="6-1-Creating-an-AbstractProcessor-Subclass"><a href="#6-1-Creating-an-AbstractProcessor-Subclass" class="headerlink" title="6.1. Creating an *AbstractProcessor* Subclass"></a><strong>6.1. Creating an *AbstractProcessor* Subclass</strong></h3><p>We’ll start with extending the <em>AbstractProcessor</em> class inside the <em>annotation-processor</em> Maven module.</p><p>First, we should specify annotations that this processor is capable of processing, and also the supported source code version. This can be done either by implementing the methods <em>getSupportedAnnotationTypes</em> and <em>getSupportedSourceVersion</em> of the <em>Processor</em> interface or by annotating your class with <em>@SupportedAnnotationTypes</em> and <em>@SupportedSourceVersion</em> annotations.</p><p>The <em>@AutoService</em> annotation is a part of the <em>auto-service</em> library and allows to generate the processor metadata which will be explained in the following sections.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SupportedAnnotationTypes(</span><br><span class="hljs-meta">  &quot;com.baeldung.annotation.processor.BuilderProperty&quot;)</span><br><span class="hljs-meta">@SupportedSourceVersion(SourceVersion.RELEASE_8)</span><br><span class="hljs-meta">@AutoService(Processor.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BuilderProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractProcessor</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">process</span><span class="hljs-params">(Set&lt;? extends TypeElement&gt; annotations, </span></span><br><span class="hljs-params"><span class="hljs-function">      RoundEnvironment roundEnv)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>You can specify not only the concrete annotation class names but also wildcards, like <em>“com.baeldung.annotation.*”</em> to process annotations inside the <em>com.baeldung.annotation</em> package and all its sub packages, or even <em>“*”</em> to process all annotations.</p><p>The single method that we’ll have to implement is the <em>process</em> method that does the processing itself. It is called by the compiler for every source file containing the matching annotations.</p><p>Annotations are passed as the first <em>Set&lt;? extends TypeElement&gt; annotations</em> argument, and the information about the current processing round is passed as the <em>RoundEnviroment roundEnv</em> argument.</p><p>The return <em>boolean</em> value should be <em>true</em> if your annotation processor has processed all the passed annotations, and you don’t want them to be passed to other annotation processors down the list.</p><h3 id="6-2-Gathering-Data"><a href="#6-2-Gathering-Data" class="headerlink" title="6.2. Gathering Data"></a><strong>6.2. Gathering Data</strong></h3><p>Our processor does not really do anything useful yet, so let’s fill it with code.</p><p>First, we’ll need to iterate through all annotation types that are found in the class — in our case, the <em>annotations</em> set will have a single element corresponding to the <em>@BuilderProperty</em> annotation, even if this annotation occurs multiple times in the source file.</p><p>Still, it’s better to implement the <em>process</em> method as an iteration cycle, for completeness sake:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">process</span><span class="hljs-params">(Set&lt;? extends TypeElement&gt; annotations, </span></span><br><span class="hljs-params"><span class="hljs-function">  RoundEnvironment roundEnv)</span> </span>&#123;<br><br>    <span class="hljs-keyword">for</span> (TypeElement annotation : annotations) &#123;<br>        Set&lt;? extends Element&gt; annotatedElements <br>          = roundEnv.getElementsAnnotatedWith(annotation);<br>        <br>        <span class="hljs-comment">// …</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>In this code, we use the <em>RoundEnvironment</em> instance to receive all elements annotated with the <em>@BuilderProperty</em> annotation. In the case of the <em>Person</em> class, these elements correspond to the <em>setName</em> and <em>setAge</em> methods.</p><p><em>@BuilderProperty</em> annotation’s user could erroneously annotate methods that are not actually setters. The setter method name should start with <em>set</em>, and the method should receive a single argument. So let’s separate the wheat from the chaff.</p><p>In the following code, we use the <em>Collectors.partitioningBy()</em> collector to split annotated methods into two collections: correctly annotated setters and other erroneously annotated methods:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;Boolean, List&lt;Element&gt;&gt; annotatedMethods = annotatedElements.stream().collect(<br>  Collectors.partitioningBy(element -&gt;<br>    ((ExecutableType) element.asType()).getParameterTypes().size() == <span class="hljs-number">1</span><br>    &amp;&amp; element.getSimpleName().toString().startsWith(<span class="hljs-string">&quot;set&quot;</span>)));<br><br>List&lt;Element&gt; setters = annotatedMethods.get(<span class="hljs-keyword">true</span>);<br>List&lt;Element&gt; otherMethods = annotatedMethods.get(<span class="hljs-keyword">false</span>);<br></code></pre></td></tr></table></figure><p>Here we use the <em>Element.asType()</em> method to receive an instance of the <em>TypeMirror</em> class which gives us some ability to introspect types even though we are only at the source processing stage.</p><p>We should warn the user about incorrectly annotated methods, so let’s use the <em>Messager</em> instance accessible from the <em>AbstractProcessor.processingEnv</em> protected field. The following lines will output an error for each erroneously annotated element during the source processing stage:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">otherMethods.forEach(element -&gt;<br>  processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,<br>    <span class="hljs-string">&quot;@BuilderProperty must be applied to a setXxx method &quot;</span> <br>      + <span class="hljs-string">&quot;with a single argument&quot;</span>, element));<br></code></pre></td></tr></table></figure><p>Of course, if the correct setters collection is empty, there is no point of continuing the current type element set iteration:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (setters.isEmpty()) &#123;<br>    <span class="hljs-keyword">continue</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>If the setters collection has at least one element, we’re going to use it to get the fully qualified class name from the enclosing element, which in case of the setter method appears to be the source class itself:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">String className = ((TypeElement) setters.get(<span class="hljs-number">0</span>)<br>  .getEnclosingElement()).getQualifiedName().toString();<br></code></pre></td></tr></table></figure><p>The last bit of information we need to generate a builder class is a map between the names of the setters and the names of their argument types:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;String, String&gt; setterMap = setters.stream().collect(Collectors.toMap(<br>    setter -&gt; setter.getSimpleName().toString(),<br>    setter -&gt; ((ExecutableType) setter.asType())<br>      .getParameterTypes().get(<span class="hljs-number">0</span>).toString()<br>));<br></code></pre></td></tr></table></figure><h3 id="6-3-Generating-the-Output-File"><a href="#6-3-Generating-the-Output-File" class="headerlink" title="6.3. Generating the Output File"></a><strong>6.3. Generating the Output File</strong></h3><p>Now we have all the information we need to generate a builder class: the name of the source class, all its setter names, and their argument types.</p><p>To generate the output file, we’ll use the <em>Filer</em> instance provided again by the object in the <em>AbstractProcessor.processingEnv</em> protected property:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">JavaFileObject builderFile = processingEnv.getFiler()<br>  .createSourceFile(builderClassName);<br><span class="hljs-keyword">try</span> (PrintWriter out = <span class="hljs-keyword">new</span> PrintWriter(builderFile.openWriter())) &#123;<br>    <span class="hljs-comment">// writing generated file to out …</span><br>&#125;<br></code></pre></td></tr></table></figure><p>The complete code of the <em>writeBuilderFile</em> method is provided below. We only need to calculate the package name, fully qualified builder class name, and simple class names for the source class and the builder class. The rest of the code is pretty straightforward.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeBuilderFile</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  String className, Map&lt;String, String&gt; setterMap)</span> </span><br><span class="hljs-function">  <span class="hljs-keyword">throws</span> IOException </span>&#123;<br><br>    String packageName = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">int</span> lastDot = className.lastIndexOf(<span class="hljs-string">&#x27;.&#x27;</span>);<br>    <span class="hljs-keyword">if</span> (lastDot &gt; <span class="hljs-number">0</span>) &#123;<br>        packageName = className.substring(<span class="hljs-number">0</span>, lastDot);<br>    &#125;<br><br>    String simpleClassName = className.substring(lastDot + <span class="hljs-number">1</span>);<br>    String builderClassName = className + <span class="hljs-string">&quot;Builder&quot;</span>;<br>    String builderSimpleClassName = builderClassName<br>      .substring(lastDot + <span class="hljs-number">1</span>);<br><br>    JavaFileObject builderFile = processingEnv.getFiler()<br>      .createSourceFile(builderClassName);<br>    <br>    <span class="hljs-keyword">try</span> (PrintWriter out = <span class="hljs-keyword">new</span> PrintWriter(builderFile.openWriter())) &#123;<br><br>        <span class="hljs-keyword">if</span> (packageName != <span class="hljs-keyword">null</span>) &#123;<br>            out.print(<span class="hljs-string">&quot;package &quot;</span>);<br>            out.print(packageName);<br>            out.println(<span class="hljs-string">&quot;;&quot;</span>);<br>            out.println();<br>        &#125;<br><br>        out.print(<span class="hljs-string">&quot;public class &quot;</span>);<br>        out.print(builderSimpleClassName);<br>        out.println(<span class="hljs-string">&quot; &#123;&quot;</span>);<br>        out.println();<br><br>        out.print(<span class="hljs-string">&quot;    private &quot;</span>);<br>        out.print(simpleClassName);<br>        out.print(<span class="hljs-string">&quot; object = new &quot;</span>);<br>        out.print(simpleClassName);<br>        out.println(<span class="hljs-string">&quot;();&quot;</span>);<br>        out.println();<br><br>        out.print(<span class="hljs-string">&quot;    public &quot;</span>);<br>        out.print(simpleClassName);<br>        out.println(<span class="hljs-string">&quot; build() &#123;&quot;</span>);<br>        out.println(<span class="hljs-string">&quot;        return object;&quot;</span>);<br>        out.println(<span class="hljs-string">&quot;    &#125;&quot;</span>);<br>        out.println();<br><br>        setterMap.entrySet().forEach(setter -&gt; &#123;<br>            String methodName = setter.getKey();<br>            String argumentType = setter.getValue();<br><br>            out.print(<span class="hljs-string">&quot;    public &quot;</span>);<br>            out.print(builderSimpleClassName);<br>            out.print(<span class="hljs-string">&quot; &quot;</span>);<br>            out.print(methodName);<br><br>            out.print(<span class="hljs-string">&quot;(&quot;</span>);<br><br>            out.print(argumentType);<br>            out.println(<span class="hljs-string">&quot; value) &#123;&quot;</span>);<br>            out.print(<span class="hljs-string">&quot;        object.&quot;</span>);<br>            out.print(methodName);<br>            out.println(<span class="hljs-string">&quot;(value);&quot;</span>);<br>            out.println(<span class="hljs-string">&quot;        return this;&quot;</span>);<br>            out.println(<span class="hljs-string">&quot;    &#125;&quot;</span>);<br>            out.println();<br>        &#125;);<br><br>        out.println(<span class="hljs-string">&quot;&#125;&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-Running-the-Example"><a href="#7-Running-the-Example" class="headerlink" title="7. Running the Example"></a><strong>7. Running the Example</strong></h2><p>To see the code generation in action, you should either compile both modules from the common parent root or first compile the <em>annotation-processor</em> module and then the <em>annotation-user</em> module.</p><p>The generated <em>PersonBuilder</em> class can be found inside the <em>annotation-user/target/generated-sources/annotations/com/baeldung/annotation/PersonBuilder.java</em> file and should look like this:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.baeldung.annotation;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonBuilder</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Person object = <span class="hljs-keyword">new</span> Person();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Person <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> object;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PersonBuilder <span class="hljs-title">setName</span><span class="hljs-params">(java.lang.String value)</span> </span>&#123;<br>        object.setName(value);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PersonBuilder <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        object.setAge(value);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-Alternative-Ways-of-Registering-a-Processor"><a href="#8-Alternative-Ways-of-Registering-a-Processor" class="headerlink" title="8. Alternative Ways of Registering a Processor"></a><strong>8. Alternative Ways of Registering a Processor</strong></h2><p>To use your annotation processor during the compilation stage, you have several other options, depending on your use case and the tools you use.</p><h3 id="8-1-Using-the-Annotation-Processor-Tool"><a href="#8-1-Using-the-Annotation-Processor-Tool" class="headerlink" title="8.1. Using the Annotation Processor Tool"></a><strong>8.1. Using the Annotation Processor Tool</strong></h3><p>The <em>apt</em> tool was a special command line utility for processing source files. It was a part of Java 5, but since Java 7 it was deprecated in favour of other options and removed completely in Java 8. It will not be discussed in this article.</p><h3 id="8-2-Using-the-Compiler-Key"><a href="#8-2-Using-the-Compiler-Key" class="headerlink" title="8.2. Using the Compiler Key"></a><strong>8.2. Using the Compiler Key</strong></h3><p>The <em>-processor</em> compiler key is a standard JDK facility to augment the source processing stage of the compiler with your own annotation processor.</p><p>Note that the processor itself and the annotation have to be already compiled as classes in a separate compilation and present on the classpath, so the first thing you should do is:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">javac com/baeldung/annotation/processor/BuilderProcessor<br>javac com/baeldung/annotation/processor/BuilderProperty<br></code></pre></td></tr></table></figure><p>Then you do the actual compilation of your sources with the <em>-processor</em> key specifying the annotation processor class you’ve just compiled:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">javac -processor com.baeldung.annotation.processor.MyProcessor Person.java<br></code></pre></td></tr></table></figure><p>To specify several annotation processors in one go, you can separate their class names with commas, like this:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">javac -processor package1.Processor1,package2.Processor2 SourceFile.java<br></code></pre></td></tr></table></figure><h3 id="8-3-Using-Maven"><a href="#8-3-Using-Maven" class="headerlink" title="8.3. Using Maven"></a><strong>8.3. Using Maven</strong></h3><p>The <em>maven-compiler-plugin</em> allows specifying annotation processors as part of its configuration.</p><p>Here’s an example of adding annotation processor for the compiler plugin. You could also specify the directory to put generated sources into, using the <em>generatedSourcesDirectory</em> configuration parameter.</p><p>Note that the <em>BuilderProcessor</em> class should already be compiled, for instance, imported from another jar in the build dependencies:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">encoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">encoding</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">generatedSourcesDirectory</span>&gt;</span>$&#123;project.build.directory&#125;<br>                  /generated-sources/<span class="hljs-tag">&lt;/<span class="hljs-name">generatedSourcesDirectory</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">annotationProcessors</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">annotationProcessor</span>&gt;</span><br>                        com.baeldung.annotation.processor.BuilderProcessor<br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">annotationProcessor</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">annotationProcessors</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="8-4-Adding-a-Processor-Jar-to-the-Classpath"><a href="#8-4-Adding-a-Processor-Jar-to-the-Classpath" class="headerlink" title="8.4. Adding a Processor Jar to the Classpath"></a><strong>8.4. Adding a Processor Jar to the Classpath</strong></h3><p>Instead of specifying the annotation processor in the compiler options, you may simply add a specially structured jar with the processor class to the classpath of the compiler.</p><p>To pick it up automatically, the compiler has to know the name of the processor class. So you have to specify it in the <em>META-INF/services/javax.annotation.processing.Processor</em> file as a fully qualified class name of the processor:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">com.baeldung.annotation.processor.BuilderProcessor<br></code></pre></td></tr></table></figure><p>You can also specify several processors from this jar to pick up automatically by separating them with a new line:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">package1.Processor1<br>package2.Processor2<br>package3.Processor3<br></code></pre></td></tr></table></figure><p>If you use Maven to build this jar and try to put this file directly into the <em>src/main/resources/META-INF/services</em> directory, you’ll encounter the following error:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">[ERROR] Bad service configuration file, or exception thrown <span class="hljs-keyword">while</span> <br>constructing Processor object: javax.annotation.processing.Processor: <br>Provider com.baeldung.annotation.processor.BuilderProcessor not found<br></code></pre></td></tr></table></figure><p>This is because the compiler tries to use this file during the <em>source-processing</em> stage of the module itself when the <em>BuilderProcessor</em> file is not yet compiled. The file has to be either put inside another resource directory and copied to the <em>META-INF/services</em> directory during the resource copying stage of the Maven build, or (even better) generated during the build.</p><p>The Google <em>auto-service</em> library, discussed in the following section, allows generating this file using a simple annotation.</p><h3 id="8-5-Using-the-Google-auto-service-Library"><a href="#8-5-Using-the-Google-auto-service-Library" class="headerlink" title="8.5. Using the Google *auto-service* Library"></a><strong>8.5. Using the Google *auto-service* Library</strong></h3><p>To generate the registration file automatically, you can use the <em>@AutoService</em> annotation from the Google’s <em>auto-service</em> library, like this:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AutoService(Processor.class)</span><br><span class="hljs-keyword">public</span> BuilderProcessor extends AbstractProcessor &#123;<br>    <span class="hljs-comment">// …</span><br>&#125;<br></code></pre></td></tr></table></figure><p>This annotation is itself processed by the annotation processor from the auto-service library. This processor generates the <em>META-INF/services/javax.annotation.processing.Processor</em> file containing the <em>BuilderProcessor</em> class name.</p><h2 id="9-Conclusion"><a href="#9-Conclusion" class="headerlink" title="9. Conclusion"></a><strong>9. Conclusion</strong></h2><p>In this article, we’ve demonstrated source-level annotation processing using an example of generating a Builder class for a POJO. We have also provided several alternative ways of registering annotation processors in your project.</p><p>The source code for the article is available <a href="https://github.com/eugenp/tutorials/tree/master/annotations">on GitHub</a>.</p><hr><h1 id="官方qpi文档"><a href="#官方qpi文档" class="headerlink" title="官方qpi文档"></a>官方qpi文档</h1><p>可以看到,AbstractProcessor实现了接口Processor,那么,我们在来看下Processor的api文档:</p><blockquote><p>javax.annotation.processing<br> Interface Processor</p><p>All Known Implementing Classes:<br> <a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/AbstractProcessor.html">AbstractProcessor</a></p><hr><p>public interface Processor</p></blockquote><blockquote><p>The interface for an annotation processor.</p></blockquote><blockquote><p>Annotation processing happens in a sequence of <a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/RoundEnvironment.html">rounds</a>. On each round, a processor may be asked to [process](<a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/Processor.html#process">https://link.jianshu.com?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/Processor.html#process</a>(java.util.Set, javax.annotation.processing.RoundEnvironment)) a subset of the annotations found on the source and class files produced by a prior round. The inputs to the first round of processing are the initial inputs to a run of the tool; these initial inputs can be regarded as the output of a virtual zeroth round of processing. If a processor was asked to process on a given round, it will be asked to process on subsequent rounds, including the last round, even if there are no annotations for it to process. The tool infrastructure may also ask a processor to process files generated implicitly by the tool’s operation.<br> Each implementation of a Processor  must provide a public no-argument constructor to be used by tools to instantiate the processor. The tool infrastructure will interact with classes implementing this interface as follows:</p><ol><li>If an existing Processor object is not being used, to create an instance of a processor the tool calls the no-arg constructor of the processor class.</li><li>Next, the tool calls the <a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/Processor.html#init(javax.annotation.processing.ProcessingEnvironment)">init </a> method with an appropriate ProcessingEnvironment .</li><li>Afterwards, the tool calls <a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/Processor.html#getSupportedAnnotationTypes()">getSupportedAnnotationTypes </a>, <a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/Processor.html#getSupportedOptions()">getSupportedOptions </a>, and <a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/Processor.html#getSupportedSourceVersion()">getSupportedSourceVersion </a>. These methods are only called once per run, not on each round.</li><li>As appropriate, the tool calls the [process<br> ](<a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/Processor.html#process">https://link.jianshu.com?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/Processor.html#process</a>(java.util.Set, javax.annotation.processing.RoundEnvironment)) method on the Processor object; a new Processor object is <em>not</em> created for each round.</li></ol><p>If a processor object is created and used without the above protocol being followed, then the processor’s behavior is not defined by this interface specification.The tool uses a <em>discovery process</em> to find annotation processors and decide whether or not they should be run. By configuring the tool, the set of potential processors can be controlled. For example, for a <a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/tools/JavaCompiler.html">JavaCompiler </a> the list of candidate processors to run can be <a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/tools/JavaCompiler.CompilationTask.html#setProcessors(java.lang.Iterable)">set directly</a> or controlled by a <a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/tools/StandardLocation.html#ANNOTATION_PROCESSOR_PATH">search path</a> used for a <a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/java/util/ServiceLoader.html">service-style</a> lookup. Other tool implementations may have different configuration mechanisms, such as command line options; for details, refer to the particular tool’s documentation. Which processors the tool asks to [run](<a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/Processor.html#process">https://link.jianshu.com?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/Processor.html#process</a>(java.util.Set, javax.annotation.processing.RoundEnvironment)) is a function of what annotations are present on the <a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/RoundEnvironment.html#getRootElements()">root elements</a>, what <a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/Processor.html#getSupportedAnnotationTypes()">annotation types a processor processes</a>, and whether or not a processor [claims the annotations it processes](<a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/Processor.html#process">https://link.jianshu.com?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/Processor.html#process</a>(java.util.Set, javax.annotation.processing.RoundEnvironment)). A processor will be asked to process a subset of the annotation types it supports, possibly an empty set. For a given round, the tool computes the set of annotation types on the root elements. If there is at least one annotation type present, as processors claim annotation types, they are removed from the set of unmatched annotations. When the set is empty or no more processors are available, the round has run to completion. If there are no annotation types present, annotation processing still occurs but only <em>universal processors</em> which support processing “<em>“<br> can claim the (empty) set of annotation types.<br> Note that if a processor supports “</em>“<br> and returns true<br> , all annotations are claimed. Therefore, a universal processor being used to, for example, implement additional validity checks should return false<br> so as to not prevent other such checkers from being able to run.<br> If a processor throws an uncaught exception, the tool may cease other active annotation processors. If a processor raises an error, the current round will run to completion and the subsequent round will indicate an <a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/RoundEnvironment.html#errorRaised()">error was raised</a>. Since annotation processors are run in a cooperative environment, a processor should throw an uncaught exception only in situations where no error recovery or reporting is feasible.<br> The tool environment is not required to support annotation processors that access environmental resources, either <a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/RoundEnvironment.html">per round</a> or <a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/ProcessingEnvironment.html">cross-round</a>, in a multi-threaded fashion.<br> If the methods that return configuration information about the annotation processor return null<br> , return other invalid input, or throw an exception, the tool infrastructure must treat this as an error condition.<br> To be robust when running in different tool implementations, an annotation processor should have the following properties:</p><ol><li>The result of processing a given input is not a function of the presence or absence of other inputs (orthogonality).</li><li>Processing the same input produces the same output (consistency).</li><li>Processing input <em>A</em> followed by processing input <em>B</em> is equivalent to processing <em>B</em> then <em>A</em>(commutativity)</li><li>Processing an input does not rely on the presence of the output of other annotation processors (independence)</li></ol><p>The <a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/Filer.html">Filer </a> interface discusses restrictions on how processors can operate on files.<br> Note that implementors of this interface may find it convenient to extend <a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/AbstractProcessor.html">AbstractProcessor </a> rather than implementing this interface directly.</p><p>Since:<br> 1.6</p></blockquote><p>注解处理发生在一系列回合中.每个回合中,注解处理器都有可能被叫去处理由上一次注解产生的源码和类文件中的找到的注解子集.第一次注解处理回合的输入就是工具第一次运行的输入;这些初始输入可以认为是一个虚拟的第零次注解处理回合的输出.如果注解处理器被叫去处理一个特定的回合,那么接下来的回合它都会继续处理,即使后续回合没有它需要处理的注解.注解处理器有可能会被叫去处理由(编译)工具隐式生成的文件.每个注解处理器的实现都必须提供一个公有的无参构造函数,由工具进行实例化.工具会与实现该接口(Processor)的类进行如下交互:</p><ol><li>如果一个已存在的Processor实例未被使用,(编译)工具会调用注解处理器的无参构造函数实例化出一个Processor对象.</li><li>接下来,(编译)工具会调用init函数,并传入一个合适的ProcessingEnvironment.</li><li>之后,(编译)工具会调用getSupportedAnnotationTypes,getSupportedOptions和getSupportedSourceVersion.这些方法只会在每一次运行时被调用一次,而不会在每个注解回合都被调用.</li><li>正常情况下,(编译)工具会调用注解处理器实例的process函数;每个注解回合并不会产生新的注解实例.</li></ol><p>如果一个注解处理器实例被创建,但是使用却没有遵循上述协议,那么这个注解处理器的行为并未被该接口规范定义.(编译)工具使用搜索程序去找到注解处理器并决定它们是否得以运行.通过配置(编译)工具,潜在的注解处理器可以被控制.比如,对于javaCompiler,候选处理器可以直接被指定或者通过使用service-style查找指定搜索路径进行控制.其他(编译)工具可以具有不同的配置机制,比如控制行选项;具体点讲,参考特定工具文档.(编译)工具会调用运行的注解处理器是由root elements指示的注解,是注解处理器处理的注解类型和注解处理器声明它要处理的注解的方法.注解处理器会被叫去处理它支持的注解类型子集,有可能是一个空的集合.在给定回合,(编译)工具会计算root elements的注解类型集合.如果有最少一个注解类型存在,就是注解处理器声明的注解类型之一,它们就会被从未匹配的注解类型集合中移除.当(未匹配)注解集合为空或者没有其它的注解处理器,那么该注解处理回合就结束了.如果没有声明注解类型,只有通用处理器(支持处理”<em>“声明(空)所有注解类型集合)仍然会进行注解处理.注意如果一个注解处理器支持”</em>“并且返回true,则所有的注解类型都被声明.因此,一个通用注解处理器如果被用于实现附加有效检验,那么应该返回false,为了不防止这类检验器得以运行.如果一个注解处理器抛出了一个未捕获异常,(编译)工具可能会停止其他活动的注解处理器.如果一个注解处理器引起了一个错误,当前注解回合会结束,并且后续回合会指明一个错误产生了.因为注解处理器都是运行在共同协作的环境中,只有当错误恢复或报告提交是无法执行的情况下,注解处理器才允许抛出一个未捕获异常.<br> (编译)工具环境不要求要支持注解处理器能以多线程方式在每一回合或交叉回合能访问环境资源.<br> 如果返回注解处理器的配置信息的方法返回null,返回其他无效输入,或者抛出一个异常,(编译)工具必须将这些当做是一个错误条件.<br> 为了在不同的工具实现能够健壮运行,注解处理器必须有以下性能:</p><ol><li>对于一个给定的输入的处理结果,不影响其他输入的存在或缺失(正交性)</li><li>处于相同的输入会产生相同的输出(一致性)</li><li>先处理输入A,然后处于输入B等同于先处理B在处理A(可交换性)</li><li>处理输入会依赖于其他注解处理器的输出(独立性)</li></ol><p>Filer接口讨论了注解处理器操作文件的限定.<br> 请知悉Processor的实现通过继承AbstractProcessor会比直接实现该接口更加方便.</p><p>简单总结如下:</p><ul><li>Annotation Processor可能会被多次调用.</li><li>Annotation Processor被调用一次后,后续若还有注解处理,该Annotation Processor仍然会继续被调用.</li><li>自定义Annotation Processor必须带有一个无参构造函数,让javac进行实例化.</li><li>如果Annotation Processor抛出一个未捕获异常,javac可能会停止其他的Annotation Processor.只有在无法抛出错误或报告的情况下,才允许抛出异常.</li><li>Annotation Processor运行在一个独立的jvm中,所以可以将它看成是一个java应用程序.</li></ul><p>作者：Whyn<br>链接：<a href="https://www.jianshu.com/p/b6b3283968e0">https://www.jianshu.com/p/b6b3283968e0</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><hr><h1 id="插件化注解处理API-Pluggable-Annotation-Processing-API"><a href="#插件化注解处理API-Pluggable-Annotation-Processing-API" class="headerlink" title="插件化注解处理API(Pluggable Annotation Processing API)"></a><a href="https://www.cnblogs.com/throwable/p/9139908.html">插件化注解处理API(Pluggable Annotation Processing API)</a></h1><h1 id="Java奇技淫巧-插件化注解处理API-Pluggable-Annotation-Processing-API"><a href="#Java奇技淫巧-插件化注解处理API-Pluggable-Annotation-Processing-API" class="headerlink" title="Java奇技淫巧-插件化注解处理API(Pluggable Annotation Processing API)"></a>Java奇技淫巧-插件化注解处理API(Pluggable Annotation Processing API)</h1><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://blog.csdn.net/Chinajash/article/details/1471081">JDK6的新特性之六:插入式注解处理API(Pluggable Annotation Processing API)</a></li><li><a href="http://www.baeldung.com/java-annotation-processing-builder">Java Annotation Processing and Creating a Builder</a></li></ul><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>插件化注解处理(Pluggable Annotation Processing)API<a href="http://jcp.org/en/jsr/detail?id=269">JSR 269</a>提供一套标准API来处理Annotations<a href="http://jcp.org/en/jsr/detail?id=175">JSR 175</a>,实际上JSR 269不仅仅用来处理Annotation，我觉得更强大的功能是它建立了Java 语言本身的一个模型,它把method、package、constructor、type、variable、enum、annotation等Java语言元素映射为Types和Elements，从而将Java语言的语义映射成为对象，我们可以在javax.lang.model包下面可以看到这些类。所以我们可以利用JSR 269提供的API来构建一个功能丰富的元编程(metaprogramming)环境。JSR 269用Annotation Processor在编译期间而不是运行期间处理Annotation, Annotation Processor相当于编译器的一个插件,所以称为插入式注解处理.如果Annotation Processor处理Annotation时(执行process方法)产生了新的Java代码，编译器会再调用一次Annotation Processor，如果第二次处理还有新代码产生，就会接着调用Annotation Processor，直到没有新代码产生为止。每执行一次process()方法被称为一个”round”，这样整个Annotation processing过程可以看作是一个round的序列。JSR 269主要被设计成为针对Tools或者容器的API。这个特性虽然在JavaSE 6已经存在，但是很少人知道它的存在。下一篇介绍的<strong>Java奇技淫巧-lombok</strong>就是使用这个特性实现编译期的代码插入的。另外，如果没有猜错，像IDEA在编写代码时候的标记语法错误的红色下划线也是通过这个特性实现的。KAPT(Annotation Processing for Kotlin)，也就是Kotlin的编译也是通过此特性的。</p><p>Pluggable Annotation Processing API的核心是Annotation Processor即注解处理器，一般需要继承抽象类<code>javax.annotation.processing.AbstractProcessor</code>。注意，与运行时注解<code>RetentionPolicy.RUNTIME</code>不同，注解处理器只会处理编译期注解，也就是<code>RetentionPolicy.SOURCE</code>的注解类型，处理的阶段位于Java代码编译期间。</p><h1 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h1><p>插件化注解处理API的使用步骤大概如下：</p><ul><li>1、自定义一个Annotation Processor，需要继承<code>javax.annotation.processing.AbstractProcessor</code>，并覆写process方法。</li><li>2、自定义一个注解，注解的元注解需要指定<code>@Retention(RetentionPolicy.SOURCE)</code>。</li><li>3、需要在声明的自定义Annotation Processor中使用<code>javax.annotation.processing.SupportedAnnotationTypes</code>指定在第2步创建的注解类型的名称(注意需要全类名，”包名.注解类型名称”，否则会不生效)。</li><li>4、需要在声明的自定义Annotation Processor中使用<code>javax.annotation.processing.SupportedSourceVersion</code>指定编译版本。</li><li>5、可选操作，可以通在声明的自定义Annotation Processor中使用<code>javax.annotation.processing.SupportedOptions</code>指定编译参数。</li></ul><h1 id="实战例子"><a href="#实战例子" class="headerlink" title="实战例子"></a>实战例子</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础#"></a>基础<a href="https://www.cnblogs.com/throwable/p/9139908.html#%E5%9F%BA%E7%A1%80">#</a></h2><p>下面我们模仿一下测试框架Junit里面的@Test注解，在运行时通过Annotation Processor获取到使用了自定义的@Test注解对应的方法的信息。因为如果想要动态修改一个类或者方法的代码内容，需要使用到字节码修改工具例如ASM等，这些操作过于深入，日后再谈。先定义一个注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> club.throwable.processor;<br><br><span class="hljs-keyword">import</span> java.lang.annotation.ElementType;<br><span class="hljs-keyword">import</span> java.lang.annotation.Retention;<br><span class="hljs-keyword">import</span> java.lang.annotation.RetentionPolicy;<br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> throwable</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> v1.0</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 2018/5/27 11:18</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Target(&#123;ElementType.METHOD&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Test &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>定义一个注解处理器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SupportedAnnotationTypes(value = &#123;&quot;club.throwable.processor.Test&quot;&#125;)</span><br><span class="hljs-meta">@SupportedSourceVersion(value = SourceVersion.RELEASE_8)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnnotationProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractProcessor</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">process</span><span class="hljs-params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Log in AnnotationProcessor.process&quot;</span>);<br>        <span class="hljs-keyword">for</span> (TypeElement typeElement : annotations) &#123;<br>            System.out.println(typeElement);<br>        &#125;<br>        System.out.println(roundEnv);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编写一个主类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;success&quot;</span>);<br>        test();<br>    &#125;<br><br>    <span class="hljs-meta">@Test(value = &quot;method is test&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span><span class="hljs-keyword">throws</span> Exception</span>&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着需要指定Processor，如果使用IDEA的话，Compiler-&gt;Annotation Processors中的Enable annotation processing必须勾选。然后可以通过下面几种方式指定指定Processor。</p><ul><li>1、直接使用编译参数指定，例如：javac -processor club.throwable.processor.AnnotationProcessor Main.java。</li><li>2、通过服务注册指定，就是META-INF/services/javax.annotation.processing.Processor文件中添加club.throwable.processor.AnnotationProcessor。</li><li>3、通过Maven的编译插件的配置指定如下：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">encoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">encoding</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">annotationProcessors</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">annotationProcessor</span>&gt;</span><br>                club.throwable.processor.AnnotationProcessor<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">annotationProcessor</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">annotationProcessors</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br></code></pre></td></tr></table></figure><p>值得注意的是，以上三点生效的前提是club.throwable.processor.AnnotationProcessor已经被编译过，否则编译的时候就会报错：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-attr">[ERROR]</span> Bad service configuration file, or exception thrown while<br>constructing Processor <span class="hljs-selector-tag">object</span>: javax<span class="hljs-selector-class">.annotation</span><span class="hljs-selector-class">.processing</span><span class="hljs-selector-class">.Processor</span>: <br>Provider club<span class="hljs-selector-class">.throwable</span><span class="hljs-selector-class">.processor</span><span class="hljs-selector-class">.AnnotationProcessor</span> not found<br></code></pre></td></tr></table></figure><p>解决方法有两种，第一种是提前使用命令或者IDEA右键club.throwable.processor.AnnotationProcessor对它进行编译；第二种是把club.throwable.processor.AnnotationProcessor放到一个独立的Jar包引入。我在这里使用第一种方式解决。</p><p>最后，使用Maven命令mvn compile进行编译。输出如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Log <span class="hljs-keyword">in</span> AnnotationProcessor.process<br>[<span class="hljs-attribute">errorRaised</span>=<span class="hljs-literal">false</span>, rootElements=[club.throwable.processor.Test,club.throwable.processor.Main, club.throwable.processor.AnnotationProcessor, <span class="hljs-attribute">processingOver</span>=<span class="hljs-literal">false</span>]<br>Log <span class="hljs-keyword">in</span> AnnotationProcessor.process<br>[<span class="hljs-attribute">errorRaised</span>=<span class="hljs-literal">false</span>, rootElements=[], <span class="hljs-attribute">processingOver</span>=<span class="hljs-literal">false</span>]<br>Log <span class="hljs-keyword">in</span> AnnotationProcessor.process<br>[<span class="hljs-attribute">errorRaised</span>=<span class="hljs-literal">false</span>, rootElements=[], <span class="hljs-attribute">processingOver</span>=<span class="hljs-literal">true</span>]<br></code></pre></td></tr></table></figure><p>可见编译期间AnnotationProcessor生效了。</p><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶#"></a>进阶<a href="https://www.cnblogs.com/throwable/p/9139908.html#%E8%BF%9B%E9%98%B6">#</a></h2><p>下面是一个例子直接修改类的代码，为实体类的Setter方法对应的属性生成一个Builder类，也就是原来的类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-meta">@Builder</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(Integer age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-meta">@Builder</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>生成的Builder类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonBuilder</span> </span>&#123;<br> <br>    <span class="hljs-keyword">private</span> Person object = <span class="hljs-keyword">new</span> Person();<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Person <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> object;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PersonBuilder <span class="hljs-title">setName</span><span class="hljs-params">(java.lang.String value)</span> </span>&#123;<br>        object.setName(value);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PersonBuilder <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        object.setAge(value);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>自定义的注解如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.METHOD&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Builder &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>自定义的注解处理器如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> javax.annotation.processing.AbstractProcessor;<br><span class="hljs-keyword">import</span> javax.annotation.processing.RoundEnvironment;<br><span class="hljs-keyword">import</span> javax.annotation.processing.SupportedAnnotationTypes;<br><span class="hljs-keyword">import</span> javax.annotation.processing.SupportedSourceVersion;<br><span class="hljs-keyword">import</span> javax.lang.model.SourceVersion;<br><span class="hljs-keyword">import</span> javax.lang.model.element.Element;<br><span class="hljs-keyword">import</span> javax.lang.model.element.TypeElement;<br><span class="hljs-keyword">import</span> javax.lang.model.type.ExecutableType;<br><span class="hljs-keyword">import</span> javax.tools.Diagnostic;<br><span class="hljs-keyword">import</span> javax.tools.JavaFileObject;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.PrintWriter;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.util.Set;<br><span class="hljs-keyword">import</span> java.util.stream.Collectors;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> throwable</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> v1.0</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 2018/5/27 11:21</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@SupportedAnnotationTypes(value = &#123;&quot;club.throwable.processor.builder.Builder&quot;&#125;)</span><br><span class="hljs-meta">@SupportedSourceVersion(value = SourceVersion.RELEASE_8)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BuilderProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractProcessor</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">process</span><span class="hljs-params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (TypeElement typeElement : annotations) &#123;<br>            Set&lt;? extends Element&gt; annotatedElements = roundEnv.getElementsAnnotatedWith(typeElement);<br>            Map&lt;Boolean, List&lt;Element&gt;&gt; annotatedMethods<br>                    = annotatedElements.stream().collect(Collectors.partitioningBy(<br>                    element -&gt; ((ExecutableType) element.asType()).getParameterTypes().size() == <span class="hljs-number">1</span><br>                            &amp;&amp; element.getSimpleName().toString().startsWith(<span class="hljs-string">&quot;set&quot;</span>)));<br>            List&lt;Element&gt; setters = annotatedMethods.get(<span class="hljs-keyword">true</span>);<br>            List&lt;Element&gt; otherMethods = annotatedMethods.get(<span class="hljs-keyword">false</span>);<br>            otherMethods.forEach(element -&gt;<br>                    processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,<br>                            <span class="hljs-string">&quot;@Builder must be applied to a setXxx method &quot;</span><br>                                    + <span class="hljs-string">&quot;with a single argument&quot;</span>, element));<br>            Map&lt;String, String&gt; setterMap = setters.stream().collect(Collectors.toMap(<br>                    setter -&gt; setter.getSimpleName().toString(),<br>                    setter -&gt; ((ExecutableType) setter.asType())<br>                            .getParameterTypes().get(<span class="hljs-number">0</span>).toString()<br>            ));<br>            String className = ((TypeElement) setters.get(<span class="hljs-number">0</span>)<br>                    .getEnclosingElement()).getQualifiedName().toString();<br>            <span class="hljs-keyword">try</span> &#123;<br>                writeBuilderFile(className, setterMap);<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeBuilderFile</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">            String className, Map&lt;String, String&gt; setterMap)</span></span><br><span class="hljs-function">            <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        String packageName = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">int</span> lastDot = className.lastIndexOf(<span class="hljs-string">&#x27;.&#x27;</span>);<br>        <span class="hljs-keyword">if</span> (lastDot &gt; <span class="hljs-number">0</span>) &#123;<br>            packageName = className.substring(<span class="hljs-number">0</span>, lastDot);<br>        &#125;<br>        String simpleClassName = className.substring(lastDot + <span class="hljs-number">1</span>);<br>        String builderClassName = className + <span class="hljs-string">&quot;Builder&quot;</span>;<br>        String builderSimpleClassName = builderClassName<br>                .substring(lastDot + <span class="hljs-number">1</span>);<br><br>        JavaFileObject builderFile = processingEnv.getFiler().createSourceFile(builderClassName);<br><br>        <span class="hljs-keyword">try</span> (PrintWriter out = <span class="hljs-keyword">new</span> PrintWriter(builderFile.openWriter())) &#123;<br><br>            <span class="hljs-keyword">if</span> (packageName != <span class="hljs-keyword">null</span>) &#123;<br>                out.print(<span class="hljs-string">&quot;package &quot;</span>);<br>                out.print(packageName);<br>                out.println(<span class="hljs-string">&quot;;&quot;</span>);<br>                out.println();<br>            &#125;<br>            out.print(<span class="hljs-string">&quot;public class &quot;</span>);<br>            out.print(builderSimpleClassName);<br>            out.println(<span class="hljs-string">&quot; &#123;&quot;</span>);<br>            out.println();<br>            out.print(<span class="hljs-string">&quot;    private &quot;</span>);<br>            out.print(simpleClassName);<br>            out.print(<span class="hljs-string">&quot; object = new &quot;</span>);<br>            out.print(simpleClassName);<br>            out.println(<span class="hljs-string">&quot;();&quot;</span>);<br>            out.println();<br>            out.print(<span class="hljs-string">&quot;    public &quot;</span>);<br>            out.print(simpleClassName);<br>            out.println(<span class="hljs-string">&quot; build() &#123;&quot;</span>);<br>            out.println(<span class="hljs-string">&quot;        return object;&quot;</span>);<br>            out.println(<span class="hljs-string">&quot;    &#125;&quot;</span>);<br>            out.println();<br>            setterMap.forEach((methodName, argumentType) -&gt; &#123;<br>                out.print(<span class="hljs-string">&quot;    public &quot;</span>);<br>                out.print(builderSimpleClassName);<br>                out.print(<span class="hljs-string">&quot; &quot;</span>);<br>                out.print(methodName);<br><br>                out.print(<span class="hljs-string">&quot;(&quot;</span>);<br><br>                out.print(argumentType);<br>                out.println(<span class="hljs-string">&quot; value) &#123;&quot;</span>);<br>                out.print(<span class="hljs-string">&quot;        object.&quot;</span>);<br>                out.print(methodName);<br>                out.println(<span class="hljs-string">&quot;(value);&quot;</span>);<br>                out.println(<span class="hljs-string">&quot;        return this;&quot;</span>);<br>                out.println(<span class="hljs-string">&quot;    &#125;&quot;</span>);<br>                out.println();<br>            &#125;);<br>            out.println(<span class="hljs-string">&quot;&#125;&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>主类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>      <span class="hljs-comment">//PersonBuilder在编译之后才会生成，这里需要编译后才能这样写</span><br>      Person person  = <span class="hljs-keyword">new</span> PersonBuilder().setAge(<span class="hljs-number">25</span>).setName(<span class="hljs-string">&quot;doge&quot;</span>).build();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>先手动编译BuilderProcessor，然后在META-INF/services/javax.annotation.processing.Processor文件中添加<code>club.throwable.processor.builder.BuilderProcessor</code>，最后执行Maven命令mvn compile进行编译。</p><p>编译后控制台输出:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[errorRaised=<span class="hljs-literal">false</span>, rootElements=[club.throwable.processor.builder.PersonBuilder], processingOver=<span class="hljs-literal">false</span>]<br></code></pre></td></tr></table></figure><p>编译成功之后，target/classes包下面的club.throwable.processor.builder子包路径中会新增了一个类<code>PersonBuilder</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> club.throwable.processor.builder;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonBuilder</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Person object = <span class="hljs-keyword">new</span> Person();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PersonBuilder</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Person <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.object;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PersonBuilder <span class="hljs-title">setName</span><span class="hljs-params">(String value)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.object.setName(value);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PersonBuilder <span class="hljs-title">setAge</span><span class="hljs-params">(Integer value)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.object.setAge(value);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个类就是编译期新增的。在这个例子中，编译期新增的类貌似没有什么作用。但是，如果像lombok那样对原来的实体类添加新的方法，那样的话就比较有用了。因为些类或者方法是编译期添加的，因此在代码中直接使用会标红。因此，lombok提供了IDEA或者eclipse的插件，插件的功能的实现估计也是用了插件式注解处理API。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>java注解</title>
    <link href="/2021/12/23/java%E6%B3%A8%E8%A7%A3/"/>
    <url>/2021/12/23/java%E6%B3%A8%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="process方法的调用方式"><a href="#process方法的调用方式" class="headerlink" title="process方法的调用方式"></a>process方法的调用方式</h1><p>注释处理分多轮完成。每一轮都从编译器开始搜索源文件中的注释并选择适合这些注释的注释处理器。依次在相应的源上调用每个注释处理器。</p><p>如果在此过程中生成了任何文件，则以生成的文件作为其输入开始另一轮。这个过程一直持续到在处理阶段没有新文件产生。</p><p>依次在相应的源上调用每个注释处理器。如果在此过程中生成了任何文件，则以生成的文件作为其输入开始另一轮。这个过程一直持续到在处理阶段没有新文件产生。</p><p>注释处理 <code>API </code>位于<code>javax.annotation.processing</code>包中。您必须实现的主要接口是<em>Processor</em>接口，它具有<code>AbstractProcessor</code>类形式的部分实现。这个类是我们将要扩展以创建我们自己的注释处理器的类。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">原文：<br>The annotation processing <span class="hljs-keyword">is</span> done <span class="hljs-keyword">in</span> multiple rounds. <span class="hljs-keyword">Each</span> round starts <span class="hljs-keyword">with</span> the compiler searching <span class="hljs-keyword">for</span> the annotations <span class="hljs-keyword">in</span> the source files <span class="hljs-keyword">and</span> choosing the annotation processors suited <span class="hljs-keyword">for</span> these annotations. <span class="hljs-keyword">Each</span> annotation processor, <span class="hljs-keyword">in</span> turn, <span class="hljs-keyword">is</span> <span class="hljs-keyword">called</span> <span class="hljs-keyword">on</span> the corresponding sources.<br><br><span class="hljs-keyword">If</span> <span class="hljs-keyword">any</span> files are <span class="hljs-keyword">generated</span> during this process, another round <span class="hljs-keyword">is</span> started <span class="hljs-keyword">with</span> the <span class="hljs-keyword">generated</span> files <span class="hljs-keyword">as</span> its <span class="hljs-keyword">input</span>. This process continues <span class="hljs-keyword">until</span> <span class="hljs-keyword">no</span> <span class="hljs-built_in">new</span> files are <span class="hljs-keyword">generated</span> during the processing stage.<br><br><span class="hljs-keyword">Each</span> annotation processor, <span class="hljs-keyword">in</span> turn, <span class="hljs-keyword">is</span> <span class="hljs-keyword">called</span> <span class="hljs-keyword">on</span> the corresponding sources. <span class="hljs-keyword">If</span> <span class="hljs-keyword">any</span> files are <span class="hljs-keyword">generated</span> during this process, another round <span class="hljs-keyword">is</span> started <span class="hljs-keyword">with</span> the <span class="hljs-keyword">generated</span> files <span class="hljs-keyword">as</span> its <span class="hljs-keyword">input</span>. This process continues <span class="hljs-keyword">until</span> <span class="hljs-keyword">no</span> <span class="hljs-built_in">new</span> files are <span class="hljs-keyword">generated</span> during the processing stage.<br><br>The annotation processing API <span class="hljs-keyword">is</span> located <span class="hljs-keyword">in</span> the javax.annotation.processing package. The main interface that you’ll have <span class="hljs-keyword">to</span> implement <span class="hljs-keyword">is</span> the Processor interface, which has a partial implementation <span class="hljs-keyword">in</span> the form <span class="hljs-keyword">of</span> AbstractProcessor <span class="hljs-keyword">class</span>. This <span class="hljs-keyword">class</span> <span class="hljs-keyword">is</span> the one we’re going <span class="hljs-keyword">to</span> extend <span class="hljs-keyword">to</span> <span class="hljs-keyword">create</span> our own annotation processor.<br><br><br></code></pre></td></tr></table></figure><p>这是一个实现处理器的例子：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@SupportedAnnotationTypes</span>(<span class="hljs-string">&quot;com.baeldung.annotation.processor.BuilderProperty&quot;</span>)<span class="hljs-comment">//指定这个处理器能处理的注解</span><br><span class="hljs-variable">@SupportedSourceVersion</span>(SourceVersion.RELEASE_8)<br><span class="hljs-variable">@AutoService</span>(Processor.class)<br>public class BuilderProcessor extends AbstractProcessor &#123;<br><br>    <span class="hljs-variable">@Override</span><br>    public boolean process(Set&lt;? extends TypeElement&gt; annotations, <br>      RoundEnvironment roundEnv) &#123;<br>        <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不仅可以指定具体的注释类名称，还可以指定通配符，例如<code>“com.baeldung.annotation.\*”</code> 来处理<code>com.baeldung.annotation</code>包及其所有子包中的注释，甚至可以<em>“*”</em>来处理所有注释.</p><p>我们必须实现的单一方法是处理本身的<code>process</code>方法。编译器为每个包含匹配注释的源文件调用它。</p><p>注释作为第一个<code>Set&lt;? extends TypeElement&gt; annotations</code>参数，有关当前处理轮次的信息作为<code>RoundEnviroment roundEnv</code>参数传递。</p><p>如果您的注释处理器已经处理了所有传递的注释，并且您不希望它们被传递到列表中的其他注释处理器，则返回<em>布尔</em>值应该为<em>true</em>。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">原文：<br>You can specify <span class="hljs-keyword">not</span> only <span class="hljs-keyword">the</span> concrete annotation class names but also wildcards, like “com.baeldung.annotation.*” <span class="hljs-built_in">to</span> <span class="hljs-built_in">process</span> annotations inside <span class="hljs-keyword">the</span> com.baeldung.annotation package <span class="hljs-keyword">and</span> all its sub packages, <span class="hljs-keyword">or</span> even “*” <span class="hljs-built_in">to</span> <span class="hljs-built_in">process</span> all annotations.<br><br>The single method that we’ll have <span class="hljs-built_in">to</span> implement is <span class="hljs-keyword">the</span> <span class="hljs-built_in">process</span> method that does <span class="hljs-keyword">the</span> processing itself. It is called <span class="hljs-keyword">by</span> <span class="hljs-keyword">the</span> compiler <span class="hljs-keyword">for</span> every source <span class="hljs-built_in">file</span> containing <span class="hljs-keyword">the</span> matching annotations.<br><br>Annotations are passed <span class="hljs-keyword">as</span> <span class="hljs-keyword">the</span> <span class="hljs-keyword">first</span> Set<span class="hljs-meta">&lt;?</span> extends TypeElement&gt; annotations argument, <span class="hljs-keyword">and</span> <span class="hljs-keyword">the</span> information about <span class="hljs-keyword">the</span> current processing <span class="hljs-built_in">round</span> is passed <span class="hljs-keyword">as</span> <span class="hljs-keyword">the</span> RoundEnviroment roundEnv argument.<br><br>The <span class="hljs-literal">return</span> boolean <span class="hljs-built_in">value</span> should be <span class="hljs-literal">true</span> <span class="hljs-keyword">if</span> your annotation processor has processed all <span class="hljs-keyword">the</span> passed annotations, <span class="hljs-keyword">and</span> you don<span class="hljs-string">&#x27;t want them to be passed to other annotation processors down the list.</span><br></code></pre></td></tr></table></figure><p>总结：</p><p>在我们自定义的处理器类中，我们指定了这个处理器类可以处理的注解。</p><p>然后，<code>java</code>编译器会依次调用注册好的注解处理器处理注解，这会有多轮处理。</p><p>在调用注解处理器的时候，编译器会筛选出这个注解处理器可以处理的注解信息给它处理。</p><p>在当前注解处理器处理注解的时候，如果产生的新类里依旧包含注解，那么，在其他所有注解处理器完成处理之后，会进行第二轮处理，第三轮，直到没有新的注解产生。</p><ul><li><p>例子：</p><ul><li><p><strong>MainActivity</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>&#123;<br><br>    <span class="hljs-meta">@BindView</span>(<span class="hljs-type">R</span>.id.tv_hello)<br>    <span class="hljs-type">TextView</span> tvHello;<br>  &#125;<br></code></pre></td></tr></table></figure></li><li><p>在第一轮处理注解时，我们生成了新的类,而这个类使用**@Keep**注解标记了，那么注解处理器就会        开始下一轮的处理，直到生成的类里面再也没有任何注解了。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">@Keep<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">MainActivity</span>$<span class="hljs-symbol">Binding</span> &#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h1 id="解析注解的步骤"><a href="#解析注解的步骤" class="headerlink" title="解析注解的步骤"></a>解析注解的步骤</h1><h2 id="插件化注解处理API的使用步骤大概如下："><a href="#插件化注解处理API的使用步骤大概如下：" class="headerlink" title="插件化注解处理API的使用步骤大概如下："></a>插件化注解处理API的使用步骤大概如下：</h2><ul><li>1、自定义一个Annotation Processor，需要继承<code>javax.annotation.processing.AbstractProcessor</code>，需要重写<code>process()</code>方法。<ul><li> 1.1、此外还需要实现几个简单的方法<code>init ()</code>、<code>getSupportedSourceVersion()</code>、<code>getSupportedAnnotationTypes()</code> </li></ul></li><li>2、自定义一个注解，注解的元注解需要指定<code>@Retention(RetentionPolicy.SOURCE)</code>。</li><li>3、需要在声明的自定义Annotation Processor中使用<code>javax.annotation.processing.SupportedAnnotationTypes</code>指定在第2步创建的注解类型的名称(注意需要全类名，”包名.注解类型名称”，否则会不生效)。</li><li>4、需要在声明的自定义Annotation Processor中使用<code>javax.annotation.processing.SupportedSourceVersion</code>指定编译版本。</li><li>5、可选操作，可以通在声明的自定义Annotation Processor中使用<code>javax.annotation.processing.SupportedOptions</code>指定编译参数。</li></ul><h2 id="配置和注册"><a href="#配置和注册" class="headerlink" title="配置和注册"></a>配置和注册</h2><ul><li>创建一个自定义Annotation Processor继承于AbstractProcessor</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AutoService(Processor.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractProcessor</span> </span>&#123;<br> 。。。省略。。。<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>@AutoService(Processor.class) :向javac注册我们这个自定义的注解处理器，这样，在javac编译时，才会调用到我们这个自定义的注解处理器方法。<br> AutoService这里主要是用来生成<br> <strong>建议直接采用@AutoService(Processor.class)进行自定义注解处理器注册，简洁方便</strong></p></li><li><p>其他方式注册</p><p>例如：</p><p>我们模仿一下测试框架Junit里面的@Test注解，在运行时通过Annotation Processor获取到使用了自定义的@Test注解对应的方法的信息。因为如果想要动态修改一个类或者方法的代码内容，需要使用到字节码修改工具例如ASM等，这些操作过于深入，日后再谈。先定义一个注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> club.throwable.processor;<br><br><span class="hljs-keyword">import</span> java.lang.annotation.ElementType;<br><span class="hljs-keyword">import</span> java.lang.annotation.Retention;<br><span class="hljs-keyword">import</span> java.lang.annotation.RetentionPolicy;<br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> throwable</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> v1.0</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 2018/5/27 11:18</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Target(&#123;ElementType.METHOD&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Test &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>定义一个注解处理器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SupportedAnnotationTypes(value = &#123;&quot;club.throwable.processor.Test&quot;&#125;)</span><br><span class="hljs-meta">@SupportedSourceVersion(value = SourceVersion.RELEASE_8)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnnotationProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractProcessor</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">process</span><span class="hljs-params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Log in AnnotationProcessor.process&quot;</span>);<br>        <span class="hljs-keyword">for</span> (TypeElement typeElement : annotations) &#123;<br>            System.out.println(typeElement);<br>        &#125;<br>        System.out.println(roundEnv);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编写一个主类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;success&quot;</span>);<br>        test();<br>    &#125;<br><br>    <span class="hljs-meta">@Test(value = &quot;method is test&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span><span class="hljs-keyword">throws</span> Exception</span>&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着需要指定Processor，如果使用IDEA的话，Compiler-&gt;Annotation Processors中的Enable annotation processing必须勾选。然后可以通过下面几种方式指定指定Processor。</p><ul><li><p>1、直接使用编译参数指定，例如：javac -processor club.throwable.processor.AnnotationProcessor Main.java。</p></li><li><p>2、<strong>通过服务注册指定</strong>，就是META-INF/services/javax.annotation.processing.Processor文件中添加club.throwable.processor.AnnotationProcessor。</p><ul><li><p>具体手动注册方法如下：</p><ol><li><p>创建一个<br>META-INF/services/javax.annotation.processing.Processor文件，<br>其内容是一系列的自定义注解处理器完整有效类名集合，以换行切割。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.MyProcessor</span><br>com<span class="hljs-selector-class">.foo</span><span class="hljs-selector-class">.OtherProcessor</span><br>net<span class="hljs-selector-class">.blabla</span>.SpecialProcessor<br></code></pre></td></tr></table></figure><ul><li>文件放在<code>/src/main/resources/META-INF/services/javax.annotation.processing.Processor</code></li><li>处理器类文件放在<code>/src/main/java/com/example/annotationcomplierlib/AnnotationComplier.java</code></li></ul></li><li><p>将自定义注解处理器和<br>META-INF/services/javax.annotation.processing.Processor打包成一个.jar文件。所以其目录结构大概如下所示：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css">MyProcessor<span class="hljs-selector-class">.jar</span><br>    - com<br>        - example<br>            - MyProcessor<span class="hljs-selector-class">.class</span><br><br>    - META-INF<br>        - services<br>            - javax<span class="hljs-selector-class">.annotation</span><span class="hljs-selector-class">.processing</span><span class="hljs-selector-class">.Processor</span><br></code></pre></td></tr></table></figure></li></ol></li></ul></li><li><p>3、通过Maven的编译插件的配置指定如下：</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">encoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">encoding</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">annotationProcessors</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">annotationProcessor</span>&gt;</span><br>                club.throwable.processor.AnnotationProcessor<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">annotationProcessor</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">annotationProcessors</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br></code></pre></td></tr></table></figure><p>值得注意的是，以上三点生效的前提是club.throwable.processor.AnnotationProcessor已经被编译过，否则编译的时候就会报错：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-attr">[ERROR]</span> Bad service configuration file, or exception thrown while<br>constructing Processor <span class="hljs-selector-tag">object</span>: javax<span class="hljs-selector-class">.annotation</span><span class="hljs-selector-class">.processing</span><span class="hljs-selector-class">.Processor</span>: <br>Provider club<span class="hljs-selector-class">.throwable</span><span class="hljs-selector-class">.processor</span><span class="hljs-selector-class">.AnnotationProcessor</span> not found<br></code></pre></td></tr></table></figure><p>解决方法有两种，第一种是提前使用命令或者IDEA右键club.throwable.processor.AnnotationProcessor对它进行编译；第二种是把club.throwable.processor.AnnotationProcessor放到一个独立的Jar包引入。我在这里使用第一种方式解决。</p><p>最后，使用Maven命令mvn compile进行编译。输出如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Log <span class="hljs-keyword">in</span> AnnotationProcessor.process<br>[<span class="hljs-attribute">errorRaised</span>=<span class="hljs-literal">false</span>, rootElements=[club.throwable.processor.Test,club.throwable.processor.Main, club.throwable.processor.AnnotationProcessor, <span class="hljs-attribute">processingOver</span>=<span class="hljs-literal">false</span>]<br>Log <span class="hljs-keyword">in</span> AnnotationProcessor.process<br>[<span class="hljs-attribute">errorRaised</span>=<span class="hljs-literal">false</span>, rootElements=[], <span class="hljs-attribute">processingOver</span>=<span class="hljs-literal">false</span>]<br>Log <span class="hljs-keyword">in</span> AnnotationProcessor.process<br>[<span class="hljs-attribute">errorRaised</span>=<span class="hljs-literal">false</span>, rootElements=[], <span class="hljs-attribute">processingOver</span>=<span class="hljs-literal">true</span>]<br></code></pre></td></tr></table></figure><p>可见编译期间AnnotationProcessor生效了。</p></li></ul><h2 id="备注："><a href="#备注：" class="headerlink" title="备注："></a>备注：</h2><ul><li>Gradle配置如下：</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs php"><br>dependencies &#123;<br>    implementation fileTree(<span class="hljs-keyword">include</span>: [<span class="hljs-string">&#x27;*.jar&#x27;</span>], dir: <span class="hljs-string">&#x27;libs&#x27;</span>)<br><br>    implementation project(<span class="hljs-string">&#x27;:annotation&#x27;</span>)<br>    <span class="hljs-comment">//用于自动为 JAVA Processor 生成 META-INF 信息。</span><br>    implementation <span class="hljs-string">&#x27;com.google.auto.service:auto-service:1.0-rc3&#x27;</span><br>    <span class="hljs-comment">//快速生成.java文件的库</span><br>    implementation <span class="hljs-string">&#x27;com.squareup:javapoet:1.8.0&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><code>Processor</code> 重写父类的几个方法：</p><ul><li><code>process()</code>方法，这里是处理注解内部逻辑的，也是本文的关键点之一；</li><li><code>getSupportedSourceVersion()</code>：设置支持的版本，一般用最新的就好；</li></ul><ul><li><p><code>getSupportedAnnotationTypes()</code>：添加支持的注解类型，可以是单个／多个，用Set存储；</p></li><li><p><code>init ()</code>：一些初始化操作，获取一些有用的系统工具类，比如生成文件、打印信息、处理元素等；</p></li></ul></li></ul><p>​            <code>getSupportedSourceVersion()</code>、<code>getSupportedAnnotationTypes()</code>这2个方法还有一种    简单的方式来实现，如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@AutoService</span>(Processor.class)<br>@SupportedAnnotationTypes(&#123;&quot;com<span class="hljs-selector-class">.zx</span><span class="hljs-selector-class">.annotation</span>&quot;&#125;)<br><span class="hljs-keyword">@SupportedSourceVersion</span>(SourceVersion.RELEASE_8)<br>public class ViewInjectProcessor extends AbstractProcessor &#123;&#125;<br></code></pre></td></tr></table></figure><p>是通过注解来实现的，看上去是比较简洁</p><ul><li><code>@SupportedAnnotationTypes()</code>可以申明一个注解数组，但是这种字符串拼接容易出错；</li><li><code>@SupportedSourceVersion</code>：设置支持的源码版本，可以是RELEASE_0～RELEASE_8，但是不能使用<code>latestSupported()</code>设置最新的版本；</li></ul><h1 id="方法讲解"><a href="#方法讲解" class="headerlink" title="方法讲解"></a>方法讲解</h1><p>我们今天只说Processor。先从接口的方法介绍起把。</p><table><thead><tr><th>变量和类型</th><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>Iterable&lt;? extends Completion&gt;</code></td><td>getCompletions(Element element, AnnotationMirror annotation, ExecutableElement member, String userText)</td><td>返回一个空的迭代完成。</td></tr><tr><td><code>Set&lt;String&gt;</code></td><td>getSupportedAnnotationTypes()</td><td>如果处理器类使用SupportedAnnotationTypes进行批注，则返回与注释具有相同字符串集的不可修改集。</td></tr><tr><td><code>Set&lt;String&gt;</code></td><td>getSupportedOptions()</td><td>如果处理器类使用SupportedOptions进行批注，则返回具有与批注相同的字符串集的不可修改集。</td></tr><tr><td><code>SourceVersion</code></td><td>getSupportedSourceVersion()</td><td>如果处理器类使用SupportedSourceVersion进行批注，请在批注中返回源版本。</td></tr><tr><td><code>void</code></td><td>init(ProcessingEnvironment processingEnv)</td><td>通过将 processingEnv字段设置为 processingEnv参数的值，使用处理环境初始化处理器。</td></tr><tr><td><code>boolean</code></td><td>process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</td><td>处理源自前一轮的类型元素的一组注释类型，并返回此处理器是否声明了这些注释类型。 如果返回true ，则声明注释类型，并且不会要求后续处理器处理它们; 如果返回false ，则注释类型无人认领，可能会要求后续处理器处理它们。 处理器可以总是返回相同的布尔值，或者可以根据其自己选择的标准改变结果。</td></tr></tbody></table><ul><li><p>init：<br>初始化工作，我们可以得到一些有用的工具，例如 Filer，我们需要它将生成的代码写入文件中</p><p>init(ProcessingEnvironment env):每个Annotation Processor必须***<br> 有一个空的构造函数 ***。编译期间，init()会自动被注解处理工具调用，并传入ProcessingEnviroment参数，通过该参数可以获取到很多有用的工具类:  <strong>Elements , Types , Filer</strong>  等等</p></li><li><p>process：<br>最重要的方法，所有的注解处理都是在此完成</p><p>process(Set&lt;? extends TypeElement&gt; annoations, RoundEnvironment roundEnv):Annotation Processor扫描出的结果会存储进roundEnv中，可以在这里获取到注解内容，编写你的操作逻辑。注意,process()函数中不能直接进行异常抛出,否则的话,运行Annotation Processor的进程会异常崩溃,然后弹出一大堆让人捉摸不清的堆栈调用日志显示.</p></li><li><p>getSupportedAnnotationTypes：<br>返回我们所要处理的注解的一个集合</p><p>getSupportedAnnotationTypes(): 该函数用于指定该自定义注解处理器(Annotation Processor)是注册给哪些注解的(Annotation),注解(Annotation)指定必须是完整的包名+类名(eg:com.example.MyAnnotation)</p></li><li><p>getSupportedSourceVersion：<br>要支持的java版本</p><p>getSupportedSourceVersion():用于指定你的java版本，一般返回：SourceVersion.latestSupported()。当然，你也可以指定具体java版本：<br> return SourceVersion.RELEASE_7;</p></li></ul><h2 id="ProcessingEnvironment"><a href="#ProcessingEnvironment" class="headerlink" title="ProcessingEnvironment"></a>ProcessingEnvironment</h2><p>这个类很重要，要考的。这个类会在函数init的时候被传入，主要的工具类方法都在这个类上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ProcessingEnvironment</span> </span>&#123;<br>    <span class="hljs-function">Map&lt;String, String&gt; <span class="hljs-title">getOptions</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">Messager <span class="hljs-title">getMessager</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">Filer <span class="hljs-title">getFiler</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">Elements <span class="hljs-title">getElementUtils</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">Types <span class="hljs-title">getTypeUtils</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">SourceVersion <span class="hljs-title">getSourceVersion</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">Locale <span class="hljs-title">getLocale</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Filer 就是文件流输出路径，当我们用AbstractProcess生成一个java类的时候，我们需要保存在Filer指定的目录下。</p><p>Messager 输出日志工具，需要输出一些日志相关的时候我们就要使用这个了。</p><p>Elements 获取元素信息的工具，比如说一些类信息继承关系等。</p><p>Types 类型相关的工具类，processor java代码不同的是，当process执行的时候，class的由于类并没有被传递出来，所以大部分都行都是用element来代替了，所以很多类型比较等等的就会转化成type相关的进行比较了。</p><p>类型相关的都被转化成了一个叫TypeMirror，其getKind方法返回类型信息，其中包含了基础类型以及引用类型。</p><p>举个简单的例子，当一个实现了注解的Element被传入的时候，我们要判断Element是不是实现了特定接口，那么应该如何做呢？</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">private</span> Elements elementUtils;<br><span class="hljs-keyword">private</span> Types types;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> synchronized <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">init</span>(<span class="hljs-params">ProcessingEnvironment processingEnv</span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>.init(processingEnv);<br>    types = processingEnv.getTypeUtils();<br>    elementUtils = processingEnv.getElementUtils();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-function"><span class="hljs-title">isSubType</span>(<span class="hljs-params">Element element, <span class="hljs-built_in">String</span> className</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> element != <span class="hljs-literal">null</span> &amp;&amp; isSubType(element.asType(), className);<br>&#125;<br><br><span class="hljs-keyword">public</span> TypeMirror <span class="hljs-function"><span class="hljs-title">typeMirror</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> className</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> typeElement(className).asType();<br>&#125;<br><br><span class="hljs-keyword">public</span> TypeElement <span class="hljs-function"><span class="hljs-title">typeElement</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> className</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> elementUtils.getTypeElement(className);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-function"><span class="hljs-title">isSubType</span>(<span class="hljs-params">TypeMirror <span class="hljs-keyword">type</span>, <span class="hljs-built_in">String</span> className</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">type</span> != <span class="hljs-literal">null</span> &amp;&amp; types.isSubtype(<span class="hljs-keyword">type</span>, typeMirror(className));<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>其中isSubType方法是判断传入的Element是不是一个接口的实现类。首先我们要将对象都转化成Element, 然后将两个element转化成TypeMirror，之后调用Types的isSubtype方法对两个TypeMirror进行比较，如果发现类型一样，则该输入的Element是特定接口的实现类。</strong></p><h2 id="process"><a href="#process" class="headerlink" title="process()"></a>process()</h2><p>扫描代码的时候会把当前获取到的，此processer能处理的annotations传入当前方法</p><h3 id="Processor的kapt优化"><a href="#Processor的kapt优化" class="headerlink" title="Processor的kapt优化"></a>Processor的kapt优化</h3><p>kotlin对apt做了很多优化，内部完成了增量编译。但是对于低版本的autoservice，其增量编译会被关闭。</p><p>这里简单给各位大佬做下这方面的升级就好了。</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs clean">apply plugin: <span class="hljs-string">&#x27;java-library&#x27;</span><br>apply plugin: <span class="hljs-string">&#x27;kotlin&#x27;</span><br>apply plugin: <span class="hljs-string">&#x27;kotlin-kapt&#x27;</span><br><br>dependencies &#123;<br>    <span class="hljs-keyword">implementation</span> <span class="hljs-string">&#x27;com.google.auto.service:auto-service:1.0-rc5&#x27;</span><br>    <span class="hljs-keyword">implementation</span> <span class="hljs-string">&#x27;com.squareup:javapoet:1.10.0&#x27;</span><br>    <span class="hljs-keyword">implementation</span> <span class="hljs-string">&#x27;com.github.leifzhang:RouterAnnotation:0.5.0&#x27;</span><br>    <span class="hljs-keyword">implementation</span> <span class="hljs-string">&quot;org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version&quot;</span><br>    kapt <span class="hljs-string">&quot;com.google.auto.service:auto-service:1.0-rc5&quot;</span><br>&#125;<br>sourceCompatibility = <span class="hljs-number">1.8</span><br>targetCompatibility = <span class="hljs-number">1.8</span><br><br></code></pre></td></tr></table></figure><p>简单的说就是把processor 升级到rc5，然后用kapt的方式去把它注册起来就行了。</p><h2 id="缺点和总结"><a href="#缺点和总结" class="headerlink" title="缺点和总结"></a>缺点和总结</h2><p>缺点：apt能做的事情还是比较有限的</p><ol><li>javapoet只能新增一个类，而不能对当前类进行更改。</li><li>proessor在javac执行之前，所以只能对当前moudule生效</li><li>当Module一多，可能会有类名冲突的问题</li></ol><p>但是apt还是能帮助我们解决很多问题的，我们可以把一些机械化的操作，通过anntation的方式去简化，比如butterknife，这样开发就可以有更多的精力去专注做写别的事情。一部分abtest赋值的操作其实也可以用同样的方式去调整。</p><hr><h2 id="一些疑问"><a href="#一些疑问" class="headerlink" title="一些疑问"></a>一些疑问</h2><ul><li>注解处理器processor为什么要在META-INF注册？</li><li>注解处理器processor是如何被系统调用的？</li><li>注解申明和注解处理器为什么要分Module处理？</li><li>apt项目不会增加apk体积？</li></ul><p>先来回顾一下之前项目的部分目录结构</p><p><img src="https://upload-images.jianshu.io/upload_images/4134622-6cfb718f3055b89b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image.png</p><p>先明确一些概念：<br> <code>AbstractProcessor</code>是抽象处理器，开发apt时都必须继承这个类来生成<code>.java</code>文件，实现的这个类后叫做注解处理器，也就是这里的<code>ButterKnifeProcessor</code>。</p><h4 id="Q1-注解处理器processor为什么要在META-INF注册？"><a href="#Q1-注解处理器processor为什么要在META-INF注册？" class="headerlink" title="Q1:注解处理器processor为什么要在META-INF注册？"></a>Q1:注解处理器processor为什么要在META-INF注册？</h4><hr><p><code>META-INF</code>的作用<br> META-INF, 相当于一个信息包，用于存放一些meta information相关的文件。用来配置应用程序、扩展程序、类加载器和服务<a href="https://links.jianshu.com/go?to=https://www.baidu.com/s?wd=manifest.mf&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">manifest.mf</a>文件，在用jar打包时自动生成。</p><p>在之前的文章中说过，通过<code>@AutoService(Processor.class)</code>注解把注解处理器<code>ButterKnifeProcessor</code>注册到META-INF/services中，这里的包名是<code>META-INF/services/javax.annotation.processing.Processor</code>,<br> 这个文件的内容是</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">com<span class="hljs-selector-class">.zx</span><span class="hljs-selector-class">.processor</span><span class="hljs-selector-class">.ButterKnifeProcessor</span><br></code></pre></td></tr></table></figure><p>这个包名其实就是<code>@AutoService(Processor.class)</code>里面的<code>Processor</code>类；而文件内容就是注解处理器。</p><p><strong>在编译时，java编译器（javac）会去META-INF中查找实现了的AbstractProcessor的子类，并且调用该类的process函数，最终生成<code>.java</code>文件。</strong>其实就像activity需要注册一样，就是要到META-INF注册 ，javac才知道要给你调用哪个类来处理注解。</p><h4 id="Q2：注解处理器processor是如何被系统调用的？"><a href="#Q2：注解处理器processor是如何被系统调用的？" class="headerlink" title="Q2：注解处理器processor是如何被系统调用的？"></a>Q2：注解处理器processor是如何被系统调用的？</h4><hr><p>一些细心的同学应该发现了这个问题，我们并没有手动调用<code>AbstractProcessor</code>这个注解处理器类，那系统是什么时间调用的？又是如何调用的？这其实就牵扯到apt工作机制。</p><p>在上一问中，我们已经了解到，在编译时javac会查找所有的 在META_INF 中注册的注解处理器来处理注解。</p><p>到这里，好像有点清楚了，大概知道javac会去找到Processor并调用。但是呢还是没找到直接源头，因为它不像我们面向对象编程中可以准确追踪到是哪个对象调用的。</p><p>别着急，先来看这么个东西.<br> 是我项目中使用到注解的<code>app.Gradle</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp">dependencies &#123;<br>    <span class="hljs-function">implementation <span class="hljs-title">project</span>(<span class="hljs-params"><span class="hljs-string">&#x27;:annotation&#x27;</span></span>)</span><br><span class="hljs-function">    implementation <span class="hljs-title">project</span>(<span class="hljs-params"><span class="hljs-string">&#x27;:inject_api&#x27;</span></span>)</span><br><span class="hljs-function">    <span class="hljs-comment">//gradle3.0以上apt的实现方式</span></span><br><span class="hljs-function">    annotationProcessor <span class="hljs-title">project</span>(<span class="hljs-params"><span class="hljs-string">&#x27;:processor&#x27;</span></span>)</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><p>这里的<code>annotationProcessor</code>有点特别，没错，它是<strong>APT</strong>实现方案的一种。这里简单介绍一下：</p><blockquote><p>APT实现方案<br> <code>android-apt</code>和<code>annotationProcessor</code>功能是一样的，都是apt的实现方案，前者是个人开发者提供，比较早（现在不再维护了），后者是google官方开发的内置在<code>gradle</code>里的apt。</p><p>annotationProcessor是APT工具中的一种，是google开发的内置框架，不需要引入，可以直接在<code>build.gradle</code>文件中使用。</p></blockquote><p>只有在你使用注解的地方引入了<code>annotationProcessor</code>，系统才会主动调用注解处理类<code>Processor</code>,才会最终生成如下的<code>.java</code>文件</p><p><img src="TyporaRaw/java%E6%B3%A8%E8%A7%A3.assets/4134622-86775724faaeaa3e.png" alt="img"></p><p>apt生成类.png</p><p>这里先简单总结一下：<br> 2.1、在完成注解处理类<code>Processor</code>之后，需要做2件事情：</p><ul><li>1、在META-INF目录下注册<code>Processor</code>；</li><li>2、在项目中使用注解的地方添加apt工具<code>annotationProcessor</code></li></ul><p>2.2、APT 4要素<br> 　<strong>注解处理器（AbstractProcess）+ 代码处理（javaPoet）+ 处理器注册（AutoService）+ apt（annotationProcessor）</strong></p><p><code>APT(Annotation Processing Tool)总结</code><br> 首先，APT是javac提供的一种工具，它在编译时扫描、解析、处理注解。它会对源代码文件进行检测，找出用户自定义的注解，根据注解、注解处理器和相应的apt工具自动生成代码。这段代码是根据用户编写的注解处理逻辑去生成的。<strong>最终将生成的新的源文件与原来的源文件共同编译（注意：APT并不能对源文件进行修改操作，只能生成新的文件，例如往原来的类中添加方法）</strong>。具体流程图如下图所示：</p><p><img src="TyporaRaw/java%E6%B3%A8%E8%A7%A3.assets/4134622-b1f7494d18e216d1.png" alt="img"></p><p>apt工作流程.png</p><p>APT技术的使用，需要我们遵守一定的规则。大家先看一下整个APT项目项目构建的一个规则图，具体如下所示：</p><p><img src="TyporaRaw/java%E6%B3%A8%E8%A7%A3.assets/4134622-55d88199566ac011.png" alt="img"></p><h4 id="Q3：注解申明和注解处理器为什么要分Module处理？"><a href="#Q3：注解申明和注解处理器为什么要分Module处理？" class="headerlink" title="Q3：注解申明和注解处理器为什么要分Module处理？"></a>Q3：注解申明和注解处理器为什么要分Module处理？</h4><hr><p>先来回顾一下之前的项目结构：</p><p><img src="TyporaRaw/java%E6%B3%A8%E8%A7%A3.assets/4134622-1a701ad9e6425883.png" alt="img"></p><ul><li><code>annotation</code>：申明注解 （java lib）</li><li><code>processor</code>：注解处理器（java lib）</li><li><code>inject_api</code>：调用处理器中生成的类 （android lib）</li><li><code>app</code>：项目使用 （android lib）</li></ul><p>我们都知道注解处理器都需要继承<code>AbstractProcessor</code>类，但是<code>AbstractProcessor</code>是JDK中的类，不在android sdk中，所以需要放在单独的java lib中；而<code>processor</code>中需要依赖自定义注解，把<code>annotation</code>抽成一个独立的lib，便于维护。</p><p><strong>那注解声明和注解处理为什么要分开呢？可不可以放在一起？</strong><br> 先说结论：可以放在一起，放在一起对功能上没有什么影响；但是一般不放在一起，原因如下：</p><blockquote><p>我们都知道<code>processor</code>的作用是：在编译器解析注解、生成新的<code>.java</code>文件。<strong>这个lib只在编译器用到，是不会被打包进apk的。</strong>对于调用者来说，你只是想使用这个注解，而不希望你已经编译好的项目中引进注解处理器相关的内容，所以为了不引入没必要的文件，我们一般选择将注解声明和注解处理分开处理。</p></blockquote><p>到这里apt相关知识就说完了，我们也可以理解为什么<code>ButterKnife</code>这种注解库不会增加项目体积了。</p><p>想了解更多apt知识，可以参考：<br> <a href="https://www.jianshu.com/p/b6b3283968e0">https://www.jianshu.com/p/b6b3283968e0</a></p><p>感谢<br> <a href="https://links.jianshu.com/go?to=https://blog.csdn.net/xx326664162/article/details/68490059">你必须知道的APT、annotationProcessor、android-apt、Provided、自定义注解</a></p><p>作者：唠嗑008<br>链接：<a href="https://www.jianshu.com/p/89ac9a2513c4">https://www.jianshu.com/p/89ac9a2513c4</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/12/22/hello-world/"/>
    <url>/2021/12/22/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>aria2整理</title>
    <link href="/2021/12/20/Aria2/"/>
    <url>/2021/12/20/Aria2/</url>
    
    <content type="html"><![CDATA[<h1 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h1><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> pacman -S aria<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h2 id="2-Aria2-配置说明"><a href="#2-Aria2-配置说明" class="headerlink" title="2.Aria2 配置说明"></a>2.Aria2 配置说明</h2><ol><li>创建<code>/home/用户名/.config/aria2/</code>文件夹，新建一个名为aria2.conf的配置文件，并把下面的配置示例修改后复制进去</li><li>创建<code>/home/用户名/.aria2/</code>文件夹，用touch命令建立两个文件<code>aria2.session</code>和<code>input.session</code></li><li>第二步里的路径可以自行修改，在配置文件里填写好就行</li></ol><ul><li><p><strong>完整选项说明请参考 <a href="https://aria2.github.io/manual/en/html/aria2c.html">Aria2 Manual</a></strong></p></li><li><p><strong>参数 <code>--dir</code> <code>--input-file</code> <code>--save-session</code> 根据实际情况修改路径</strong></p></li><li><p>配置示例, 可根据需要修改各项参数</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta">## &#x27;#&#x27;开头为注释内容, 选项都有相应的注释说明, 根据需要修改 ##</span><br><span class="hljs-meta">## 被注释的选项填写的是默认值, 建议在需要修改时再取消注释  ##</span><br><br><span class="hljs-meta">## 文件保存相关 ##</span><br><br><span class="hljs-meta"># 文件的保存路径(可使用绝对路径或相对路径), 默认: 当前启动位置</span><br>dir=$&#123;HOME&#125;/下载<br><span class="hljs-meta"># 启用磁盘缓存, 0为禁用缓存, 需1.16以上版本, 默认:16M</span><br><span class="hljs-meta">#disk-cache=32M</span><br><span class="hljs-meta"># 文件预分配方式, 能有效降低磁盘碎片, 默认:prealloc</span><br><span class="hljs-meta"># 预分配所需时间: none &lt; falloc ? trunc &lt; prealloc</span><br><span class="hljs-meta"># falloc和trunc则需要文件系统和内核支持</span><br><span class="hljs-meta"># NTFS建议使用falloc, EXT3/4建议trunc, MAC 下需要注释此项</span><br><span class="hljs-meta">#file-allocation=none</span><br><span class="hljs-meta"># 断点续传</span><br>continue=<span class="hljs-literal">true</span><br><br><span class="hljs-meta">## 下载连接相关 ##</span><br><br><span class="hljs-meta"># 最大同时下载任务数, 运行时可修改, 默认:5</span><br><span class="hljs-meta">#max-concurrent-downloads=5</span><br><span class="hljs-meta"># 同一服务器连接数, 添加时可指定, 默认:1</span><br>max-connection-per-server=<span class="hljs-number">5</span><br><span class="hljs-meta"># 最小文件分片大小, 添加时可指定, 取值范围1M -1024M, 默认:20M</span><br><span class="hljs-meta"># 假定size=10M, 文件为20MiB 则使用两个来源下载; 文件为15MiB 则使用一个来源下载</span><br>min-split-size=<span class="hljs-number">10</span>M<br><span class="hljs-meta"># 单个任务最大线程数, 添加时可指定, 默认:5</span><br><span class="hljs-meta">#split=5</span><br><span class="hljs-meta"># 整体下载速度限制, 运行时可修改, 默认:0</span><br><span class="hljs-meta">#max-overall-download-limit=0</span><br><span class="hljs-meta"># 单个任务下载速度限制, 默认:0</span><br><span class="hljs-meta">#max-download-limit=0</span><br><span class="hljs-meta"># 整体上传速度限制, 运行时可修改, 默认:0</span><br><span class="hljs-meta">#max-overall-upload-limit=0</span><br><span class="hljs-meta"># 单个任务上传速度限制, 默认:0</span><br><span class="hljs-meta">#max-upload-limit=0</span><br><span class="hljs-meta"># 禁用IPv6, 默认:false</span><br><span class="hljs-meta">#disable-ipv6=true</span><br><span class="hljs-meta"># 连接超时时间, 默认:60</span><br><span class="hljs-meta">#timeout=60</span><br><span class="hljs-meta"># 最大重试次数, 设置为0表示不限制重试次数, 默认:5</span><br><span class="hljs-meta">#max-tries=5</span><br><span class="hljs-meta"># 设置重试等待的秒数, 默认:0</span><br><span class="hljs-meta">#retry-wait=0</span><br><br><span class="hljs-meta">## 进度保存相关 ##</span><br><br><span class="hljs-meta"># 从会话文件中读取下载任务。比如： /etc/aria2/aria2.session</span><br>input-file=$&#123;HOME&#125;/.aria2/input.session<br><span class="hljs-meta"># 在Aria2退出时保存`错误/未完成`的下载任务到会话文件。比如： /etc/aria2/aria2.session</span><br>save-session=$&#123;HOME&#125;/.aria2/aria2.session<br><span class="hljs-meta"># 定时保存会话, 0为退出时才保存, 需1.16.1以上版本, 默认:0</span><br><span class="hljs-meta">#save-session-interval=60</span><br><br><span class="hljs-meta">## RPC相关设置 ##</span><br><br><span class="hljs-meta"># 启用RPC, 默认:false</span><br>enable-rpc=<span class="hljs-literal">true</span><br><span class="hljs-meta"># 允许所有来源, 默认:false</span><br>rpc-allow-origin-all=<span class="hljs-literal">true</span><br><span class="hljs-meta"># 允许非外部访问, 默认:false</span><br>rpc-listen-all=<span class="hljs-literal">true</span><br><span class="hljs-meta"># 事件轮询方式, 取值:[epoll, kqueue, port, poll, select], 不同系统默认值不同</span><br><span class="hljs-meta">#event-poll=select</span><br><span class="hljs-meta"># RPC监听端口, 端口被占用时可以修改, 默认:6800</span><br><span class="hljs-meta">#rpc-listen-port=6800</span><br><span class="hljs-meta"># 设置的RPC授权令牌, v1.18.4新增功能, 取代 --rpc-user 和 --rpc-passwd 选项</span><br><span class="hljs-meta">#rpc-secret=&lt;TOKEN&gt;</span><br><span class="hljs-meta"># 设置的RPC访问用户名, 此选项新版已废弃, 建议改用 --rpc-secret 选项</span><br><span class="hljs-meta">#rpc-user=&lt;USER&gt;</span><br><span class="hljs-meta"># 设置的RPC访问密码, 此选项新版已废弃, 建议改用 --rpc-secret 选项</span><br><span class="hljs-meta">#rpc-passwd=&lt;PASSWD&gt;</span><br><span class="hljs-meta"># 是否启用 RPC 服务的 SSL/TLS 加密,</span><br><span class="hljs-meta"># 启用加密后 RPC 服务需要使用 https 或者 wss 协议连接</span><br><span class="hljs-meta">#rpc-secure=true</span><br><span class="hljs-meta"># 在 RPC 服务中启用 SSL/TLS 加密时的证书文件,</span><br><span class="hljs-meta"># 使用 PEM 格式时，您必须通过 --rpc-private-key 指定私钥</span><br><span class="hljs-meta">#rpc-certificate=/path/to/certificate.pem</span><br><span class="hljs-meta"># 在 RPC 服务中启用 SSL/TLS 加密时的私钥文件</span><br><span class="hljs-meta">#rpc-private-key=/path/to/certificate.key</span><br><br><span class="hljs-meta">## BT/PT下载相关 ##</span><br><br><span class="hljs-meta"># 当下载的是一个种子(以.torrent结尾)时, 自动开始BT任务, 默认:true</span><br><span class="hljs-meta">#follow-torrent=true</span><br><span class="hljs-meta"># BT监听端口, 当端口被屏蔽时使用, 默认:6881-6999</span><br>listen-port=<span class="hljs-number">51413</span><br><span class="hljs-meta"># 单个种子最大连接数, 默认:55</span><br><span class="hljs-meta">#bt-max-peers=55</span><br><span class="hljs-meta"># 打开DHT功能, PT需要禁用, 默认:true</span><br>enable-dht=<span class="hljs-literal">false</span><br><span class="hljs-meta"># 打开IPv6 DHT功能, PT需要禁用</span><br><span class="hljs-meta">#enable-dht6=false</span><br><span class="hljs-meta"># DHT网络监听端口, 默认:6881-6999</span><br><span class="hljs-meta">#dht-listen-port=6881-6999</span><br><span class="hljs-meta"># 本地节点查找, PT需要禁用, 默认:false</span><br><span class="hljs-meta">#bt-enable-lpd=false</span><br><span class="hljs-meta"># 种子交换, PT需要禁用, 默认:true</span><br>enable-peer-exchange=<span class="hljs-literal">false</span><br><span class="hljs-meta"># 每个种子限速, 对少种的PT很有用, 默认:50K</span><br><span class="hljs-meta">#bt-request-peer-speed-limit=50K</span><br><span class="hljs-meta"># 客户端伪装, PT需要</span><br>peer-id-prefix=-TR2770-<br>user-agent=Transmission/<span class="hljs-number">2.77</span><br>peer-agent=Transmission/<span class="hljs-number">2.77</span><br><span class="hljs-meta"># 当种子的分享率达到这个数时, 自动停止做种, 0为一直做种, 默认:1.0</span><br>seed-ratio=<span class="hljs-number">0</span><br><span class="hljs-meta"># 强制保存会话, 即使任务已经完成, 默认:false</span><br><span class="hljs-meta"># 较新的版本开启后会在任务完成后依然保留.aria2文件</span><br><span class="hljs-meta">#force-save=false</span><br><span class="hljs-meta"># BT校验相关, 默认:true</span><br><span class="hljs-meta">#bt-hash-check-seed=true</span><br><span class="hljs-meta"># 继续之前的BT任务时, 无需再次校验, 默认:false</span><br>bt-seed-unverified=<span class="hljs-literal">true</span><br><span class="hljs-meta"># 保存磁力链接元数据为种子文件(.torrent文件), 默认:false</span><br>bt-save-metadata=<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="使用aria2下载"><a href="#使用aria2下载" class="headerlink" title="使用aria2下载"></a>使用aria2下载</h2><ol><li><p>在终端里输入<code>aria2c</code> 启动服务，出现监听端口</p></li><li><p>用浏览器打开<a href="http://aria2c.com/">Aria2 Web 控制台</a></p></li><li><p>不使用aria2时在终端里按下<code>ctrl+c</code>回车停止aria2服务</p></li></ol><h2 id="Aria2-相关下载"><a href="#Aria2-相关下载" class="headerlink" title="Aria2 相关下载"></a>Aria2 相关下载</h2><ul><li><p><a href="https://github.com/aria2/aria2/releases/latest">Aria2 源码/程序下载</a></p></li><li><p><a href="http://aria2c.com/archiver/aria2.conf">配置示例下载</a></p></li><li><p>重要文件</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs 1c">aria2.conf    <span class="hljs-meta"># 配置文件 可以自己根据说明修改</span><br>aria2.session <span class="hljs-meta"># 任务保存文件 错误/未完成任务会保存在这里（下载历史）</span><br>Aria2.<span class="hljs-built_in">log</span> <span class="hljs-meta">#（日志，空文件就行）</span><br>input.session <span class="hljs-meta"># 从会话文件中读取下载任务</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h1><p>推荐使用AriaNG</p><p><a href="http://ariang.mayswind.net/zh_Hans/">ariaNg下载到本地使用</a></p><h2 id="创建-systemd-守护进程"><a href="#创建-systemd-守护进程" class="headerlink" title="创建 systemd 守护进程"></a>创建 systemd 守护进程</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo vim /etc/systemd/user/aria2.service<br>[Unit]<br><span class="hljs-attribute">Description</span>=Aria2<span class="hljs-built_in"> Service</span><br><span class="hljs-built_in"></span><span class="hljs-attribute">After</span>=network.target<br><br>[Service]<br><span class="hljs-attribute">Type</span>=forking<br><span class="hljs-attribute">WorkingDirectory</span>=%h<br><span class="hljs-attribute">ExecStart</span>=/usr/bin/aria2c --daemon --enable-rpc --rpc-listen-all --rpc-allow-origin-all -c -D  <span class="hljs-attribute">--conf-path</span>=%h/.config/aria2/aria2.conf<br><br>[Install]<br><span class="hljs-attribute">WantedBy</span>=default.target<br><span class="hljs-comment"># 启动</span><br>systemctl --user start aria2.service<br>systemctl --user <span class="hljs-builtin-name">enable</span> aria2.service<br></code></pre></td></tr></table></figure><h2 id="YAAW-使用说明"><a href="#YAAW-使用说明" class="headerlink" title="YAAW 使用说明"></a>YAAW 使用说明</h2><p><strong>JSON-RPC Path</strong></p><ul><li><p><code>JSON-RPC Path</code> 默认为: <code>http://localhost:6800/jsonrpc</code></p></li><li><p>如果提示 </p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">Aria2</span> RPC 服务器错误<br></code></pre></td></tr></table></figure><p> 按照以下方法修改             </p><ul><li><p><strong><code>host</code></strong>: 指运行 Aria2 所在机器的 IP 或者名字</p></li><li><p><strong><code>port</code></strong>: 使用 <code>--rpc-listen-port</code> 选项设置的端口, 未设置则是 <code>6800</code></p></li><li><p>普通情况设置为: <code>http://host:port/jsonrpc</code></p></li><li><p>使用 <code>--rpc-secret=xxxxxx</code> 选项设置为: <code>http://token:xxxxxx@host:port/jsonrpc</code></p></li><li><p>使用 <code>--rpc-user=user --rpc-passwd=pwd </code> 选项设置为: <code>http://user:pwd@host:port/jsonrpc</code></p></li><li><p>以上 <code>JSON-RPC Path</code> 中的 <code>http</code> 可以用 <code>ws</code> 替代, 代表使用 <code>WebSocket 协议</code></p></li><li><p>当使用 <a href="https://aria2c.com/">https://aria2c.com</a> 访问时, 需要使用 <code>https</code> 或 <code>wss</code> 协议</p></li></ul></li></ul><p><strong>Tips</strong></p><ul><li>在 YAAW 中对 Aria2 的设置会在 Aria2 重启后丢失, 必要的设置请写入配置文件</li><li>已经下载完成的任务会在 Aria2 重启后消失, 除非启用了 <code>--force-save</code> 选项</li><li>因界面已汉化, 其他不再赘述.</li></ul><h2 id="YAAW-搭配脚本"><a href="#YAAW-搭配脚本" class="headerlink" title="YAAW 搭配脚本"></a>YAAW 搭配脚本</h2><p><strong>迅雷离线</strong></p><ul><li><p>Chrome Extension: <a href="https://chrome.google.com/webstore/detail/eehlmkfpnagoieibahhcghphdbjcdmen">ThunderLixianAssistant</a></p></li><li><p>UserScript: <a href="https://github.com/binux/ThunderLixianExporter">ThunderLixianExporter</a></p></li><li><p><a href="https://greasyfork.org/scripts/2398-lixianexporter">https://greasyfork.org/scripts/2398-lixianexporter</a>)</p></li></ul><p><strong>百度网盘</strong></p><ul><li>Chrome Extension: <a href="https://chrome.google.com/webstore/detail/mjaenbjdjmgolhoafkohbhhbaiedbkno">BaiduExporter</a></li><li>Firefox Addons: <a href="https://github.com/acgotaku/BaiduExporter">BaiduExporter</a></li><li>UserScript: <a href="https://greasyfork.org/scripts/294-baidupandownloadhelper">BaiduPanDownloadHelper</a></li></ul><p><strong>其他脚本</strong></p><ul><li>Chrome Extension: <a href="https://chrome.google.com/webstore/detail/nimeojfecmndgolmlmjghjmbpdkhhogl">添加到aria2</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ssh使用</title>
    <link href="/2021/12/20/SSH%E4%BD%BF%E7%94%A8/"/>
    <url>/2021/12/20/SSH%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="实践原理："><a href="#实践原理：" class="headerlink" title="实践原理："></a>实践原理：</h1><p>读者一定很好奇SSH认证的流程，这里给出一张粗陋的图简单解释一下：</p><p><img src="TyporaRaw/SSH%E4%BD%BF%E7%94%A8.assets/1200.jpeg" alt="img"></p><p>如果我们事先在服务器中存储了USER1的公钥(后面会讲解如何做)，则USER1发起SSH连接服务器的流程如下：</p><ul><li>1.USER1发起SSH请求</li><li>2.服务器生成随机数R1发给USER1，USER1用私钥加密生成R2。</li><li>3.USER1把R2回发给服务器，服务器用公钥解密并对比R1，相同则成功连接。</li></ul><p>其实很简单，但是如果还不懂，没有关系，可以先做一遍，再会过头来看，让我们开始吧。</p><h2 id="实践步骤1：生成密钥对"><a href="#实践步骤1：生成密钥对" class="headerlink" title="实践步骤1：生成密钥对"></a>实践步骤1：生成密钥对</h2><p>读者可能有两个疑惑：</p><h4 id="第一，生成的密钥对应当放在何处？"><a href="#第一，生成的密钥对应当放在何处？" class="headerlink" title="第一，生成的密钥对应当放在何处？"></a>第一，生成的密钥对应当放在何处？</h4><p>因为密钥一定要牢牢把握在自己手中，不能让别人知道。所以我们一定要在自己的物理机上生成密钥对，千万不能在远程计算机上生成，否则就不符合密钥的定义了。</p><h4 id="第二，如何生成密钥对？"><a href="#第二，如何生成密钥对？" class="headerlink" title="第二，如何生成密钥对？"></a>第二，如何生成密钥对？</h4><ol><li>在本机终端运行<code>ssh-keygen</code>命令, 即可生成一对默认的RSA密钥。管理员可以通过<code>ssh-keygen -t</code>命令自定义上述的5种密钥类型，具体可以通过<code>man ssh-keygen</code>查看。这里我们用默认的RSA密钥即可。</li><li>然后自己输入保存的路径，推荐保存到home目录的.ssh文件夹下。</li><li>输入管理密码(不建议为空，并且需记住)。注意，这里的密码是防止别人用你的电脑SSH无密码登陆远程服务器，可以理解成开机密码，可防止别人乱动你的电脑。</li></ol><p>前三步操作完结果如下：</p><p><img src="TyporaRaw/SSH%E4%BD%BF%E7%94%A8.assets/1154.jpeg" alt="img"></p><p>存储路径如下：</p><p><img src="TyporaRaw/SSH%E4%BD%BF%E7%94%A8.assets/1130.jpeg" alt="img"></p><h2 id="实践步骤2：把公钥内容复制到服务器的认证列表中"><a href="#实践步骤2：把公钥内容复制到服务器的认证列表中" class="headerlink" title="实践步骤2：把公钥内容复制到服务器的认证列表中"></a>实践步骤2：把公钥内容复制到服务器的认证列表中</h2><p>这里读者可能又有三个问题。</p><h4 id="第一，什么是服务器认证列表？"><a href="#第一，什么是服务器认证列表？" class="headerlink" title="第一，什么是服务器认证列表？"></a>第一，什么是服务器认证列表？</h4><p>服务器认证列表是一个文件，可以理解为&lt;存储用户SSH公钥的地方&gt;，因为SSH是一个验证过程，所以服务器需要事先保存对方的公钥，这样管理员就可以指定哪些用户(准确说是密钥对)可以登录了。</p><h4 id="第二，认证列表的路径是什么？"><a href="#第二，认证列表的路径是什么？" class="headerlink" title="第二，认证列表的路径是什么？"></a>第二，认证列表的路径是什么？</h4><p>在服务器的配置文件<code>/etc/ssh/sshd_config</code>中记录的着认证列表的目录。</p><p>首先, 我们可以先进入服务器(若没有设置SSH登陆只能用密码登陆)，然后进入此路径查看，如下：</p><p><img src="TyporaRaw/SSH%E4%BD%BF%E7%94%A8.assets/1154.jpeg" alt="img"></p><p>即<code>~/.ssh/authorized_keys</code>(注意，此文件不一定存在)</p><h4 id="第三，如何把公钥复制进认证列表？"><a href="#第三，如何把公钥复制进认证列表？" class="headerlink" title="第三，如何把公钥复制进认证列表？"></a>第三，如何把公钥复制进认证列表？</h4><p>首先，认证列表文件不一定存在，所以我们要先在远程服务器上执行创建命令, 并设置权限：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">mkdir .ssh  <span class="hljs-comment">//创建文件夹</span><br>touch .ssh/authorized_keys  <span class="hljs-comment">// 创建文件</span><br>chmod <span class="hljs-number">700</span> .ssh      <span class="hljs-comment">//设置权限</span><br>chmod <span class="hljs-number">644</span> .ssh/auauthorized_keys  <span class="hljs-comment">//设置权限</span><br></code></pre></td></tr></table></figure><p>然后用<code>nano</code>编辑器打开:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">nano ~<span class="hljs-regexp">/.ssh/</span>authorized_keys<br></code></pre></td></tr></table></figure><p>如果没设置过SSH的公钥，里面内容是为空的。如果设置过SSH公钥，则空行添加公钥。</p><p><img src="TyporaRaw/SSH%E4%BD%BF%E7%94%A8.assets/1154.jpeg" alt="img"></p><p>最后把实践步骤1中生成的公钥内容复制粘贴到里面。可以采用文本打开复制，也可以用<code>nano</code>编辑器复制。这里演示方式为<code>nano</code>打开复制：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">nano ~<span class="hljs-regexp">/.ssh/</span>MyLinux.pub<br></code></pre></td></tr></table></figure><p>运行后复制粘贴到远程服务器的认证列表中退出保存即可：</p><p><img src="TyporaRaw/SSH%E4%BD%BF%E7%94%A8.assets/1144.jpeg" alt="img"></p><p>这样我们就可以用SSH登陆了。</p><h2 id="实践步骤3：SSH远程连接Linux服务器"><a href="#实践步骤3：SSH远程连接Linux服务器" class="headerlink" title="实践步骤3：SSH远程连接Linux服务器"></a>实践步骤3：SSH远程连接Linux服务器</h2><p>一切设置都已完成，我们如何连接到远程服务器呢？<br> 命令格式如下：</p><p>1首先开启ssh <strong><code>systemctl start sshd</code>开启<code>sshd</code>服务</strong></p><p>2连接命令格式如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">ssh student<span class="hljs-keyword">@127</span>.0.0.1 -p <span class="hljs-number">2222</span> -i ~/.ssh/MyLinux<br></code></pre></td></tr></table></figure><p><img src="TyporaRaw/SSH%E4%BD%BF%E7%94%A8.assets/990.jpeg" alt="img"></p><ul><li>1表示ssh连接</li><li>2表示服务器上的用户名</li><li>3表示远程主机的host IP(这里是本机)</li><li>4表示远程主机端口(默认22，<a href="https://link.jianshu.com/?t=https://www.vagrantup.com/docs/getting-started/">vagrant</a>采用2222, 本文不讨论)</li><li>5表示用户私钥</li></ul><p>然后输入该密钥对的管理密码即可连接服务器, 如下：</p><p><img src="TyporaRaw/SSH%E4%BD%BF%E7%94%A8.assets/990.jpeg" alt="img"></p><h2 id="实践步骤4：设置只许SSH登录不可密码登陆"><a href="#实践步骤4：设置只许SSH登录不可密码登陆" class="headerlink" title="实践步骤4：设置只许SSH登录不可密码登陆"></a>实践步骤4：设置只许SSH登录不可密码登陆</h2><p>最终我们的目的是消除密码登陆这一留给黑客的安全隐患，而只采用用SSH登陆，故我们在服务器配置文件<code>/etc/ssh/sshd_config</code>里小小的设置一下即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">nano /etc/ssh/sshd_config<br></code></pre></td></tr></table></figure><p>把其中的<code>PasswordAuthentication</code>中的yes改成no就不可再用密码登陆了。</p><p><img src="TyporaRaw/SSH%E4%BD%BF%E7%94%A8.assets/1196.jpeg" alt="img"></p><h2 id="ssh配置文件"><a href="#ssh配置文件" class="headerlink" title="ssh配置文件"></a>ssh配置文件</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle">* ssh-server配置文件位于<span class="hljs-regexp">/etc/</span>ssh/sshd_config，在这里可以定义SSH的服务端口，默认端口是<span class="hljs-number">22</span><br>* 作为服务端，~<span class="hljs-regexp">/.ssh/</span>authorized_keys文件中<br>* ssh会把你每个你访问过计算机的公钥(<span class="hljs-keyword">public</span> key)都记录在~<span class="hljs-regexp">/.ssh/</span>known_hosts<br></code></pre></td></tr></table></figure><ul><li><strong>authorized_keys</strong></li></ul><p>我们需要本地机器ssh访问远程服务器时为了减少输入密码的步骤，基本上都会在本地机器生成ssh公钥，然后将本地ssh公钥复制到远程服务器的<code>.ssh/authorized_keys</code>中，这样就可以免密登录了。（ 服务器之间访问同理）。<br>流程如下</p><pre><code>本机生成 ssh公钥；复制本机公钥到远程服务器.ssh/authorized_keys中，authorized_keys文件不存在则创建；本机直接ssh连接远程；结束</code></pre><ul><li><strong>known_hosts</strong></li></ul><p>第一次连接远程数据库时我们可以发现我们本地的.ssh/目录下多了一个文件<code>known_hosts</code>，里面有我们刚刚连接的服务器的信息（如果以前就存在<code>known_hosts</code>，则会发现多了刚刚连接的服务器的信息）。<br><code>known_hosts</code>文件每连接一个新的远程服务器都会产生一份数据，如下：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">0.0.0.0</span> ecdsa-sha2-nistp256 AAAA...........=<br></code></pre></td></tr></table></figure><p>包括远程机器<code>ip</code>、远程机器公钥<br><code>known_hosts</code>有什么用？<br>手动修改一下远程机器A的密钥，然后再连接远程机器A，提示：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vbnet">The authenticity <span class="hljs-keyword">of</span> host <span class="hljs-comment">&#x27;0.0.0.0 (0.0.0.0)&#x27; can&#x27;t be established.</span><br>ECDSA <span class="hljs-keyword">key</span> fingerprint <span class="hljs-built_in">is</span> SHA256:xxxxxxxx.<br>Are you sure you want <span class="hljs-keyword">to</span> <span class="hljs-keyword">continue</span> connecting (yes/no)?<br></code></pre></td></tr></table></figure><p>得到类似这种提示，大概意思就是登录远程机器A验证失败，然后向你确定是否需要继续连接。<br>known_hosts的作用就很明显了，known_hosts的作用就是记录你曾经远程连接过的机器信息。如果远程机器信息不变，则直接连接，如果改变了ssh就会问你一下，小子，你还连不连了？<br>如果你yes， 他就重新保存一份到known_hosts文件了。</p><ul><li>总结一下： 1. authorized_keys由本地主机生成，多用于放在远程主机实现免密登录 2. known_hosts放在本地主机，用来记录连接过的远程主机</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>git常用</title>
    <link href="/2021/12/20/git%E5%B8%B8%E7%94%A8/"/>
    <url>/2021/12/20/git%E5%B8%B8%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h2><p>安装完成后，还需要配置git，在命令行输入：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog">$ git <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> user<span class="hljs-variable">.name</span> <span class="hljs-string">&quot;Your Name&quot;</span><br>$ git <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> user<span class="hljs-variable">.email</span> <span class="hljs-string">&quot;email@example.com&quot;</span><br></code></pre></td></tr></table></figure><p>Git 使用一系列配置文件来保存你自定义的行为。 它首先会查找系统级的 <code>/etc/gitconfig</code> 文件，该文件含有系统里每位用户及他们所拥有的仓库的配置值。 如果你传递 <code>--system</code> 选项给 <code>git config</code>，它就会读写该文件。</p><p>接下来 Git 会查找每个用户的 <code>~/.gitconfig</code> 文件（或者 <code>~/.config/git/config</code> 文件）。 你可以传递 <code>--global</code> 选项让 Git 读写该文件。</p><p>最后 Git 会查找你正在操作的仓库所对应的 Git 目录下的配置文件（<code>.git/config</code>）。 这个文件中的值只对该仓库有效，它对应于向 <code>git config</code> 传递 <code>--local</code> 选项。</p><p>以上三个层次中每层的配置（系统、全局、本地）都会覆盖掉上一层次的配置，所以 <code>.git/config</code> 中的值会覆盖掉 <code>/etc/gitconfig</code> 中所对应的值。</p><ul><li><p>注</p><p>注意<code>git config</code>命令的<code>--global</code>参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p><p>Git 的配置文件是纯文本的，所以你可以直接手动编辑这些配置文件，输入合乎语法的值。 但是运行 <code>git config</code> 命令会更简单些。</p></li></ul><h3 id="配置ssh"><a href="#配置ssh" class="headerlink" title="配置ssh"></a>配置ssh</h3><p>第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有<code>id_rsa</code>和<code>id_rsa.pub</code>这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>ssh-keygen -t rsa -C <span class="hljs-string">&quot;youremail@example.com&quot;</span><br></code></pre></td></tr></table></figure><p>你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。</p><p>如果一切顺利的话，可以在用户主目录里找到<code>.ssh</code>目录，里面有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，这两个就是SSH Key的秘钥对，<code>id_rsa</code>是私钥，不能泄露出去，<code>id_rsa.pub</code>是公钥，可以放心地告诉任何人。</p><p>第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：</p><p>然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴<code>id_rsa.pub</code>文件的内容。</p><p>使用下面命令</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Swift">ssh <span class="hljs-operator">-</span><span class="hljs-type">T</span> git<span class="hljs-meta">@github</span>.com<br></code></pre></td></tr></table></figure><p>测试是否配置成功</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">Hi RoninLee! You<span class="hljs-symbol">&#x27;ve</span> successfully authenticated, but GitHub does <span class="hljs-keyword">not</span> provide shell <span class="hljs-keyword">access</span>.<br></code></pre></td></tr></table></figure><p>出现这样一段话，即证明配置成功。</p><h2 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h2><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">git</span>@github.com:Knightwood/Aplayer.git <span class="hljs-comment">#克隆项目</span><br>git <span class="hljs-keyword">clone</span> <span class="hljs-title">-b</span> <span class="hljs-tag">&lt;分支名称&gt;</span> git@github.com:Knightwood/Aplayer.git <span class="hljs-comment">#克隆特定的分支</span><br><br><br></code></pre></td></tr></table></figure><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">git <span class="hljs-keyword">branch </span><span class="hljs-comment"># 查看分支</span><br>git <span class="hljs-keyword">branch </span>&lt;分支名称&gt; <span class="hljs-comment">#创建新分支</span><br>git checkout -<span class="hljs-keyword">b </span>&lt;分支名称&gt; <span class="hljs-comment">#创建新分支并切换到新分支</span><br>git checkout &lt;分支名称&gt; <span class="hljs-comment">#切换到新的分支</span><br>git <span class="hljs-keyword">branch </span>-r <span class="hljs-comment">#查看远程分支</span><br>git <span class="hljs-keyword">branch </span>-a <span class="hljs-comment">#查看所有分支</span><br>git push <span class="hljs-keyword">origin </span>[<span class="hljs-keyword">branch </span>name] <span class="hljs-comment">#将新分支推送到github</span><br>git <span class="hljs-keyword">branch </span>-d [<span class="hljs-keyword">branch </span>name] <span class="hljs-comment">#删除本地分支</span><br>git push <span class="hljs-keyword">origin </span>:[<span class="hljs-keyword">branch </span>name] <span class="hljs-comment">#删除github远程分支</span><br></code></pre></td></tr></table></figure><h2 id="提交代码"><a href="#提交代码" class="headerlink" title="提交代码"></a>提交代码</h2><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">git <span class="hljs-built_in">add</span> all <span class="hljs-comment">#可以提交未跟踪、修改和删除文件（无论在哪个目录执行都会提交相应文件）</span><br>git <span class="hljs-built_in">add</span> . <span class="hljs-comment">#可以提交未跟踪和修改文件，但是不处理删除文件（只能够提交当前目录或者它后代目录下相应文件）</span><br><span class="hljs-comment">-----</span><br>git commit <span class="hljs-comment">#提交代码</span><br>git commit -m <span class="hljs-string">&quot;add my code to new branchB&quot;</span> <span class="hljs-comment"># -m 参数：可以直接在后面添加提交信息。</span><br>git push origin [branch name] <span class="hljs-comment">#push 到git仓库</span><br>git commit -<span class="hljs-keyword">a</span> -m <span class="hljs-string">&#x27;合并module&#x27;</span> <span class="hljs-comment"># -a 把所有未暂存的提交.-m 附带了题解信息</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>pacman包管理</title>
    <link href="/2021/12/20/manjaro%E5%8C%85%E7%AE%A1%E7%90%86/"/>
    <url>/2021/12/20/manjaro%E5%8C%85%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="pacman包管理"><a href="#pacman包管理" class="headerlink" title="pacman包管理"></a>pacman包管理</h1><h4 id="安装指定的包"><a href="#安装指定的包" class="headerlink" title="安装指定的包"></a>安装指定的包</h4><p>安装或者升级单个软件包，或者一列软件包（包含依赖包），使用如下命令：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-attr"># pacman -S package_name1</span> package_<span class="hljs-symbol">name2</span> ...<br></code></pre></td></tr></table></figure><p>用正则表达式安装多个软件包（参见 <a href="https://bbs.archlinux.org/viewtopic.php?id=7179">这个帖子</a>）：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"># pacman -S <span class="hljs-constructor">$(<span class="hljs-params">pacman</span> -Ssq <span class="hljs-params">package_regex</span>)</span><br></code></pre></td></tr></table></figure><p>有时候在不同的软件仓库中，一个软件包有多个版本（比如[extra]和[testing]）。可以选择一个来安装：</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># pacman -S extra/package_name</span><br></code></pre></td></tr></table></figure><p>安装多个含有相似名称的软件包，而并非整个包组或全部匹配的软件包； 例如，<a href="https://archlinux.org/groups/x86_64/plasma/">plasma</a>:</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># pacman -S plasma-&#123;desktop,mediacenter,nm&#125;</span><br></code></pre></td></tr></table></figure><p>当然，可以多层扩展，并不作限制：</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># pacman -S plasma-&#123;workspace&#123;,-wallpapers&#125;,pa&#125;</span><br></code></pre></td></tr></table></figure><h5 id="虚包"><a href="#虚包" class="headerlink" title="虚包"></a>虚包</h5><p>虚拟软件包是一个特殊的软件包，它本身并不存在，但由一或多个其它软件包提供。虚拟软件包允许其它软件包不以某一个特定的包为依赖，以应对有多个候选的情况。虚包不能用它们的名称安装，相反它们会在你安装<em>提供</em>虚包的软件包时被安装到你的系统中。</p><h4 id="安装包组"><a href="#安装包组" class="headerlink" title="安装包组"></a>安装包组</h4><p>一些包属于一个可以同时安装的<a href="https://wiki.archlinux.org/index.php/Meta_package_and_package_group_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">软件包组</a>。例如，运行下面的命令</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># pacman -S gnome</span><br></code></pre></td></tr></table></figure><p>会提醒用户选择 <code>gnome</code> 内需要安装的包。</p><p>有的包组包含大量的软件包，有时用户只需其中几个。除了逐一键入序号外，pacman 还支持选择或排除某个区间内的的软件包：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Enter</span> a selection (default=<span class="hljs-literal">all</span>): <span class="hljs-number">1</span>-<span class="hljs-number">10</span> <span class="hljs-number">15</span><br></code></pre></td></tr></table></figure><p>这将选中序号 1 至 10 和 15 的软件包。而</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Enter</span> a selection (default=<span class="hljs-literal">all</span>): ^<span class="hljs-number">5</span>-<span class="hljs-number">8</span> ^<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>将会选中除了序号 5 至 8 和 2 之外的所有软件包。</p><p>想要查看哪些包属于 gnome 组，运行：</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># pacman -Sg gnome</span><br></code></pre></td></tr></table></figure><p>也可以访问 <a href="https://archlinux.org/groups/">https://archlinux.org/groups/</a> 查看可用的包组。</p><p><strong>注意：</strong> 如果列表中的包已经安装在系统中，它会被重新安装，即使它已经是最新的。可以用 <code>--needed</code> 选项覆盖这种行为。</p><h3 id="删除软件包"><a href="#删除软件包" class="headerlink" title="删除软件包"></a>删除软件包</h3><p>删除单个软件包，保留其全部已经安装的依赖关系</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># pacman -R package_name</span><br></code></pre></td></tr></table></figure><p>删除指定软件包，及其所有没有被其他已安装软件包使用的依赖关系：</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># pacman -Rs package_name</span><br></code></pre></td></tr></table></figure><p>上面这条命令在移除包含其他所需包的组时有时候会拒绝运行。这种情况下可以尝试</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># pacman -Rsu package_name</span><br></code></pre></td></tr></table></figure><p>要删除软件包和所有依赖这个软件包的程序:</p><p><strong>警告：</strong> 此操作是递归的，请小心检查，可能会一次删除大量的软件包。</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># pacman -Rsc package_name</span><br></code></pre></td></tr></table></figure><p>要删除一个被其他软件包依赖的软件包，但是不删除依赖这个软件包的其他软件包：</p><p><strong>警告：</strong> 此操作有破坏系统的能力，应该尽量避免使用。详情请看 <a href="https://wiki.archlinux.org/index.php/System_maintenance#Avoid_certain_pacman_commands">避免某些 Pacman 命令</a>。</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># pacman -Rdd package_name</span><br></code></pre></td></tr></table></figure><p><em>pacman</em> 删除某些程序时会备份重要配置文件，在其后面加上*.pacsave扩展名。-n 选项可以避免备份这些文件：</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ceylon">pacman -Rn <span class="hljs-keyword">package</span><span class="hljs-number">_n</span>ame<br></code></pre></td></tr></table></figure><p><strong>注意：</strong> <em>pacman</em> 不会删除软件自己创建的文件（例如主目录中的“点文件”不会被删除。）</p><h3 id="升级软件包"><a href="#升级软件包" class="headerlink" title="升级软件包"></a>升级软件包</h3><p><strong>警告：</strong></p><ul><li>建议用户遵守<a href="https://wiki.archlinux.org/index.php/System_maintenance_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E6%9B%B4%E6%96%B0%E7%B3%BB%E7%BB%9F">System maintenance (简体中文)#更新系统</a>的指导，定期更新系统，并不盲目地执行这些命令。</li><li>Arch 只支持系统完整升级，详细参见<a href="https://wiki.archlinux.org/index.php/System_maintenance_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E4%B8%8D%E6%94%AF%E6%8C%81%E9%83%A8%E5%88%86%E5%8D%87%E7%BA%A7">System maintenance (简体中文)#不支持部分升级</a>和<a href="https://wiki.archlinux.org/index.php/Pacman_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E5%8C%85">#安装软件包</a>。</li></ul><p>一个 <em>pacman</em> 命令就可以升级整个系统。花费的时间取决于系统有多老。这个命令会同步非本地(local)软件仓库并升级系统的软件包：</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># pacman -Syu</span><br></code></pre></td></tr></table></figure><h3 id="查询包数据库"><a href="#查询包数据库" class="headerlink" title="查询包数据库"></a>查询包数据库</h3><p><em>pacman</em> 使用 <code>-Q</code> 参数查询本地软件包数据库， <code>-S</code> 查询同步数据库，以及 <code>-F</code>查询文件数据库。要了解每个参数的子选项，分别参见 <a href="https://wiki.archlinux.org/index.php?title=Template:Pacman_-Q_--help&action=edit&redlink=1">Template:Pacman -Q –help</a>，<a href="https://wiki.archlinux.org/index.php?title=Template:Pacman_-S_--help&action=edit&redlink=1">Template:Pacman -S –help</a>和<a href="https://wiki.archlinux.org/index.php?title=Template:Pacman_-F_--help&action=edit&redlink=1">Template:Pacman -F –help</a>。</p><p><em>pacman</em> 可以在包数据库中查询软件包，查询位置包含了软件包的名字和描述：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">$ pacman -Ss <span class="hljs-built_in">string</span>1 <span class="hljs-built_in">string</span>2 ...<br></code></pre></td></tr></table></figure><p>有时，<code>-s</code>的内置正则会匹配很多不需要的结果，所以应当指定仅搜索包名，而非描述或其他子段:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>pacman -Ss <span class="hljs-string">&#x27;^vim-&#x27;</span><br></code></pre></td></tr></table></figure><p>要查询已安装的软件包：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">$ pacman -Qs <span class="hljs-built_in">string</span>1 <span class="hljs-built_in">string</span>2 ...<br></code></pre></td></tr></table></figure><p>按文件名查找软件库：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">$ pacman -F <span class="hljs-built_in">string</span>1 <span class="hljs-built_in">string</span>2 ...<br></code></pre></td></tr></table></figure><p>显示软件包的详尽的信息：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>pacman -Si package_name<br></code></pre></td></tr></table></figure><p>查询本地安装包的详细信息：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>pacman -Qi package_name<br></code></pre></td></tr></table></figure><p>使用两个 <code>-i</code> 将同时显示备份文件和修改状态：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>pacman -Qii package_name<br></code></pre></td></tr></table></figure><p>要获取已安装软件包所包含文件的列表：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>pacman -Ql package_name<br></code></pre></td></tr></table></figure><p>查询远程库中软件包包含的文件：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>pacman -Fl package_name<br></code></pre></td></tr></table></figure><p>检查软件包安装的文件是否都存在：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>pacman -Qk package_name<br></code></pre></td></tr></table></figure><p>两个参数<code>k</code>将会执行一次更彻底的检查。 查询数据库获取某个文件属于哪个软件包：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ pacman -Qo <span class="hljs-regexp">/path/</span>to/file_name<br></code></pre></td></tr></table></figure><p>查询文件属于远程数据库中的哪个软件包：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ pacman -F <span class="hljs-regexp">/path/</span>to/file_name<br></code></pre></td></tr></table></figure><p>要罗列所有不再作为依赖的软件包(孤立orphans)：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>pacman -Qdt<br></code></pre></td></tr></table></figure><p><strong>提示：</strong> 将上述命令添加到 pacman 的一个处理后 <a href="https://wiki.archlinux.org/index.php/Pacman_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#Hooks">hook</a>用于在如果有处理产生孤立包后获得提示。这在当有软件包被仓库放弃时是有用的，因为任何被抛弃的包都会成为本地的一个孤立包（除非它是被显式安装的）。要避免在没有找到孤立包时”failed to execute command”的错误，在你的 hook 中为<code>Exec</code>使用如下的指令: <code>/usr/bin/bash -c &quot;/usr/bin/pacman -Qtd || /usr/bin/echo &#39;=&gt; None found.&#39;&quot;</code></p><p>要罗列所有明确安装而且不被其它包依赖的软件包：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>pacman -Qet<br></code></pre></td></tr></table></figure><p>更多例子查看<a href="https://wiki.archlinux.org/index.php/Pacman_tips">pacman tips</a>。</p><h4 id="Pactree"><a href="#Pactree" class="headerlink" title="Pactree"></a>Pactree</h4><p><strong>注意：</strong> <a href="https://man.archlinux.org/man/pactree.8">pactree(8)</a>不再是<a href="https://archlinux.org/packages/?name=pacman">pacman</a>的一部分。它现在在<a href="https://archlinux.org/packages/?name=pacman-contrib">pacman-contrib</a>中。</p><p>要显示软件包的依赖树：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>pactree package_name<br></code></pre></td></tr></table></figure><p>检查一个<em>安装</em>的软件包被那些包依赖，将递归标识<code>-r</code>传递给 <em>pactree</em>，或者使用 <a href="https://aur.archlinux.org/packages/pkgtools/">pkgtools</a>AUR中的<em>whoneeds</em></p><h4 id="数据库结构"><a href="#数据库结构" class="headerlink" title="数据库结构"></a>数据库结构</h4><p>pacman数据库通常位于 <code>/var/lib/pacman/sync</code>. 对于每一个在<code>/etc/pacman.conf</code>中指定的软件仓库， 这里都有一个一致的数据库。数据库文件夹里每个tar.gz文件都包含着一个仓库的软件包信息。例如<a href="https://archlinux.org/packages/?name=which">which</a> 包:</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">$ tree which<span class="hljs-string">-2</span>.21<span class="hljs-string">-5</span><br>which<span class="hljs-string">-2</span>.21<span class="hljs-string">-5</span><br>|-- desc<br></code></pre></td></tr></table></figure><p>这个 <code>depends</code> 项列出了该软件的依赖包， 而<code>desc</code>有该包的介绍，例如文件大小和MD5值 。</p><h3 id="清理软件包缓存"><a href="#清理软件包缓存" class="headerlink" title="清理软件包缓存"></a>清理软件包缓存</h3><p><em>pacman</em> 将下载的软件包保存在 <code>/var/cache/pacman/pkg/</code> 并且不会自动移除旧的和未安装版本的软件包。这样做有一些好处：</p><ol><li>这样允许<a href="https://wiki.archlinux.org/index.php/Downgrading_packages_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">降级</a>软件包而不需要通过其他方式提取旧版本，例如 <a href="https://wiki.archlinux.org/index.php/Arch_Linux_Archive_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">Arch Linux Archive</a>.</li><li>被卸载的软件包可以轻易地直接从缓存文件夹重新安装，不需要重新从软件仓库下载。</li></ol><p>然而，需要定期手动清理缓存来避免该文件夹无限制增大。</p><p><a href="https://archlinux.org/packages/?name=pacman-contrib">pacman-contrib</a> 提供的 <a href="https://man.archlinux.org/man/paccache.8">paccache(8)</a> 脚本默认会删除所有缓存的版本和已卸载的软件包，除了最近的3个会被保留：</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># paccache -r</span><br></code></pre></td></tr></table></figure><p><a href="https://wiki.archlinux.org/index.php/Enable">启用</a> 和 <a href="https://wiki.archlinux.org/index.php/Start">启动</a> <code>paccache.timer</code>来每周删除不使用的包。</p><p><strong>提示：</strong> 可以使用 <a href="https://wiki.archlinux.org/index.php/Pacman_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#Hooks">hook</a> 自动执行清理，参考[<a href="https://bbs.archlinux.org/viewtopic.php?pid=1694743#p1694743">1]</a>和<a href="https://aur.archlinux.org/packages/pacman-cleanup-hook/">pacman-cleanup-hook</a>AUR。</p><p>也可以自己设置保留最近几个版本：</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># paccache -rk1</span><br></code></pre></td></tr></table></figure><p>添加<code>-u</code>/<code>--uninstalled</code>开关来限制<em>paccache</em>的行为只作用于卸载的包。例如清理所有卸载的包的缓存版本，可以用以下命令:</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># paccache -ruk0</span><br></code></pre></td></tr></table></figure><p>或者你可以将安装其结合，同时作用于安装的和卸载的包，例如想要保留最近两个安装的包但是移除所有卸载的包的缓存版本，使用以下命令：</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># paccache -rk2 -ruk0</span><br></code></pre></td></tr></table></figure><p>更多参数参见<code>paccache -h</code>。</p><p><em>pacman</em>也有一些内建参数用于清除缓存和那些不再在<code>/etc/pacman.conf</code>配置文件中列出的软件仓库残留数据库文件。然而<em>pacman</em>并不提供保留一定数量的过去版本的功能，因此它比<em>paccache</em>的默认选项更加激进。</p><p>要删除目前没有安装的所有缓存的包，和没有被使用的同步数据库，执行：</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># pacman -Sc</span><br></code></pre></td></tr></table></figure><p>要删除缓存中的全部文件，使用两次<code>-c</code>开关。这是最为激进的方式，将会清空缓存文件夹：</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># pacman -Scc</span><br></code></pre></td></tr></table></figure><p><strong>警告：</strong> 应当避免从缓存中删除所有过去版本和卸载的包，除非需要更多磁盘空间。这样会导致无法降级或重新安装包而不再次下载他们</p><p><a href="https://aur.archlinux.org/packages/pkgcacheclean/">pkgcacheclean</a>AUR以及<a href="https://aur.archlinux.org/packages/pacleaner/">pacleaner</a>AUR是两个进一步清理缓存的替代工具</p><h3 id="其它命令"><a href="#其它命令" class="headerlink" title="其它命令"></a>其它命令</h3><p>升级系统时安装其他软件包：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-attr"># pacman -Syu package_name1</span> package_<span class="hljs-symbol">name2</span> ...<br></code></pre></td></tr></table></figure><p>下载包而不安装它：</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># pacman -Sw package_name</span><br></code></pre></td></tr></table></figure><p>安装一个<strong>本地</strong>包(不从源里下载）：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"># pacman -U <span class="hljs-regexp">/path/</span>to<span class="hljs-regexp">/package/</span>package_name-version.pkg.tar.xz<br></code></pre></td></tr></table></figure><p>要将本地包保存至缓存，可执行：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"># pacman -U file:///<span class="hljs-type">path</span>/<span class="hljs-keyword">to</span>/package/package_name-<span class="hljs-keyword">version</span>.pkg.tar.xz<br></code></pre></td></tr></table></figure><p>安装一个<strong>远程</strong>包（不在 <em>pacman</em> 配置的源里面）：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta"># pacman -U http:<span class="hljs-comment">//www.example.com/repo/example.pkg.tar.xz</span></span><br></code></pre></td></tr></table></figure><p>要禁用 <code>-S</code>, <code>-U</code> 和 <code>-R</code> 动作，可以使用 <code>-p</code> 选项.</p><p><em>pacman</em> 会列出需要安装和删除的软件，并在执行动作前要求需要的权限。</p><h3 id="安装原因"><a href="#安装原因" class="headerlink" title="安装原因"></a>安装原因</h3><p><em>pacman</em>数据库按照软件包被安装的原因，将其分为两类：</p><ul><li><strong>显式安装</strong>：那些真正地被传递给通用<em>pacman</em><code>-S</code>和<code>-U</code>命令的包；</li><li><strong>依赖</strong>：那些虽然（一般）从未被传递给<em>pacman</em>安装命令，但由于被其它显式安装的包<a href="https://wiki.archlinux.org/index.php/Dependency">需要</a>从而被隐式安装的包</li></ul><p>当安装软件包时，可以把安装原因强制设为<strong>依赖</strong>:</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># pacman -S --asdeps package_name</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong> 用<code>--asdeps</code>安装可选依赖将导致如果你<a href="https://wiki.archlinux.org/index.php/Pacman/Tips_and_tricks#Removing_unused_packages_.28orphans.29">移除孤立包</a>，<em>pacman</em>将会一同移除剩下的可选依赖。</p><p>但是当重新安装该软件包时，安装原因将会被设为软件包所默认的。</p><p>显式安装的软件包列表可用<code>pacman -Qe</code>获取, 与之互补的已安装的依赖包可用<code>pacman -Qd</code>获取。</p><p>改变某个已安装软件包的安装原因，可以执行：</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># pacman -D --asdeps package_name</span><br></code></pre></td></tr></table></figure><p><strong>注意：</strong> 在升级时使用<code>--asdeps</code>和<code>--asexplicit</code>选项，例如<code>pacman -Syu *package_name* --asdeps</code>，是不被推荐的。这会导致不仅改变要被安装的软件包的安装原因，也会改变被升级的软件包的安装原因。</p><h3 id="查询一个包含具体文件的包名"><a href="#查询一个包含具体文件的包名" class="headerlink" title="查询一个包含具体文件的包名"></a>查询一个包含具体文件的包名</h3><p>同步文件数据库:</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># pacman -Fy</span><br></code></pre></td></tr></table></figure><p>查询包含某个文件的包名，比如:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># pacman -F pacman</span><br>core/pacman <span class="hljs-number">5.0</span>.<span class="hljs-number">1</span>-<span class="hljs-number">4</span><br>    usr<span class="hljs-regexp">/bin/</span>pacman<br>    usr<span class="hljs-regexp">/share/</span>bash-completion<span class="hljs-regexp">/completions/</span>pacman<br>extra/xscreensaver <span class="hljs-number">5.36</span>-<span class="hljs-number">1</span><br>    usr<span class="hljs-regexp">/lib/</span>xscreensaver/pacman<br></code></pre></td></tr></table></figure><p><strong>提示：</strong>  可以设置一个 <code>crontab</code> 或者 <code>systemd timer</code> 来定期同步文件信息数据库。</p><p>如果需要高级功能请安装 <a href="https://wiki.archlinux.org/index.php/Pkgfile">pkgfile</a>，它使用一个单独的数据库来保存文件和它们所关联的软件包的信息。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p><em>pacman</em> 的配置文件位于<code>/etc/pacman.conf</code>。 <a href="https://archlinux.org/pacman/pacman.conf.5.html">man pacman.conf</a> 可以查看配置文件的进一步信息。</p><h3 id="通用选项"><a href="#通用选项" class="headerlink" title="通用选项"></a>通用选项</h3><p>通用选项都在<code>[options]</code>段。阅读 man 手册或者查看默认的 pacman.conf 可以获得有关信息和用法。</p><h3 id="升级前对比版本"><a href="#升级前对比版本" class="headerlink" title="升级前对比版本"></a>升级前对比版本</h3><p>要查看旧版和新版的有效安装包，请取消<code>/etc/pacman.conf</code>中”VerbosePkgLists”的注释。修改后的<code>pacman -Syu</code>输出如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Package</span> (<span class="hljs-number">6</span>)             Old Version  New Version  Net Change  Download Size<br><br><span class="hljs-attribute">extra</span>/libmariadbclient  <span class="hljs-number">10</span>.<span class="hljs-number">1</span>.<span class="hljs-number">9</span>-<span class="hljs-number">4</span>     <span class="hljs-number">10</span>.<span class="hljs-number">1</span>.<span class="hljs-number">10</span>-<span class="hljs-number">1</span>      <span class="hljs-number">0</span>.<span class="hljs-number">03</span> MiB       <span class="hljs-number">4</span>.<span class="hljs-number">35</span> MiB<br><span class="hljs-attribute">extra</span>/libpng            <span class="hljs-number">1</span>.<span class="hljs-number">6</span>.<span class="hljs-number">19</span>-<span class="hljs-number">1</span>     <span class="hljs-number">1</span>.<span class="hljs-number">6</span>.<span class="hljs-number">20</span>-<span class="hljs-number">1</span>       <span class="hljs-number">0</span>.<span class="hljs-number">00</span> MiB       <span class="hljs-number">0</span>.<span class="hljs-number">23</span> MiB<br><span class="hljs-attribute">extra</span>/mariadb           <span class="hljs-number">10</span>.<span class="hljs-number">1</span>.<span class="hljs-number">9</span>-<span class="hljs-number">4</span>     <span class="hljs-number">10</span>.<span class="hljs-number">1</span>.<span class="hljs-number">10</span>-<span class="hljs-number">1</span>      <span class="hljs-number">0</span>.<span class="hljs-number">26</span> MiB      <span class="hljs-number">13</span>.<span class="hljs-number">80</span> MiB<br></code></pre></td></tr></table></figure><h4 id="在升级时跳过软件包"><a href="#在升级时跳过软件包" class="headerlink" title="在升级时跳过软件包"></a>在升级时跳过软件包</h4><p><strong>警告：</strong> 在跳过软件包时要小心，因为<a href="https://wiki.archlinux.org/index.php/System_maintenance_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E4%B8%8D%E6%94%AF%E6%8C%81%E9%83%A8%E5%88%86%E5%8D%87%E7%BA%A7">部分升级不受支持</a></p><p>要想在<a href="https://wiki.archlinux.org/index.php/Pacman_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E5%8D%87%E7%BA%A7%E8%BD%AF%E4%BB%B6%E5%8C%85">升级</a>系统时跳过特定的软件包，用像如下的命令指明：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">IgnorePkg</span>=linux<br></code></pre></td></tr></table></figure><p>多软件包可以用空格隔开，或者用另外的<code>IgnorePkg</code>行。也可使用 <a href="https://en.wikipedia.org/wiki/glob_(programming)">glob</a> 模式。如果只打算忽略一次升级，可以使用 <code>--ignore</code> 选项，这时使用逗号隔开的列表。</p><p>忽略了的软件包依然可通过 <code>pacman -S</code> 升级。这种情况下<em>pacman</em>会提醒你这些软件包已经被包含在<code>IgnorePkg</code>声明中。</p><h4 id="在升级时跳过软件包组"><a href="#在升级时跳过软件包组" class="headerlink" title="在升级时跳过软件包组"></a>在升级时跳过软件包组</h4><p><strong>警告：</strong> 在跳过软件包时要小心，因为<a href="https://wiki.archlinux.org/index.php/System_maintenance_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E4%B8%8D%E6%94%AF%E6%8C%81%E9%83%A8%E5%88%86%E5%8D%87%E7%BA%A7">部分升级不受支持</a></p><p>和软件包一样，也可以不升级某个软件包组：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">IgnoreGroup</span> = gnome<br></code></pre></td></tr></table></figure><h4 id="在升级时跳过文件"><a href="#在升级时跳过文件" class="headerlink" title="在升级时跳过文件"></a>在升级时跳过文件</h4><p>所有在<code>NoUpgrade</code>指令中列出的文件都会在软件包被安装/升级时不会被更改，并且新文件会以带有*.pacnew*后缀名的形式安装</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">NoUpgrade=path<span class="hljs-regexp">/to/</span><span class="hljs-keyword">file</span><br></code></pre></td></tr></table></figure><p><strong>注意：</strong> 这个路径指软件包中的文件，所以不要包括开头的斜线。</p><h4 id="在安装时跳过文件"><a href="#在安装时跳过文件" class="headerlink" title="在安装时跳过文件"></a>在安装时跳过文件</h4><p>要总是跳过某些文件夹的安装，可以将它们放到 <code>NoExtract</code> 中，例如不想安装 <a href="https://wiki.archlinux.org/index.php/Systemd">systemd</a> 模块：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">NoExtract=usr<span class="hljs-regexp">/lib/</span>systemd<span class="hljs-regexp">/system/</span>*<br></code></pre></td></tr></table></figure><p>后面的规则覆盖前面的规则，加上 <code>!</code> 可以取消跳过效果。</p><p><strong>提示：</strong> <em>pacman</em>会在更新locales已经被<em>localepurge</em>或者<em>bleachbit</em>清除的包时发出警告。将<code>CheckSpace</code>参数加入<code>pacman.conf</code>能够抑制这种警告，但是要意识到space-check功能将会对所有软件包禁用。</p><h3 id="保留多个配置文件"><a href="#保留多个配置文件" class="headerlink" title="保留多个配置文件"></a>保留多个配置文件</h3><p>如果你有多个配置文件（比如，主配置和启用了<a href="https://wiki.archlinux.org/index.php/Official_repositories_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#testing_%E4%BB%93%E5%BA%93">测试仓库</a>的配置文件），需要共享一些设置，你可以在配置文件中使用<code>Include</code>选项，例如：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">Include</span> = <span class="hljs-regexp">/path/</span>to<span class="hljs-regexp">/common/</span>settings<br></code></pre></td></tr></table></figure><p><code>*/path/to/common/settings*</code>文件中是两个配置文件共享的相同配置。</p><h3 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h3><p><em>pacman</em>可以在处理前后，运行<code>/usr/share/libalpm/hooks/</code>文件夹下的hooks，更多的hooks文件夹可以通过<code>HooDir</code>选项在<code>pacman.conf</code>中指明，默认<code>/etc/pacman.d/hooks</code>。Hook文件必须以*.hook*为后缀。Pacman hooks不是交互式的。</p><p><em>pacman</em> hooks用于，比如说，和<code>systemd-sysusers</code>和<code>systemd-tmpfiles</code>结合来在安装包时自动创建系统用户和文件。例如，<a href="https://archlinux.org/packages/?name=tomcat8">tomcat8</a>指明它想要创建一个叫做<code>tomcat8</code>的系统用户和一些属于该用户的文件。当<em>pacman</em>确定<a href="https://archlinux.org/packages/?name=tomcat8">tomcat8</a>包含文件指明用户和临时文件时，<em>pacman</em> hooks <code>systemd-sysusers.hook</code>和<code>systemd-tmpfiles.hook</code>唤起<code>systemd-sysusers</code>和<code>systemd-tmpfiles</code>。</p><p>有关 alpm hooks 的更多信息，参见<a href="https://man.archlinux.org/man/alpm-hooks.5">alpm-hooks(5)</a>。</p><h3 id="软件仓库"><a href="#软件仓库" class="headerlink" title="软件仓库"></a>软件仓库</h3><p>除了特殊的<a href="https://wiki.archlinux.org/index.php/Pacman_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E9%80%9A%E7%94%A8%E9%80%89%E9%A1%B9">通用选项</a>节, 每个<code>pacman.conf</code>中的<code>[section]</code>都定义了一个使用的软件包仓库，<em>仓库</em>是多个软件包的<em>逻辑</em>上的集合，他们<em>物理</em>上存储在一个或多个服务器：这也是为什么每一个服务器都叫做这个仓库的<em>镜像</em>。</p><p>仓库区分为<a href="https://wiki.archlinux.org/index.php/Official_repositories_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">官方仓库</a>与<a href="https://wiki.archlinux.org/index.php/Unofficial_user_repositories_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">非官方仓库</a>。配置文件中仓库的顺序十分重要；当几个仓库出现同名安装包，不管版本号如何，<em>pacman</em>将使用配置文件中排前的仓库。要在添加后使用某个仓库，你需要先<a href="https://wiki.archlinux.org/index.php/Pacman_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E5%8D%87%E7%BA%A7%E8%BD%AF%E4%BB%B6%E5%8C%85">升级</a>整个系统</p><p>每个仓库节都可以直接指定镜像列表或者<code>Include</code>引用其他的文件：例如，官方镜像引用了<code>/etc/pacman.d/mirrorlist/</code>。具体查看<a href="https://wiki.archlinux.org/index.php/Mirrors_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">Mirrors (简体中文)</a>。</p><h3 id="软件包的安全性"><a href="#软件包的安全性" class="headerlink" title="软件包的安全性"></a>软件包的安全性</h3><p><em>pacman</em> 支持软件包签名，会为软件包提供额外的安全性。默认配置，<code>SigLevel = Required DatabaseOptional</code> 将启用全局签名验证，但会被每个软件仓库的 <code>SigLevel</code> 行所覆盖。有关软件包签名和签名验证的更多细节，参见 <a href="https://wiki.archlinux.org/index.php/Pacman-key_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">pacman-key</a>。</p><hr><h2 id="Manjaro包管理常用命令"><a href="#Manjaro包管理常用命令" class="headerlink" title="Manjaro包管理常用命令"></a>Manjaro包管理常用命令</h2><ul><li>对整个系统进行更新</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo pacman -Syu   <br></code></pre></td></tr></table></figure><ul><li>升级软件包</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo pacman -Syu<br></code></pre></td></tr></table></figure><ul><li>安装或者升级单个软件包，或者一列软件包（包含依赖包），使用如下命令：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo pacman -S package_name1 package_name2 ...<br></code></pre></td></tr></table></figure><ul><li>与上面命令不同的是，该命令将在同步包数据库后再执行安装</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo pacman -Sy package_name<br></code></pre></td></tr></table></figure><ul><li>安装本地包</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo pacman -U local_package_name#其扩展名为pkg.tar.gz或pkg.tar.xz<br></code></pre></td></tr></table></figure><ul><li>安装一个远程包</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo pacman -U url#不在 pacman 配置的源里面，例：pacman -U http://www.example.com/repo/example.pkg.tar.xz<br></code></pre></td></tr></table></figure><ul><li>在仓库中搜索含关键字的包</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo pacman -Ss keyword<br></code></pre></td></tr></table></figure><ul><li>查看已安装软件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo pacman -Qs keyword     <br></code></pre></td></tr></table></figure><ul><li>删除单个软件包，保留其全部已经安装的依赖关系</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo pacman -R package_name<br></code></pre></td></tr></table></figure><ul><li>删除指定软件包，及其所有没有被其他已安装软件包使用的依赖关系：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo pacman -Rs package_name#要删除软件包和所有依赖这个软件包的程序，警告: 此操作是递归的，请小心检查，可能会一次删除大量的软件包。<br></code></pre></td></tr></table></figure><ul><li>清理软件包缓存</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo pacman -Sc<br></code></pre></td></tr></table></figure><ul><li>清理所有的缓存文件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo pacman -Scc<br></code></pre></td></tr></table></figure><ul><li>清除系统中无用的包</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo pacman -R $(pacman -Qdtq)<br></code></pre></td></tr></table></figure><ul><li><strong>从 AUR 安装软件包</strong>  </li><li>yay 安装命令不需要加 sudo</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">yay -S package <br></code></pre></td></tr></table></figure><ul><li>yay删除包</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">yay -Rns package <br></code></pre></td></tr></table></figure><ul><li>升级所有已安装的包</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">yay -Syu<br></code></pre></td></tr></table></figure><ul><li>打印系统统计信息</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">yay -Ps<br></code></pre></td></tr></table></figure><ul><li>检查安装的版本</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">yay -Qi package<br></code></pre></td></tr></table></figure><hr><h1 id="AUR国内源"><a href="#AUR国内源" class="headerlink" title="AUR国内源"></a>AUR国内源</h1><p>笔者在写这篇文章的时候，网上的资料并不多。毕竟选择Arch的用户较少，而选择<strong>Yay</strong>的用户更少。<strong>Yay</strong>默认使用法国的aur.archlinux.org作为AUR源，这样的速度显然不是我们可以接受的，因此我们需要切换为国内的tuna源</p><p><strong>Yay</strong>在安装好以后是默认不生成配置文件的。这就难以去更改默认源。笔者搜罗GIthub上的issue，根据 <a href="https://github.com/Jguer/yay/issues/697">#697</a> Issue，运行以下命令更新软件源和系统，顺便创建配置文件</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">yay</span> <span class="hljs-literal">-</span><span class="hljs-comment">Syu</span> --<span class="hljs-comment">devel</span> --<span class="hljs-comment">combinedupgrade</span> --<span class="hljs-comment">save</span><br></code></pre></td></tr></table></figure><p>然后编辑<code>~/.config/yay/config.json</code>文件，就可以看到熟悉的aururl参数啦，那么把它替换为<code>https://aur.tuna.tsinghua.edu.cn</code>即可</p><hr><h1 id="yay命令"><a href="#yay命令" class="headerlink" title="yay命令"></a>yay命令</h1><table><thead><tr><th align="left"><code>yay &lt;Search Term&gt;</code></th><th>Present package-installation selection menu.</th></tr></thead><tbody><tr><td align="left"><code>yay -Ps</code></td><td>Print system statistics.</td></tr><tr><td align="left"><code>yay -Yc</code></td><td>Clean unneeded dependencies.</td></tr><tr><td align="left"><code>yay -G &lt;AUR Package&gt;</code></td><td>Download PKGBUILD from ABS or AUR.</td></tr><tr><td align="left"><code>yay -Y --gendb</code></td><td>Generate development package database used for devel update.</td></tr><tr><td align="left"><code>yay -Syu --devel --timeupdate</code></td><td>Perform system upgrade, but also check for development package  updates and use PKGBUILD modification time (not version number) to  determine update.</td></tr></tbody></table><p>使用 yay：</p><p>搜索：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">yay -Ss &lt;package-name&gt;<br></code></pre></td></tr></table></figure><p>安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">yay -S &lt;package-name&gt;<br></code></pre></td></tr></table></figure><hr><h1 id="有关yay的基本用法，请参阅下面的示例。"><a href="#有关yay的基本用法，请参阅下面的示例。" class="headerlink" title="有关yay的基本用法，请参阅下面的示例。"></a>有关yay的基本用法，请参阅下面的示例。</h1><p>示例1：使用yay安装包</p><p>使用选项-S使用yay从AUR安装软件包：</p><p>$ yay -S package</p><p>示例2：使用yay删除包</p><p>要删除包，请使用-Rns选项：</p><p>$ yay -Rns package</p><p>示例3：启动包选择菜单</p><p>使用：</p><p>$ yay <Search Term></p><p>示例4：使用yay升级已安装的软件包</p><p>要升级所有已安装的包，请使用以下选项：</p><p>$ yay -Syu</p><p> 要包含开发包，请使用：</p><p>$ yay -Syu –devel –timeupdate</p><p>示例5：使用yay清除不需要的依赖项</p><p>使用选项可删除系统上所有不需要的依赖项：</p><p>$ yay -Yc</p><p>示例6：使用yay打印系统统计信息</p><p>要打印系统统计信息，请使用-Ps：</p><p>$ yay -Ps</p><p>示例7：生成用于开发更新的开发包DB</p><p>$ yay -Y –gendb</p><p>至此，yay基本使用方法就讲到这了。</p><hr><h1 id="snap"><a href="#snap" class="headerlink" title="snap"></a>snap</h1><h3 id="如何使用snap"><a href="#如何使用snap" class="headerlink" title="如何使用snap"></a>如何使用snap</h3><p>列出计算机上所有snap安装情况：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo snap list</span><br></code></pre></td></tr></table></figure><p>在应用商店中查找snap：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo snap <span class="hljs-builtin-name">find</span> &lt;软件包名&gt;<br></code></pre></td></tr></table></figure><p>安装Snap软件：</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bnf">sudo snap install <span class="hljs-attribute">&lt;snap软件包名&gt;</span><br></code></pre></td></tr></table></figure><p>更新Snap软件：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">sudo snap <span class="hljs-built_in">ref</span>resh &lt;snap软件包名&gt;<br></code></pre></td></tr></table></figure><p>更新所有的snap软件包：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">sudo snap <span class="hljs-keyword">refresh</span> <span class="hljs-keyword">all</span><br></code></pre></td></tr></table></figure><p>要将Snap还原到以前安装的版本：</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bnf">sudo snap revert <span class="hljs-attribute">&lt;snap软件包名&gt;</span><br></code></pre></td></tr></table></figure><p>卸载snap软件：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo snap <span class="hljs-builtin-name">remove</span> &lt;snap软件包名&gt;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>manjaro常用命令</title>
    <link href="/2021/12/20/manjaro%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2021/12/20/manjaro%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h3 id="常规配置"><a href="#常规配置" class="headerlink" title="常规配置"></a>常规配置</h3><h4 id="软件源"><a href="#软件源" class="headerlink" title="软件源"></a>软件源</h4><p>配置中国的镜像</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gauss">sudo pacman-mirrors -g  <span class="hljs-meta"># 排列源，可不执行</span><br>sudo pacman-mirrors -c China -m <span class="hljs-built_in">rank</span> <span class="hljs-meta"># 更改源，在跳出的对话框里选择想要的源</span><br></code></pre></td></tr></table></figure><p>同步并更新系统：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo pacman -Syyu</span><br></code></pre></td></tr></table></figure><h4 id="pacman常用命令"><a href="#pacman常用命令" class="headerlink" title="pacman常用命令"></a>pacman常用命令</h4><h5 id="更新系统"><a href="#更新系统" class="headerlink" title="更新系统"></a>更新系统</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">sudo</span> <span class="hljs-string">pacman</span> <span class="hljs-string">-Syu</span>    <span class="hljs-comment">#对整个系统进行更新</span><br><span class="hljs-string">sudo</span> <span class="hljs-string">acman</span> <span class="hljs-string">-Syy</span>        <span class="hljs-comment">#强制更新</span><br><span class="hljs-string">sudo</span> <span class="hljs-string">acman</span> <span class="hljs-string">-Syudd</span>    <span class="hljs-comment">#  使用 -dd跳过所有检测</span><br><span class="hljs-attr">sudo acman -Sy:</span> <span class="hljs-string">从服务器下载新的软件包数据库（实际上就是下载远程仓库最新软件列表到本地）。</span><br><span class="hljs-attr">sudo acman -Su:</span> <span class="hljs-string">升级所有已安装的软件包。</span><br><span class="hljs-attr">sudo acman -Syyu:</span> <span class="hljs-string">更新软件库并更新系统</span><br></code></pre></td></tr></table></figure><h5 id="搜索包"><a href="#搜索包" class="headerlink" title="搜索包"></a>搜索包</h5><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs ceylon">pacman 使用 -Q 参数查询本地软件包数据库， -S 查询同步数据库，以及 -F查询文件数据库。<br><br>pacman -Ss keyword在仓库中搜索含关键字的包，查询位置包含了软件包的名字和描述<br>有时，-s的内置正则会匹配很多不需要的结果，所以应当指定仅搜索包名，而非描述或其他子段: <br>pacman -Ss <span class="hljs-string">&#x27;^vim-&#x27;</span><br><br><br>pacman -Sl &lt;repo&gt;:<br>显示软件仓库中所有软件的列表<br>    可以省略，通常这样用:pacman -Sl | 关键字<br><br>pacman -Qs keyword搜索已安装的包（常用）<br>pacman -Qu: 列出所有可升级的软件包<br>pacman -Qt: 列出不被任何软件要求的软件包<br><br>pacman -Q 软件名: 查看软件包是否已安装，已安装则显示软件包名称和版本<br>pacman -Qi <span class="hljs-keyword">package</span><span class="hljs-number">_n</span>ame查询本地安装包的详细信息<br>pacman -Ql <span class="hljs-keyword">package</span><span class="hljs-number">_n</span>ame列出该包的文件<br>pacman -F string<span class="hljs-number">1</span> string<span class="hljs-number">2</span> ... 按文件名查找软件库：<br>pacman -Si <span class="hljs-keyword">package</span><span class="hljs-number">_n</span>ame显示远程软件包的详尽的信息<br>pacman -Qii <span class="hljs-keyword">package</span><span class="hljs-number">_n</span>ame使用两个 -i 将同时显示备份文件和修改状态<br>pacman -Ql <span class="hljs-keyword">package</span><span class="hljs-number">_n</span>ame要获取已安装软件包所包含文件的列表<br>pacman -Fl <span class="hljs-keyword">package</span><span class="hljs-number">_n</span>ame查询远程库中软件包包含的文件<br>pacman -Qk <span class="hljs-keyword">package</span><span class="hljs-number">_n</span>ame检查软件包安装的文件是否都存在<br>pacman -Fo /path/to/file<span class="hljs-number">_n</span>ame查询文件属于远程数据库中的哪个软件包<br>pacman -Qdt要罗列所有不再作为依赖的软件包(孤立orphans)<br>pacman -Qet要罗列所有明确安装而且不被其它包依赖的软件包<br><br>pacman -Sg: 列出软件仓库上所有的软件包组<br>pacman -Qg: 列出本地已经安装的软件包组和子包（pacman -Qg 软件包组: 和pacman -Sg 软件包组完全一样）<br></code></pre></td></tr></table></figure><h5 id="软件依赖"><a href="#软件依赖" class="headerlink" title="软件依赖"></a>软件依赖</h5><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ceylon">pactree <span class="hljs-keyword">package</span><span class="hljs-number">_n</span>ame要显示软件包的依赖树<br>whoneeds <span class="hljs-keyword">package</span><span class="hljs-number">_n</span>ame检查一个安装的软件包被那些包依赖pkgtoolsAUR中的whoneeds<br>pactree -r <span class="hljs-keyword">package</span><span class="hljs-number">_n</span>ame检查一个安装的软件包被那些包依赖<br></code></pre></td></tr></table></figure><h5 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h5><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">pacman -S package_name执行 pacman -S firefox 将安装 Firefox（常用）你也可以同时安装多个包，只需以空格分隔包名即<br>pacman -S --needed 软件名<span class="hljs-number">1</span> 软件名<span class="hljs-number">2</span>: 安装软件，但不重新安装已经是最新的软件。<br>pacman -Sy package_name与上面命令不同的是，该命令将在同步包数据库后再执行安装。<br>pacman -Sv package_name在显示一些操作信息后执行安装。<br>pacman -Sw 软件名: 只下载软件包，不安装。<br>pacman -U local_package_name安装本地包，其扩展名为pkg.tar.gz或pkg.tar.xz<br>pacman -U url安装一个远程包（不在 pacman 配置的源里面）例：pacman -U http:<span class="hljs-regexp">//</span>www.example.com<span class="hljs-regexp">/repo/</span>example.pkg.tar.xz<br></code></pre></td></tr></table></figure><h5 id="卸载软件"><a href="#卸载软件" class="headerlink" title="卸载软件"></a>卸载软件</h5><figure class="highlight ldif"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ldif"><span class="hljs-attribute">pacman -R 软件名</span>: 该命令将只删除包，保留其全部已经安装的依赖关系<br><span class="hljs-attribute">pacman -Rv 软件名</span>: 删除软件，并显示详细的信息<br><span class="hljs-attribute">pacman -Rs 软件名</span>: 删除软件，同时删除本机上只有该软件依赖的软件。<br><span class="hljs-attribute">pacman -Rsc 软件名</span>: 删除软件，并删除所有依赖这个软件的程序，慎用<br><span class="hljs-attribute">pacman -Ru 软件名</span>: 删除软件,同时删除不再被任何软件所需要的依赖<br></code></pre></td></tr></table></figure><h5 id="清理缓存"><a href="#清理缓存" class="headerlink" title="清理缓存"></a>清理缓存</h5><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">pacman -Sc 清理未安装的包文件，包文件位于 <span class="hljs-regexp">/var/</span>cache<span class="hljs-regexp">/pacman/</span>pkg/ 目录。<br><br>pacman -Scc 要删除缓存中的全部文件，使用两次-c开关。这是最为激进的方式，将会清空缓存文件夹。<br>注： 应当避免从缓存中删除所有过去版本和卸载的包，除非需要更多磁盘空间。这样会导致无法降级或重新安装包而不再次下载他们<br></code></pre></td></tr></table></figure><h4 id="yay"><a href="#yay" class="headerlink" title="yay"></a>yay</h4><p>Yay 是用 Go 编写的 Arch Linux AUR 包管理工具。AUR 的全称是 Arch User Repository，是  Arch Linux/Manjaro 用户的社区驱动存储库，创建 AUR 的目的是使共享社区包的过程更容易和有条理。使用它可以在 Arch  Linux/Manjaro 系统中安装和更新软件包。这个软件仓库的软件包是相当丰富，可以查看这个网站的统计<a href="https://repology.org/repositories/statistics/total">Repository statistics</a>，它的软件列表可以在<a href="https://aur.archlinux.org/packages/">Archlinux AUR</a>查看。具体可以查看 Arch Wiki</p><blockquote><p>注意：很多教程比较老了，yaourt 目前已经停止维护，用户可以考虑迁移到 aurman 或 yay</p></blockquote><p><strong>安装 yay：</strong></p><p>配置 yay 的 aur 源为清华源 AUR 镜像：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">yay <span class="hljs-params">--aururl</span> <span class="hljs-string">&quot;https://aur.tuna.tsinghua.edu.cn&quot;</span> <span class="hljs-params">--save</span><br></code></pre></td></tr></table></figure><p>修改的配置文件位于 ~/.config/yay/config.json ，还可通过以下命令查看修改过的配置:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">yay -<span class="hljs-selector-tag">P</span> -g<br></code></pre></td></tr></table></figure><p>yay 的常用命令：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs haxe">yay -S <span class="hljs-keyword">package</span> <span class="hljs-meta"># 从 AUR 安装软件包</span><br>yay -Rns <span class="hljs-keyword">package</span> <span class="hljs-meta"># 删除包</span><br>yay -Syu <span class="hljs-meta"># 升级所有已安装的包</span><br>yay -Ps <span class="hljs-meta"># 打印系统统计信息</span><br>yay -Qi <span class="hljs-keyword">package</span> <span class="hljs-meta"># 检查安装的版本</span><br>yay 安装命令不需要加 sudo。<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ohmyzsh整理</title>
    <link href="/2021/12/20/oh-my-zsh/"/>
    <url>/2021/12/20/oh-my-zsh/</url>
    
    <content type="html"><![CDATA[<h1 id="手动安装"><a href="#手动安装" class="headerlink" title="手动安装"></a>手动安装</h1><h2 id="github"><a href="#github" class="headerlink" title="github"></a>github</h2><p><code>https://github.com/ohmyzsh/ohmyzsh</code></p><h3 id="1-克隆仓库"><a href="#1-克隆仓库" class="headerlink" title="1 克隆仓库"></a>1 克隆仓库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://github.com/ohmyzsh/ohmyzsh.git ~/.oh-my-zsh<br>或者<br>git clone git@github.com:ohmyzsh/ohmyzsh.git ~/.oh-my-zsh<br></code></pre></td></tr></table></figure><h3 id="2-将原来的～-zshrc备份"><a href="#2-将原来的～-zshrc备份" class="headerlink" title="2 将原来的～/.zshrc备份"></a>2 将原来的<code>～/.zshrc</code>备份</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp ~/.zshrc ~/.zshrc.bak<br></code></pre></td></tr></table></figure><h3 id="3-用新的zsh配置文件"><a href="#3-用新的zsh配置文件" class="headerlink" title="3 用新的zsh配置文件"></a>3 用新的zsh配置文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc<br></code></pre></td></tr></table></figure><h3 id="4-使得zsh变成默认的shell"><a href="#4-使得zsh变成默认的shell" class="headerlink" title="4 使得zsh变成默认的shell"></a>4 使得zsh变成默认的shell</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">nano .bashrc<br>在第一行添加<br>zsh<br></code></pre></td></tr></table></figure><h1 id="设置主题"><a href="#设置主题" class="headerlink" title="设置主题"></a>设置主题</h1><h2 id="设置固定主题"><a href="#设置固定主题" class="headerlink" title="设置固定主题"></a>设置固定主题</h2><ul><li><strong>安装完毕后，我们就可以使用了，先来简单配置一下，Oh My Zsh 提供了很多主题风格，我们可以根据自己的喜好，设置主题风格</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">open ~/.zshrc<br><br><span class="hljs-comment"># 找到 ZSH_THEME</span><br><span class="hljs-comment"># robbyrussell 是默认的主题</span><br>ZSH_THEME=<span class="hljs-string">&quot;robbyrussell&quot;</span><br><br><span class="hljs-comment"># ZSH_THEME=&quot;样式名称&quot; </span><br></code></pre></td></tr></table></figure><ul><li>保存这个文件文件，重新打开终端。</li></ul><h2 id="设置随机主题"><a href="#设置随机主题" class="headerlink" title="设置随机主题"></a>设置随机主题</h2><ul><li><strong>我们还可以随机设置主题：</strong></li><li>步骤同上</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ZSH_THEME=<span class="hljs-string">&quot;random&quot;</span><br></code></pre></td></tr></table></figure><ul><li>每次打开终端主题是随机的。</li><li>终端输出：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">[oh-my-zsh] Random theme <span class="hljs-string">&#x27;/Users/xxxx/.oh-my-zsh/themes/zhann.zsh-theme&#x27;</span> loaded...<br></code></pre></td></tr></table></figure><ul><li>其中 <strong>zhann.zsh-theme</strong> 是主题的名称， 有喜欢的童鞋可以记录保留.</li></ul><h2 id="查看主题名称"><a href="#查看主题名称" class="headerlink" title="查看主题名称"></a>查看主题名称</h2><ul><li><strong>Oh My Zsh</strong> 默认自带了一些默认主题，存放在 <strong>~/.oh-my-zsh/themes</strong> 目录中。我们可以查看这些主题</li><li>终端输入：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/.oh-my-zsh/themes &amp;&amp; ls<br></code></pre></td></tr></table></figure><h2 id="卸载-Oh-My-Zsh"><a href="#卸载-Oh-My-Zsh" class="headerlink" title="卸载 Oh My Zsh"></a>卸载 Oh My Zsh</h2><ul><li>终端输入 ：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">uninstall_oh_my_zsh<br>Are you sure you want to remove Oh My Zsh? [y/N]  Y<br></code></pre></td></tr></table></figure><ul><li>终端提示信息：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">Removing ~/.oh-my-zsh<br>Looking <span class="hljs-keyword">for</span> original zsh config...<br>Found ~/.zshrc.pre-oh-my-zsh -- Restoring to ~/.zshrc<br>Found ~/.zshrc -- Renaming to ~/.zshrc.omz-uninstalled-20170820200007<br>Your original zsh config was restored. Please restart your session.<br>Thanks <span class="hljs-keyword">for</span> trying out Oh My Zsh. It<span class="hljs-string">&#x27;s been uninstalled.</span><br></code></pre></td></tr></table></figure><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><h3 id="manjaro自带插件"><a href="#manjaro自带插件" class="headerlink" title="manjaro自带插件"></a>manjaro自带插件</h3><p>自己下载的插件放在<code>/home/kiylx/.oh-my-zsh/custom/plugins/</code></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vim">位置/usr/share/zsh/plugins/<br>一共三个<br>zsh-autosuggestions<br>zsh-<span class="hljs-keyword">history</span>-substring-<span class="hljs-built_in">search</span><br>zsh-<span class="hljs-keyword">syntax</span>-highlighting<br><br><span class="hljs-keyword">ps</span>：<br><span class="hljs-number">1</span>.其中zsh-<span class="hljs-keyword">history</span>-substring-<span class="hljs-built_in">search</span>是ohmyzsh自带的，只是名称不同，是<span class="hljs-keyword">history</span>-substring-<span class="hljs-built_in">search</span>。<br><span class="hljs-number">2</span>.zsh-<span class="hljs-keyword">syntax</span>-highligting必须排最后一个<br></code></pre></td></tr></table></figure><h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><p>这个是装好<a href="https://link.zhihu.com/?target=http://ohmyz.sh/">oh-my-zsh</a>就默认已经开启的</p><p>查看所有的git命令<a href="https://link.zhihu.com/?target=http://man.linuxde.net/alias?oqnsle=octhb">alias</a></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">~<span class="hljs-regexp">/.oh-my-zsh/</span>plugins<span class="hljs-regexp">/git/gi</span>t.plugin.zsh<br></code></pre></td></tr></table></figure><h3 id="z"><a href="#z" class="headerlink" title="z"></a>z</h3><p>这个是oh-my-zsh默认就装好的，需要自己开启。还有一个<code>autojump</code>的插件和<code>z</code>功能差不多，<code>autojump</code>需要单独装，</p><p>如果z插件历史记录太多，并且有一些不是自己想要的，可以删除</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">z -<span class="hljs-keyword">x</span> 不要的路径<br></code></pre></td></tr></table></figure><h3 id="auto-suggestions"><a href="#auto-suggestions" class="headerlink" title="auto-suggestions"></a>auto-suggestions</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions<br></code></pre></td></tr></table></figure><h3 id="zsh-syntax-highligting"><a href="#zsh-syntax-highligting" class="headerlink" title="zsh-syntax-highligting"></a>zsh-syntax-highligting</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $ZSH_CUSTOM/plugins/zsh-syntax-highlighting<br></code></pre></td></tr></table></figure><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-meta">## git open 插件</span><br>$ git <span class="hljs-keyword">open</span><br><span class="hljs-meta"># opens https:<span class="hljs-comment">//github.com/TRACKED_REMOTE_USER/CURRENT_REPO/tree/CURRENT_BRANCH</span></span><br><br>$ git <span class="hljs-keyword">open</span> someremote<br><span class="hljs-meta"># opens https:<span class="hljs-comment">//github.com/PROVIDED_REMOTE_USER/CURRENT_REPO/tree/CURRENT_BRANCH</span></span><br><br>$ git <span class="hljs-keyword">open</span> someremote somebranch<br><span class="hljs-meta"># opens https:<span class="hljs-comment">//github.com/PROVIDED_REMOTE_USER/CURRENT_REPO/tree/PROVIDED_BRANCH</span></span><br><br>$ git <span class="hljs-keyword">open</span> --issue<br><span class="hljs-meta"># If branches use naming convention of issues/#123,</span><br><span class="hljs-meta"># opens https:<span class="hljs-comment">//github.com/TRACKED_REMOTE_USER/CURRENT_REPO/issues/123</span></span><br><br>$ git <span class="hljs-keyword">open</span> --<span class="hljs-keyword">print</span><br><span class="hljs-meta"># prints https:<span class="hljs-comment">//github.com/TRACKED_REMOTE_USER/CURRENT_REPO/tree/CURRENT_BRANCH</span></span><br><br>$ git <span class="hljs-keyword">open</span> --suffix pulls<br><span class="hljs-meta"># opens https:<span class="hljs-comment">//github.com/TRACKED_REMOTE_USER/CURRENT_REPO/pulls</span></span><br><br></code></pre></td></tr></table></figure><hr><h3 id="thefuck修正命令"><a href="#thefuck修正命令" class="headerlink" title="thefuck修正命令"></a>thefuck修正命令</h3><p><a href="https://github.com/nvbn/thefuck#manual-installation">github</a></p><ul><li>安装thefuck  使用python的pip</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pip <span class="hljs-keyword">install</span> thefuck<br></code></pre></td></tr></table></figure><ul><li><p>配置</p><p>在<code>.bash_profile</code>, <code>.bashrc</code>, <code>.zshrc</code> or 其他启动脚本文件中添加</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">eval</span> $(thefuck --<span class="hljs-built_in">alias</span>)<br><span class="hljs-comment"># You can use whatever you want as an alias, like for Mondays:</span><br><span class="hljs-comment"># 你可以使用其他名称替代默认的别名，比如：</span><br><span class="hljs-built_in">eval</span> $(thefuck --<span class="hljs-built_in">alias</span> FUCK)<br></code></pre></td></tr></table></figure><p>让配置立即生效，需要重启终端，，或者，输入<code>source ~/.bashrc</code> (或者你的shell配置文件名称 <code>.zshrc</code>).</p></li></ul><h2 id="修改～-zshrc文件"><a href="#修改～-zshrc文件" class="headerlink" title="修改～/.zshrc文件"></a>修改～/.zshrc文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">例子<br>plugins=(<br>git <br>pip<br>extract <br>z <br>wd<br>auto-suggestions<br>zsh-syntax-highligting<br>auto-jumplast-working-dir<br>)<br><br>ZSH_THEME=&quot;robbyrussell&quot;<br></code></pre></td></tr></table></figure><p>如果想要启用某个插件，装好之后直接修改<br>plugins = (插件A 插件B 插件C)<br>git<br>这个是装好<a href="https://link.zhihu.com/?target=http://ohmyz.sh/">oh-my-zsh</a>就默认已经开启的<br>查看所有的git命令<a href="https://link.zhihu.com/?target=http://man.linuxde.net/alias?oqnsle=octhb">alias</a><br>~/.oh-my-zsh/plugins/git/git.plugin.zsh<br>z<br>这个是oh-my-zsh默认就装好的，需要自己开启。还有一个<code>autojump</code>的插件和<code>z</code>功能差不多，<code>autojump</code>需要单独装，<br>如果z插件历史记录太多，并且有一些不是自己想要的，可以删除<br>z -x 不要的路径</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>软件整理</title>
    <link href="/2021/12/20/%E8%BD%AF%E4%BB%B6/"/>
    <url>/2021/12/20/%E8%BD%AF%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="wps"><a href="#wps" class="headerlink" title="wps"></a>wps</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">yay -S wps-office wps-office-mui-zh-cn<br><br>安装完后启动WPS，可能会弹出窗口，提示「系统缺失字体」。问题原因是WPS For Linux没有自带Windows的字体。<br>在终端中输入以下命令进入tmp目录<br><span class="hljs-keyword">cd</span> <span class="hljs-string">/tmp</span><br>将字体库克隆下来<br>git clone git@github.com<span class="hljs-function">:IamDH4</span>/ttf-wps-fonts.git<br>进入下面的目录<br><span class="hljs-keyword">cd</span> ttf-wps-fonts<br>使用安装脚本安装字体<br>sudo bash install.sh<br>清理tmp目录<br>rm -rf <span class="hljs-string">/tmp/ttf-wps-fonts</span><br>完成<br><br>如果需要修改WPS的界面语言，先打开WPS Writer，新建一个文件，界面的右上方有个A字符的按钮，点进去后，取消勾选「跟随系统语言」选项，然后选择你想要的语言即可。<br> <br> 注：使用wps的用户还需要编辑~<span class="hljs-string">/.xprofile</span>添加以下内容（在新版中bug被修复了，但是如果有问题的话，可以尝试此方法）<br>export QT_IM_MODULE=fcitx5<br><br></code></pre></td></tr></table></figure><p>解决无法输入中文问题：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo vim /usr/bin/wps，在第一行（#!/bin/bash）下面添加：<br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">XMODIFIERS</span>=<span class="hljs-string">&quot;@im=fcitx&quot;</span><br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">QT_IM_MODULE</span>=<span class="hljs-string">&quot;fcitx&quot;</span><br><span class="hljs-attribute">gOpt</span>=gTemplateExt=(&quot;wpt&quot; <span class="hljs-string">&quot;dot&quot;</span> <span class="hljs-string">&quot;dotx&quot;</span>)<br></code></pre></td></tr></table></figure><hr><h3 id="使用timeshift备份系统"><a href="#使用timeshift备份系统" class="headerlink" title="使用timeshift备份系统"></a>使用timeshift备份系统</h3><p>安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">yay -S timeshift<br></code></pre></td></tr></table></figure><p>打开软件，保持默认。</p><p>在【用户】选项内设置需要备份的分区，</p><ul><li>root选择【包含一切】或者【排除一切】</li><li>home选择【排除一切】</li></ul><p>注： <strong>root</strong>默认就是全备份的，经测试更改也是无效的，也就是<strong>root</strong>必须备份。</p><p>在【筛选】选项内可以自定义备份文件或文件夹</p><p>建议这样配置：</p><ul><li><p>先将home整个目录排除，添加<code>/home/用户名/**</code></p></li><li><p>home目录下比较重要的如：<code>.local</code>、<code>.config</code>等，需要加入，切记要加上<code>***</code>三个星</p></li><li><p>创建快照</p><p>此时timeshift会根据时间生成一个带有时间戳的快照，此过程需要等待一段时间，并且期间不要对电脑执行任何操作。</p></li></ul><h5 id="如果只能进入登录界面"><a href="#如果只能进入登录界面" class="headerlink" title="如果只能进入登录界面"></a>如果只能进入登录界面</h5><p>一般系统崩溃后不能进入桌面，但是能够进入登录界面，现象就是在登录界面输入密码后不会进入桌面，那么就要通过命令行的方式进行还原。</p><ol><li><p>通过<code>Ctrl+Alt+F1</code>（一般是F1-F6都可）进入tty终端：</p></li><li><p>输入用户和密码登录</p></li><li><p>执行下面命令获取系统当前可以还原的节点：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">sudo timeshift <span class="hljs-comment">--list</span><br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>输出内容：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs subunit">Device : /dev/sdb4<br>UUID   : 197c4161-abc6<span class="hljs-string">-4069</span><span class="hljs-string">-8544</span>-d86594211f04<br>Path   : /home<br>Mode   : RSYNC<br>Device is OK<br>12 snapshots, 92.5 GB free<br><br>Num     Name                 Tags  Description  <br>------------------------------------------------------------------------------<br>0    &gt;  2018<span class="hljs-string">-08</span><span class="hljs-string">-08</span>_11<span class="hljs-string">-49</span><span class="hljs-string">-26</span>  O D                <br>1    &gt;  2018<span class="hljs-string">-08</span><span class="hljs-string">-13</span>_23<span class="hljs-string">-02</span><span class="hljs-string">-06</span>  O                  <br>2    &gt;  2018<span class="hljs-string">-08</span><span class="hljs-string">-15</span>_22<span class="hljs-string">-53</span><span class="hljs-string">-24</span>  O                  <br>3    &gt;  2018<span class="hljs-string">-08</span><span class="hljs-string">-21</span>_09<span class="hljs-string">-37</span><span class="hljs-string">-29</span>  O                  <br>4    &gt;  2018<span class="hljs-string">-11</span><span class="hljs-string">-19</span>_17<span class="hljs-string">-43</span><span class="hljs-string">-59</span>  O                  <br>5    &gt;  2019<span class="hljs-string">-01</span><span class="hljs-string">-20</span>_19<span class="hljs-string">-36</span><span class="hljs-string">-34</span>  O                  <br>6    &gt;  2019<span class="hljs-string">-03</span><span class="hljs-string">-01</span>_11<span class="hljs-string">-18</span><span class="hljs-string">-09</span>  O                  <br>7    &gt;  2019<span class="hljs-string">-03</span><span class="hljs-string">-01</span>_14<span class="hljs-string">-54</span><span class="hljs-string">-37</span>  O                  <br>8    &gt;  2019<span class="hljs-string">-03</span><span class="hljs-string">-04</span>_14<span class="hljs-string">-48</span><span class="hljs-string">-57</span>  O                  <br>9    &gt;  2019<span class="hljs-string">-03</span><span class="hljs-string">-10</span>_20<span class="hljs-string">-50</span><span class="hljs-string">-00</span>  O                  <br>10   &gt;  2019<span class="hljs-string">-03</span><span class="hljs-string">-14</span>_11<span class="hljs-string">-51</span><span class="hljs-string">-54</span>  O                  <br>11   &gt;  2019<span class="hljs-string">-07</span><span class="hljs-string">-16</span>_16<span class="hljs-string">-35</span><span class="hljs-string">-42</span>  O<br>123456789101112131415161718192021<br></code></pre></td></tr></table></figure></li><li><p>选择一个节点进行还原</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> timeshift --restore --snapshot &#x27;<span class="hljs-number">2019</span>-<span class="hljs-number">07</span>-<span class="hljs-number">16</span>_<span class="hljs-number">16</span>-<span class="hljs-number">35</span>-<span class="hljs-number">42</span>&#x27; --skip-grub<br><span class="hljs-attribute">1</span><br></code></pre></td></tr></table></figure><blockquote><p>–skip-grub 选项为跳过grub安装，一般来说grub不需要重新安装，除非bios启动无法找到正确的grub启动项，才需要安装。</p></blockquote><p>在输出的内容中依次输入【Enter】键和【y】键。</p><p>当然也可以直接输入下面的命令，忽略交互式的安装界面：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> timeshift --restore --snapshot &#x27;<span class="hljs-number">2019</span>-<span class="hljs-number">07</span>-<span class="hljs-number">16</span>_<span class="hljs-number">16</span>-<span class="hljs-number">35</span>-<span class="hljs-number">42</span>&#x27; --skip-grub --scripted<br><span class="hljs-attribute">1</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="无法进入系统，通过U盘启动系统"><a href="#无法进入系统，通过U盘启动系统" class="headerlink" title="无法进入系统，通过U盘启动系统"></a>无法进入系统，通过U盘启动系统</h3><p>当登录界面和桌面环境都无法进入时，一般系统已经彻底崩溃，此时只能通过Linux live CD进行还原。</p><ol><li><p>制作Linux Mint 启动盘，制作过程略。</p></li><li><p>进入Live系统后打开 <strong>Timeshift</strong> 软件，点击设置按钮，设置快照的存储位置：</p></li><li><blockquote><p>快照的存储位置是<strong>Timeshift</strong>在做备份的时候就已经设置好的。</p></blockquote></li><li><p>后续步骤和【如果能够进入系统】内的还原方式一样。</p></li></ol><p>其实此时还可以通过命令行的方式进行还原，但是首先需要设置快照存储的位置：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo timeshift --snapshot-device <span class="hljs-regexp">/dev/</span>sdb4<br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>后续步骤和【如果只能进入登录界面】内的还原方式一样。</p><hr><h5 id="错误：-Cannot-find-the-fakeroot-binary-gt-错误：-Cannot-find-the-strip-binary-required-for-object-fil…"><a href="#错误：-Cannot-find-the-fakeroot-binary-gt-错误：-Cannot-find-the-strip-binary-required-for-object-fil…" class="headerlink" title="错误： Cannot find the fakeroot binary. ==&gt; 错误： Cannot find the strip binary required for object fil…"></a>错误： Cannot find the fakeroot binary. ==&gt; 错误： Cannot find the strip binary required for object fil…</h5><p>解决方法：因为没安装 fakeroot、binutils 等打包基本工具，所以<code> sudo pacman -S base-devel</code> 装一下。(<code>sudo pacman -S -needed base-devel</code>安装包，且不重新安装已安装的包)</p><hr><h3 id="imwheel-调整鼠标滚轮速度"><a href="#imwheel-调整鼠标滚轮速度" class="headerlink" title="imwheel 调整鼠标滚轮速度"></a>imwheel 调整鼠标滚轮速度</h3><p>Arch：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo pacman -S imwheel<br></code></pre></td></tr></table></figure><h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a><strong>配置</strong></h5><p>创建<code>~/.imwheelrc</code>文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">nano ~/.imwheelrc<br></code></pre></td></tr></table></figure><p>编辑内容：</p><p>后面的数字就是速度的倍数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">&quot;.*&quot;<br>None,      Up,   Button4, 4<br>None,      Down, Button5, 4<br>Control_L, Up,   Control_L|Button4<br>Control_L, Down, Control_L|Button5<br>Shift_L,   Up,   Shift_L|Button4<br>Shift_L,   Down, Shift_L|Button5<br></code></pre></td></tr></table></figure><h5 id="运行"><a href="#运行" class="headerlink" title="运行"></a><strong>运行</strong></h5><p>运行测试一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">imwheel<br></code></pre></td></tr></table></figure><p>重新运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">imwheel kill<br></code></pre></td></tr></table></figure><p>看到提示就成功了。</p><p>使用systemed服务或者shell脚本在系统启动后自动调用<code>imwheel</code>，参照wiki.</p><h5 id="Run-IMWheel-on-startup-using-a-service"><a href="#Run-IMWheel-on-startup-using-a-service" class="headerlink" title="Run IMWheel on startup using a service"></a>Run IMWheel on startup using a service</h5><p>To avoid starting IMWheel manually, you can run it as part of your systemd startup.</p><p>Example:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs routeros">~/.config/systemd/user/imwheel.service<br>[Unit]<br><span class="hljs-attribute">Description</span>=IMWheel<br><span class="hljs-attribute">Wants</span>=display-manager.service<br><span class="hljs-attribute">After</span>=display-manager.service<br><br>[Service]<br><span class="hljs-attribute">Type</span>=simple<br><span class="hljs-attribute">Environment</span>=XAUTHORITY=%h/.Xauthority<br><span class="hljs-attribute">ExecStart</span>=/usr/bin/imwheel -d<br><span class="hljs-attribute">ExecStop</span>=/usr/bin/pkill imwheel<br><span class="hljs-attribute">RemainAfterExit</span>=<span class="hljs-literal">yes</span><br><br>[Install]<br><span class="hljs-attribute">WantedBy</span>=graphical-session.target<br></code></pre></td></tr></table></figure><p>After installing the above:</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">systemctl --<span class="hljs-keyword">user</span> <span class="hljs-title">daemon-reload</span><br>systemctl --<span class="hljs-keyword">user</span> <span class="hljs-title">enable</span> --now imwheel<br>journalctl --<span class="hljs-keyword">user</span> <span class="hljs-title">--unit</span> imwheel<br></code></pre></td></tr></table></figure><h5 id="Run-IMWheel-on-startup-using-a-shell-script"><a href="#Run-IMWheel-on-startup-using-a-shell-script" class="headerlink" title="Run IMWheel on startup using a shell script"></a>Run IMWheel on startup using a shell script</h5><p>Alternatively, you can create a startup.sh script in /etc/profile.d</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh</span><br><br>imwheel<br></code></pre></td></tr></table></figure><p>And then, on restart, it will automatically read and run the file. Always test your script manually before putting it in /etc/profile.d</p><hr><h3 id="安装配置vmware-workstation"><a href="#安装配置vmware-workstation" class="headerlink" title="安装配置vmware workstation"></a>安装配置vmware workstation</h3><h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>在manjaro的安装配置中，关于vmware的安装着实让我头疼;新建虚拟机打开出现错误</p><blockquote><p>could not open /dev/vmmon:?????? please make sure that the kernel moduel vmmon is load</p></blockquote><p>google、baidu搜索有遇到同样问题的，但是没有一个能够解决！！！前后折腾了许久，还选择安装了VirtulBox但是使用不习惯，后来突然醒悟可以去<code>manjaro</code>的论坛找找，这才找到解决方法。<br> 感慨：</p><ul><li>使用linux真的可以很好锻炼自我解决问题的能力。</li><li>找资料要有的放矢，不能盲目,否则就是浪费时间，要缩小查找范围。</li></ul><h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><ul><li>使用manjaro提供的方法Install vmware-workstation</li></ul><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">pamac build vmware-workstation</span><br></code></pre></td></tr></table></figure><ul><li>安装之后，重启你的设备，执行下面命令加载vmmon模块</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">sudo modprobe -<span class="hljs-selector-tag">a</span> vmw_vmci vmmon<br></code></pre></td></tr></table></figure><ul><li>Start and enable services（开启以及自启动服务）</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">sudo systemctl <span class="hljs-keyword">enable</span> <span class="hljs-comment">--now vmware-networks.service</span><br>sudo systemctl <span class="hljs-keyword">enable</span> <span class="hljs-comment">--now vmware-usbarbitrator.service</span><br>sudo systemctl <span class="hljs-keyword">enable</span> <span class="hljs-comment">--now vmware-hostd.service</span><br></code></pre></td></tr></table></figure><blockquote><p>上述服务的用处：<br>vmware-networks.service: Provides network access inside VMs, most people will want this enabled<br>vmware-usbarbitrator.service: Allows USB devices to be connected inside VMs<br>vmware-hostd.service: Enables sharing of VMs on the network</p></blockquote><p><em>至此，vmmon的问题应该完美解决了;如果你的问题还没有解决可以参考以下链接或者到manjaro frum提出问题</em><br> <a href="https://wiki.manjaro.org/index.php?title=VMware#Installing_VMWare_Workstation_on_Manjaro">Installing VMWare Workstation on Manjaro</a></p><h3 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">sudo pacman -S netease-cloud-music <span class="hljs-comment">#安装网易云音乐</span><br>高分屏缩放 可以通过 env QT_SCREEN_SCALE_FACTORS=<span class="hljs-number">1.25</span> netease-cloud-music 启动来解决,也就是在启动文件里添加。<br><br>如果应用商店下载时遇到下面错误<br>错误：未知下载协议：<span class="hljs-keyword">https</span><br>问题的解决办法是，修改一下 PKGBUILD 的第 <span class="hljs-number">18</span> 行，把 <span class="hljs-keyword">http</span> 改成 <span class="hljs-keyword">https</span> 就可以了。<br>DLAGENTS=(<span class="hljs-string">&quot;https::/usr/bin/curl -A &#x27;Mozilla&#x27; -fLC - --retry 3 --retry-delay 3 -o %o %u&quot;</span>)<br><br></code></pre></td></tr></table></figure><p>可能无法输入中文</p><ul><li>高颜值、开发活跃的第三方客户端：<code>yay -S yesplaymusic</code></li><li>qq音乐 <code>yay -S qqmusic-bin</code></li><li>一个支持全平台听歌的软件：FeelUown <code>yay -S feeluown</code></li></ul><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><ul><li><p>为知笔记：全平台通用、有云端同步、支持md的笔记 ： <code>yay -S wiznote</code></p></li><li><p>如果你更喜欢开源软件，这里还有个很好的选择： joplin <code>yay -S joplin</code></p></li><li><p>还有个选择：notion ： <code>yay -S notion-app</code></p></li><li><p>mkdown编辑器Typora： <code>yay -S typora</code></p></li><li><p>LaTeX是学术出版的标准排版软件。可以直接从软件仓库中安装，不需要完全安装，安装基础组件以及中文语言包即可：<code>sudo pacman -S texlive-most texlive-langchinese</code></p><p>编辑器TexStudio也是必备的：<code>sudo pacman -S texstudio</code></p></li></ul><h3 id="Android反编译"><a href="#Android反编译" class="headerlink" title="Android反编译"></a>Android反编译</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim">sudo pacman -S jadx<br>#官网：http<span class="hljs-variable">s:</span>//github.<span class="hljs-keyword">com</span>/skylot/jadx<br>打开<span class="hljs-keyword">gui</span>界面：jadx-<span class="hljs-keyword">gui</span><br></code></pre></td></tr></table></figure><h3 id="腾讯软件"><a href="#腾讯软件" class="headerlink" title="腾讯软件"></a>腾讯软件</h3><ul><li><p>安装qq</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">yay -S com<span class="hljs-selector-class">.qq</span><span class="hljs-selector-class">.im</span><span class="hljs-selector-class">.deepin</span><br>这个使用的是deepin-wine5<br>调整qq的缩放<br>WINEPREFIX=~/.deepinwine/Deepin-QQ deepin-wine5 winecfg<br></code></pre></td></tr></table></figure></li><li><p>安装Tim</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">yay -S deepin-wine-tim<br></code></pre></td></tr></table></figure><p>安装过程中出现选择输入n就好</p><p>切换deepin-wine环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">sh /opt/deepinwine/apps/Deepin-Tim/run.sh -d<br></code></pre></td></tr></table></figure><p>如果这个版本的卡或者有其他问题，建议安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">yay -S deepin.com.qq.office<br></code></pre></td></tr></table></figure><p>如果这个也没办法装，则使用linuxqq</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">yay -S linuxqq<br></code></pre></td></tr></table></figure><ul><li>安装微信</li></ul><p>deepin-wine版：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">yay -S deepin-wine-wechat<br></code></pre></td></tr></table></figure><p>切换到deepin-wine环境：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">/opt/apps/com.qq.weixin.deepin/files/run.sh -d<br></code></pre></td></tr></table></figure><p>关于字体发虚问题：</p><p>在切换到deepin-wine环境后，在terminal输入下面的指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">env WINEPREFIX=<span class="hljs-string">&quot;<span class="hljs-variable">$HOME</span>/.deepinwine/Deepin-TIM&quot;</span> /usr/bin/deepin-wine winecfg<br></code></pre></td></tr></table></figure><p>在弹出的窗口中选择windows xp，将DPI调大（默认是96），我调成了120</p><p>微信的同样，只需要将命令改为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">env WINEPREFIX=<span class="hljs-string">&quot;<span class="hljs-variable">$HOME</span>/.deepinwine/Deepin-WeChat&quot;</span> /usr/bin/deepin-wine winecfg<br></code></pre></td></tr></table></figure><p>electron版：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">yay -S electron-wechat<br></code></pre></td></tr></table></figure><hr><h5 id="隔离应用"><a href="#隔离应用" class="headerlink" title="隔离应用"></a>隔离应用</h5><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">firejail或者他的<span class="hljs-keyword">gui</span>版本风传讹<br></code></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># deepin 系的软件</span><br>sudo pacman -S deepin-picker <span class="hljs-comment"># 深度取色器</span><br>sudo pacman -S deepin-screen-recorder <span class="hljs-comment"># 录屏软件，可以录制 Gif 或者 MP4 格式</span><br>sudo pacman -S deepin-screenshot <span class="hljs-comment"># 深度截图</span><br>sudo pacman -S deepin-system-monitor <span class="hljs-comment"># 系统状态监控</span><br>yay -s deepin-wine-wechat<br>yay -S deepin-wine-tim<br>yay -S deepin-wine-baidupan<br>yay -S deepin.com.thunderspeed<br><br><span class="hljs-comment"># 开发软件</span><br>sudo pacman -S jdk8-openjdk<br>sudo pacman -S make<br>sudo pacman -S cmake<br>sudo pacman -S clang<br>sudo pacman -S nodejs<br>sudo pacman -S npm<br>sudo pacman -S goland<br>sudo pacman -S vim<br>sudo pacman -S maven<br>sudo pacman -S pycharm-professional <span class="hljs-comment"># Python IDE</span><br>sudo pacman -S intellij-idea-ultimate-edition <span class="hljs-comment"># JAVA IDE</span><br>yay -S pycharm pycharm-jre <span class="hljs-comment">#pycharm</span><br>sudo pacman -S goland <span class="hljs-comment"># Go IDE</span><br>sudo pacman -S visual-studio-code-bin <span class="hljs-comment"># vscode</span><br>sudo pacman -S qtcreator <span class="hljs-comment"># 一款QT开发软件</span><br>sudo pacman -S postman-bin<br>sudo pacman -S insomnia <span class="hljs-comment"># REST模拟工具</span><br>sudo pacman -S gitkraken <span class="hljs-comment"># GIT管理工具</span><br>sudo pacman -S wireshark-qt <span class="hljs-comment"># 抓包</span><br>sudo pacman -S zeal<br>sudo pacman -S gitkraken <span class="hljs-comment"># Git 管理工具</span><br><br><span class="hljs-comment"># 办公&amp;文本</span><br>yay -S youdao-dict <span class="hljs-comment">#安装有道词典安装 </span><br>yay -S foxitreader <span class="hljs-comment">#福昕pdf阅读器 </span><br>sudo pacman -S bookworm <span class="hljs-comment"># 电子书阅读</span><br>sudo pacman -S unrar unzip p7zip<br>sudo pacman -S goldendict <span class="hljs-comment"># 翻译、取词</span><br>yay -S typora <span class="hljs-comment"># markdown 编辑</span><br>yay -S electron-ssr <span class="hljs-comment"># 缺少我需要的加密算法</span><br>yay -S xmind-<span class="hljs-number">2020</span>  <span class="hljs-comment">#xmind-2020</span><br>yay -S calibre <span class="hljs-comment"># calibre：电子书管理</span><br><br><span class="hljs-comment"># 设计</span><br>sudo pacman -S pencil <span class="hljs-comment"># 免费开源界面原型图绘制工具</span><br><br><span class="hljs-comment"># 娱乐软件</span><br>sudo pacman -S netease-cloud-music     <span class="hljs-comment"># 网易云音乐</span><br>（注：直接安装完Wireshark后启动软件，会提示<span class="hljs-regexp">/usr/</span>bin/dumpcap无权限，运行下面的命令即可解决问题： sudo gpasswd -a username wireshark  <span class="hljs-comment"># username是用户名）</span><br><br><span class="hljs-comment"># 下载软件&amp;网络浏览</span><br>sudo pacman -S aria2<br>sudo pacman -S filezilla  <span class="hljs-comment"># filezilla 强大的FTP工具</span><br>yay -Sy filezilla <span class="hljs-comment"># filezilla 强大的FTP工具</span><br><br>yay -S baidunetdisk-bin <span class="hljs-comment">#百度云</span><br>yay -S xunlei-bin <span class="hljs-comment">#迅雷</span><br>sudo pacman -S google-chrome<br>yay -S microsoft-edge-dev-bin <span class="hljs-comment">#edge浏览器</span><br>sudo pacman -S you-get <span class="hljs-comment">#强大的Web内容（视频，音频，图片）下载工具</span><br>yay -S nutstore <span class="hljs-comment">#坚果云</span><br>注： yay -S python-gobject <span class="hljs-comment">#如果出现坚果云打不开或者没有登录页面的情况，安装坚果云相关依赖</span><br><br><br><span class="hljs-comment"># 图形</span><br>sudo pacman -S gimp <span class="hljs-comment"># 修图</span><br>sudo pacman -Sy obs-studio <span class="hljs-comment"># OBS</span><br><br><span class="hljs-comment"># 系统工具</span><br>sudo pacman -S albert <span class="hljs-comment">#类似Mac Spotlight，另外一款https://cerebroapp.com/</span><br>yay -S copyq <span class="hljs-comment">#  剪贴板工具，类似 Windows 上的 Ditto</span><br>sudo pacman -S gufw<span class="hljs-comment">#安装防火墙Linux 世界中最简单的防火墙之一</span><br>sudo pacman -S yay                     <span class="hljs-comment"># AUR助手</span><br>yay -S latte-dock <span class="hljs-comment"># 安装latte-dock</span><br><br><span class="hljs-comment"># 终端</span><br>sudo pacman -S screenfetch <span class="hljs-comment"># 终端打印出你的系统信息，screenfetch -A &#x27;Arch Linux&#x27;</span><br>sudo pacman -S htop     <span class="hljs-comment">#可以在终端中直接管理进程</span><br>sudo pacman -S bat<br>sudo pacman -S yakuake <span class="hljs-comment"># 堪称 KDE 下的终端神器，KDE 已经自带，F12 可以唤醒</span><br>sudo pacman -S net-tools <span class="hljs-comment"># 这样可以使用 ifconfig 和 netstat</span><br>yay -S tldr<br>yay -S tig <span class="hljs-comment"># 命令行下的 git 历史查看工具</span><br>yay -S tree<br>yay -S ncdu <span class="hljs-comment"># 命令行下的磁盘分析器，支持Vim操作</span><br>yay -S mosh <span class="hljs-comment"># 一款速度更快的 ssh 工具，网络不稳定时使用有奇效</span><br>sudo pacman -S thefuck <span class="hljs-comment">#自动纠正上一个控制台命令</span><br>sudo pacman -S tmux<span class="hljs-comment">#强大的终端复用工具</span><br>yay -S lolcat <span class="hljs-comment">#终端渐变色工具</span><br>yay -S ranger <span class="hljs-comment">#终端文件浏览器</span><br><br>其他：<br>sudo pacman -S clang make cmake gdb    <span class="hljs-comment"># 编译调试环境</span><br>sudo pacman -S visual-studio-code-bin  <span class="hljs-comment"># 牛逼的编辑器</span><br>sudo pacman -S vim                     <span class="hljs-comment"># 命令行下的编辑器</span><br>sudo pacman -S qtcreator               <span class="hljs-comment"># IDE for Qt</span><br>sudo pacman -S wireshark-qt            <span class="hljs-comment"># 抓包工具</span><br>sudo pacman -S git                     <span class="hljs-comment"># 版本管理工具</span><br>sudo pacman -S octave                  <span class="hljs-comment"># Matlab的开源替代</span><br><br><span class="hljs-comment"># zsh</span><br>zsh以默认安装在系统中，F12中输入zsh即可使用，输入<span class="hljs-keyword">exit</span>退出zsh<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>scroller</title>
    <link href="/2021/02/04/scroll/"/>
    <url>/2021/02/04/scroll/</url>
    
    <content type="html"><![CDATA[<p>Scroller的总结<br>内容来自各个博客</p><ul><li>本质及作用：<br>Scroller本质就是一个Helper类，里面保存了目标对象要移动的距离，时间等属性！     </li></ul><p>Android ViewGroup中的Scroller与computeScroll的有什么关系？</p><p>答：没有直接的关系</p><p>1.Scroller到底是什么？</p><p>答：Scroller只是个计算器，提供插值计算，让滚动过程具有动画属性，但它并不是UI，也不是辅助UI滑动，反而是单纯地为滑动提供计算。</p><p>无论从构造方法还是其他方法，以及Scroller的属性可知，其并不会持有View，辅助ViewGroup滑动</p><p>2.Scroller只是提供计算，那谁来调用computeScroll使得ViewGroup滑动</p><p>答：computeScroll也不是来让ViewGroup滑动的，真正让ViewGroup滑动的是scrollTo,scrollBy。computeScroll的作用是计算ViewGroup如何滑动。而computeScroll是通过draw来调用的。</p><p>3.computeScroll和Scroller都是计算，两者有啥关系？</p><p>答：文章开始已作答，没有直接的关系。computeScroll和Scroller要是飞得拉关系的话，那就是computeScroll可以参考Scroller计算结果来影响scrollTo,scrollBy,从而使得滑动发生改变。也就是Scroller不会调用computeScroll，反而是computeScroll调用Scroller。</p><p>4.滑动时连续的，如何让Scroller的计算也是连续的？</p><p>这个就问到了什么时候调用computeScroll了，如上所说computeScroll调用Scroller，只要computeScroll调用连续，Scroller也会连续，实质上computeScroll的连续性又invalidate方法控制，scrollTo,scrollBy都会调用invalidate，而invalidate回去触发draw,从而computeScroll被连续调用，综上，Scroller也会被连续调用，除非invalidate停止调用。</p><p>5.computeScroll如何和Scroller的调用过程保持一致。</p><p>computeScroll参考Scroller影响scrollTo,scrollBy，实质上，为了不重复影响scrollTo,scrollBy，那么Scroller必须终止计算currX，currY。要知道计算有没有终止，需要通过mScroller.computeScrollOffset()</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">computeScroll</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">super</span>.computeScroll();<br><span class="hljs-keyword">if</span>(!mScroll.computeScrollOffset())&#123;<br><span class="hljs-comment">//计算currX,currY,并检测是否已完成&quot;滚动&quot;</span><br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">int</span> tempX=mScroll.getCurrX();<br>scrollTo(tempX,<span class="hljs-number">0</span>);<span class="hljs-comment">//会重复调用invalidate</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>注意：在移动平台中，要明确知道“滑动”与“滚动”的不同，具体来说，滑动和滚动的方向总是相反的。</code></p><p>再来看一下scrollTo,scrollBy这两个方法的区别, scrollTo()方法是让View相对于初始的位置滚动某段距离，由于View的初始位置是不变的，因此不管我们点击多少次scrollTo按钮滚动到的都将是同一个位置。而scrollBy()方法则是让View相对于当前的位置滚动某段距离，那每当我们点击一次scrollBy按钮，View的当前位置都进行了变动，因此不停点击会一直移动。</p><p>通过这个例子来理解，相信大家已经把scrollTo()和scrollBy()这两个方法的区别搞清楚了，但是现在还有一个问题，目前使用这两个方法完成的滚动效果是跳跃式的，没有任何平滑滚动的效果。没错，只靠scrollTo()和scrollBy()这两个方法是很难完成ViewPager这样的效果的，因此我们还需要借助另外一个关键性的工具，也就我们今天的主角Scroller。<br>Scroller的基本用法其实还是比较简单的，主要可以分为以下几个步骤：</p><p>1.创建Scroller的实例<br>2.调用startScroll()方法来初始化滚动数据并刷新界面<br>3.重写computeScroll()方法，并在其内部完成平滑滚动的逻辑<br>那么下面我们就按照上述的步骤，通过一个模仿ViewPager的简易例子来学习和理解一下Scroller的用法。<br>新建一个ScrollerLayout并让它继承自ViewGroup来作为我们的简易ViewPager布局，代码如下所示：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Created by guolin on 16/1/12.</span><br><span class="hljs-comment"> */</span><br>public <span class="hljs-keyword">class</span> ScrollerLayout extends ViewGroup &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用于完成滚动操作的实例</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Scroller mScroller;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判定为拖动的最小移动像素数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> mTouchSlop;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 手机按下时的屏幕坐标</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span> mXDown;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 手机当时所处的屏幕坐标</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span> mXMove;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 上次触发ACTION_MOVE事件时的屏幕坐标</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span> mXLastMove;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 界面可滚动的左边界</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> leftBorder;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 界面可滚动的右边界</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> rightBorder;<br><br>    public <span class="hljs-constructor">ScrollerLayout(Context <span class="hljs-params">context</span>, AttributeSet <span class="hljs-params">attrs</span>)</span> &#123;<br>        super(context, attrs);<br>        <span class="hljs-comment">// 第一步，创建Scroller的实例</span><br>        mScroller = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Scroller(<span class="hljs-params">context</span>)</span>;<br>        ViewConfiguration configuration = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ViewConfiguration</span>.</span></span>get(context);<br>        <span class="hljs-comment">// 获取TouchSlop值</span><br>        mTouchSlop = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ViewConfigurationCompat</span>.</span></span>get<span class="hljs-constructor">ScaledPagingTouchSlop(<span class="hljs-params">configuration</span>)</span>;<br>    &#125;<br><br>    @Override<br>    protected void on<span class="hljs-constructor">Measure(<span class="hljs-params">int</span> <span class="hljs-params">widthMeasureSpec</span>, <span class="hljs-params">int</span> <span class="hljs-params">heightMeasureSpec</span>)</span> &#123;<br>        super.on<span class="hljs-constructor">Measure(<span class="hljs-params">widthMeasureSpec</span>, <span class="hljs-params">heightMeasureSpec</span>)</span>;<br>        <span class="hljs-built_in">int</span> childCount = get<span class="hljs-constructor">ChildCount()</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; childCount; i++) &#123;<br>            View childView = get<span class="hljs-constructor">ChildAt(<span class="hljs-params">i</span>)</span>;<br>            <span class="hljs-comment">// 为ScrollerLayout中的每一个子控件测量大小</span><br>            measure<span class="hljs-constructor">Child(<span class="hljs-params">childView</span>, <span class="hljs-params">widthMeasureSpec</span>, <span class="hljs-params">heightMeasureSpec</span>)</span>;<br>        &#125;<br>    &#125;<br><br>    @Override<br>    protected void on<span class="hljs-constructor">Layout(<span class="hljs-params">boolean</span> <span class="hljs-params">changed</span>, <span class="hljs-params">int</span> <span class="hljs-params">l</span>, <span class="hljs-params">int</span> <span class="hljs-params">t</span>, <span class="hljs-params">int</span> <span class="hljs-params">r</span>, <span class="hljs-params">int</span> <span class="hljs-params">b</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (changed) &#123;<br>            <span class="hljs-built_in">int</span> childCount = get<span class="hljs-constructor">ChildCount()</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; childCount; i++) &#123;<br>                View childView = get<span class="hljs-constructor">ChildAt(<span class="hljs-params">i</span>)</span>;<br>                <span class="hljs-comment">// 为ScrollerLayout中的每一个子控件在水平方向上进行布局</span><br>                childView.layout(i<span class="hljs-operator"> * </span>childView.get<span class="hljs-constructor">MeasuredWidth()</span>, <span class="hljs-number">0</span>, (i + <span class="hljs-number">1</span>)<span class="hljs-operator"> * </span>childView.get<span class="hljs-constructor">MeasuredWidth()</span>, childView.get<span class="hljs-constructor">MeasuredHeight()</span>);<br>            &#125;<br>            <span class="hljs-comment">// 初始化左右边界值</span><br>            leftBorder = get<span class="hljs-constructor">ChildAt(0)</span>.get<span class="hljs-constructor">Left()</span>;<br>            rightBorder = get<span class="hljs-constructor">ChildAt(<span class="hljs-params">getChildCount</span>()</span> - <span class="hljs-number">1</span>).get<span class="hljs-constructor">Right()</span>;<br>        &#125;<br>    &#125;<br><br>    @Override<br>    public boolean on<span class="hljs-constructor">InterceptTouchEvent(MotionEvent <span class="hljs-params">ev</span>)</span> &#123;<br>        switch (ev.get<span class="hljs-constructor">Action()</span>) &#123;<br>            case MotionEvent.ACTION_DOWN:<br>                mXDown = ev.get<span class="hljs-constructor">RawX()</span>;<br>                mXLastMove = mXDown;<br>                break;<br>            case MotionEvent.ACTION_MOVE:<br>                mXMove = ev.get<span class="hljs-constructor">RawX()</span>;<br>                <span class="hljs-built_in">float</span> diff = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>abs(mXMove - mXDown);<br>                mXLastMove = mXMove;<br>                <span class="hljs-comment">// 当手指拖动值大于TouchSlop值时，认为应该进行滚动，拦截子控件的事件</span><br>                <span class="hljs-keyword">if</span> (diff &gt; mTouchSlop) &#123;<br>                    return <span class="hljs-literal">true</span>;<br>                &#125;<br>                break;<br>        &#125;<br>        return super.on<span class="hljs-constructor">InterceptTouchEvent(<span class="hljs-params">ev</span>)</span>;<br>    &#125;<br><br>    @Override<br>    public boolean on<span class="hljs-constructor">TouchEvent(MotionEvent <span class="hljs-params">event</span>)</span> &#123;<br>        switch (event.get<span class="hljs-constructor">Action()</span>) &#123;<br>            case MotionEvent.ACTION_MOVE:<br>                mXMove = event.get<span class="hljs-constructor">RawX()</span>;<br>                <span class="hljs-built_in">int</span> scrolledX = (<span class="hljs-built_in">int</span>) (mXLastMove - mXMove);<br>                <span class="hljs-keyword">if</span> (get<span class="hljs-constructor">ScrollX()</span> + scrolledX &lt; leftBorder) &#123;<br>                    scroll<span class="hljs-constructor">To(<span class="hljs-params">leftBorder</span>, 0)</span>;<br>                    return <span class="hljs-literal">true</span>;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (get<span class="hljs-constructor">ScrollX()</span> + get<span class="hljs-constructor">Width()</span> + scrolledX &gt; rightBorder) &#123;<br>                    scroll<span class="hljs-constructor">To(<span class="hljs-params">rightBorder</span> - <span class="hljs-params">getWidth</span>()</span>, <span class="hljs-number">0</span>);<br>                    return <span class="hljs-literal">true</span>;<br>                &#125;<br>                scroll<span class="hljs-constructor">By(<span class="hljs-params">scrolledX</span>, 0)</span>;<br>                mXLastMove = mXMove;<br>                break;<br>            case MotionEvent.ACTION_UP:<br>                <span class="hljs-comment">// 当手指抬起时，根据当前的滚动值来判定应该滚动到哪个子控件的界面</span><br>                <span class="hljs-built_in">int</span> targetIndex = (get<span class="hljs-constructor">ScrollX()</span> + get<span class="hljs-constructor">Width()</span><span class="hljs-operator"> / </span><span class="hljs-number">2</span>)<span class="hljs-operator"> / </span>get<span class="hljs-constructor">Width()</span>;<br>                <span class="hljs-built_in">int</span> dx = targetIndex<span class="hljs-operator"> * </span>get<span class="hljs-constructor">Width()</span> - get<span class="hljs-constructor">ScrollX()</span>;<br>                <span class="hljs-comment">// 第二步，调用startScroll()方法来初始化滚动数据并刷新界面</span><br>                mScroller.start<span class="hljs-constructor">Scroll(<span class="hljs-params">getScrollX</span>()</span>, <span class="hljs-number">0</span>, dx, <span class="hljs-number">0</span>);<br>                invalidate<span class="hljs-literal">()</span>;<br>                break;<br>        &#125;<br>        return super.on<span class="hljs-constructor">TouchEvent(<span class="hljs-params">event</span>)</span>;<br>    &#125;<br><br>    @Override<br>    public void compute<span class="hljs-constructor">Scroll()</span> &#123;<br>        <span class="hljs-comment">// 第三步，重写computeScroll()方法，并在其内部完成平滑滚动的逻辑</span><br>        <span class="hljs-keyword">if</span> (mScroller.compute<span class="hljs-constructor">ScrollOffset()</span>) &#123;<br>            scroll<span class="hljs-constructor">To(<span class="hljs-params">mScroller</span>.<span class="hljs-params">getCurrX</span>()</span>, mScroller.get<span class="hljs-constructor">CurrY()</span>);<br>            invalidate<span class="hljs-literal">()</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>整个Scroller用法的代码都在这里了，代码并不长，一共才100多行，我们一点点来看。<br>首先在ScrollerLayout的构造函数里面我们进行了上述步骤中的第一步操作，即创建Scroller的实例，由于Scroller的实例只需创建一次，因此我们把它放到构造函数里面执行。另外在构建函数中我们还初始化的TouchSlop的值，这个值在后面将用于判断当前用户的操作是否是拖动。</p><p>接着重写onMeasure()方法和onLayout()方法，在onMeasure()方法中测量ScrollerLayout里的每一个子控件的大小，在onLayout()方法中为ScrollerLayout里的每一个子控件在水平方向上进行布局。</p><p>接着重写onInterceptTouchEvent()方法， 在这个方法中我们记录了用户手指按下时的X坐标位置，以及用户手指在屏幕上拖动时的X坐标位置，当两者之间的距离大于TouchSlop值时，就认为用户正在拖动布局，然后我们就将事件在这里拦截掉，阻止事件传递到子控件当中。</p><p>那么当我们把事件拦截掉之后，就会将事件交给ScrollerLayout的onTouchEvent()方法来处理。如果当前事件是ACTION_MOVE，说明用户正在拖动布局，那么我们就应该对布局内容进行滚动从而影响拖动事件，实现的方式就是使用我们刚刚所学的scrollBy()方法，用户拖动了多少这里就scrollBy多少。另外为了防止用户拖出边界这里还专门做了边界保护，当拖出边界时就调用scrollTo()方法来回到边界位置。</p><p>如果当前事件是ACTION_UP时，说明用户手指抬起来了，但是目前很有可能用户只是将布局拖动到了中间，我们不可能让布局就这么停留在中间的位置，因此接下来就需要借助Scroller来完成后续的滚动操作。首先这里我们先根据当前的滚动位置来计算布局应该继续滚动到哪一个子控件的页面，然后计算出距离该页面还需滚动多少距离。接下来我们就该进行上述步骤中的第二步操作，调用startScroll()方法来初始化滚动数据并调用invalidate()来刷新界面。startScroll()方法接收四个参数，第一个参数是滚动开始时X的坐标，第二个参数是滚动开始时Y的坐标，第三个参数是横向滚动的距离，正值表示向左滚动，第四个参数是纵向滚动的距离，正值表示向上滚动。紧接着调用invalidate()方法来刷新界面。</p><p>现在前两步都已经完成了，最后我们还需要进行第三步操作，即重写computeScroll()方法，并在其内部完成平滑滚动的逻辑 。在整个后续的平滑滚动过程中，computeScroll()方法是会一直被调用的，因此我们需要不断调用Scroller的computeScrollOffset()方法来进行判断滚动操作是否已经完成了，如果还没完成的话，那就继续调用scrollTo()方法，并把Scroller的curX和curY坐标传入，然后刷新界面从而完成平滑滚动的操作。</p><hr><p>实现惯性滚动 (Scroller的妙用)<br><a href="%22https://blog.csdn.net/u011387817/article/details/80313184%22">Android实现圆弧滑动效果之ArcSlidingHelper篇</a><br>说到Scroller，相信大家第一时间想到要配合View中的computeScroll方法来使用对吧，但是呢，我们这篇文章的主题是辅助类，并不打算继承View，而且不持有Context引用，这个时候，可能有同学就会有以下疑问了：</p><ul><li>这种情况下，Scroller还能正常工作吗？</li><li>调用它的startScroll或fling方法后，不是还要调用View中的invalidate方法来触发的吗？</li><li>不继承View，哪来的 invalidate方法？  </li><li>不继承View，怎么重写computeScroll方法？在哪里处理惯性滚动？  </li><li>哈哈，其实Scroller是完全可以脱离View来使用的，既然说是妙用，妙在哪里呢？在开始之前，我们先来了解一下Scroller：  </li></ul><p>1.它看上去更像是一个ValueAnimator，但它跟ValueAnimator有个明显的区别就是：它不会主动更新动画的值。我们在获取最新值之前，总是要先调用computeScrollOffset方法来刷新内部的mCurrX、mCurrY的值，如果是惯性滚动模式(调用fling方法)，还会刷新mCurrVelocity的值。  </p><p>2.在这里先分享大家一个理解源码调用顺序的方法：<br>比如我们想知道是哪个方法调用了computeScroll：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">@Override<br>public void compute<span class="hljs-constructor">Scroll()</span> &#123;<br>    StackTraceElement<span class="hljs-literal">[]</span> elements = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">StackTrace()</span>;<br>    <span class="hljs-keyword">for</span> (StackTraceElement element : elements) &#123;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>i(<span class="hljs-string">&quot;computeScroll&quot;</span>, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">String</span>.</span></span>format(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Locale</span>.</span></span>get<span class="hljs-constructor">Default()</span>, <span class="hljs-string">&quot;%s-----&gt;%s\tline: %d&quot;</span>,<br>                element.get<span class="hljs-constructor">ClassName()</span>, element.get<span class="hljs-constructor">MethodName()</span>, element.get<span class="hljs-constructor">LineNumber()</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>日志输出：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">com.wuyr.testview.MyView<span class="hljs-comment">-----&gt;computeScrollline: 141</span><br>android.<span class="hljs-keyword">view</span>.<span class="hljs-keyword">View</span><span class="hljs-comment">-----&gt;updateDisplayListIfDirtyline: 15361</span><br>android.<span class="hljs-keyword">view</span>.<span class="hljs-keyword">View</span><span class="hljs-comment">-----&gt;drawline: 16182</span><br>android.<span class="hljs-keyword">view</span>.ViewGroup<span class="hljs-comment">-----&gt;drawChildline: 3777</span><br>android.<span class="hljs-keyword">view</span>.ViewGroup<span class="hljs-comment">-----&gt;dispatchDrawline: 3567</span><br>android.<span class="hljs-keyword">view</span>.<span class="hljs-keyword">View</span><span class="hljs-comment">-----&gt;updateDisplayListIfDirtyline: 15373</span><br>android.<span class="hljs-keyword">view</span>.<span class="hljs-keyword">View</span><span class="hljs-comment">-----&gt;drawline: 16182</span><br>android.<span class="hljs-keyword">view</span>.ViewGroup<span class="hljs-comment">-----&gt;drawChildline: 3777</span><br>android.<span class="hljs-keyword">view</span>.ViewGroup<span class="hljs-comment">-----&gt;dispatchDrawline: 3567</span><br>android.<span class="hljs-keyword">view</span>.<span class="hljs-keyword">View</span><span class="hljs-comment">-----&gt;updateDisplayListIfDirtyline: 15373</span><br>android.<span class="hljs-keyword">view</span>.<span class="hljs-keyword">View</span><span class="hljs-comment">-----&gt;drawline: 16182</span><br></code></pre></td></tr></table></figure><p>这样我们就能够很清晰的看到它的调用链了。</p><p>回到正题，所谓的调用invalidate方法来触发，是这样的：我们都知道，调用了这个方法之后，onDraw方法就会回调，而调用onDraw的那个方法，是draw(Canvas canvas)，再上一级，是draw(Canvas canvas, ViewGroup parent, long drawingTime)，重点来了：<br>computeScroll也是在这个方法中回调的，现在可以得出一个结论：<br>我们在View中调用invalidate方法，也就是间接地调用computeScroll，而computeScroll中，是我们处理滚动的方法，在使用Scroller时，我们都会重写这个方法，并在里面调用Scroller的computeScrollOffset方法，然后调用getCurrX或getCurrY来获取到最新的值。(好像我前面说的都是多余的) 但是！有没有发现，这个过程，我们完全可以不依赖View来做到的？</p><p>3.现在思路就很清晰了，invalidate方法？对于Scroller来说，它的作用只是回调computeScroll从而更新x和y的值而已。</p><p>4.所以完全可以自己写两个方法来实现Scroller在View中的效果，我们这次打算利用Hanlder来帮我们处理异步的问题，这样的话，我们就不用自己新开线程去不断的调用方法啦。</p><p>好了，现在我们所遇到的问题，都已经有解决方案了，可以动手咯！</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"> <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 处理触摸事件</span><br><span class="hljs-comment">     */</span><br>    public void handle<span class="hljs-constructor">Movement(MotionEvent <span class="hljs-params">event</span>)</span> &#123;<br>     .....<br>        mVelocityTracker.add<span class="hljs-constructor">Movement(<span class="hljs-params">event</span>)</span>;<br>        switch (event.get<span class="hljs-constructor">Action()</span>) &#123;<br>            case MotionEvent.ACTION_DOWN:<br>             .....<br>                break;<br>            case MotionEvent.ACTION_MOVE:<br>                handle<span class="hljs-constructor">ActionMove(<span class="hljs-params">x</span>, <span class="hljs-params">y</span>)</span>;<br>                break;<br>            case MotionEvent.ACTION_UP:<br>            case MotionEvent.ACTION_CANCEL:<br>            case MotionEvent.ACTION_OUTSIDE:<br>                <span class="hljs-keyword">if</span> (isInertialSlidingEnable) &#123;<br>                    mVelocityTracker.compute<span class="hljs-constructor">CurrentVelocity(1000)</span>;<br>                    mScroller.fling(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, (<span class="hljs-built_in">int</span>) mVelocityTracker.get<span class="hljs-constructor">XVelocity()</span>, (<span class="hljs-built_in">int</span>) mVelocityTracker.get<span class="hljs-constructor">YVelocity()</span>,Integer.MIN_VALUE, Integer.MAX_VALUE, Integer.MIN_VALUE, Integer.MAX_VALUE); <br>                    <span class="hljs-comment">//我们在调用Scroller的fling方法之后，并没有调用invalidate方法，而是我们自定义的startFling方法. </span><br>                    start<span class="hljs-constructor">Fling()</span>;<br>                &#125;<br>                break;<br>           .....<br>        &#125;<br> .....<br>    &#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 处理惯性滚动</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> void compute<span class="hljs-constructor">InertialSliding()</span> &#123;<br>        check<span class="hljs-constructor">IsRecycled()</span>;<br>        <span class="hljs-keyword">if</span> (mScroller.compute<span class="hljs-constructor">ScrollOffset()</span>) &#123;<br>            <span class="hljs-built_in">float</span> y = ((isShouldBeGetY ? mScroller.get<span class="hljs-constructor">CurrY()</span> : mScroller.get<span class="hljs-constructor">CurrX()</span>)<span class="hljs-operator"> * </span>mScrollAvailabilityRatio);<br>            <span class="hljs-keyword">if</span> (mLastScrollOffset != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-built_in">float</span> offset = fix<span class="hljs-constructor">Angle(Math.<span class="hljs-params">abs</span>(<span class="hljs-params">y</span> - <span class="hljs-params">mLastScrollOffset</span>)</span>);<br>                mSlidingListener.on<span class="hljs-constructor">Sliding(<span class="hljs-params">isClockwiseScrolling</span> ? <span class="hljs-params">offset</span> : -<span class="hljs-params">offset</span>)</span>;<br>            &#125;<br>            mLastScrollOffset = y;<br>            start<span class="hljs-constructor">Fling()</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mScroller.is<span class="hljs-constructor">Finished()</span>) &#123;<br>            mLastScrollOffset = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (mSlideFinishListener != null) &#123;<br>                mSlideFinishListener.on<span class="hljs-constructor">SlideFinished()</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 开始惯性滚动</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> void start<span class="hljs-constructor">Fling()</span> &#123;<br>        mHandler.send<span class="hljs-constructor">EmptyMessage(0)</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 主线程回调惯性滚动</span><br><span class="hljs-comment">     *Handler来处理异步的问题，这样就不用自己去新开线程了。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> static <span class="hljs-keyword">class</span> InertialSlidingHandler extends Handler &#123;<br><br>        ArcSlidingHelper mHelper;<br><br>        <span class="hljs-constructor">InertialSlidingHandler(ArcSlidingHelper <span class="hljs-params">helper</span>)</span> &#123;<br>            mHelper = helper;<br>        &#125;<br><br>        @Override<br>        public void handle<span class="hljs-constructor">Message(Message <span class="hljs-params">msg</span>)</span> &#123;<br>            mHelper.compute<span class="hljs-constructor">InertialSliding()</span>;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>我们用computeInertialSliding来代替了View中的computeScroll方法，用startFling代替了invalidate，可以说是完全脱离了View来使用Scroller，妙就妙在这里啦，嘻嘻。</p><hr><p>Scroller主要使用的滚动方法有：startScroll、fling。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">start<span class="hljs-constructor">Scroll(<span class="hljs-params">int</span> <span class="hljs-params">startX</span>, <span class="hljs-params">int</span> <span class="hljs-params">startY</span>, <span class="hljs-params">int</span> <span class="hljs-params">dx</span>, <span class="hljs-params">int</span> <span class="hljs-params">dy</span>, <span class="hljs-params">int</span> <span class="hljs-params">duration</span>)</span>：<br>指定起点（startX，startY），从起点平滑变化（dx，dy），耗时duration，通常用于：知道起点与需要改变的距离的平滑滚动等。<br><br>fling(<span class="hljs-built_in">int</span> startX, <span class="hljs-built_in">int</span> startY, <span class="hljs-built_in">int</span> velocityX, <span class="hljs-built_in">int</span> velocityY, <span class="hljs-built_in">int</span> minX, <span class="hljs-built_in">int</span> maxX, <span class="hljs-built_in">int</span> minY, <span class="hljs-built_in">int</span> maxY)：<br>惯性滑动。  给定一个初始速度（ velocityX， velocityY ），该方法内部会根据这个速度去计算需要滑动的距离以及需要耗费的时间。通常用于：界面的惯性滑动等。<br></code></pre></td></tr></table></figure><p>scroller的实例化：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Scroller mScroller = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Scroller(Context <span class="hljs-params">mContext</span>)</span>&#123;&#125;; :采用默认插值器<br>Scroller mScroller = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Scroller(Context <span class="hljs-params">mContext</span>，Interpolator <span class="hljs-params">interpolator</span>)</span>&#123;&#125;;采用指定的插值器<br></code></pre></td></tr></table></figure><p>调用过程：</p><pre><code>   public void startScroll( int startX, int startY, int dx,int dy)&#123;&#125;;</code></pre><p>这方法并不是真正意义上的开始Scroll，它的作用是为Scroller做一些准备工作,比如设置移动的初始位置，滑动的位移以及持续时间等。</p><pre><code>   public boolean computeScrollOffset()&#123;&#125;</code></pre><p>这方法用于判断移动过程是否完成</p><pre><code>   getCurrX、getCurrY、getFinalX、getFinalY、</code></pre><p>这些方法用于获取scroll的一些位置信息</p><ul><li>Scroller与View结合使用：</li></ul><p>首先需要在自定义的View中定义一个私有成员 mScroller，用于记录view滚动的位置，然后再重写View的<code>computeScroll（）</code>方法来实现具体移动</p><p>注意：Scroller的作用只是保存一些信息，以及判断是否移动完成，所以我们得知道<code>computeScroll（）</code>这个方法的调用流程，在查看Android源码时发现<br>View.java中的<code>computeScroll（）</code>方法是一个空函数，所以我们需要在自定义的View中重写这个方法来实现我们想要的功能，那么<code>computeScroll（）</code>是怎么样被调用的呢？</p><p>调用<code>invalidate()</code>（UI线程）或者<code>postInvalidate（）</code>使View（Viewgroup）树重绘.<br>重绘分成两种情况：</p><p>1、Viewgroup的重绘<br><code>ViewGroup的绘制流程：onDraw（）--&gt;dispatchDraw()--&gt;drawChild()--&gt;child.computeScroll()</code></p><p>2、View的重绘：</p><p>View没有子view所以在View的源码中看到<code>dispatchDraw（）</code>方法是一个空方法，那么其调用流程就和ViewGroup是不一样的，那么View是怎样调用<code>computeScroll（）</code>的呢？</p><p>我们注意到invalidate是重绘整个View树或者ViewGroup树，所以当View重绘时其所在父容器也会重绘，so，父容器就会经历<code>onDraw（）--&gt;dispatchDraw()--&gt;drawChild() --&gt;child.computeScroll()</code>流程，这时候自定义View中重写的computeScroll（）方法就会被调用。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"> <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ViewGroup</span>.</span></span>java：<br><br>@Override  <br>protected void dispatch<span class="hljs-constructor">Draw(Canvas <span class="hljs-params">canvas</span>)</span>&#123; <br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;  <br>            final View child = children<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>;  <br>            <span class="hljs-keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK)<span class="hljs-operator"> == </span>VISIBLE<span class="hljs-operator"> || </span>child.get<span class="hljs-constructor">Animation()</span> != null)  <br>  <br>            &#123;  <br>                more <span class="hljs-pattern-match">|= draw<span class="hljs-constructor">Child(<span class="hljs-params">canvas</span>, <span class="hljs-params">child</span>, <span class="hljs-params">drawingTime</span>)</span>;  </span><br><span class="hljs-pattern-match">            &#125;  </span><br><span class="hljs-pattern-match">draw<span class="hljs-constructor">Child</span>函数：</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">protected boolean draw<span class="hljs-constructor">Child(Canvas <span class="hljs-params">canvas</span>, View <span class="hljs-params">child</span>, <span class="hljs-params">long</span> <span class="hljs-params">drawingTime</span>)</span> &#123;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">                  ----------</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">child.compute<span class="hljs-constructor">Scroll()</span>;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">              -----------------</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match"> <span class="hljs-keyword">if</span> ((child.m<span class="hljs-constructor">PrivateFlags</span> &amp; <span class="hljs-constructor">SKIP_DRAW</span>) <span class="hljs-operator">==</span> <span class="hljs-constructor">SKIP_DRAW</span>) &#123;</span><br><span class="hljs-pattern-match">        <span class="hljs-keyword">if</span> (<span class="hljs-constructor">ViewDebug</span>.<span class="hljs-constructor">TRACE_HIERARCHY</span>) &#123;</span><br><span class="hljs-pattern-match">            <span class="hljs-constructor">ViewDebug</span>.trace(this, <span class="hljs-constructor">ViewDebug</span>.<span class="hljs-constructor">HierarchyTraceType</span>.<span class="hljs-constructor">DRAW</span>);</span><br><span class="hljs-pattern-match">        &#125;</span><br><span class="hljs-pattern-match">        child.dispatch<span class="hljs-constructor">Draw(<span class="hljs-params">canvas</span>)</span>;</span><br><span class="hljs-pattern-match">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="hljs-pattern-match">        child.draw(canvas);</span><br><span class="hljs-pattern-match">    &#125;</span><br></code></pre></td></tr></table></figure><ul><li>自定义View：</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> CustomView extends View &#123;  <br>  <br>    <span class="hljs-keyword">private</span> Scroller mScroller;  <br> <br>    public <span class="hljs-constructor">CustomView(Context <span class="hljs-params">context</span>, AttributeSet <span class="hljs-params">attrs</span>)</span> &#123;  <br>        super(context, attrs);  <br>        mScroller = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Scroller(<span class="hljs-params">context</span>)</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//调用此方法滚动到目标位置  </span><br>    public void smooth<span class="hljs-constructor">ScrollTo(<span class="hljs-params">int</span> <span class="hljs-params">fx</span>, <span class="hljs-params">int</span> <span class="hljs-params">fy</span>)</span> &#123;  <br>        <span class="hljs-built_in">int</span> dx = fx - mScroller.get<span class="hljs-constructor">FinalX()</span>;  <br>        <span class="hljs-built_in">int</span> dy = fy - mScroller.get<span class="hljs-constructor">FinalY()</span>;  <br>        smooth<span class="hljs-constructor">ScrollBy(<span class="hljs-params">dx</span>, <span class="hljs-params">dy</span>)</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//调用此方法设置滚动的相对偏移  </span><br>    public void smooth<span class="hljs-constructor">ScrollBy(<span class="hljs-params">int</span> <span class="hljs-params">dx</span>, <span class="hljs-params">int</span> <span class="hljs-params">dy</span>)</span> &#123;  <br>        <span class="hljs-comment">//设置mScroller的滚动偏移量  </span><br>        mScroller.start<span class="hljs-constructor">Scroll(<span class="hljs-params">mScroller</span>.<span class="hljs-params">getFinalX</span>()</span>, mScroller.get<span class="hljs-constructor">FinalY()</span>, dx, dy);  <br>        invalidate<span class="hljs-literal">()</span>;<span class="hljs-comment">//这里必须调用invalidate()才能保证computeScroll()会被调用，否则不一定会刷新界面，看不到滚动效果  </span><br>    &#125;  <br>      <br>    @Override  <br>    public void compute<span class="hljs-constructor">Scroll()</span> &#123;  <br>        <span class="hljs-comment">//先判断mScroller滚动是否完成  </span><br>        <span class="hljs-keyword">if</span> (mScroller.compute<span class="hljs-constructor">ScrollOffset()</span>) &#123;  <br>            <span class="hljs-comment">//这里调用View的scrollTo()完成实际的滚动  </span><br>            scroll<span class="hljs-constructor">To(<span class="hljs-params">mScroller</span>.<span class="hljs-params">getCurrX</span>()</span>, mScroller.get<span class="hljs-constructor">CurrY()</span>);  <br>              <br>            <span class="hljs-comment">//必须调用该方法，否则不一定能看到滚动效果  </span><br>            post<span class="hljs-constructor">Invalidate()</span>;  <br>        &#125;  <br>        super.compute<span class="hljs-constructor">Scroll()</span>;  <br>    &#125;  <br>&#125;  <br></code></pre></td></tr></table></figure><hr><p>android.view.VelocityTracker主要用跟踪触摸屏事件（flinging事件和其他gestures手势事件）的速率。用addMovement(MotionEvent)函数将Motion event加入到VelocityTracker类实例中.你可以使用getXVelocity() 或getXVelocity()获得横向和竖向的速率到速率时，但是使用它们之前请先调用computeCurrentVelocity(int)来初始化速率的单位 。  </p><p>示例： </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> VelocityTracker mVelocityTracker;<span class="hljs-comment">//生命变量 </span><br><span class="hljs-comment">//在onTouchEvent(MotionEvent ev)中 </span><br><span class="hljs-keyword">if</span> (mVelocityTracker<span class="hljs-operator"> == </span>null) &#123; <br>        mVelocityTracker = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">VelocityTracker</span>.</span></span>obtain<span class="hljs-literal">()</span>;<span class="hljs-comment">//获得VelocityTracker类实例 </span><br>&#125; <br>mVelocityTracker.add<span class="hljs-constructor">Movement(<span class="hljs-params">ev</span>)</span>;<span class="hljs-comment">//将事件加入到VelocityTracker类实例中 </span><br><span class="hljs-comment">//判断当ev事件是MotionEvent.ACTION_UP时：计算速率 </span><br>final VelocityTracker velocityTracker = mVelocityTracker; <br><span class="hljs-comment">// 1000 provides pixels per second </span><br>velocityTracker.compute<span class="hljs-constructor">CurrentVelocity(1, (<span class="hljs-params">float</span>)</span><span class="hljs-number">0.01</span>); <span class="hljs-comment">//设置maxVelocity值为0.1时，速率大于0.01时，显示的速率都是0.01,速率小于0.01时，显示正常 </span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>i(<span class="hljs-string">&quot;test&quot;</span>,<span class="hljs-string">&quot;velocityTraker&quot;</span>+velocityTracker.get<span class="hljs-constructor">XVelocity()</span>);                     <br>velocityTracker.compute<span class="hljs-constructor">CurrentVelocity(1000)</span>; <span class="hljs-comment">//设置units的值为1000，意思为一秒时间内运动了多少个像素 </span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>i(<span class="hljs-string">&quot;test&quot;</span>,<span class="hljs-string">&quot;velocityTraker&quot;</span>+velocityTracker.get<span class="hljs-constructor">XVelocity()</span>); <br></code></pre></td></tr></table></figure><p>大体的使用是这样的：<br>当你需要跟踪触摸屏事件的速度的时候,使用obtain()方法来获得VelocityTracker类的一个实例对象<br>在onTouchEvent回调函数中，使用addMovement(MotionEvent)函数将当前的移动事件传递给VelocityTracker对象<br>使用computeCurrentVelocity  (int units)函数来计算当前的速度，使用 getXVelocity  ()、 getYVelocity  ()函数来获得当前的速度</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
