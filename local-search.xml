<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Rsync</title>
    <link href="/posts/899e41d0/"/>
    <url>/posts/899e41d0/</url>
    
    <content type="html"><![CDATA[<p><a href="https://bleepcoder.com/cn/timeshift/362931478/folder-exclusion-doesn-t-work">网页</a></p><p><a href="http://www.voycn.com/article/timeshiftxitongbeifenyuhaiyuan">使用</a></p><hr><ul><li><p>匹配是从父目录到子目录，如果排除了某个目录，那被排除目录的子目录的任何规则不再生效。</p><p>例如: exclude=’/var’ include=’var/opt’</p></li><li><p><code>**</code>表示匹配这个地址的每一层</p></li></ul><p>​        例如 <code>/var/opt/**</code>可以被理解为 include=“/” include=“/var” include=“/var/opt”</p><p>例如</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">$ rsync -anv <span class="hljs-params">--include=</span><span class="hljs-string">&quot;/home/kiylx/文档/Linux学习/**&quot;</span> <span class="hljs-params">--exclude=</span><span class="hljs-string">&quot;.*&quot;</span> <span class="hljs-params">--exclude=</span><span class="hljs-string">&quot;/Linux学习/linux/***&quot;</span> <span class="hljs-string">/home/kiylx/</span>文档<span class="hljs-string">/Linux</span>学习  <span class="hljs-string">/home/kiylx/Android</span><br><br>输出：<br>Linux学习/<br>Linux学习<span class="hljs-string">/Font</span> configuration_Examples - ArchWiki <span class="hljs-params">(2021_9_14 下午5_33_06)</span><span class="hljs-string">.html</span><br>Linux学习<span class="hljs-string">/VimVi</span>使用<span class="hljs-string">.md</span><br>Linux学习<span class="hljs-string">/VimVi</span>使用<span class="hljs-string">.pdf</span><br>Linux学习<span class="hljs-string">/freebsd.md</span><br>Linux学习<span class="hljs-string">/iptables</span>和firewalld.pdf<br>Linux学习<span class="hljs-string">/manjaro</span>配置<span class="hljs-string">.md</span><br>Linux学习<span class="hljs-string">/ranger.svg</span><br>Linux学习<span class="hljs-string">/ranger</span>使用<span class="hljs-string">.md</span><br>Linux学习/背景介绍<span class="hljs-string">.md</span><br>Linux学习<span class="hljs-string">/TyporaRaw/</span><br>Linux学习<span class="hljs-string">/TyporaRaw/ranger</span>使用<span class="hljs-string">.assets/</span><br>Linux学习<span class="hljs-string">/TyporaRaw/ranger</span>使用<span class="hljs-string">.assets/cheatsheet.svg</span><br><br>排除了所有的前缀是`.`的文件，排除了linux文件夹<br></code></pre></td></tr></table></figure><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gradle">$ rsync -anv --<span class="hljs-keyword">exclude</span>=<span class="hljs-string">&#x27;*&#x27;</span>  --<span class="hljs-keyword">include</span>=<span class="hljs-string">&quot;/Linux学习/linux/***&quot;</span> <span class="hljs-regexp">/home/</span>kiylx<span class="hljs-regexp">/文档/</span>Linux学习  <span class="hljs-regexp">/home/</span>kiylx/Android<br><br>输出：<br>空白<br>开头的--<span class="hljs-keyword">exclude</span>=<span class="hljs-string">&#x27;*&#x27;</span> 排除了所有文件，后面的规则不再生效<br></code></pre></td></tr></table></figure><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gradle">$ rsync -anv --<span class="hljs-keyword">include</span>=<span class="hljs-string">&quot;/home/kiylx/文档/Linux学习/**&quot;</span> --<span class="hljs-keyword">exclude</span>=<span class="hljs-string">&#x27;Linux学习/*&#x27;</span> --<span class="hljs-keyword">include</span>=<span class="hljs-string">&quot;/Linux学习/linux/***&quot;</span> <span class="hljs-regexp">/home/</span>kiylx<span class="hljs-regexp">/文档/</span>Linux学习  <span class="hljs-regexp">/home/</span>kiylx/Android<br><br>输出：<br>Linux学习/<br>包含Linux学习<span class="hljs-regexp">/下的东西，又排除了Linux学习/</span>下的东西，所以，包含Linux学习<span class="hljs-regexp">/linux/</span>文件夹的规则不再生效<br></code></pre></td></tr></table></figure><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs gradle">$ rsync -anv --<span class="hljs-keyword">include</span>=<span class="hljs-string">&quot;/home/kiylx/文档/Linux学习/**&quot;</span> --<span class="hljs-keyword">include</span>=<span class="hljs-string">&quot;/Linux学习/linux/***&quot;</span>  --<span class="hljs-keyword">exclude</span>=<span class="hljs-string">&#x27;Linux学习/*&#x27;</span> <span class="hljs-regexp">/home/</span>kiylx<span class="hljs-regexp">/文档/</span>Linux学习  <span class="hljs-regexp">/home/</span>kiylx/Android<br><br>输出：<br>Linux学习/<br>Linux学习<span class="hljs-regexp">/linux/</span><br>Linux学习<span class="hljs-regexp">/linux/</span>.MD文档.md<br>Linux学习<span class="hljs-regexp">/linux/</span>Linux就该这么学（完整目录版）.pdf<br>Linux学习<span class="hljs-regexp">/linux/</span>linux学习.md<br>Linux学习<span class="hljs-regexp">/linux/</span>文件与目录管理.md<br>Linux学习<span class="hljs-regexp">/linux/</span>文件基本属性.md<br>Linux学习<span class="hljs-regexp">/linux/</span>用户与用户组管理.md<br>Linux学习<span class="hljs-regexp">/linux/</span>目录结构.md<br>Linux学习<span class="hljs-regexp">/linux/</span>磁盘管理.md<br>先包含linux学习文件夹和其下的linux文件夹，然后再排除linux学习文件夹下的一切<br><br></code></pre></td></tr></table></figure><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">$ rsync -anv <span class="hljs-params">--include=</span><span class="hljs-string">&quot;/home/kiylx/文档/Linux学习/**&quot;</span> <span class="hljs-params">--exclude=</span>&#x27;Linux学习<span class="hljs-string">/linux</span>*&#x27; <span class="hljs-string">/home/kiylx/</span>文档<span class="hljs-string">/Linux</span>学习  <span class="hljs-string">/home/kiylx/Android</span><br><br>输出：<br>Linux学习/<br>Linux学习<span class="hljs-string">/Font</span> configuration_Examples - ArchWiki <span class="hljs-params">(2021_9_14 下午5_33_06)</span><span class="hljs-string">.html</span><br>Linux学习<span class="hljs-string">/Linux</span> chmod 命令 _ 菜鸟教程 <span class="hljs-params">(2021_3_18 上午10_08_38)</span><span class="hljs-string">.html</span><br>Linux学习<span class="hljs-string">/Manjaro</span> XFCE 安装和调教 _ Azure <span class="hljs-params">(2021_2_26 下午9_47_19)</span><span class="hljs-string">.html</span><br>Linux学习<span class="hljs-string">/VimVi</span>使用<span class="hljs-string">.md</span><br>Linux学习<span class="hljs-string">/VimVi</span>使用<span class="hljs-string">.pdf</span><br>Linux学习<span class="hljs-string">/freebsd.md</span><br>Linux学习<span class="hljs-string">/iptables</span>和firewalld.pdf<br>Linux学习<span class="hljs-string">/manjaro</span>配置<span class="hljs-string">.md</span><br>Linux学习<span class="hljs-string">/ranger.svg</span><br>Linux学习<span class="hljs-string">/ranger</span>使用<span class="hljs-string">.md</span><br>Linux学习/背景介绍<span class="hljs-string">.md</span><br>Linux学习<span class="hljs-string">/.obsidian/</span><br>Linux学习<span class="hljs-string">/.obsidian/app.json</span><br>Linux学习<span class="hljs-string">/.obsidian/appearance.json</span><br>Linux学习<span class="hljs-string">/.obsidian/core-plugins.json</span><br>Linux学习<span class="hljs-string">/.obsidian/graph.json</span><br>Linux学习<span class="hljs-string">/.obsidian/hotkeys.json</span><br>Linux学习<span class="hljs-string">/.obsidian/workspace</span><br>Linux学习<span class="hljs-string">/TyporaRaw/</span><br>Linux学习<span class="hljs-string">/TyporaRaw/ranger</span>使用<span class="hljs-string">.assets/</span><br>Linux学习<span class="hljs-string">/TyporaRaw/ranger</span>使用<span class="hljs-string">.assets/cheatsheet.svg</span><br><br></code></pre></td></tr></table></figure><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">rsync -anv <span class="hljs-params">--exclude=</span><span class="hljs-string">&quot;/home/kiylx/文档/Linux学习/linux&quot;</span> <span class="hljs-params">--include=</span><span class="hljs-string">&quot;/home/kiylx/文档/Linux学习/**&quot;</span> <span class="hljs-string">/home/kiylx/</span>文档<span class="hljs-string">/Linux</span>学习  <span class="hljs-string">/home/kiylx/Android</span><br>sending incremental file list<br>Linux学习/<br>Linux学习<span class="hljs-string">/Font</span> configuration_Examples - ArchWiki <span class="hljs-params">(2021_9_14 下午5_33_06)</span><span class="hljs-string">.html</span><br>Linux学习<span class="hljs-string">/Linux</span> chmod 命令 _ 菜鸟教程 <span class="hljs-params">(2021_3_18 上午10_08_38)</span><span class="hljs-string">.html</span><br>Linux学习<span class="hljs-string">/Manjaro</span> XFCE 安装和调教 _ Azure <span class="hljs-params">(2021_2_26 下午9_47_19)</span><span class="hljs-string">.html</span><br>Linux学习<span class="hljs-string">/VimVi</span>使用<span class="hljs-string">.md</span><br>Linux学习<span class="hljs-string">/VimVi</span>使用<span class="hljs-string">.pdf</span><br>Linux学习<span class="hljs-string">/freebsd.md</span><br>Linux学习<span class="hljs-string">/iptables</span>和firewalld.pdf<br>Linux学习<span class="hljs-string">/manjaro</span>配置<span class="hljs-string">.md</span><br>Linux学习<span class="hljs-string">/ranger.svg</span><br>Linux学习<span class="hljs-string">/ranger</span>使用<span class="hljs-string">.md</span><br>Linux学习/背景介绍<span class="hljs-string">.md</span><br>Linux学习<span class="hljs-string">/.obsidian/</span><br>Linux学习<span class="hljs-string">/.obsidian/app.json</span><br>Linux学习<span class="hljs-string">/.obsidian/appearance.json</span><br>Linux学习<span class="hljs-string">/.obsidian/core-plugins.json</span><br>Linux学习<span class="hljs-string">/.obsidian/graph.json</span><br>Linux学习<span class="hljs-string">/.obsidian/hotkeys.json</span><br>Linux学习<span class="hljs-string">/.obsidian/workspace</span><br>Linux学习<span class="hljs-string">/TyporaRaw/</span><br>Linux学习<span class="hljs-string">/TyporaRaw/ranger</span>使用<span class="hljs-string">.assets/</span><br>Linux学习<span class="hljs-string">/TyporaRaw/ranger</span>使用<span class="hljs-string">.assets/cheatsheet.svg</span><br>Linux学习<span class="hljs-string">/linux/</span><br>Linux学习<span class="hljs-string">/linux/.MD</span>文档<span class="hljs-string">.md</span><br>Linux学习<span class="hljs-string">/linux/Linux</span>就该这么学（完整目录版）<span class="hljs-string">.pdf</span><br>Linux学习<span class="hljs-string">/linux/linux</span>学习<span class="hljs-string">.md</span><br>Linux学习<span class="hljs-string">/linux/</span>文件与目录管理<span class="hljs-string">.md</span><br>Linux学习<span class="hljs-string">/linux/</span>文件基本属性<span class="hljs-string">.md</span><br>Linux学习<span class="hljs-string">/linux/</span>用户与用户组管理<span class="hljs-string">.md</span><br>Linux学习<span class="hljs-string">/linux/</span>目录结构<span class="hljs-string">.md</span><br>Linux学习<span class="hljs-string">/linux/</span>磁盘管理<span class="hljs-string">.md</span><br><br></code></pre></td></tr></table></figure><hr><h1 id="man-page"><a href="#man-page" class="headerlink" title="man page"></a><a href="https://download.samba.org/pub/rsync/rsync.1">man page</a></h1><h2 id="包含-排除模式规则"><a href="#包含-排除模式规则" class="headerlink" title="包含/排除模式规则"></a>包含/排除模式规则</h2><p>您可以通过使用“+”、“-⁠”等过滤规则指定模式来包含和排除文件（如上面的过滤规则部分所述）。每个包含/排除规则都指定了一个模式，该模式与将要传输的文件的名称相匹配。这些模式可以采用多种形式：</p><ul><li>如果模式以 a 开头，<code>/</code>则它被锚定到文件层次结构中的特定位置，否则它与路径名的末尾匹配。这类似于<code>^</code>正则表达式中的前导。因此 <code>/foo</code>将匹配“传输根”（对于全局规则）或合并文件的目录（对于每个目录规则）中的“foo”名称。一个不合格<code>foo</code>将匹配树中任何位置的“foo”名称，因为该算法是从上到下递归应用的；它的行为就像每个路径组件在文件名结尾处轮流。即使未锚定的“sub/foo”也会在层次结构中的任何点匹配，其中在名为“sub”的目录中找到“foo”。有关如何指定在传输的根处匹配的模式的完整讨论，请参阅关于 ANCHORING INCLUDE/EXCLUDE PATTERNS 的部分。</li><li>如果模式以 a 结尾，<code>/</code>那么它只会匹配一个目录，而不是常规文件、符号链接或设备。</li><li>rsync 通过检查模式是否包含以下三个通配符之一来选择进行简单的字符串匹配和通配符匹配：’ <code>*</code>‘、’ <code>?</code>‘ 和 ‘ <code>[</code>‘ 。</li><li>‘ <code>*</code>‘ 匹配任何路径组件，但它在斜线处停止。</li><li>使用 ‘ <code>**</code>‘ 来匹配任何东西，包括斜线。</li><li>‘ <code>?</code>‘ 匹配除斜杠 ( <code>/</code>)之外的任何字符。</li><li>‘ <code>[</code>‘ 引入了一个字符类，例如<code>[a-z]</code>or <code>[[:alpha:]]</code>。</li><li>在通配符模式中，反斜杠可用于转义通配符，但在不存在通配符时按字面匹配。这意味着与没有通配符的模式相比，当模式包含通配符时，反斜杠删除的级别更高。例如，如果您将通配符添加到“ <code>foo\bar</code>”（与反斜杠匹配），您将需要使用“ <code>foo\\bar*</code>”来避免“ <code>\b</code>”变成“b”。</li><li>如果模式包含<code>/</code>（不包括尾随 /）或“ <code>**</code>”，则它与完整路径名匹配，包括任何前导目录。如果模式不包含 a<code>/</code>或 “ <code>**</code>“，则它仅与文件名的最后一部分匹配。（请记住，该算法是递归应用的，因此“完整文件名”实际上可以是从起始目录向下的路径的任何部分。）</li><li>尾随的“ <code>dir_name/***</code>”将匹配目录（就像指定了“dir_name/”）和目录中的所有内容（就像<code>dir_name/**</code>已经指定了“ ”）。此行为是在 2.6.7 版中添加的。</li></ul><p>请注意，当使用<code>--recursive</code>( <code>-r</code>) 选项（由 暗示 <code>-a</code>）时，从左到右访问每个路径的每个子目录组件，每个目录都有机会在其内容之前排除。通过这种方式，包含/排除模式以递归方式应用于文件系统树中每个节点的路径名（传输内部的节点）。当 rsync 找到要发送的文件时，排除模式会使目录遍历阶段短路。</p><p>例如，要包含“ <code>/foo/bar/baz</code>”，不得排除目录“ <code>/foo</code>”和“ <code>/foo/bar</code>”。排除这些父目录之一会阻止检查其内容，切断 rsync 到这些路径的递归并使“ <code>/foo/bar/baz</code>”的包含无效（因为 rsync 无法匹配它在目录层次结构的截止部分中从未见过的内容） .</p><p>使用尾随“ <code>*</code>”规则时，概念路径排除尤其重要。例如，这行不通：</p><blockquote><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle">+ <span class="hljs-regexp">/some/</span>path/<span class="hljs-keyword">this</span>-<span class="hljs-keyword">file</span>-will-not-be-found<br>+ /<span class="hljs-keyword">file</span>-is-included<br>- *<br></code></pre></td></tr></table></figure></blockquote><p>这将失败，因为父目录“some”被 ‘ <code>*</code>‘ 规则排除，所以 rsync 从不访问“some”或“some/path”目录中的任何文件。一种解决方案是通过使用单个规则：“ <code>+ */</code>”（将其放在“ <code>- *</code>”规则之前的某个位置）要求包含层次结构中的所有目录，并且可能使用该<code>--prune-empty-dirs</code>选项。另一种解决方案是为所有需要访问的父目录添加特定的包含规则。例如，这组规则工作正常：</p><blockquote><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gradle">+ <span class="hljs-regexp">/some/</span><br>+ <span class="hljs-regexp">/some/</span>path/<br>+ <span class="hljs-regexp">/some/</span>path/<span class="hljs-keyword">this</span>-<span class="hljs-keyword">file</span>-is-found<br>+ /<span class="hljs-keyword">file</span>-also-included<br>- *<br></code></pre></td></tr></table></figure></blockquote><p>以下是排除/包含匹配的一些示例：</p><ul><li>“ <code>- *.o</code>“ 将排除所有匹配的名称<code>*.o</code></li><li>“ <code>- /foo</code>“ 将排除 transfer-root 目录中名为 foo 的文件（或目录）</li><li>“ <code>- foo/</code>“ 将排除任何名为 foo 的目录</li><li>“ <code>- /foo/*/bar</code>“ 将排除位于 transfer-root 目录中名为 foo 的目录下两级的名为 bar 的任何文件</li><li>“ <code>- /foo/**/bar</code>“ 将排除在 transfer-root 目录中名为 foo 的目录下两级或更多级名为 bar 的任何文件</li><li>“ <code>+ */</code>“、” <code>+ *.c</code>“ 和 “ <code>- *</code>“ 的组合将包含所有目录和 C 源文件，但不包含其他内容（另请参见 <code>--prune-empty-dirs</code>选项）</li><li>“ <code>+ foo/</code>“、” <code>+ foo/bar.c</code>“ 和 “ <code>- *</code>“ 的组合将仅包含 foo 目录和 foo/bar.c（必须明确包含 foo 目录，否则它将被 “ <code>*</code>“排除）</li></ul><p>在 “ <code>+</code>“ 或 “ <code>-</code>“之后接受以下修饰符：</p><ul><li><p>A<code>/</code>指定包含/排除规则应与当前项的绝对路径名匹配。例如，“ <code>-/ /etc/passwd</code>”会在传输从“/etc”目录发送文件时排除 passwd 文件，而“-⁠/subdir/foo”在名为“subdir”的目录中时将始终排除“foo” , 即使“foo”是当前传输的根。</p></li><li><p>A<code>!</code>指定如果模式匹配失败，包含/排除应该生效。例如，“ <code>-! */</code>”将排除所有非目录。</p></li><li><p>A<code>C</code>用于指示所有全局 CVS 排除规则都应作为排除插入来代替“-⁠C”。不应遵循任何 arg。</p></li><li><p>An<code>s</code>用于指示规则适用于发送方。当规则影响发送方时，它会阻止文件传输。除非<code>--delete-excluded</code>指定，否则默认规则会影响双方，在这种情况下，默认规则仅成为发送方。另请参阅隐藏 (H) 和显示 (S) 规则，它们是指定发送方包含/排除的另一种方法。</p></li><li><p>An<code>r</code>用于指示规则适用于接收方。当规则影响接收方时，它可以防止文件被删除。有关<code>s</code>更多信息，请参阅修饰符。另请参阅保护 (P) 和风险 (R) 规则，这是指定接收方包含/排除的另一种方法。</p></li><li><p>A<code>p</code>表示规则易腐烂，这意味着它在被删除的目录中被忽略。例如，<code>-C</code>排除诸如“CVS”和“ <code>*.o</code>”之类的选项的默认规则被标记为易腐烂，并且不会阻止在源上删除的目录在目标上被删除。</p></li><li><p>An<code>x</code>表示规则影响 xattr 复制/删除操作中的 xattr 名称（因此在匹配文件/目录名称时被忽略）。如果未指定 xattr 匹配规则，则使用默认的 xattr 过滤规则（请参阅<code>--xattrs</code>选项）。</p><hr></li></ul><h1 id="博客1-地址"><a href="#博客1-地址" class="headerlink" title="博客1 地址"></a><a href="https://developer.aliyun.com/article/428319">博客1 地址</a></h1><p>   关于rsync的过滤规则：<br>  译者注：这部分其实是man page中关于client的过滤规则的条目！不过，我把daemon中的过滤规则也集合到了里，两部分对比着进行理解。<br>  关于pattern和rule，个人理解是：pattern是用来匹配文件或目录的正则，而rule则是前缀+pattern，也即整条规则。如：</p>  <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">+</span> foo/<br><span class="hljs-bullet">+</span> foo/bar.c<br><span class="hljs-bullet">-</span> <span class="hljs-emphasis">*</span><br></code></pre></td></tr></table></figure><p>  这是三条规则（rule），规则开头的”+”或”-“是前缀，foo/等前缀后面的东西即pattern（模式）。</p><p>  下面是正文：<br>  首先，来看rsyncd.conf官方文档在filter部分的描述（daemon上的过滤规则）：<br>  daemon拥有自己的过滤链，来决定哪些文件允许被client访问。这个过滤链不会被发送到client，并且独立于client中已经指定的过滤规则。<br>  当client拉文件时，那些被daemon过滤链排除的文件会被视为不存在；而当client往server推送文件时，会跳过那些被daemon过滤链排除的文件，并且server会返回client一个错误消息；（当同步文件时）被daemon过滤链排除的文件永远不会从模块中删除。<br>  daemon过滤链由”filter”、”include from”、”include”、”exclude from”、”exclude”参数组成，并以此为先后（生效）顺序。<br>  （译者注：关于规则的生效顺序，应该是最先匹配。rsyncd.conf文档明确指出include规则可以覆盖掉exclude规则，照此理解，如果发生冲突，后面的规则应该不会覆盖掉前面的规则。下面filter rules部分也提到，最先匹配的模式会生效，但是在include/exclude pattern rules部分也提到一个特殊例子，在排除父目录，特别是使用<em>号匹配来排除父目录时，有些地方需要特别留意。<br>  条目中还有一句话：Anchored patterns are anchored at the root of the module.大意似乎是：锚点模式标记的是模块根目录。下面还会有提到Anchored pattern。）<br>  要阻止对整个目录的访问，必须排除该目录下的所有文件，最简单的方法是使用三个星号，如，想要阻止访问/secret，过滤规则就应该这样写：/secret/</em>**</p><p>  再来看rsync的man page对过滤规则的描述（client中的过滤规则），这部分内容很多，由FILTER RULES条目开始，包括了条目：INCLUDE/EXCLUDE PATTERN RULES、MERGE-FILE FILTER RULES、MERGE-FILE FILTER RULES、ANCHORING INCLUDE/EXCLUDE PATTERNS等。</p><p>  <strong>filter rules：</strong><br>  filter规则允许选择传输哪些文件（include），跳过哪些文件（exclude）。filter规则既可以直接指定include/exclude模式，也可以指定一个获取include/exclude模式的途径（如从一个文件中读取）。<br>  当建立了要传输的文件/目录列表后，rsync会依次核查它们是否符合include/exclude模式，匹配到的第一个模式会生效：如果符合exclude模式，则跳过该文件，如果符合include模式，不跳过该，如果不符合任何模式，文件也不会被跳过。<br>  rsync按照命令行中filter规则顺序建立一个有序列表。filter规则的语法如下：<br>  rule [pattern_or_filename]<br>  rule,modfiers [pattern_or_filename]<br>  可以使用完整规则名称，也可以使用简写名称，可用的规则前缀如下：<br>  exclude, - ：排除模式<br>  include, + ：包含模式<br>  merge, . ：指定一个merge-file，供多个规则读取<br>  dir-merge, : ：指定一个per-directory merge-file<br>  hide, H ：指定一个模式，符合该模式的文件将被隐藏，以防止传输<br>  show, S ：不隐藏符合该模式的文件<br>  protect, p ：指定一个模式来防止文件被删除<br>  risk, R ：符合该模式的文件不会被保护<br>  clear, ! ：清除当前的include/exclude模式列表（该选项无参数）<br>  注：关于merge-file和per-directory，见下文。<br>  如果使用简写形式，前面语法中rule和modefiers之间的逗号是可选的，紧跟着的pattern或filename（如果存在）之后必须有一个空格或下划线。<br>  如果规则是从文件中读取的，那么文件中的空白行将被忽略，以#开头的行被视为注释。<br>  注意：–include/–exclude命令行中的选项，不能完全依照上面filter规则的解释。–include/–exclude命令只允许使用指明的include/exclude模式加”!”标识（即：模式+标识）来清除（译者注：排除或许更准确）（文件或目录）列表。如果模式不以”- “（两个字符：减号和空格）或”+ “（两个字符：加号和空格）开头，那么，对于包含选项而言，规则将被解释为字符串前添加了”+”前缀；对于排除选项而言，规则将被解释为字符串前添加了”-“前缀。与之相反，–filter选项必须在规则开头包含一个简写或完整的规则名称。<br>  另外要注意的是，每个–filter选项，–include选项，和–exclude选项只接受一个rule/pattern，如果想添加多个rule/pattern，可以在命令行中的重复这些选项，或在–filter选项中使用merge-file语法，或使用–include-from/–exclude-from选项。</p><p>  <strong>include/exclude pattern ruls：</strong><br>  注：rsync的man page说，–include和–exclude是–filter选项的简化版。<br>  你可以使用”+”、”-“等filter过滤规则来指定模式，用以包含和排除文件。每个include/exclude规则指定一个模式来匹配传输文件。模式可以有以下几种形式：<br>  1）如果”/”出现在模式的开头，那么它标记了层级中的一个特殊位置（译者注：指的应该是文件系统的位置或完整路径的层次结构中的某一层次），否则，它只是匹配路径的结束。（译者注：这里又出现了anchor，计算机术语称之为锚点，它设置一个标记，然后可以在本文档或页面的其它地方创建一个指向本标记的链接：锚点，标记了一个特定位置。）因此，”/foo”将匹配”root of the transfer”中的foo（对全局规则而言），或者merge-file目录中的foo（对per-directory规则而言）。而未经限定的foo将匹配文件系统中任何位置的foo，因为算法是自上而下递归地生效，就像是路径的每个部分轮流变成文件或目录的结尾（译者注：例如foo/a/b/c，算法对该路径的解释将会是foo/a，foo/a/b，foo/a/b/c，算法依次把a、b、c作为文件或目录结尾）。实际上，非锚定的”sub/foo”将会匹配层次结构中包含子目录sub的，任何位置的foo。<br>  2）如果”/”出现在模式的结尾，那么它只匹配目录，而不匹配常规文件、链接，或设备。<br>  3）rsync会检查模式中是否包含下列通配符，以确定做简单的字符匹配还是通配符匹配：”*”、”?”、”[“<br>  * ：匹配路径的任何部分，遇到斜杠终止<br>  ** ：匹配任何东西，包括斜杠<br>  ? ：匹配任何单个字符，斜杠(“/”)除外<br>  [ ：匹配一个字符集，如[a-z]，或[[:alpha:]]<br>  4）在通配符模式中，反斜杠(“\”)对通配符进行转义，如果通配符不存在，它会被解释一个普通字符<br>  5）如果模式包含”/”（尾部的”/”不计算在内）或”<strong>”，它将匹配完整路径，包括前导目录（即foo/a，既匹配a，也匹配前导的foo）；如果模式不包含”/”或”</strong>”，它只匹配路径最后的部分。（注意：算法是递归地应用，所以实际上“完整路径”可能是从起始目录向下，路径的任何一个部分。）<br>  6）以dir_name/***结尾的模式，既匹配目录（就像指定了dir_name/），又匹配目录中的所有文件（就像指定了dir_name/*<em>）。<br>  请注意：如果使用了-r选项（-a选项隐含了此选项），那么，自顶向下，路径的每一个部分都将被访问，所以，include/exclude模式会递归地对路径的每个组成部分生效（如，要包含/foo/bar/baz，就不能排除/foo和/foo/bar）。当rsync寻找要发送的文件时，exclude模式实际上是rsync在历遍目录时的一个短路。如果一个模式排除了特定的父目录，它就能使一个更深的include模式无法生效，因为rsync无法穿过层级中的排除部分而向下（匹配文件）。（译者注：意思应该是，如果模式排除一个指定的父目录，那么它将无法继续匹配该父目录下的子目录或文件。）这一点非常重要，尤其是使用一个以”</em>”结尾的规则时。如下：<br>  + /some/path/this-file-will-not-be-found<br>  + /file-is-included<br>  - *<br>  上述规则链将无法得到你想要的结果，因为父目录some被”*”规则排除了，所以rsync不会去访问some或some/path目录下的任何文件。要解决这个问题，可以使用一个”+ */”规则来包含层级的所有目录（把它放到”- <em>”前面的任意位置），或许还需要–prune-empty-dirs选项。另外一个解决途径是，添加一个include规则来包含所有需要被访问的父目录。下例的规则集就可以很好的工作：<br>  + /some/<br>  + /some/path/<br>  + /some/path/this-file-is-found<br>  + /file-also-included<br>  - *<br>  （译者注：<br>  1）不知道大家是否理解了上面的官方示例。第一个例子本想包含两个文件，但结果只包含到了一个。文件this-file-will-not-be-found没有被包含的原因在于：基于最先匹配原则，文件本身被include规则所匹配，但其父目录以及爷爷目录并没有被include规则所匹配，所以它们被后面的exclude规则所匹配，而由于rsync不能穿过被exclude规则排除的父目录而匹配其中的文件，所以该文件最终将无法出现在匹配结果中。<br>  这一过程有三个关键：一是rsync无法穿过被排除的父目录而向下匹配文件；二是</em>匹配路径任一部分，遇/终止匹配；三是最先匹配。<br>  2）关于–prune-empty-dirs（简写模式为-m）：这个命令行中的选项告诉rsync的接收方从文件列表中删除空目录，包括那些没有非空子目录的嵌套目录。这个选项很有用，当rsync的发送方使用include/exclude/filter规则扫描具有多层次结构的文件时，它可以避免（接收方）创建一系列无用的目录。）</p><p>  下面是一些exclude/include匹配的示例：<br>  - <em>.o：排除所有以o结尾的文件<br>  - /foo：排除transfer-root目录中，名为foo的文件或目录<br>  （译者注：前面也提到了transfer-root，这个概念会在ANCHORING INCLUDE/EXCLUDE PATTERNS条目中讲到，举例来说明，有一个路径/home/me/foo/bar：<br>  rsync -a - /me/foo/bar /home/me /dest<br>  rsync -a - /foo/bar /home/me/ /dest<br>  上述规则要复制/home/me目录及其下所有文件到/dest，但要排除/me/foo/bar文件（或目录）。两条规则的效果是一样的，但是transfer-root不同。第一条规则中，/home目录就是transfer-root；而对于第二条规则，/home/me/才是transfer-root。也就是说，transfer-root是从路径的最末位向前追溯，遇到的第一个以”/“结尾的目录。）<br>  - foo/：排除任何名为foo的目录<br>  - /foo/</em>/bar：从transfer-root中的foo目录向下两级的位置，排除名为bar的文件。<br>  - /foo/**/bar：从transfer-root中的foo目录向下至少两级的位置，排除名为bar的文件。<br>  + */c，+ *.c，和- *的组合，会包含所有目录，以及以c结尾的文件，除此之外，所有文件都排除。<br>  + /foo/，+ foo/bar.c，和- <em>的组合，将只包含foo目录，以及foo/bar.c文件。（必须明确包含foo目录，否则它将被exclude规则中的</em>所匹配，这会导致前面所讲到的排除特定父目录的问题，将无法如你所愿匹配到foo/bar.c文件。）</p><p>  “+”或”-“接受下列修饰符：<br>  /，指定include/exclude规则要匹配当前项目的绝对路径。例如，-/ /etc/passwd，每当从/etc目录中传输文件时，都要排除密码文件；再比如，-/ subdir/foo，当从名为subdir的目录中传输文件时，总是排除文件foo，即使该文件位于当前传输的根目录。<br>  译者注：不要混淆匹配模式中的/和修饰符/ ！<br>  !，告诉rsync，当模式匹配失败时，include/exclude规则才生效。如，-! */，它将匹配所有非目录文件。<br>  C，该修饰符指示，所有全局的CVS-exclude规则将插入到-C的地方。该修饰符后面无参数。（译者注：文档在介绍-C –cvs-exclude选项时说，如果在自己的–filter规则中同时使用-C，那么所有的CVS exclude规则将附加到你自己的规则的末尾，不管-C位于命令行的什么地方。）<br>  s，指示规则作用于发送端。当规则对发送端生效时，它将阻止文件被传输。该修饰符通常用于那些在两端都生效的规则，除非指定了–delete-excluded；它将使规则默认只在发送端生效。另一种指定发送端includes/excludes的途经是使用hide(H)和show(S)。<br>  r，通常用来指示规则应用于接收端。当规则对接收方生效时，它将防止文件被删除。另一种指定接收端includes/excludes的方法是，使用protect(P)和risk(R)规则。</p><p>  本文转自 li_qinshan 51CTO博客，原文链接:<a href="http://blog.51cto.com/share/567578">http://blog.51cto.com/share/567578</a></p><p>  <strong>版权声明：</strong>本文内容由阿里云实名注册用户自发贡献，版权归原作者所有，阿里云开发者社区不拥有其著作权，亦不承担相应法律责任。具体规则请查看《<a href="https://developer.aliyun.com/article/768092">阿里云开发者社区用户服务协议</a>》和《<a href="https://developer.aliyun.com/article/768093">阿里云开发者社区知识产权保护指引</a>》。如果您发现本社区中有涉嫌抄袭的内容，填写<a href="https://yida.alibaba-inc.com/o/right">侵权投诉表单</a>进行举报，一经查实，本社区将立刻删除涉嫌侵权内容。</p><hr><h1 id="博客2-地址"><a href="#博客2-地址" class="headerlink" title="博客2 地址"></a><a href="https://blog.csdn.net/weixin_30657541/article/details/95381658">博客2 地址</a></h1><p>  rsync –include-from –exclude-from的理解：</p><p>  1、同时添加–include-from –exclude-from时。后者是对前者的结果进行排除</p><p>  如：“–include-from include.txt –include-from exclude.txt” #也就是说绝对不会超过–include-from声明的范围</p><p>  2、–include-from 文件前面的符号是有效的有意义的</p><p>  3、–exclude-from 文件前面不管是什么符号、有没有符号都是排除的意思</p><p>  4、每一个目录、子目录、文件都会与这个过滤规则列表进行匹配，直到找到一个命中的（命中的规则说要过滤就过滤，要包含那就包含），</p><p>  5、最重要的一个原则： 只找第一个匹配的规则</p><p>   以下是原文，我把关键词标出来方便阅读：</p><h2 id="FILTER-RULES"><a href="#FILTER-RULES" class="headerlink" title="FILTER RULES"></a>FILTER RULES</h2><p>  The filter rules allow for flexible selection of which files to transfer (include) and which files to skip (exclude). The rules either directly specify include/exclude patterns or they specify a way to acquire more include/exclude patterns (e.g. to read them from a file).</p><p>  As the list of files/directories to transfer is built, rsync checks each name to be transferred against the list of include/exclude patterns in turn, and the first matching pattern is acted on: if it is an exclude pattern, then that file is skipped; if it is an include pattern then that filename is not skipped; if no matching pattern is found, then the filename is not skipped.</p><p>  Rsync builds an ordered list of filter rules as specified on the command-line.</p><p>  以下是一个实例后面添加对相关过滤规则的说明和理解</p><p>  #############################################################################</p><p>  ### include.txt:</p><p>  # CompanyAttachment Files</p><p>  # 限制所有目录只包含2019开头的</p><p>  - ETest/20191/ #如果非要排除 ETest/20191下的文件 这个排除规则应该放前面。每个路径 只找第一个匹配的规则 （ 只找第一个、只找第一个、只找第一个 这很重要，理解了这个原则，才能理解所有的规则）</p><p>  + 2019*/ #这个只是 包含了目录，目录下的文件不会同步</p><p>  + 2019*/** #这个只包含了目录下的文件，如果没有上面的这个也无效</p><p>  + ETest/ #这个只是 包含了目录 但是子目录如果符合上面的其它条件也会被同步（如ETest目录下有2019开头的文件夹，也会同步）</p><p>  - * #排除其它文件</p><p>  - *.tmp #排除所有的.tmp文件。 这是个 错误 的示例，这个不一定会排除所有目录的.tmp文件。因为有些路径会命中前面的规则就直接返回了。这个排除规则要么写到最前面，要么写到exclude.txt里去</p><p>  #############################################################################</p><p>  #############################################################################</p><p>  # exclude.txt</p><p>  *.tmp #exclude-from文件里不管前面加不加+、-号都是排除（测试+号、-号、不要符号结果是一样的,很奇怪，但测试结果是这样，不知道我是不是理解错误）</p><p>  #* #exclude-from 是对include-from的结果进行排除，所以不能加这个。这个相当于禁用同步了。</p><p>  #############################################################################</p><p>  总结一下：</p><p>  1、顺序很重要，重要的、命中范围小的写前面</p><p>  2、最重要的还是理解它的过滤逻辑：每一个目录、子目录、文件都会与这个过滤规则列表进行匹配，直到找到一个命中的（命中的规则说要过滤就过滤，要包含那就包含），</p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>rsync</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>shell学习</title>
    <link href="/posts/f8d5cfbe/"/>
    <url>/posts/f8d5cfbe/</url>
    
    <content type="html"><![CDATA[<h1 id="bash-shell-获取当前正在执行脚本的绝对路径"><a href="#bash-shell-获取当前正在执行脚本的绝对路径" class="headerlink" title="bash shell 获取当前正在执行脚本的绝对路径"></a>bash shell 获取当前正在执行脚本的绝对路径</h1><p>一般我们写Shell脚本的时候，都倾向使用绝对路径，这样无论脚本在什么目录执行，都应该起到相同的效果，但是有些时候，我们设计一个软件包中的工具脚本或者远程调用某个脚本时，可能使用相对路径更加灵活一点，因为你不知道用户会在哪个目录执行你的程序，于是问题就来了，如何获取当前正在执行脚本的绝对路径？</p><p>常见的一种误区，是使用 pwd 命令，该命令的作用是<code>“print name of current/working directory”，</code>这才是此命令的真实含义，当前的工作目录，这里没有任何意思说明，这个目录就是脚本存放的目录。所以，这是不对的。你可以试试<code>bash shell/a.sh</code>，a.sh 内容是 pwd，你会发现，显示的是执行命令的路径 <code>/home/ljl</code>，并不是 a.sh 所在路径：<code>/home/ljl/shell/a.sh</code></p><p>另一个误人子弟的答案，是 <code>$0</code>，这个也是不对的，这个<code>$0</code>是Bash环境下的特殊变量，其真实含义是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">Expands to the name <span class="hljs-keyword">of</span> the shell or shell script. This is set at shell initialization. If bash is invoked <span class="hljs-keyword">with</span> a file <span class="hljs-keyword">of</span> commands, <br>$<span class="hljs-number">0</span><br> is set to the name <span class="hljs-keyword">of</span> that file. If bash is started <span class="hljs-keyword">with</span> the -c option, then <br>$<span class="hljs-number">0</span><br>is set to the first argument after the string to be executed, <span class="hljs-keyword">if</span> one is present. Otherwise, it is set to the file name used to invoke bash, <span class="hljs-keyword">as</span> given by argument zero.<br></code></pre></td></tr></table></figure><p> 这个$0有可能是好几种值，跟调用的方式有关系：</p><ul><li>使用一个文件调用bash，那$0的值，是那个文件的名字(没说是绝对路径噢)</li><li>使用-c选项启动bash的话，真正执行的命令会从一个字符串中读取，字符串后面如果还有别的参数的话，使用从$0开始的特殊变量引用(跟路径无关了)</li><li>除此以外，$0会被设置成调用bash的那个文件的名字(没说是绝对路径)</li></ul><p>下面对比下正确答案：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell">Jun@VAIO 192.168.1.216 23:52:54 ~ &gt;<br>cat shell/a.sh<br><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br>echo &#x27;$0: &#x27;$0<br>echo &quot;pwd: &quot;`pwd`<br>echo &quot;=============================&quot;<br>echo &quot;scriptPath1: &quot;$(cd `dirname $0`; pwd)<br>echo &quot;scriptPath2: &quot;$(pwd)<br>echo &quot;scriptPath3: &quot;$(dirname $(readlink -f $0))<br>echo &quot;scriptPath4: &quot;$(cd $(dirname $&#123;BASH_SOURCE:-$0&#125;);pwd)<br>echo -n &quot;scriptPath5: &quot; &amp;&amp; dirname $(readlink -f $&#123;BASH_SOURCE[0]&#125;)<br>Jun@VAIO 192.168.1.216 23:53:17 ~ &gt;<br>bash shell/a.sh<br><span class="hljs-meta">$</span><span class="bash">0: shell/a.sh</span><br>pwd: /home/Jun<br>=============================<br>scriptPath1: /home/Jun/shell<br>scriptPath2: /home/Jun<br>scriptPath3: /home/Jun/shell<br>scriptPath4: /home/Jun/shell<br>scriptPath5: /home/Jun/shell<br>Jun@VAIO 192.168.1.216 23:54:54 ~ &gt;<br></code></pre></td></tr></table></figure><p>在此解释下 <code>scriptPath1</code> ：</p><ul><li><ul><li><code>dirname $0</code>，取得当前执行的脚本文件的父目录</li><li><code>cd dirname $0</code>，进入这个目录(切换当前工作目录)</li><li><code>pwd</code>，显示当前工作目录(cd执行后的)</li></ul></li></ul><p>由此，我们获得了当前正在执行的脚本的存放路径。</p><hr><p>有时候，我们需要知道当前执行的输出shell脚本的所在绝对路径，可以用dirname实现。<br>我们知道 dirname 可以获取一个文件所在的路径，dirname的用处是：</p><blockquote><p>输出已经去除了尾部的”/”字符部分的名称；如果名称中不包含”/”，<br>则显示”.”(表示当前目录)。</p></blockquote><p>直接从dirname返回的未必是绝对路径，取决于提供给dirname的参数是否是绝对路径。<br>所以下面这样的代码中SHELL_FOLDER中不一定是绝对路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">SHELL_FOLDER=$(dirname &quot;$0&quot;)<br></code></pre></td></tr></table></figure><p>需要用cd和pwd命令配合获取脚本所在绝对路径，正确的写法是这样的，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">! /bin/bash</span><br><span class="hljs-meta">#</span><span class="bash">输出当前目录-版本1</span><br>this_dir=`pwd`<br>echo &quot;$this_dir ,this is pwd&quot;<br>echo &quot;$0 ,this is \$0&quot;<br>dirname $0|grep &quot;^/&quot; &gt;/dev/null<br>if [ $? -eq 0 ];then<br>    this_dir=`dirname $0`<br>else<br>    dirname $0|grep &quot;^\.&quot; &gt;/dev/null<br>     retval=$?<br>if [ $retval -eq 0 ];then<br>    this_dir=`dirname $0|sed &quot;s#^.#$this_dir#&quot;`<br>else<br>    this_dir=`dirname $0|sed &quot;s#^#$this_dir/#&quot;`<br>fi<br> fi<br> echo $this_dir<br></code></pre></td></tr></table></figure><p>简单版一句</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">SHELL_FOLDER=$(cd &quot;$(dirname &quot;$0&quot;)&quot;;pwd)<br></code></pre></td></tr></table></figure><p> 如果你觉得上面的写法比较麻烦，还有一个方式获取脚本的绝对路径,就是借助readlink命令，下面是readlink的命令行说明：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">readlink [选项]<span class="hljs-string">...</span> [文件列表]<span class="hljs-string">...</span><br>描述<br>       请注意，realpath<span class="hljs-params">(1)</span> 是更建议使用的用于标准化（或正规化，canonicalization）功能的命令。<br>       输出符号链接值或权威文件名<br>       -f, <span class="hljs-params">--canonicalize</span><br>              递归跟随给出文件名的所有符号链接以标准化；所有组件都必须存在<br>       -e, <span class="hljs-params">--canonicalize-existing</span><br>              递归跟随给出文件名的所有符号链接以标准化，除最后一个外所有组件必须存在<br>       -m, <span class="hljs-params">--canonicalize-missing</span><br>              递归跟随给出文件名的所有符号链接以标准化；各个组件没有必须存在的要求<br>       -n, <span class="hljs-params">--no-newline</span><br>              不要输出末尾定界符<br></code></pre></td></tr></table></figure><p>所以用readlink命令我们可以直接获取$0参数的全路径文件名，然后再用dirname获取其所在的绝对路径：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">SHELL_FOLDER=<span class="hljs-variable">$</span>(dirname <span class="hljs-variable">$</span>(readlink <span class="hljs-operator">-f</span> <span class="hljs-string">&quot;<span class="hljs-variable">$0</span>&quot;</span>))<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gson的github文档翻译</title>
    <link href="/posts/f0a26b8/"/>
    <url>/posts/f0a26b8/</url>
    
    <content type="html"><![CDATA[<h2 id="Overview-概述"><a href="#Overview-概述" class="headerlink" title="Overview-概述"></a>Overview-概述</h2><p>Gson is a Java library that can be used to convert Java Objects into their JSON representation. It can also be used to convert a JSON string to an equivalent Java object.</p><p>Gson是一个用于将java对象转换为json表示的java库。他也可以用于将json字符串转换为等效的java对象。</p><p>Gson can work with arbitrary Java objects including pre-existing objects that you do not have source code of.</p><p>Gson 可以处理任意 Java 对象，包括您没有源代码的预先存在的对象。</p><h2 id="Goals-for-Gson-Gson-的目标"><a href="#Goals-for-Gson-Gson-的目标" class="headerlink" title="Goals for Gson -Gson 的目标"></a>Goals for Gson -Gson 的目标</h2><ul><li>Provide easy to use mechanisms like <code>toString()</code> and constructor (factory method) to convert Java to JSON and vice-versa -提供易于使用的机制，如<code>toString()</code>构造函数（工厂方法）将 Java 转换为 JSON，反之亦然</li><li>Allow pre-existing unmodifiable objects to be converted to and from JSON -允许预先存在的不可修改对象与 JSON 相互转换</li><li>Allow custom representations for objects -允许对象的自定义表示</li><li>Support arbitrarily complex objects -支持任意复杂的对象</li><li>Generate compact and readable JSON output -生成紧凑且可读的 JSON 输出</li></ul><h2 id="Gson-Performance-and-Scalability-Gson-性能和可扩展性"><a href="#Gson-Performance-and-Scalability-Gson-性能和可扩展性" class="headerlink" title="Gson Performance and Scalability -Gson 性能和可扩展性"></a>Gson Performance and Scalability -Gson 性能和可扩展性</h2><p>Here are some metrics that we obtained on a desktop (dual opteron, 8GB RAM, 64-bit Ubuntu) running lots of other things along-with the tests. You can rerun these tests by using the class <a href="https://github.com/google/gson/blob/master/gson/src/test/java/com/google/gson/metrics/PerformanceTest.java"><code>PerformanceTest</code></a>.</p><ul><li>Strings: Deserialized strings of over 25MB without any problems (see <code>disabled_testStringDeserializationPerformance</code> method in <code>PerformanceTest</code>)</li><li>Large collections:<ul><li>Serialized a collection of 1.4 million objects (see <code>disabled_testLargeCollectionSerialization</code> method in <code>PerformanceTest</code>)</li><li>Deserialized a collection of 87,000 objects (see <code>disabled_testLargeCollectionDeserialization</code> in <code>PerformanceTest</code>)</li></ul></li><li>Gson 1.4 raised the deserialization limit for byte arrays and collection to over 11MB from 80KB.</li></ul><p>Note: Delete the <code>disabled_</code> prefix to run these tests. We use this prefix to prevent running these tests every time we run JUnit tests.</p><h2 id="Gson-Users"><a href="#Gson-Users" class="headerlink" title="Gson Users"></a>Gson Users</h2><p>Gson was originally created for use inside Google where it is currently used in a number of projects. It is now used by a number of public projects and companies.</p><h2 id="Using-Gson-使用-Gson"><a href="#Using-Gson-使用-Gson" class="headerlink" title="Using Gson -使用 Gson"></a>Using Gson -使用 Gson</h2><p>The primary class to use is <a href="https://github.com/google/gson/blob/master/gson/src/main/java/com/google/gson/Gson.java"><code>Gson</code></a> which you can just create by calling <code>new Gson()</code>. There is also a class <a href="https://github.com/google/gson/blob/master/gson/src/main/java/com/google/gson/GsonBuilder.java"><code>GsonBuilder</code></a> available that can be used to create a Gson instance with various settings like version control and so on.</p><p>要使用的主要类是<a href="https://github.com/google/gson/blob/master/gson/src/main/java/com/google/gson/Gson.java"><code>Gson</code></a>您可以通过调用创建的类<code>new Gson()</code>。还有一个<a href="https://github.com/google/gson/blob/master/gson/src/main/java/com/google/gson/GsonBuilder.java"><code>GsonBuilder</code></a>可用的类可用于创建具有各种设置（如版本控制等）的 Gson 实例。</p><p>The Gson instance does not maintain any state while invoking Json operations. So, you are free to reuse the same object for multiple Json serialization and deserialization operations.</p><p>Gson 实例在调用 Json 操作时不维护任何状态。因此，您可以自由地为多个 Json 序列化和反序列化操作重用同一个对象。</p><h2 id="Using-Gson-with-Gradle-Android-在-Gradle-Android-中使用-Gson"><a href="#Using-Gson-with-Gradle-Android-在-Gradle-Android-中使用-Gson" class="headerlink" title="Using Gson with Gradle/Android -在 Gradle/Android 中使用 Gson"></a>Using Gson with Gradle/Android -在 Gradle/Android 中使用 Gson</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">dependencies</span> &#123;<br>    <span class="hljs-attribute">implementation</span> <span class="hljs-string">&#x27;com.google.code.gson:gson:2.8.9&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Using-Gson-with-Maven-在-Maven-中使用-Gson"><a href="#Using-Gson-with-Maven-在-Maven-中使用-Gson" class="headerlink" title="Using Gson with Maven -在 Maven 中使用 Gson"></a>Using Gson with Maven -在 Maven 中使用 Gson</h2><p>To use Gson with Maven2/3, you can use the Gson version available in Maven Central by adding the following dependency:</p><p>要将 Gson 与 Maven2/3 一起使用，您可以通过添加以下依赖项来使用 Maven Central 中可用的 Gson 版本：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--  Gson: Java to Json conversion --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.code.gson<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>gson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.8.9<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>That is it, now your maven project is Gson enabled.</p><p>现在您的 Maven 项目启用了 Gson。</p><h3 id="Primitives-Examples-基本类型示例"><a href="#Primitives-Examples-基本类型示例" class="headerlink" title="Primitives Examples -基本类型示例"></a>Primitives Examples -基本类型示例</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// Serialization 序列化</span><br>Gson gson = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Gson()</span>;<br>gson.<span class="hljs-keyword">to</span><span class="hljs-constructor">Json(1)</span>;            <span class="hljs-comment">// ==&gt; 1</span><br>gson.<span class="hljs-keyword">to</span><span class="hljs-constructor">Json(<span class="hljs-string">&quot;abcd&quot;</span>)</span>;       <span class="hljs-comment">// ==&gt; &quot;abcd&quot;</span><br>gson.<span class="hljs-keyword">to</span><span class="hljs-constructor">Json(<span class="hljs-params">new</span> Long(10)</span>); <span class="hljs-comment">// ==&gt; 10</span><br><span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> values = &#123; <span class="hljs-number">1</span> &#125;;<br>gson.<span class="hljs-keyword">to</span><span class="hljs-constructor">Json(<span class="hljs-params">values</span>)</span>;       <span class="hljs-comment">// ==&gt; [1]</span><br><br><span class="hljs-comment">// Deserialization 反序列化</span><br><span class="hljs-built_in">int</span> one = gson.from<span class="hljs-constructor">Json(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-params">int</span>.<span class="hljs-params">class</span>)</span>;<br>Integer one = gson.from<span class="hljs-constructor">Json(<span class="hljs-string">&quot;1&quot;</span>, Integer.<span class="hljs-params">class</span>)</span>;<br>Long one = gson.from<span class="hljs-constructor">Json(<span class="hljs-string">&quot;1&quot;</span>, Long.<span class="hljs-params">class</span>)</span>;<br>Boolean <span class="hljs-literal">false</span> = gson.from<span class="hljs-constructor">Json(<span class="hljs-string">&quot;false&quot;</span>, Boolean.<span class="hljs-params">class</span>)</span>;<br>String str = gson.from<span class="hljs-constructor">Json(<span class="hljs-string">&quot;\&quot;abc\&quot;&quot;</span>, String.<span class="hljs-params">class</span>)</span>;<br>String<span class="hljs-literal">[]</span> anotherStr = gson.from<span class="hljs-constructor">Json(<span class="hljs-string">&quot;[\&quot;abc\&quot;]&quot;</span>, String[].<span class="hljs-params">class</span>)</span>;<br></code></pre></td></tr></table></figure><h3 id="Object-Examples-对象示例"><a href="#Object-Examples-对象示例" class="headerlink" title="Object Examples -对象示例"></a>Object Examples -对象示例</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> BagOfPrimitives &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> value1 = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">private</span> String value2 = <span class="hljs-string">&quot;abc&quot;</span>;<br>  <span class="hljs-keyword">private</span> transient <span class="hljs-built_in">int</span> value3 = <span class="hljs-number">3</span>;<br>  <span class="hljs-constructor">BagOfPrimitives()</span> &#123;<br>    <span class="hljs-comment">// no-args constructor</span><br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// Serialization</span><br>BagOfPrimitives obj = <span class="hljs-keyword">new</span> <span class="hljs-constructor">BagOfPrimitives()</span>;<br>Gson gson = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Gson()</span>;<br>String json = gson.<span class="hljs-keyword">to</span><span class="hljs-constructor">Json(<span class="hljs-params">obj</span>)</span>;  <br><br><span class="hljs-comment">// ==&gt; json is &#123;&quot;value1&quot;:1,&quot;value2&quot;:&quot;abc&quot;&#125;</span><br></code></pre></td></tr></table></figure><p>Note that you can not serialize objects with circular references since that will result in infinite recursion.</p><p>请注意，您不能使用循环引用序列化对象，因为这会导致无限递归。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// Deserialization</span><br>BagOfPrimitives obj2 = gson.from<span class="hljs-constructor">Json(<span class="hljs-params">json</span>, BagOfPrimitives.<span class="hljs-params">class</span>)</span>;<br><span class="hljs-comment">// ==&gt; obj2 is just like obj</span><br></code></pre></td></tr></table></figure><h4 id="Finer-Points-with-Objects-更精细的点与对象"><a href="#Finer-Points-with-Objects-更精细的点与对象" class="headerlink" title="Finer Points with Objects -更精细的点与对象"></a><strong>Finer Points with Objects</strong> -<strong>更精细的点与对象</strong></h4><ul><li>It is perfectly fine (and recommended) to use private fields.使用私有字段非常好（并且推荐）。</li><li>There is no need to use any annotations to indicate a field is to be included for serialization and deserialization. All fields in the current class (and from all super classes) are included by default.不需要使用任何注释来指示要包含的字段以进行序列化和反序列化。默认情况下包含当前类（以及所有超类）中的所有字段。</li><li>If a field is marked transient, (by default) it is ignored and not included in the JSON serialization or deserialization.如果字段被标记为瞬态，（默认情况下）它将被忽略并且不包含在 JSON 序列化或反序列化中。</li><li>This implementation handles nulls correctly.此实现正确处理空值。<ul><li>While serializing, a null field is omitted from the output.序列化时，输出中会省略空字段。</li><li>While deserializing, a missing entry in JSON results in setting the corresponding field in the object to its default value: null for object types, zero for numeric types, and false for booleans.反序列化时，JSON 中缺少条目会导致将对象中的相应字段设置为其默认值：对象类型为 null，数字类型为零，布尔值为 false。</li></ul></li><li>If a field is <em>synthetic</em>, it is ignored and not included in JSON serialization or deserialization.如果一个字段是<em>合成的</em>，它将被忽略并且不包含在 JSON 序列化或反序列化中。</li><li>Fields corresponding to the outer classes in inner classes, anonymous classes, and local classes are ignored and not included in serialization or deserialization.内部类、匿名类和本地类中对应于外部类的字段将被忽略，不包括在序列化或反序列化中</li></ul><h3 id="Nested-Classes-including-Inner-Classes-嵌套类（包括内部类）"><a href="#Nested-Classes-including-Inner-Classes-嵌套类（包括内部类）" class="headerlink" title="Nested Classes (including Inner Classes)嵌套类（包括内部类）"></a>Nested Classes (including Inner Classes)嵌套类（包括内部类）</h3><p>Gson can serialize static nested classes quite easily.</p><p>Gson 可以很容易地序列化静态嵌套类。</p><p>Gson can also deserialize static nested classes. However, Gson can <strong>not</strong> automatically deserialize the <strong>pure inner classes since their no-args constructor also need a reference to the containing Object</strong> which is not available at the time of deserialization. You can address this problem by either making the inner class static or by providing a custom InstanceCreator for it. Here is an example:</p><p>Gson 还可以反序列化静态嵌套类。但是，Gson<strong>不能</strong>自动反序列化<strong>纯内部类，因为它们的无参数构造函数还需要</strong>对反序列化时不可用<strong>的包含对象的引用</strong>。您可以通过将内部类设为静态或为其提供自定义 InstanceCreator 来解决此问题。下面是一个例子：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123; <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> a; <br><br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> </span>&#123; <br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> b; <br><br>    <span class="hljs-keyword">public</span> B() &#123;<br>      <span class="hljs-comment">// No args constructor for B</span><br>    &#125;<br>  &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>NOTE</strong>: The above class B can not (by default) be serialized with Gson.</p><p><strong>注意</strong>：上面的 B 类不能（默认情况下）用 Gson 序列化。</p><p>Gson can not deserialize <code>&#123;&quot;b&quot;:&quot;abc&quot;&#125;</code> into an instance of B since the class B is an inner class. If it was defined as static class B then Gson would have been able to deserialize the string. Another solution is to write a custom instance creator for B.</p><p>Gson 无法反序列<code>&#123;&quot;b&quot;:&quot;abc&quot;&#125;</code>化为 B 的实例，因为 B 类是内部类。如果它被定义为静态 B 类，那么 Gson 将能够反序列化字符串。另一种解决方案是为 B 编写自定义实例创建者。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InstanceCreatorForB</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InstanceCreator</span>&lt;<span class="hljs-title">A</span>.<span class="hljs-title">B</span>&gt; </span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> A a;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">InstanceCreatorForB</span><span class="hljs-params">(A a)</span>  </span>&#123;<br>    <span class="hljs-keyword">this</span>.a = a;<br>  &#125;<br>  <span class="hljs-keyword">public</span> A.<span class="hljs-function">B <span class="hljs-title">createInstance</span><span class="hljs-params">(Type type)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a.<span class="hljs-function"><span class="hljs-keyword">new</span> <span class="hljs-title">B</span><span class="hljs-params">()</span></span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>The above is possible, but not recommended.以上是可以的，但不推荐。</p><h3 id="Array-Examples数组示例"><a href="#Array-Examples数组示例" class="headerlink" title="Array Examples数组示例"></a>Array Examples数组示例</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Gson gson = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Gson()</span>;<br><span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> ints = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>String<span class="hljs-literal">[]</span> strings = &#123;<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;def&quot;</span>, <span class="hljs-string">&quot;ghi&quot;</span>&#125;;<br><br><span class="hljs-comment">// Serialization</span><br>gson.<span class="hljs-keyword">to</span><span class="hljs-constructor">Json(<span class="hljs-params">ints</span>)</span>;     <span class="hljs-comment">// ==&gt; [1,2,3,4,5]</span><br>gson.<span class="hljs-keyword">to</span><span class="hljs-constructor">Json(<span class="hljs-params">strings</span>)</span>;  <span class="hljs-comment">// ==&gt; [&quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;]</span><br><br><span class="hljs-comment">// Deserialization</span><br><span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> ints2 = gson.from<span class="hljs-constructor">Json(<span class="hljs-string">&quot;[1,2,3,4,5]&quot;</span>, <span class="hljs-params">int</span>[].<span class="hljs-params">class</span>)</span>; <br><span class="hljs-comment">// ==&gt; ints2 will be same as ints</span><br></code></pre></td></tr></table></figure><p>We also support multi-dimensional arrays, with arbitrarily complex element types.</p><p>我们还支持具有任意复杂元素类型的多维数组。</p><h3 id="Collections-Examples集合示例"><a href="#Collections-Examples集合示例" class="headerlink" title="Collections Examples集合示例"></a>Collections Examples集合示例</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Gson gson = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Gson()</span>;<br>Collection&lt;Integer&gt; ints = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Lists</span>.</span></span>immutable<span class="hljs-constructor">List(1,2,3,4,5)</span>;<br><br><span class="hljs-comment">// Serialization</span><br>String json = gson.<span class="hljs-keyword">to</span><span class="hljs-constructor">Json(<span class="hljs-params">ints</span>)</span>;  <span class="hljs-comment">// ==&gt; json is [1,2,3,4,5]</span><br><br><span class="hljs-comment">// Deserialization</span><br>Type collectionType = <span class="hljs-keyword">new</span> TypeToken&lt;Collection&lt;Integer&gt;&gt;<span class="hljs-literal">()</span>&#123;&#125;.get<span class="hljs-constructor">Type()</span>;<br>Collection&lt;Integer&gt; ints2 = gson.from<span class="hljs-constructor">Json(<span class="hljs-params">json</span>, <span class="hljs-params">collectionType</span>)</span>;<br><span class="hljs-comment">// ==&gt; ints2 is same as ints</span><br></code></pre></td></tr></table></figure><p>Fairly hideous: note how we define the type of collection. Unfortunately, there is no way to get around this in Java.</p><p>相当可怕：注意我们如何定义集合的类型。不幸的是，在 Java 中没有办法解决这个问题。</p><h4 id="Collections-Limitations集合限制"><a href="#Collections-Limitations集合限制" class="headerlink" title="Collections Limitations集合限制"></a>Collections Limitations集合限制</h4><p>Gson can serialize collection of arbitrary objects but can not deserialize from it, because there is no way for the user to indicate the type of the resulting object. Instead, while deserializing, the Collection must be of a specific, generic type. This makes sense, and is rarely a problem when following good Java coding practices.</p><p>Gson 可以序列化任意对象的集合，但不能反序列化，因为用户无法指示结果对象的类型。相反，在反序列化时，集合必须是特定的泛型类型。这是有道理的，并且在遵循良好的 Java 编码实践时很少会成为问题。</p><h3 id="Serializing-and-Deserializing-Generic-Types"><a href="#Serializing-and-Deserializing-Generic-Types" class="headerlink" title="Serializing and Deserializing Generic Types"></a>Serializing and Deserializing Generic Types</h3><p>When you call <code>toJson(obj)</code>, Gson calls <code>obj.getClass()</code> to get information on the fields to serialize. Similarly, you can typically pass <code>MyClass.class</code> object in the <code>fromJson(json, MyClass.class)</code> method. This works fine if the object is a non-generic type. However, if the object is of a generic type, then the Generic type information is lost because of Java Type Erasure. Here is an example illustrating the point:</p><p>当您调用 时<code>toJson(obj)</code>，Gson 会调用<code>obj.getClass()</code>以获取有关要序列化的字段的信息。同样，您通常可以<code>MyClass.class</code>在<code>fromJson(json, MyClass.class)</code>方法中传递对象。如果对象是非泛型类型，这可以正常工作。但是，如果对象是泛型类型，那么由于 Java 类型擦除，泛型类型信息将丢失。这是一个说明这一点的例子：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Foo&lt;T&gt; &#123;<br>  T value;<br>&#125;<br>Gson gson = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Gson()</span>;<br>Foo&lt;Bar&gt; foo = <span class="hljs-keyword">new</span> Foo&lt;Bar&gt;<span class="hljs-literal">()</span>;<br>gson.<span class="hljs-keyword">to</span><span class="hljs-constructor">Json(<span class="hljs-params">foo</span>)</span>; <span class="hljs-comment">// May not serialize foo.value correctly</span><br><br>gson.from<span class="hljs-constructor">Json(<span class="hljs-params">json</span>, <span class="hljs-params">foo</span>.<span class="hljs-params">getClass</span>()</span>); <span class="hljs-comment">// Fails to deserialize foo.value as Bar</span><br></code></pre></td></tr></table></figure><p>The above code fails to interpret value as type Bar because Gson invokes <code>foo.getClass()</code> to get its class information, but this method returns a raw class, <code>Foo.class</code>. This means that Gson has no way of knowing that this is an object of type <code>Foo&lt;Bar&gt;</code>, and not just plain <code>Foo</code>.</p><p>上面的代码无法将 value 解释为 Bar 类型，因为 Gson 调用<code>foo.getClass()</code>以获取其类信息，但此方法返回一个原始类<code>Foo.class</code>. 这意味着 Gson 无法知道这是一个类型的对象<code>Foo&lt;Bar&gt;</code>，而不仅仅是普通的<code>Foo</code>。</p><p>You can solve this problem by specifying the correct parameterized type for your generic type. You can do this by using the <a href="https://static.javadoc.io/com.google.code.gson/gson/2.8.5/com/google/gson/reflect/TypeToken.html"><code>TypeToken</code></a> class.</p><p>您可以通过为泛型类型指定正确的参数化类型来解决此问题。您可以通过使用<a href="https://static.javadoc.io/com.google.code.gson/gson/2.8.5/com/google/gson/reflect/TypeToken.html"><code>TypeToken</code></a>该类来做到这一点。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Type fooType = <span class="hljs-keyword">new</span> TypeToken&lt;Foo&lt;Bar&gt;&gt;<span class="hljs-literal">()</span> &#123;&#125;.get<span class="hljs-constructor">Type()</span>;<br>gson.<span class="hljs-keyword">to</span><span class="hljs-constructor">Json(<span class="hljs-params">foo</span>, <span class="hljs-params">fooType</span>)</span>;<br><br>gson.from<span class="hljs-constructor">Json(<span class="hljs-params">json</span>, <span class="hljs-params">fooType</span>)</span>;<br></code></pre></td></tr></table></figure><p>The idiom used to get <code>fooType</code> actually defines an anonymous local inner class containing a method <code>getType()</code> that returns the fully parameterized type.</p><p>用于 get 的习惯用法<code>fooType</code>实际上定义了一个匿名本地内部类，其中包含一个<code>getType()</code>返回完全参数化类型的方法。</p><h3 id="Serializing-and-Deserializing-Collection-with-Objects-of-Arbitrary-Types使用任意类型的对象序列化和反序列化集合"><a href="#Serializing-and-Deserializing-Collection-with-Objects-of-Arbitrary-Types使用任意类型的对象序列化和反序列化集合" class="headerlink" title="Serializing and Deserializing Collection with Objects of Arbitrary Types使用任意类型的对象序列化和反序列化集合"></a>Serializing and Deserializing Collection with Objects of Arbitrary Types使用任意类型的对象序列化和反序列化集合</h3><p>Sometimes you are dealing with JSON array that contains mixed types. For example: <code>[&#39;hello&#39;,5,&#123;name:&#39;GREETINGS&#39;,source:&#39;guest&#39;&#125;]</code></p><p> <code>有时您正在处理包含混合类型的 JSON 数组。例如： </code>[‘hello’,5,{name:’GREETINGS’,source:’guest’}]</p><p>The equivalent <code>Collection</code> containing this is:</p><p><code>Collection</code>包含此内容的等效项是：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Collection collection = new ArrayList();<br>collection.<span class="hljs-builtin-name">add</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>collection.<span class="hljs-builtin-name">add</span>(5);<br>collection.<span class="hljs-builtin-name">add</span>(new Event(<span class="hljs-string">&quot;GREETINGS&quot;</span>, <span class="hljs-string">&quot;guest&quot;</span>));<br></code></pre></td></tr></table></figure><p>where the <code>Event</code> class is defined as:</p><p>其中<code>Event</code>类定义为：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Event</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> name;<br>  <span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> source;<br>  <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-title">Event</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name, <span class="hljs-built_in">String</span> source</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.source = source;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>You can serialize the collection with Gson without doing anything specific: <code>toJson(collection)</code> would write out the desired output.</p><p>您可以使用 Gson 序列化集合，而无需执行任何特定操作：<code>toJson(collection)</code>将写出所需的输出。</p><p>However, deserialization with <code>fromJson(json, Collection.class)</code> will not work since Gson has no way of knowing how to map the input to the types. Gson requires that you provide a genericised version of collection type in <code>fromJson()</code>. So, you have three options:</p><p>但是，反序列化<code>fromJson(json, Collection.class)</code>不会起作用，因为 Gson 无法知道如何将输入映射到类型。Gson 要求您在<code>fromJson()</code>. 所以，你有三个选择：</p><ol><li>Use Gson’s parser API (low-level streaming parser or the DOM parser JsonParser) to parse the array elements and then use <code>Gson.fromJson()</code> on each of the array elements.This is the preferred approach. <a href="https://github.com/google/gson/blob/master/extras/src/main/java/com/google/gson/extras/examples/rawcollections/RawCollectionsExample.java">Here is an example</a> that demonstrates how to do this.使用 Gson 的解析器 API（低级流解析器或 DOM 解析器 JsonParser）解析数组元素，然后<code>Gson.fromJson()</code>在每个数组元素上使用。这是首选方法。<a href="https://github.com/google/gson/blob/master/extras/src/main/java/com/google/gson/extras/examples/rawcollections/RawCollectionsExample.java">这是一个</a>演示如何执行此操作<a href="https://github.com/google/gson/blob/master/extras/src/main/java/com/google/gson/extras/examples/rawcollections/RawCollectionsExample.java">的示例</a>。</li><li>Register a type adapter for <code>Collection.class</code> that looks at each of the array members and maps them to appropriate objects. The disadvantage of this approach is that it will screw up deserialization of other collection types in Gson.注册一个类型适配器，用于<code>Collection.class</code>查看每个数组成员并将它们映射到适当的对象。这种方法的缺点是它会搞砸 Gson 中其他集合类型的反序列化。</li><li>Register a type adapter for <code>MyCollectionMemberType</code> and use <code>fromJson()</code> with <code>Collection&lt;MyCollectionMemberType&gt;</code>.注册一个类型的适配器<code>MyCollectionMemberType</code>和使用<code>fromJson()</code>有<code>Collection&lt;MyCollectionMemberType&gt;</code>。</li></ol><p>This approach is practical only if the array appears as a top-level element or if you can change the field type holding the collection to be of type <code>Collection&lt;MyCollectionMemberType&gt;</code>.</p><p>仅当数组显示为顶级元素或者您可以将保存集合的字段类型更改为 type 时，此方法才实用<code>Collection&lt;MyCollectionMemberType&gt;</code>。</p><h3 id="Built-in-Serializers-and-Deserializers内置序列化器和反序列化器"><a href="#Built-in-Serializers-and-Deserializers内置序列化器和反序列化器" class="headerlink" title="Built-in Serializers and Deserializers内置序列化器和反序列化器"></a>Built-in Serializers and Deserializers内置序列化器和反序列化器</h3><p>Gson has built-in serializers and deserializers for commonly used classes whose default representation may be inappropriate, for instance</p><p>例如，Gson 为常用类内置了序列化器和反序列化器，这些类的默认表示可能不合适</p><ul><li><code>java.net.URL</code> to match it with strings like <code>&quot;https://github.com/google/gson/&quot; 翻译：</code>java.net.URL<code>将它与字符串匹配</code>“<a href="https://github.com/google/gson/&quot;%60%60">https://github.com/google/gson/&quot;``</a></li><li><code>java.net.URI</code> to match it with strings like <code>&quot;/google/gson/&quot; 翻译：</code>java.net.URI<code>将它与字符串匹配</code>“/google/gson/“``</li></ul><p>For many more, see the internal class <a href="https://github.com/google/gson/blob/master/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java"><code>TypeAdapters</code></a>.</p><p>有关更多信息，请参阅内部类<a href="https://github.com/google/gson/blob/master/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java"><code>TypeAdapters</code></a>。</p><p>You can also find source code for some commonly used classes such as JodaTime at <a href="https://sites.google.com/site/gson/gson-type-adapters-for-common-classes-1">this page</a>.</p><p>您还可以在<a href="https://sites.google.com/site/gson/gson-type-adapters-for-common-classes-1">此页面</a>找到一些常用类的源代码，例如 JodaTime 。</p><h3 id="Custom-Serialization-and-Deserialization自定义序列化和反序列化"><a href="#Custom-Serialization-and-Deserialization自定义序列化和反序列化" class="headerlink" title="Custom Serialization and Deserialization自定义序列化和反序列化"></a>Custom Serialization and Deserialization自定义序列化和反序列化</h3><p>Sometimes default representation is not what you want. This is often the case when dealing with library classes (DateTime, etc). Gson allows you to register your own custom serializers and deserializers. This is done by defining two parts:</p><p>有时默认表示不是您想要的。在处理库类（DateTime 等）时，通常就是这种情况。Gson 允许您注册自己的自定义序列化器和反序列化器。这是通过定义两个部分来完成的：</p><ul><li>Json Serializers: Need to define custom serialization for an object需要为对象定义自定义序列化</li><li>Json Deserializers: Needed to define custom deserialization for a type需要为类型定义自定义反序列化</li><li>Instance Creators: Not needed if no-args constructor is available or a deserializer is registered如果无参数构造函数可用或注册了反序列化器，则不需要</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">GsonBuilder gson = <span class="hljs-keyword">new</span> <span class="hljs-constructor">GsonBuilder()</span>;<br>gson.register<span class="hljs-constructor">TypeAdapter(MyType2.<span class="hljs-params">class</span>, <span class="hljs-params">new</span> MyTypeAdapter()</span>);<br>gson.register<span class="hljs-constructor">TypeAdapter(MyType.<span class="hljs-params">class</span>, <span class="hljs-params">new</span> MySerializer()</span>);<br>gson.register<span class="hljs-constructor">TypeAdapter(MyType.<span class="hljs-params">class</span>, <span class="hljs-params">new</span> MyDeserializer()</span>);<br>gson.register<span class="hljs-constructor">TypeAdapter(MyType.<span class="hljs-params">class</span>, <span class="hljs-params">new</span> MyInstanceCreator()</span>);<br></code></pre></td></tr></table></figure><p><code>registerTypeAdapter</code> call checks if the type adapter implements more than one of these interfaces and register it for all of them.</p><p><code>registerTypeAdapter</code> call 检查类型适配器是否实现了多个这些接口并为所有这些接口注册它。</p><h4 id="Writing-a-Serializer-编写序列化程序"><a href="#Writing-a-Serializer-编写序列化程序" class="headerlink" title="Writing a Serializer 编写序列化程序"></a>Writing a Serializer 编写序列化程序</h4><p>Here is an example of how to write a custom serializer for JodaTime <code>DateTime</code> class.</p><p>以下是如何为 JodaTime<code>DateTime</code>类编写自定义序列化程序的示例。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DateTimeSerializer</span> <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">JsonSerializer</span></span>&lt;<span class="hljs-title">DateTime</span>&gt; </span>&#123;<br>  <span class="hljs-keyword">public</span> JsonElement serialize(DateTime src, Type typeOfSrc, JsonSerializationContext context) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">JsonPrimitive</span>(src.toString());<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Gson calls <code>serialize()</code> when it runs into a <code>DateTime</code> object during serialization.</p><p>Gson在序列化过程中<code>serialize()</code>遇到<code>DateTime</code>对象时调用。</p><h4 id="Writing-a-Deserializer编写反序列化器"><a href="#Writing-a-Deserializer编写反序列化器" class="headerlink" title="Writing a Deserializer编写反序列化器"></a>Writing a Deserializer编写反序列化器</h4><p>Here is an example of how to write a custom deserializer for JodaTime DateTime class.</p><p>以下是如何为 JodaTime DateTime 类编写自定义反序列化器的示例。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DateTimeDeserializer</span> <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">JsonDeserializer</span></span>&lt;<span class="hljs-title">DateTime</span>&gt; </span>&#123;<br>  <span class="hljs-keyword">public</span> DateTime deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)<br>      throws JsonParseException &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">DateTime</span>(json.getAsJsonPrimitive().getAsString());<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Gson calls <code>deserialize</code> when it needs to deserialize a JSON string fragment into a DateTime object</p><p>Gson<code>deserialize</code>在需要将 JSON 字符串片段反序列化为 DateTime 对象时调用</p><p><strong>Finer points with Serializers and Deserializers</strong>序列化器和反序列化器的精髓****</p><p>Often you want to register a single handler for all generic types corresponding to a raw type</p><p>通常，您希望为与原始类型对应的所有泛型类型注册单个处理程序</p><ul><li>For example, suppose you have an <code>Id</code> class for id representation/translation (i.e. an internal vs. external representation).例如，假设您有一个<code>Id</code>用于 id 表示/翻译的类（即内部与外部表示）。</li></ul><ul><li>Id<T>type that has same serialization for all generic types 翻译：<code>Id&lt;T&gt;</code> 对所有泛型类型具有相同序列化的类型<ul><li>Essentially write out the id value本质上写出id值</li></ul></li></ul><ul><li>Deserialization is very similar but not exactly the same反序列化非常相似但不完全相同<ul><li>Need to call <code>new Id(Class&lt;T&gt;, String)</code> which returns an instance of <code>Id&lt;T&gt;</code> 需要调用<code>new Id(Class&lt;T&gt;, String)</code>它返回一个实例<code>Id&lt;T&gt;</code></li></ul></li></ul><p>Gson supports registering a single handler for this. You can also register a specific handler for a specific generic type (say <code>Id&lt;RequiresSpecialHandling&gt;</code> needed special handling). The <code>Type</code> parameter for the <code>toJson()</code> and <code>fromJson()</code> contains the generic type information to help you write a single handler for all generic types corresponding to the same raw type.</p><p>Gson 支持为此注册单个处理程序。您还可以为特定的泛型类型注册特定的处理程序（比如<code>Id&lt;RequiresSpecialHandling&gt;</code>需要特殊处理）。在<code>Type</code>该参数<code>toJson()</code>和<code>fromJson()</code>包含的通用类型的信息来帮助你编写对应于同一原始类型的所有泛型类型单一的处理程序</p><h3 id="Writing-an-Instance-Creator编写实例创建器"><a href="#Writing-an-Instance-Creator编写实例创建器" class="headerlink" title="Writing an Instance Creator编写实例创建器"></a>Writing an Instance Creator编写实例创建器</h3><p>While deserializing an Object, Gson needs to create a default instance of the class. Well-behaved classes that are meant for serialization and deserialization should have a no-argument constructor.</p><p>在反序列化对象时，Gson 需要创建类的默认实例。用于序列化和反序列化的行为良好的类应该有一个无参数的构造函数。</p><ul><li>Doesn’t matter whether public or private不管是公有私</li></ul><p>Typically, Instance Creators are needed when you are dealing with a library class that does NOT define a no-argument constructor</p><p>通常，当您处理未定义无参数构造函数的库类时，需要 Instance Creators</p><p><strong>Instance Creator Example</strong>实例创建者示例****</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MoneyInstanceCreator</span> <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">InstanceCreator</span></span>&lt;<span class="hljs-title">Money</span>&gt; </span>&#123;<br>  <span class="hljs-keyword">public</span> Money createInstance(Type type) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">Money</span>(<span class="hljs-string">&quot;1000000&quot;</span>, CurrencyCode.USD);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Type could be of a corresponding generic type类型可以是相应的泛型类型</p><ul><li>Very useful to invoke constructors which need specific generic type information调用需要特定泛型类型信息的构造函数非常有用</li><li>例如，如果<code>Id</code>类存储正在为其创建 Id 的类</li><li>For example, if the <code>Id</code> class stores the class for which the Id is being created</li></ul><h4 id="InstanceCreator-for-a-Parameterized-Type参数化类型的-InstanceCreator"><a href="#InstanceCreator-for-a-Parameterized-Type参数化类型的-InstanceCreator" class="headerlink" title="InstanceCreator for a Parameterized Type参数化类型的 InstanceCreator"></a>InstanceCreator for a Parameterized Type参数化类型的 InstanceCreator</h4><p>Sometimes the type that you are trying to instantiate is a parameterized type. Generally, this is not a problem since the actual instance is of raw type. Here is an example:</p><p>有时，您尝试实例化的类型是参数化类型。通常，这不是问题，因为实际实例是原始类型。下面是一个例子：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyList&lt;T&gt;</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ArrayList&lt;T&gt;</span> </span>&#123;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyListInstanceCreator</span> <span class="hljs-title">implements</span> <span class="hljs-title">InstanceCreator&lt;MyList&lt;?&gt;&gt;</span> </span>&#123;<br>    <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">&quot;unchecked&quot;</span>)<br>  public <span class="hljs-type">MyList</span>&lt;?&gt; createInstance(<span class="hljs-type">Type</span> <span class="hljs-class"><span class="hljs-keyword">type</span>) </span>&#123;<br>    <span class="hljs-comment">// No need to use a parameterized list since the actual instance will have the raw type anyway.</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">MyList</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>However, sometimes you do need to create instance based on the actual parameterized type. In this case, you can use the type parameter being passed to the <code>createInstance</code> method. Here is an example:</p><p>但是，有时您确实需要根据实际参数化类型创建实例。在这种情况下，您可以使用传递给<code>createInstance</code>方法的类型参数。下面是一个例子：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> Id&lt;T&gt; &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">Class</span>&lt;T&gt; classOfId;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> long <span class="hljs-keyword">value</span>;<br>  <span class="hljs-keyword">public</span> Id(<span class="hljs-keyword">Class</span>&lt;T&gt; classOfId, long <span class="hljs-keyword">value</span>) &#123;<br>    this.classOfId = classOfId;<br>    this.<span class="hljs-keyword">value</span> = <span class="hljs-keyword">value</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> IdInstanceCreator implements InstanceCreator&lt;Id&lt;?&gt;&gt; &#123;<br>  <span class="hljs-keyword">public</span> Id&lt;?&gt; createInstance(<span class="hljs-keyword">Type</span> <span class="hljs-keyword">type</span>) &#123;<br>    <span class="hljs-keyword">Type</span>[] typeParameters = ((ParameterizedType)<span class="hljs-keyword">type</span>).getActualTypeArguments();<br>    <span class="hljs-keyword">Type</span> idType = typeParameters[<span class="hljs-number">0</span>]; // Id has <span class="hljs-keyword">only</span> one parameterized <span class="hljs-keyword">type</span> T<br>    <span class="hljs-keyword">return</span> new Id((<span class="hljs-keyword">Class</span>)idType, <span class="hljs-number">0</span>L);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>In the above example, an instance of the Id class can not be created without actually passing in the actual type for the parameterized type. We solve this problem by using the passed method parameter, <code>type</code>. The <code>type</code> object in this case is the Java parameterized type representation of <code>Id&lt;Foo&gt;</code> where the actual instance should be bound to <code>Id&lt;Foo&gt;</code>. Since <code>Id</code> class has just one parameterized type parameter, <code>T</code>, we use the zeroth element of the type array returned by <code>getActualTypeArgument()</code> which will hold <code>Foo.class</code> in this case.</p><p>在上面的例子中，如果没有实际传递参数化类型的实际类型，就无法创建 Id 类的实例。我们通过使用传递的方法参数来解决这个问题，<code>type</code>。<code>type</code>在这种情况下，对象是<code>Id&lt;Foo&gt;</code>实际实例应该绑定到的位置的Java 参数化类型表示<code>Id&lt;Foo&gt;</code>。由于<code>Id</code>class 只有一个参数化类型参数 ，<code>T</code>我们使用返回的类型数组的第零个元素，在这种情况下<code>getActualTypeArgument()</code>它将保持不变<code>Foo.class</code>。</p><h3 id="Compact-Vs-Pretty-Printing-for-JSON-Output-Format紧凑型对比-JSON-输出格式的漂亮打印"><a href="#Compact-Vs-Pretty-Printing-for-JSON-Output-Format紧凑型对比-JSON-输出格式的漂亮打印" class="headerlink" title="Compact Vs. Pretty Printing for JSON Output Format紧凑型对比 JSON 输出格式的漂亮打印"></a>Compact Vs. Pretty Printing for JSON Output Format紧凑型对比 JSON 输出格式的漂亮打印</h3><p>The default JSON output that is provided by Gson is a compact JSON format. This means that there will not be any whitespace in the output JSON structure. Therefore, there will be no whitespace between field names and its value, object fields, and objects within arrays in the JSON output. As well, “null” fields will be ignored in the output (NOTE: null values will still be included in collections/arrays of objects). See the <a href="https://github.com/google/gson/blob/master/UserGuide.md#TOC-Null-Object-Support">Null Object Support</a> section for information on configure Gson to output all null values.</p><p>Gson 提供的默认 JSON 输出是紧凑的 JSON 格式。这意味着输出 JSON 结构中不会有任何空格。因此，JSON 输出中的字段名称及其值、对象字段和数组中的对象之间不会有空格。同样，输出中的“空”字段将被忽略（注意：空值仍将包含在对象的集合/数组中）。有关配置 Gson 以输出所有空值的信息，请参阅<a href="https://github.com/google/gson/blob/master/UserGuide.md#TOC-Null-Object-Support">空对象支持</a>部分。If you would like to use the Pretty Print feature, you must configure your <code>Gson</code> instance using the <code>GsonBuilder</code>. The <code>JsonFormatter</code> is not exposed through our public API, so the client is unable to configure the default print settings/margins for the JSON output. For now, we only provide a default <code>JsonPrintFormatter</code> that has default line length of 80 character, 2 character indentation, and 4 character right margin.</p><p>如果您想使用漂亮打印功能，您必须<code>Gson</code>使用<code>GsonBuilder</code>. 在<code>JsonFormatter</code>没有通过我们的公共API公开，所以客户端无法配置默认打印设置/利润率为JSON输出。目前，我们仅提供<code>JsonPrintFormatter</code>默认行长度为 80 个字符、2 个字符缩进和 4 个字符右边距的默认值。</p><p>The following is an example shows how to configure a <code>Gson</code> instance to use the default <code>JsonPrintFormatter</code> instead of the <code>JsonCompactFormatter</code>:</p><p>以下示例显示了如何将<code>Gson</code>实例配置为使用默认值<code>JsonPrintFormatter</code>而不是<code>JsonCompactFormatter</code>：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Gson gson = <span class="hljs-keyword">new</span> <span class="hljs-constructor">GsonBuilder()</span>.set<span class="hljs-constructor">PrettyPrinting()</span>.create<span class="hljs-literal">()</span>;<br>String jsonOutput = gson.<span class="hljs-keyword">to</span><span class="hljs-constructor">Json(<span class="hljs-params">someObject</span>)</span>;<br></code></pre></td></tr></table></figure><h3 id="Null-Object-Support空对象支持"><a href="#Null-Object-Support空对象支持" class="headerlink" title="Null Object Support空对象支持"></a>Null Object Support空对象支持</h3><p>The default behaviour that is implemented in Gson is that <code>null</code> object fields are ignored. This allows for a more compact output format; however, the client must define a default value for these fields as the JSON format is converted back into its Java form.</p><p>Gson 中实现的默认行为<code>null</code>是忽略对象字段。这允许更紧凑的输出格式；但是，客户端必须为这些字段定义默认值，因为 JSON 格式会转换回其 Java 格式。</p><p>Here’s how you would configure a <code>Gson</code> instance to output null:</p><p>以下是将<code>Gson</code>实例配置为输出 null 的方法：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Gson gson = <span class="hljs-keyword">new</span> <span class="hljs-constructor">GsonBuilder()</span>.serialize<span class="hljs-constructor">Nulls()</span>.create<span class="hljs-literal">()</span>;<br></code></pre></td></tr></table></figure><p>NOTE: when serializing <code>null</code>s with Gson, it will add a <code>JsonNull</code> element to the <code>JsonElement</code> structure. Therefore, this object can be used in custom serialization/deserialization.</p><p>注意：当<code>null</code>使用 Gson序列化s 时，它会<code>JsonNull</code>向<code>JsonElement</code>结构中添加一个元素。因此，该对象可用于自定义序列化/反序列化。</p><p>Here’s an example:下面是一个例子：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> Foo &#123;<br>  <span class="hljs-keyword">private</span> final String s;<br>  <span class="hljs-keyword">private</span> final <span class="hljs-built_in">int</span> i;<br><br>  public <span class="hljs-constructor">Foo()</span> &#123;<br>    this(null, <span class="hljs-number">5</span>);<br>  &#125;<br><br>  public <span class="hljs-constructor">Foo(String <span class="hljs-params">s</span>, <span class="hljs-params">int</span> <span class="hljs-params">i</span>)</span> &#123;<br>    this.s = s;<br>    this.i = i;<br>  &#125;<br>&#125;<br><br>Gson gson = <span class="hljs-keyword">new</span> <span class="hljs-constructor">GsonBuilder()</span>.serialize<span class="hljs-constructor">Nulls()</span>.create<span class="hljs-literal">()</span>;<br>Foo foo = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Foo()</span>;<br>String json = gson.<span class="hljs-keyword">to</span><span class="hljs-constructor">Json(<span class="hljs-params">foo</span>)</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(json);<br><br>json = gson.<span class="hljs-keyword">to</span><span class="hljs-constructor">Json(<span class="hljs-params">null</span>)</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(json);<br></code></pre></td></tr></table></figure><p>The output is:</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">&#123;<span class="hljs-string">&quot;s&quot;</span>:<span class="hljs-literal">null</span>,<span class="hljs-string">&quot;i&quot;</span>:<span class="hljs-number">5</span>&#125;<br><span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><h3 id="Versioning-Support版本支持"><a href="#Versioning-Support版本支持" class="headerlink" title="Versioning Support版本支持"></a>Versioning Support版本支持</h3><p>Multiple versions of the same object can be maintained by using <a href="https://github.com/google/gson/blob/master/gson/src/main/java/com/google/gson/annotations/Since.java">@Since</a> annotation. This annotation can be used on Classes, Fields and, in a future release, Methods. In order to leverage this feature, you must configure your <code>Gson</code> instance to ignore any field/object that is greater than some version number. If no version is set on the <code>Gson</code> instance then it will serialize and deserialize all fields and classes regardless of the version.</p><p>可以使用<a href="https://github.com/google/gson/blob/master/gson/src/main/java/com/google/gson/annotations/Since.java">@Since</a>注解维护同一对象的多个版本。该注解可用于类、字段以及未来版本中的方法。为了利用此功能，您必须将<code>Gson</code>实例配置为忽略大于某个版本号的任何字段/对象。如果没有在<code>Gson</code>实例上设置版本，那么无论版本如何，它都会序列化和反序列化所有字段和类。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VersionedClass</span> </span>&#123;<br>  @Since(<span class="hljs-number">1.1</span>) <span class="hljs-keyword">private</span> final <span class="hljs-keyword">String</span> <span class="hljs-keyword">new</span><span class="hljs-type">erField</span>;<br>  @Since(<span class="hljs-number">1.0</span>) <span class="hljs-keyword">private</span> final <span class="hljs-keyword">String</span> <span class="hljs-keyword">new</span><span class="hljs-type">Field</span>;<br>  <span class="hljs-keyword">private</span> final <span class="hljs-keyword">String</span> field;<br><br>  <span class="hljs-keyword">public</span> VersionedClass() &#123;<br>    <span class="hljs-built_in">this</span>.<span class="hljs-keyword">new</span><span class="hljs-type">erField</span> = <span class="hljs-string">&quot;newer&quot;</span>;<br>    <span class="hljs-built_in">this</span>.<span class="hljs-keyword">new</span><span class="hljs-type">Field</span> = <span class="hljs-string">&quot;new&quot;</span>;<br>    <span class="hljs-built_in">this</span>.field = <span class="hljs-string">&quot;old&quot;</span>;<br>  &#125;<br>&#125;<br><br>VersionedClass versionedObject = <span class="hljs-keyword">new</span> <span class="hljs-type">VersionedClass</span>();<br>Gson gson = <span class="hljs-keyword">new</span> <span class="hljs-type">GsonBuilder</span>().setVersion(<span class="hljs-number">1.0</span>).create();<br><span class="hljs-keyword">String</span> jsonOutput = gson.toJson(versionedObject);<br>System.out.println(jsonOutput);<br>System.out.println();<br><br>gson = <span class="hljs-keyword">new</span> <span class="hljs-type">Gson</span>();<br>jsonOutput = gson.toJson(versionedObject);<br>System.out.println(jsonOutput);<br></code></pre></td></tr></table></figure><p>The output is:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<span class="hljs-attr">&quot;newField&quot;</span>:<span class="hljs-string">&quot;new&quot;</span>,<span class="hljs-attr">&quot;field&quot;</span>:<span class="hljs-string">&quot;old&quot;</span>&#125;<br><br>&#123;<span class="hljs-attr">&quot;newerField&quot;</span>:<span class="hljs-string">&quot;newer&quot;</span>,<span class="hljs-attr">&quot;newField&quot;</span>:<span class="hljs-string">&quot;new&quot;</span>,<span class="hljs-attr">&quot;field&quot;</span>:<span class="hljs-string">&quot;old&quot;</span>&#125;<br></code></pre></td></tr></table></figure><h3 id="Excluding-Fields-From-Serialization-and-Deserialization从序列化和反序列化中排除字段"><a href="#Excluding-Fields-From-Serialization-and-Deserialization从序列化和反序列化中排除字段" class="headerlink" title="Excluding Fields From Serialization and Deserialization从序列化和反序列化中排除字段"></a>Excluding Fields From Serialization and Deserialization从序列化和反序列化中排除字段</h3><p>Gson supports numerous mechanisms for excluding top-level classes, fields and field types. Below are pluggable mechanisms that allow field and class exclusion. If none of the below mechanisms satisfy your needs then you can always use <a href="https://github.com/google/gson/blob/master/UserGuide.md#TOC-Custom-Serialization-and-Deserialization">custom serializers and deserializers</a>.</p><p>Gson 支持多种机制来排除顶级类、字段和字段类型。下面是允许字段和类排除的可插入机制。如果以下机制都不能满足您的需求，那么您始终可以使用<a href="https://github.com/google/gson/blob/master/UserGuide.md#TOC-Custom-Serialization-and-Deserialization">自定义序列化器和反序列化器</a>。</p><h4 id="Java-Modifier-ExclusionJava-修饰符排除"><a href="#Java-Modifier-ExclusionJava-修饰符排除" class="headerlink" title="Java Modifier ExclusionJava 修饰符排除"></a>Java Modifier ExclusionJava 修饰符排除</h4><p>By default, if you mark a field as <code>transient</code>, it will be excluded. As well, if a field is marked as <code>static</code> then by default it will be excluded. If you want to include some transient fields then you can do the following:</p><p>默认情况下，如果您将字段标记为<code>transient</code>，它将被排除在外。同样，如果一个字段被标记为<code>static</code>then 默认情况下它将被排除。如果要包含一些临时字段，则可以执行以下操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.Modifier;<br>Gson gson = <span class="hljs-keyword">new</span> GsonBuilder()<br>    .excludeFieldsWithModifiers(Modifier.STATIC)<br>    .create();<br></code></pre></td></tr></table></figure><p>NOTE: you can give any number of the <code>Modifier</code> constants to the <code>excludeFieldsWithModifiers</code> method. For example:</p><p>注意：您可以<code>Modifier</code>为该<code>excludeFieldsWithModifiers</code>方法提供任意数量的常量。例如：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle">Gson gson = <span class="hljs-keyword">new</span> GsonBuilder()<br>    .excludeFieldsWithModifiers(Modifier.<span class="hljs-keyword">STATIC</span>, Modifier.<span class="hljs-keyword">TRANSIENT</span>, Modifier.<span class="hljs-keyword">VOLATILE</span>)<br>    .create();<br></code></pre></td></tr></table></figure><h4 id="Gson’s-Expose"><a href="#Gson’s-Expose" class="headerlink" title="Gson’s @Expose"></a>Gson’s <code>@Expose</code></h4><p>This feature provides a way where you can mark certain fields of your objects to be excluded for consideration for serialization and deserialization to JSON. To use this annotation, you must create Gson by using <code>new GsonBuilder().excludeFieldsWithoutExposeAnnotation().create()</code>. The Gson instance created will exclude all fields in a class that are not marked with <code>@Expose</code> annotation.</p><p>此功能提供了一种方法，您可以将对象的某些字段标记为要排除以考虑序列化和反序列化为 JSON。要使用此注解，您必须使用<code>new GsonBuilder().excludeFieldsWithoutExposeAnnotation().create()</code>. 创建的 Gson 实例将排除类中所有没有标注的字段<code>@Expose</code>。</p><h4 id="User-Defined-Exclusion-Strategies用户定义的排除策略"><a href="#User-Defined-Exclusion-Strategies用户定义的排除策略" class="headerlink" title="User Defined Exclusion Strategies用户定义的排除策略"></a>User Defined Exclusion Strategies用户定义的排除策略</h4><p>If the above mechanisms for excluding fields and class type do not work for you then you can always write your own exclusion strategy and plug it into Gson. See the <a href="https://static.javadoc.io/com.google.code.gson/gson/2.8.5/com/google/gson/ExclusionStrategy.html"><code>ExclusionStrategy</code></a> JavaDoc for more information.</p><p>如果上述排除字段和类类型的机制对您不起作用，那么您可以随时编写自己的排除策略并将其插入 Gson。有关<a href="https://static.javadoc.io/com.google.code.gson/gson/2.8.5/com/google/gson/ExclusionStrategy.html"><code>ExclusionStrategy</code></a>更多信息，请参阅JavaDoc。</p><p>The following example shows how to exclude fields marked with a specific <code>@Foo</code> annotation and excludes top-level types (or declared field type) of class <code>String</code>.</p><p>以下示例显示了如何排除标有特定<code>@Foo</code>注释的字段并排除 class 的顶级类型（或声明的字段类型）<code>String</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(&#123;ElementType.FIELD&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Foo &#123;<br>  <span class="hljs-comment">// Field tag only annotation</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SampleObjectForTest</span> </span>&#123;<br>  <span class="hljs-meta">@Foo</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> annotatedField;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String stringField;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> longField;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Class&lt;?&gt; clazzField;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SampleObjectForTest</span><span class="hljs-params">()</span> </span>&#123;<br>    annotatedField = <span class="hljs-number">5</span>;<br>    stringField = <span class="hljs-string">&quot;someDefaultValue&quot;</span>;<br>    longField = <span class="hljs-number">1234</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyExclusionStrategy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ExclusionStrategy</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Class&lt;?&gt; typeToSkip;<br><br>  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">MyExclusionStrategy</span><span class="hljs-params">(Class&lt;?&gt; typeToSkip)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.typeToSkip = typeToSkip;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldSkipClass</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (clazz == typeToSkip);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldSkipField</span><span class="hljs-params">(FieldAttributes f)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> f.getAnnotation(Foo.class) != <span class="hljs-keyword">null</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>  Gson gson = <span class="hljs-keyword">new</span> GsonBuilder()<br>      .setExclusionStrategies(<span class="hljs-keyword">new</span> MyExclusionStrategy(String.class))<br>      .serializeNulls()<br>      .create();<br>  SampleObjectForTest src = <span class="hljs-keyword">new</span> SampleObjectForTest();<br>  String json = gson.toJson(src);<br>  System.out.println(json);<br>&#125;<br></code></pre></td></tr></table></figure><p>The output is:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<span class="hljs-attr">&quot;longField&quot;</span>:<span class="hljs-number">1234</span>&#125;<br></code></pre></td></tr></table></figure><h3 id="JSON-Field-Naming-SupportJSON-字段命名支持"><a href="#JSON-Field-Naming-SupportJSON-字段命名支持" class="headerlink" title="JSON Field Naming SupportJSON 字段命名支持"></a>JSON Field Naming SupportJSON 字段命名支持</h3><p>Gson supports some pre-defined field naming policies to convert the standard Java field names (i.e., camel cased names starting with lower case — <code>sampleFieldNameInJava</code>) to a Json field name (i.e., <code>sample_field_name_in_java</code> or <code>SampleFieldNameInJava</code>). See the <a href="https://static.javadoc.io/com.google.code.gson/gson/2.8.5/com/google/gson/FieldNamingPolicy.html">FieldNamingPolicy</a> class for information on the pre-defined naming policies.</p><p>Gson 支持一些预定义的字段命名策略来将标准的 Java 字段名称（即以小写 — 开头的驼峰命名法<code>sampleFieldNameInJava</code>）转换为 Json 字段名称（即，<code>sample_field_name_in_java</code>or <code>SampleFieldNameInJava</code>）。有关预定义命名策略的信息，请参阅<a href="https://static.javadoc.io/com.google.code.gson/gson/2.8.5/com/google/gson/FieldNamingPolicy.html">FieldNamingPolicy</a>类。</p><p>It also has an annotation based strategy to allows clients to define custom names on a per field basis. Note, that the annotation based strategy has field name validation which will raise “Runtime” exceptions if an invalid field name is provided as the annotation value.</p><p>它还具有基于注释的策略，允许客户在每个字段的基础上定义自定义名称。请注意，基于注释的策略具有字段名称验证，如果提供无效的字段名称作为注释值，则会引发“运行时”异常。</p><p>The following is an example of how to use both Gson naming policy features:</p><p>以下是如何使用 Gson 命名策略功能的示例：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SomeObject</span> &#123;</span><br>  @<span class="hljs-built_in">SerializedName</span>(<span class="hljs-string">&quot;custom_naming&quot;</span>) <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">String</span> someField;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">String</span> someOtherField;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SomeObject</span><span class="hljs-params">(<span class="hljs-keyword">String</span> a, <span class="hljs-keyword">String</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.someField = a;<br>    <span class="hljs-keyword">this</span>.someOtherField = b;<br>  &#125;<br>&#125;<br><br>SomeObject someObject = <span class="hljs-keyword">new</span> <span class="hljs-built_in">SomeObject</span>(<span class="hljs-string">&quot;first&quot;</span>, <span class="hljs-string">&quot;second&quot;</span>);<br>Gson gson = <span class="hljs-keyword">new</span> <span class="hljs-built_in">GsonBuilder</span>().<span class="hljs-built_in">setFieldNamingPolicy</span>(FieldNamingPolicy.UPPER_CAMEL_CASE).<span class="hljs-built_in">create</span>();<br><span class="hljs-keyword">String</span> jsonRepresentation = gson.<span class="hljs-built_in">toJson</span>(someObject);<br>System.out.<span class="hljs-built_in">println</span>(jsonRepresentation);<br></code></pre></td></tr></table></figure><p>The output is:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<span class="hljs-attr">&quot;custom_naming&quot;</span>:<span class="hljs-string">&quot;first&quot;</span>,<span class="hljs-attr">&quot;SomeOtherField&quot;</span>:<span class="hljs-string">&quot;second&quot;</span>&#125;<br></code></pre></td></tr></table></figure><p>If you have a need for custom naming policy (<a href="https://groups.google.com/group/google-gson/browse_thread/thread/cb441a2d717f6892">see this discussion</a>), you can use the <a href="https://static.javadoc.io/com.google.code.gson/gson/2.8.5/com/google/gson/annotations/SerializedName.html">@SerializedName</a> annotation.</p><p>如果您需要自定义命名策略（<a href="https://groups.google.com/group/google-gson/browse_thread/thread/cb441a2d717f6892">请参阅此讨论</a>），您可以使用<a href="https://static.javadoc.io/com.google.code.gson/gson/2.8.5/com/google/gson/annotations/SerializedName.html">@SerializedName</a>注释。</p><h3 id="Sharing-State-Across-Custom-Serializers-and-Deserializers在自定义序列化器和反序列化器之间共享状态"><a href="#Sharing-State-Across-Custom-Serializers-and-Deserializers在自定义序列化器和反序列化器之间共享状态" class="headerlink" title="Sharing State Across Custom Serializers and Deserializers在自定义序列化器和反序列化器之间共享状态"></a>Sharing State Across Custom Serializers and Deserializers在自定义序列化器和反序列化器之间共享状态</h3><p>Sometimes you need to share state across custom serializers/deserializers (<a href="https://groups.google.com/group/google-gson/browse_thread/thread/2850010691ea09fb">see this discussion</a>). You can use the following three strategies to accomplish this:</p><p>有时您需要在自定义序列化器/反序列化器之间共享状态（<a href="https://groups.google.com/group/google-gson/browse_thread/thread/2850010691ea09fb">请参阅此讨论</a>）。您可以使用以下三种策略来完成此操作：</p><ol><li>Store shared state in static fields  -在静态字段中存储共享状态</li><li>Declare the serializer/deserializer as inner classes of a parent type, and use the instance fields of parent type to store shared state  -将序列化器/反序列化器声明为父类型的内部类，并使用父类型的实例字段来存储共享状态</li><li>Use Java <code>ThreadLocal</code>  -使用 Java <code>ThreadLocal</code></li></ol><p>1 and 2 are not thread-safe options, but 3 is.</p><p>1 和 2 不是线程安全选项，但 3 是。</p><h3 id="Streaming"><a href="#Streaming" class="headerlink" title="Streaming"></a>Streaming</h3><p>In addition Gson’s object model and data binding, you can use Gson to read from and write to a <a href="https://sites.google.com/site/gson/streaming">stream</a>. You can also combine streaming and object model access to get the best of both approaches.</p><p>除了 Gson 的对象模型和数据绑定之外，您还可以使用 Gson 读取和写入<a href="https://sites.google.com/site/gson/streaming">流</a>。您还可以结合流和对象模型访问来充分利用这两种方法。</p><h2 id="Issues-in-Designing-Gson"><a href="#Issues-in-Designing-Gson" class="headerlink" title="Issues in Designing Gson"></a>Issues in Designing Gson</h2><p>See the <a href="https://github.com/google/gson/blob/master/GsonDesignDocument.md">Gson design document</a> for a discussion of issues we faced while designing Gson. It also include a comparison of Gson with other Java libraries that can be used for Json conversion.</p><h2 id="Future-Enhancements-to-Gson"><a href="#Future-Enhancements-to-Gson" class="headerlink" title="Future Enhancements to Gson"></a>Future Enhancements to Gson</h2><p>For the latest list of proposed enhancements or if you’d like to suggest new ones, see the <a href="https://github.com/google/gson/issues">Issues section</a> under the project website.</p>]]></content>
    
    
    
    <tags>
      
      <tag>gson</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>idea配置java注解处理器</title>
    <link href="/posts/9097d82a/"/>
    <url>/posts/9097d82a/</url>
    
    <content type="html"><![CDATA[<h1 id="IntelliJ-IDEA-和-Gradle：为什么每个子模块有-3-个模块？"><a href="#IntelliJ-IDEA-和-Gradle：为什么每个子模块有-3-个模块？" class="headerlink" title="IntelliJ IDEA 和 Gradle：为什么每个子模块有 3 个模块？"></a><a href="https://stackoverflow.com/questions/36372571/intellij-idea-and-gradle-why-there-are-3-modules-per-sub-module">IntelliJ IDEA 和 Gradle：为什么每个子模块有 3 个模块？</a></h1><p>如果您只想为之前导入的项目禁用此选项，您可以通过编辑位于**.idea/gradle.xml 中的** idea gradle 配置文件来实现 。</p><p>添加将<strong>resolveModulePerSourceSet</strong>设置为<strong>false 的</strong>这一行：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;4&quot;</span>&gt;</span><br>  ...<br>  <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;GradleSettings&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;linkedExternalProjectsSettings&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">GradleProjectSettings</span>&gt;</span><br>        ...<br>        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;resolveModulePerSourceSet&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span> /&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">GradleProjectSettings</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后刷新gradle项目。</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>在idea+gradle的环境中使用annotation processor生成代码，但是代码生成在了build文件夹下的classes里，且程序无法引用生成的类，若强行使用则报错找不到类。</p><h2 id="第一步-配置idea"><a href="#第一步-配置idea" class="headerlink" title="第一步 配置idea"></a>第一步 配置idea</h2><p>file -&gt; settting -&gt; Build,Execution,Deployment -&gt; compiler -&gt; annotation processor 进入此界面，然后：</p><ol><li>勾上<code>启用注解处理器</code></li><li>选中<code>从项目类路径获取处理器</code></li><li>选中<code>模块项目根</code></li><li><code>生产源目录</code>输入<code>../main/src/generated/java</code></li></ol><h2 id="第二步-配置gradle"><a href="#第二步-配置gradle" class="headerlink" title="第二步 配置gradle"></a>第二步 配置gradle</h2><p>这个项目有三个module：</p><p>一个是main 测试ProcessorLib库</p><p>一个是ProcessorLib 处理注解</p><p>一个是AnnotationsLib 定义注解</p><ul><li>ProcessorLib 的gradle</li></ul><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">//使编译时将文件生成到指定目录</span><br>compileJava &#123;<br><span class="hljs-comment">//配置编译时生成代码的目录</span><br>        <span class="hljs-keyword">options</span>.compilerArgs &lt;&lt; <span class="hljs-string">&quot;-s&quot;</span><br>        <span class="hljs-keyword">options</span>.compilerArgs &lt;&lt; <span class="hljs-string">&quot;$projectDir/src/main/generated/java&quot;</span><br><span class="hljs-comment">//确保文件夹存在</span><br>        <span class="hljs-keyword">doFirst</span> &#123;<br>            <span class="hljs-keyword">file</span>(<span class="hljs-keyword">new</span> <span class="hljs-keyword">File</span>(projectDir, <span class="hljs-string">&quot;/src/main/generated/java&quot;</span>)).mkdirs()<br>        &#125;<br>    &#125;<br><span class="hljs-comment">//在clean时删除编译生成的代码</span><br>    clean.<span class="hljs-keyword">doLast</span> &#123;<br>        <span class="hljs-comment">// clean-up directory when necessary</span><br>        <span class="hljs-keyword">file</span>(<span class="hljs-keyword">new</span> <span class="hljs-keyword">File</span>(projectDir, <span class="hljs-string">&quot;/src/main/generated&quot;</span>)).deleteDir()<br>    &#125;<br><span class="hljs-comment">//依赖  </span><br><span class="hljs-keyword">dependencies</span> &#123;<br>    implementation <span class="hljs-keyword">project</span>(path: <span class="hljs-string">&#x27;:AnnotationsLib&#x27;</span>)<span class="hljs-comment">//自己的注解定义module</span><br>    implementation <span class="hljs-string">&#x27;com.google.auto.service:auto-service-annotations:1.0.1&#x27;</span><span class="hljs-comment">//autoservice</span><br>    annotationProcessor <span class="hljs-string">&#x27;com.google.auto.service:auto-service:1.0.1&#x27;</span><span class="hljs-comment">//autoservice</span><br>    implementation <span class="hljs-string">&#x27;com.squareup:javapoet:1.13.0&#x27;</span><br>    testImplementation <span class="hljs-string">&#x27;org.junit.jupiter:junit-jupiter-api:5.7.2&#x27;</span><br>    testRuntimeOnly <span class="hljs-string">&#x27;org.junit.jupiter:junit-jupiter-engine:5.7.2&#x27;</span><br>&#125;<br><br><span class="hljs-comment">//详细日志打印，没有调用处理器，可能是跳过了，直接进行编译了</span><br><span class="hljs-comment">// 参数可选，重点是 -verbose -XprintRounds -XprintProcessorInfo</span><br><span class="hljs-keyword">allprojects</span> &#123;<br>    gradle.projectsEvaluated &#123;<br>        tasks.withType(JavaCompile) &#123;<br>            <span class="hljs-keyword">options</span>.compilerArgs &lt;&lt; <span class="hljs-string">&quot;-Xlint&quot;</span> &lt;&lt; <span class="hljs-string">&quot;-verbose&quot;</span> &lt;&lt; <span class="hljs-string">&quot;-XprintRounds&quot;</span> &lt;&lt; <span class="hljs-string">&quot;-XprintProcessorInfo&quot;</span> &lt;&lt; <span class="hljs-string">&quot;-Xmaxerrs&quot;</span> &lt;&lt; <span class="hljs-string">&quot;100000&quot;</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在main module的gradle中</li></ul><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs puppet"><span class="hljs-keyword">dependencies</span> &#123;<br>    implementation <span class="hljs-literal">project</span>(<span class="hljs-built_in">path</span>: <span class="hljs-string">&#x27;:ProcessorLib&#x27;</span>)<br>    annotationProcessor <span class="hljs-literal">project</span>(<span class="hljs-built_in">path</span>: <span class="hljs-string">&#x27;:ProcessorLib&#x27;</span>)<br>    implementation <span class="hljs-literal">project</span>(<span class="hljs-built_in">path</span>: <span class="hljs-string">&#x27;:AnnotationsLib&#x27;</span>)<br>    testImplementation <span class="hljs-string">&#x27;org.junit.jupiter:junit-jupiter-api:5.7.2&#x27;</span><br>    testRuntimeOnly <span class="hljs-string">&#x27;org.junit.jupiter:junit-jupiter-engine:5.7.2&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第三步-配置文件夹类型"><a href="#第三步-配置文件夹类型" class="headerlink" title="第三步 配置文件夹类型"></a>第三步 配置文件夹类型</h2><p>在执行gradle的build任务后，会在src/main下生成指定目录以及代码，但是在我们的源文件中依然没有提示，那么我们需要指定其文件夹类型。</p><p>前面用gradle生成的目录：<code>src/main/generated/java</code></p><p>把这个目录右键，将目录标记为<code>“生成文件夹的根目录”</code>。</p><h1 id="需要注意的细节"><a href="#需要注意的细节" class="headerlink" title="需要注意的细节"></a>需要注意的细节</h1><ul><li>在编写自定义Processor可能会出现处理器不起作用的情况<br>答:其很有可能是你将Processor.class写成了Process.class</li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">//正确的写法</span><br><span class="hljs-variable">@AutoService</span>(Processor.class)<br><span class="hljs-comment">//错误的写法</span><br><span class="hljs-variable">@AutoService</span>(Process.class)<br></code></pre></td></tr></table></figure><p>即使是按照上面的步骤配置，但仍然无法引用生成的代码(删除线即当时认知错误，在第4点会讲原因)<br>答:可能是由于你生成代码的文件夹与你的源文件不在一个module中，由于idea中使用gradle创建一个module，他会识别为三个module。</p><p>两种解决方式：</p><p>1.开头部分。</p><p>2.在创建项目时取消 <code>create separate per source set</code> 。</p><ul><li>annotation processor 生成类时报异常:错误: <strong>类重复: com.cxyz.test.Test</strong><br>答:其实annotation processor只能生成额外的类，而不能在原先类的基础上做改动</li></ul><hr><p>写过自定义注解处理器的老司机们乍一看这个问题觉得挺简单，是的，因为网上基本通篇都在教你怎么打日志，但是你有没有想过如果连日志都打印不出来的时候你怎么定位呢？譬如如下代码：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 确认 META-INF/services/javax.annotation.processing.Processor 没问题</span><br><span class="hljs-comment">// 确认构建脚本没问题，确认注解 Bridge 有被使用且有参与构建</span><br><span class="hljs-meta">@AutoService</span>(Processor.class)<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestAnnotationProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractProcessor</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">TestAnnotationProcessor</span>(<span class="hljs-params"></span>)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;TestAnnotationProcessor constrator&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> synchronized <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">init</span>(<span class="hljs-params">ProcessingEnvironment processingEnvironment</span>)</span> &#123;<br>        <span class="hljs-built_in">super</span>.init(processingEnvironment);<br>        System.out.println(<span class="hljs-string">&quot;TestAnnotationProcessor init&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">Set</span>&lt;<span class="hljs-built_in">String</span>&gt; <span class="hljs-function"><span class="hljs-title">getSupportedAnnotationTypes</span>(<span class="hljs-params"></span>)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;TestAnnotationProcessor getSupportedAnnotationTypes&quot;</span>);<br>        <span class="hljs-built_in">Set</span>&lt;<span class="hljs-built_in">String</span>&gt; supported = <span class="hljs-keyword">new</span> HashSet&lt;<span class="hljs-built_in">String</span>&gt;();<br>        supported.add(Bridge.class.getCanonicalName());<br>        <span class="hljs-keyword">return</span> supported;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-function"><span class="hljs-title">process</span>(<span class="hljs-params"><span class="hljs-built_in">Set</span>&lt;? <span class="hljs-keyword">extends</span> TypeElement&gt; set, RoundEnvironment roundEnvironment</span>)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;TestAnnotationProcessor process&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行构建后compileReleaseJavaWithJavac过程中没有先吐我 Annotation Processor 的任意一行日志，直接报错找不到我注解处理器产物类引用（即直接进行了 compile class 环节）。</p><p>你懵逼吗？反正我懵逼了！打印日志不好使了，哈哈，环境确认没问题，什么鬼，直接越过 Annotation Processor 进行 compile 了。</p><p>这时候就需要你稍微深入定位分析（撸javac源码的巨佬请自行飘过），前提就是你需要熟悉下 Annotation Processor 基本原理，然后我们通过一些额外的javac详细日志进行举例分析。</p><p>Annotation Processor 机制<br>注解和注解处理器是 JDK5 引入的机制，主要用来为类、方法、字段和参数等 Java 结构提供额外的信息。譬如常见的@Override就是仅仅对 Java 编译器生效的一个注解。Java 允许我们自定义注解，自定义的注解处理器就是用来处理这些自定义注解的（废话），注解处理器触发时机是由javac来处理的，所以整个javac过程的简要步骤如下图：</p><p>![在这里插入图片描述](TyporaRaw/idea 注解处理器.assets/20210111193442602.png)</p><p>可以看到，javac编译概要图主要分为如下几步：</p><p>把源文件解析为抽象语法树。<br>调用已注册的注解处理器。<br>如果注解处理器处理过程中生成了新的源文件，编译器重复第 1、2 步，当注解处理器不再生成新的源文件则进入最后一轮。<br>进入真正的 compile 字节码环节生成字节码。<br>如上就是注解处理器的核心机制，有了这个核心机制的认识我们就继续往下探索。</p><p>构建工具下 Annotation Processor 的本质<br>我们日常开发中（无论是 Java 后端还是 Android 移动端）总是多多少少会用到 JDK 提供的annotation processor能力，无论是什么构建工具（Gradle 或者 Maven 等）本质都是通过javac -processorpath命令参数显式指定哪些 Processer，或者显式声明META-INF/services/javax.annotation.processing.Processor来被javac发现并调用的（参见 google 的 AutoService 框架）。</p><p>正常情况下我们开发中使用及构建 Annotation Processor 技术都是上面几步走的方案，而且大多数照着网络上抄的都能正常工作，每次只用自己处理 process 就挺香的，因为只要按照规则声明放置，其他的 javac都能自己完美调用。</p><p>增强 javac 过程打印暴露问题<br>要解决一开始说的 Annotation Processor 中自己加的日志都不打印场景问题，我们需要获取一些额外的信息辅助定位。由于直接使用命令行javac的方式是最原始的操作，我们构建一般采用 Gradle，而 Gradle 的本质还是调用javac，所以下面我们以 Gradle 为例来分析如何定位 Annotation Processor 问题。</p><p>下面简单粗暴点就是直接在根目录的build.gradle中给所有模块添加参数：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><br><span class="hljs-comment">// 参数可选，重点是 -verbose -XprintRounds -XprintProcessorInfo</span><br>allprojects &#123;<br>    gradle<span class="hljs-selector-class">.projectsEvaluated</span> &#123;<br>        tasks<span class="hljs-selector-class">.withType</span>(JavaCompile) &#123;<br>            options<span class="hljs-selector-class">.compilerArgs</span> &lt;&lt; <span class="hljs-string">&quot;-Xlint&quot;</span> &lt;&lt; <span class="hljs-string">&quot;-verbose&quot;</span> &lt;&lt; <span class="hljs-string">&quot;-XprintRounds&quot;</span> &lt;&lt; <span class="hljs-string">&quot;-XprintProcessorInfo&quot;</span> &lt;&lt; <span class="hljs-string">&quot;-Xmaxerrs&quot;</span> &lt;&lt; <span class="hljs-string">&quot;100000&quot;</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>你也可以仅仅在自己有注解处理器的模块中添加，与上面一样，只要加给JavaCompile的参数就行。这里的参数其实就是我们平时命令行javac是否的参数，不懂的可以去命令行执行下javac -help观摩下含义吧，如下（JDK8，不同版本 JDK 略有差异）：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">yan@yanDeMackbookPro:~$ javac -help<br>用法: javac &lt;options&gt; &lt;source files&gt;<br>其中, 可能的选项包括:<br>-g                         生成所有调试信息<br><span class="hljs-code">......</span><br><span class="hljs-code">-verbose                   输出有关编译器正在执行的操作的消息</span><br><span class="hljs-code">......</span><br>-processor &lt;class1&gt;[,&lt;class2&gt;,&lt;class3&gt;...] 要运行的注释处理程序的名称; 绕过默认的搜索进程<br>-processorpath &lt;路径&gt;        指定查找注释处理程序的位置<br>......<br></code></pre></td></tr></table></figure><p>至于脚本中其他几个在javac -help中没有的参数可以看下官方文档<a href="https://docs.oracle.com/en/java/javase/11/tools/javac.html">https://docs.oracle.com/en/java/javase/11/tools/javac.html</a> ，里面详细解释了参数含义。</p><p>添加上面参数后一定要将你的构建日志追加到一个磁盘文件中，因为日志会变得非常庞大，同时也变得很容易定位问题。</p><p>通过构建日志分析定位问题<br>执行你的构建任务，完毕后分析定位主要分为如下几个步骤，每一步都是一种场景的定位，循序渐进定位分析即可。</p><p>在你的日志中搜索你的 Processor 类名，譬如TestAnnotationProcessor.class，看到的日志会是如下。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 如果你的注解处理器在项目中是源码形式的日志<br>[loading RegularFileObject[<span class="hljs-regexp">/home/u</span>ser<span class="hljs-regexp">/yan/</span>test<span class="hljs-regexp">/target/</span>classes<span class="hljs-regexp">/cn/y</span>an<span class="hljs-regexp">/test/</span>TestAnnotationProcessor.class]]<br><br><span class="hljs-regexp">//</span> 如果你的注解处理器在项目中是依赖 jar 形式的日志<br>[loading ZipFileIndexFileObject[......<span class="hljs-regexp">/test.jar(cn/y</span>an<span class="hljs-regexp">/test/</span>TestAnnotationProcessor.class)]]<br></code></pre></td></tr></table></figure><p>分析： 如果你的日志中搜不到上面信息，说明你的注解处理器没有被添加到javac的 classpath 中。一般问题就是你的META-INF/services/javax.annotation.processing.Processor声明有问题，javac无法找到你的注解处理器。有些同学可能是通过 google 的 AutoService 来生成META-INF/services/javax.annotation.processing.Processor的，这种情况下也要自己检查是否 OK（譬如之前安卓中 AGP 有一段时间的中间过渡版本就修改了 classpath，需要手动将 compile 改成 annotationProcessor 才行）。</p><p>在你的日志中搜索Round关键字，建议直接搜Round 1:这样的格式容易点，看到的日志会是如下。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vim">Round <span class="hljs-number">1</span>:<br>        <span class="hljs-built_in">input</span> <span class="hljs-keyword">file</span><span class="hljs-variable">s:</span> &#123;<span class="hljs-keyword">cn</span>.yan.test.Application, ......, <span class="hljs-keyword">cn</span>.yan.test.UseMarkedAnnotation&#125;<br>                annotation<span class="hljs-variable">s:</span> [java.lang.Override, <span class="hljs-keyword">cn</span>.yan.annotation.Bridge]<br>                <span class="hljs-keyword">last</span> <span class="hljs-built_in">round</span>: false<br></code></pre></td></tr></table></figure><p>上面日志中的input files:部分是扫到的你的源码，annotations:部分就是扫到你代码中使用了哪些注解，如果你注解处理器声明了要处理这种注解（譬如@cn.yan.annotation.Bridge），则日志如上才是正常的。</p><p>分析： 如果你日志中没搜到上面的Round，则说明javac没有触发调用任何注解处理器（无论是你写的还是依赖三方框架的），最大的可疑点就是检查下自己有没有禁用javac注解处理器，也就是确认javac执行时没有-proc:none参数。如果你的日志中有Round，但是input files:和annotations:没有你的注解类和使用类，则说明你没有在代码中使用你注解处理器要处理的注解。</p><p>在你的日志中搜索Loaded cn.yan.test.TestAnnotationProcessor关键字，看到的日志会是如下。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">[Loaded cn.yan.test.TestAnnotationProcessor <span class="hljs-keyword">from</span> <span class="hljs-keyword">file</span>:<span class="hljs-regexp">/home/u</span>ser<span class="hljs-regexp">/yan/</span>test<span class="hljs-regexp">/target/</span>classes<span class="hljs-regexp">/cn/y</span>an<span class="hljs-regexp">/test/</span>TestAnnotationProcessor.<span class="hljs-keyword">class</span>]<br></code></pre></td></tr></table></figure><p>分析： 如果你看不到上面这行日志，说明你的注解处理器类自己没有被加载成功，为什么没有我也不知道怎么分析了，但是至少说明没加载成功，你可能需要仔细核对哪里不规范或者不合法导致的了。</p><p>上面都排查完了，如果还是找不到问题原因，不妨换个思路，去仔细检查下你参与构建的普通 java 文件，是否存在语法错误或者什么问题（譬如常量没声明等）；如果有，解决完了再试试，别问我为什么，我也没有深入研究javac这块源码，只是我遇到过，且也没有异常堆栈信息，最终发现是合并解决冲突后代码少了一个变量声明，就是单纯的越过了 Annotation Processor 过程直接进行 compile to class 流程了）。<br>这个技能有什么鸟用？<br>不瞒你说，我也算是老司机了，好些年前 Annotation Processor 就玩的很 6 了，但是最近项目升级构建和 Java8 及 androidX 支持后 merge 了下代码，然后项目中的注解处理器、dataBinding 全部都不工作了，更可气的是，这个不工作是真的很吝啬，什么错误堆栈都没有，大致如下奇葩构建日志：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">FAILURE: Build failed <span class="hljs-keyword">with</span> an <span class="hljs-keyword">exception</span>.<span class="hljs-operator"></span><br><span class="hljs-operator"></span><br><span class="hljs-operator">* </span>What went wrong:<br>Execution failed <span class="hljs-keyword">for</span> task &#x27;:test:compileReleaseJavaWithJavac&#x27;.<br><span class="hljs-comment">// 本来这里该先吐我注解处理器内部的日志，然后才继续 javac 编译，实际什么都没吐</span><br>&gt; Compilation failed; see the compiler error output <span class="hljs-keyword">for</span> details.<span class="hljs-operator"></span><br><span class="hljs-operator">* </span>Exception is:<br>org.gradle.api.tasks.TaskExecutionException: Execution failed <span class="hljs-keyword">for</span> task &#x27;:moffice:compileReleaseJavaWithJavac&#x27;.<br>at org.gradle.api.internal.tasks.execution.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ExecuteActionsTaskExecuter</span>.</span></span>lambda<span class="hljs-constructor">$executeIfValid$1(ExecuteActionsTaskExecuter.<span class="hljs-params">java</span>:200)</span><br>......<br>Caused by: org.gradle.api.internal.tasks.compile.CompilationFailedException: Compilation failed; see the compiler error output <span class="hljs-keyword">for</span> details.<br>at org.gradle.api.internal.tasks.compile.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JdkJavaCompiler</span>.</span></span>execute(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JdkJavaCompiler</span>.</span></span>java:<span class="hljs-number">57</span>)<br><br></code></pre></td></tr></table></figure><p>Gradle 构建命令已经添加了各种详细参数供查看堆栈和详细日志，但奇妙的事情就是他走到compileReleaseJavaWithJavac就直接出错了，前后没有任何错误提示（有的只是一坨 Gradle 自己的 task 调用链）。我特么大意了，我就同步了下代码，编不过就编不过啊，你倒是提示下问题啊！啥也不提示直接干到 compile class 环节了，跳过了 Annotation Processor 流程，这就很恼火了。好在按照上面方式定位修复了，哈哈。</p><hr><p><a href="https://blog.csdn.net/qq_40985294/article/details/90041296#t4">引用</a></p><p><a href="https://blog.csdn.net/yanbober/article/details/112487959">引用</a></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>注解</tag>
      
      <tag>idea</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Manjaro文档</title>
    <link href="/posts/e1aff6f4/"/>
    <url>/posts/e1aff6f4/</url>
    
    <content type="html"><![CDATA[<h1 id="更换国内源（可以在软件商店设置里修改）"><a href="#更换国内源（可以在软件商店设置里修改）" class="headerlink" title="更换国内源（可以在软件商店设置里修改）"></a>更换国内源（可以在软件商店设置里修改）</h1><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">sudo pacman-mirrors -<span class="hljs-selector-tag">i</span> -c China -m rank<br></code></pre></td></tr></table></figure><h1 id="fcitx5"><a href="#fcitx5" class="headerlink" title="fcitx5"></a>fcitx5</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> pacman -S fcitx<span class="hljs-number">5</span>-im fcitx<span class="hljs-number">5</span>-chinese-addons<br></code></pre></td></tr></table></figure><ul><li><p>其他一些软件包</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">fcitx5:</span> <span class="hljs-string">输入法基础框架主程序</span><br>   <span class="hljs-attr">fcitx5-chinese-addons:</span> <span class="hljs-string">简体中文输入的支持，云拼音</span><br>   <span class="hljs-attr">fcitx5-gtk:</span> <span class="hljs-string">GTK程序的支持</span><br>   <span class="hljs-attr">fcitx5-qt:</span> <span class="hljs-string">QT5程序的支持</span><br>   <span class="hljs-attr">fcitx5-pinyin-zhwiki:</span> <span class="hljs-string">肥猫制作的维基百万词库，没有版权风险,</span> <span class="hljs-string">放心使用</span><br>   <span class="hljs-attr">fcitx5-configtool:</span> <span class="hljs-string">图形化配置工具</span><br>   <span class="hljs-attr">kcm-fcitx5:</span> <span class="hljs-string">KDE桌面环境的支持</span><br></code></pre></td></tr></table></figure></li></ul><p>打开系统设置在 设置–区域设置—输入法—添加输入法—拼音—配置—-在程序中显示与编辑文本——启用云拼音 返回 配置附加组件 Classic User Interface 选择主题</p><p>配置fcitx5的环境变量：</p><p> <strong>不要在 fcitx 运行时修改, 因为进程退出后会覆写所有配置文件 (大字才能醒目)</strong></p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">nano ~<span class="hljs-string">/.pam_environment</span><br></code></pre></td></tr></table></figure><p>写入以下内容（内容来自manjaro的wiki）</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">GTK_IM_MODULE <span class="hljs-attribute">DEFAULT</span>=fcitx<br>QT_IM_MODULE  <span class="hljs-attribute">DEFAULT</span>=fcitx<br>XMODIFIERS    <span class="hljs-attribute">DEFAULT</span>=\@im=fcitx<br>SDL_IM_MODULE <span class="hljs-attribute">DEFAULT</span>=fcitx<br>最后那行 SDL_IM_MODULE 是为了让一些使用特定版本 SDL2 库的游戏，比如 Dota2 能正常使用输入法。 <br></code></pre></td></tr></table></figure><p>使用wps的用户还需要编辑~/.xprofile添加以下内容（在新版中bug被修复了，但是如果有问题的话，可以尝试此方法）</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">QT_IM_MODULE</span>=fcitx5<br></code></pre></td></tr></table></figure><p>自启动<br>在设置的开机里设置fcitx5自启动</p><p>输入法的默认设置：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dos">Ctrl + Space 激活输入法<br>左<span class="hljs-built_in">Shift</span> 临时切换到英文<br>Ctrl + <span class="hljs-built_in">Shift</span> 输入法间切换<br>-/= 向前/向后翻页<br><span class="hljs-built_in">Shift</span> + Space 全角、半角切换<br></code></pre></td></tr></table></figure><h2 id="全自动配置"><a href="#全自动配置" class="headerlink" title="全自动配置"></a>全自动配置</h2><p>manjaro的源里的<code>manjaro-asian-input-support</code></p><h2 id="fcitx5主题文件"><a href="#fcitx5主题文件" class="headerlink" title="fcitx5主题文件"></a>fcitx5主题文件</h2><h3 id="fcitx5-material-color-主题"><a href="#fcitx5-material-color-主题" class="headerlink" title="fcitx5-material-color 主题"></a>fcitx5-material-color 主题</h3><ul><li>安装</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">yay</span> -S fcitx<span class="hljs-number">5</span>-material-color<br></code></pre></td></tr></table></figure><p>然后修改配置文件 ~/.config/fcitx5/conf/classicui.conf</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 横向候选列表</span><br>Vertical Candidate <span class="hljs-attribute">List</span>=<span class="hljs-literal">False</span><br><br><span class="hljs-comment"># 禁止字体随着DPI缩放，避免界面太大</span><br><span class="hljs-attribute">PerScreenDPI</span>=<span class="hljs-literal">False</span><br><br><span class="hljs-comment"># 字体和大小，可以用 fc-list 命令来查看使用</span><br><span class="hljs-attribute">Font</span>=<span class="hljs-string">&quot;Noto Sans Mono 13&quot;</span><br><br><span class="hljs-comment"># 默认蓝色主题</span><br><span class="hljs-attribute">Theme</span>=Material-Color-Blue<br></code></pre></td></tr></table></figure><h1 id="pacman常用命令"><a href="#pacman常用命令" class="headerlink" title="pacman常用命令"></a>pacman常用命令</h1><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs applescript">pacman -Ss <span class="hljs-built_in">string</span>             <span class="hljs-comment"># 在包数据库中查询软件</span><br>pacman -S package_name        <span class="hljs-comment"># 安装软件</span><br><br>pacman -S extra/package_name  <span class="hljs-comment"># 安装不同仓库中的版本</span><br>pacman -Syu                   <span class="hljs-comment"># 升级整个系统，y是更新数据库，yy是强制更新，u是升级软件</span><br>pacman -Si package_name       <span class="hljs-comment"># 显示软件的详细信息</span><br>pacman -Sc                    <span class="hljs-comment"># 清除软件缓存，即/var/cache/pacman/pkg目录下的文件</span><br>pacman -R package_name        <span class="hljs-comment"># 删除单个软件</span><br>pacman -Rs package_name       <span class="hljs-comment"># 删除指定软件及其没有被其他已安装软件使用的依赖关系</span><br>pacman -Qs <span class="hljs-built_in">string</span>             <span class="hljs-comment"># 查询已安装的软件包</span><br>pacman -Qi package_name       <span class="hljs-comment"># 查询本地安装包的详细信息</span><br>pacman -Ql package_name       <span class="hljs-comment"># 获取已安装软件所包含的文件的列表</span><br>pacman -U package.tar.zx      <span class="hljs-comment"># 从本地文件安装</span><br>pactree package_name          <span class="hljs-comment"># 显示软件的依赖树</span><br></code></pre></td></tr></table></figure><h1 id="manjaro的pamac命令"><a href="#manjaro的pamac命令" class="headerlink" title="manjaro的pamac命令"></a>manjaro的pamac命令</h1><p>他是软件商店的命令版本，也是manjaro自己的包管理命令。类似于ubuntu的apt命令。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs applescript">pamac search <span class="hljs-built_in">name</span> <span class="hljs-comment">#搜索</span><br>pamac info <span class="hljs-built_in">name</span>  <span class="hljs-comment">#详细信息</span><br>pamac install <span class="hljs-built_in">name</span> <span class="hljs-comment">#安装软件</span><br>pamac remove <span class="hljs-built_in">name</span> <span class="hljs-comment">#卸载软件</span><br>pamac checkupdates <span class="hljs-comment">#检查更新</span><br>pamac upgrade <span class="hljs-comment">#安装更新</span><br></code></pre></td></tr></table></figure><h1 id="改善火狐或chrome滚动"><a href="#改善火狐或chrome滚动" class="headerlink" title="改善火狐或chrome滚动"></a>改善火狐或chrome滚动</h1><ul><li>在火狐中搜索<code> Yet Another Smooth Scrolling WE</code>扩展</li><li>chrome中搜索<code>Chromium Wheel Smooth Scroller</code>扩展</li></ul><p>或者</p><ul><li><p>输入在火狐浏览器地址栏输入</p><p>about:config<br>搜索mousewheel<br>其中<code> mousewheel.defalut.delta_multiplier_y</code>越大，每次滚动一下<br>滚轮，屏幕就滑动地越大。<br>除此之外，推测<code>durationMaxMs和durationMinMs</code>参数是<br>完成滚动的时间间隔，以毫秒计算，数值越小，单次滚动越快。factor<br>和鼠标滚轮滚动时，屏幕滚动的加速度有关。</p></li></ul><h1 id="设置界面缩放"><a href="#设置界面缩放" class="headerlink" title="设置界面缩放"></a>设置界面缩放</h1><pre><code>高分屏缩放，比如netease-cloud-music软件：可以通过 env QT_SCREEN_SCALE_FACTORS=1.25 netease-cloud-music 启动来解决,也就是在启动文件里添加。</code></pre><h1 id="设置快捷键启动的方式："><a href="#设置快捷键启动的方式：" class="headerlink" title="设置快捷键启动的方式："></a>设置快捷键启动的方式：</h1><p>设置 -&gt; 快捷键 -&gt; 自定义快捷键 -&gt; 编辑 -&gt; 新建 -&gt; 全局快捷键 -&gt; 命令/URL</p><p>设置触发器：设置为你习惯的快捷键 -&gt; 动作：命令/URL这填：/usr/bin/flameshot gui</p><h1 id="网络启停"><a href="#网络启停" class="headerlink" title="网络启停"></a>网络启停</h1><p>开机后显示wifi不可用，鼠标放在网络图标上显示<code>Networkmanager未运行</code>，解决方法是在终端执行以下命令</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">systemctl restart <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">NetworkManager</span>.</span></span>service<br>systemctl enable <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">NetworkManager</span>.</span></span>service<br></code></pre></td></tr></table></figure><hr><h1 id="ZSH"><a href="#ZSH" class="headerlink" title="ZSH"></a>ZSH</h1><ul><li><strong>替换shell</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">yay -Sy zsh  #安装zsh  manjaro现在默认就已经安装了zsh<br>chsh -l  #列出现在安装的shell<br>chsh -s /bin/zsh # 设置zsh为默认  重启生效<br></code></pre></td></tr></table></figure><ul><li><strong>备注</strong>： <strong>manjaro已经内置zsh,直接在kde设置里修改即可，ohmyzsh在manjaro也内置了，所以如果自己想折腾，可以直接去github把ohmyzsh克隆到任意位置使用。</strong></li></ul><h2 id="PART-1-→-oh-my-zsh"><a href="#PART-1-→-oh-my-zsh" class="headerlink" title="PART 1 → oh-my-zsh"></a>PART 1 → oh-my-zsh</h2><p>默认的 Zsh 配置有点麻烦。因此一个叫 robbyrussel 的用户在 GitHub 上制作了一个配置文件 oh-my-zsh，这是目前为止最流行的 Zsh 配置：</p><p><a href="https://link.zhihu.com/?target=https://github.com/robbyrussell/oh-my-zsh">oh-my-zsh 项目地址（不要吝啬你的 Star）</a></p><p>如果你不想看官方的安装说明，请看这里：</p><p><strong>第一步 → 把 oh-my-zsh 项目 Clone 下来：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh<br></code></pre></td></tr></table></figure><p><strong>第二步 → 复制 .zshrc</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc<br></code></pre></td></tr></table></figure><p><strong>第三步 → 更改你的默认 Shell</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">chsh -s /bin/zsh<br></code></pre></td></tr></table></figure><p>现在，你会看到你的命令提示符变了。</p><p>zsh的配置文件存在当前用户目录中的.zshrc文件，如果你发现切换了shell之后，以前的配置的环境变量不生效了，可以打开 .zshrc文件，找到：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># User configuration</span><br><span class="hljs-built_in">source</span> ~/.bash_profile<br></code></pre></td></tr></table></figure><p>指定配置的环境变量文件，之后运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> .zshrc<br></code></pre></td></tr></table></figure><p>前往 <a href="https://link.zhihu.com/?target=https://github.com/robbyrussell/oh-my-zsh/wiki/Themes">oh-my-zsh 的 Wiki</a> 就可以看到大多数 oh-my-zsh 的内置主题以及它们的截图。如果你看中的其中的一款，可以重复上面的步骤，编辑~/.zshrc，并更改ZSH_THEME=”xxx”。</p><p>比如你看中了 ys 主题（我的最爱），你可以把 ZSH_THEME 改成 “ys”，然后回到终端，执行 source ~/.zshrc 命令。</p><p>P.S. 这些主题都保存在 “~/.oh-my-zsh/themes” 目录中</p><ul><li><h1 id="powerlevel10k主题"><a href="#powerlevel10k主题" class="headerlink" title="powerlevel10k主题"></a>powerlevel10k主题</h1><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-number">1</span>. 安装 <br>git clone --depth=<span class="hljs-number">1</span> https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/romkatv/</span>powerlevel10k.git <span class="hljs-variable">$&#123;ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom&#125;</span><span class="hljs-regexp">/themes/</span>powerlevel10k<br><span class="hljs-number">2</span>. 傻瓜式配置 终端中输入 p10k configure<br></code></pre></td></tr></table></figure><ul><li>安装完 powerlevel10k 后你可能会发现有乱码，这是因为你终端字体不支持那么多的字符，这就需要使用扩展字体了。</li></ul></li></ul><h2 id="PART-3-→-插件"><a href="#PART-3-→-插件" class="headerlink" title="PART 3 → 插件"></a>PART 3 → 插件</h2><pre><code>oh-my-zsh 的自带插件都储存在 &quot;~/.oh-my-zsh/plugins&quot; 目录中，如果你希望安装一个插件，可以在 &quot;~/.zshrc&quot; 的 plugins=(xxx, xxx, ...) 这一行里加入插件名称如果你需要安装第三方插件和主题，你可以在 &quot;~/.zshrc&quot; 的某一行（比如末尾）加入 source /path/to/plugin比如你希望添加一个 zsh-syntax-highlighting 插件 ↓</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> ~/.zsh-syntax-highlighting/zsh-syntax-highlighting.zsh<br><span class="hljs-comment"># 这里要根据你自己的输入目录，而不是抄我的，否则然并卵</span><br></code></pre></td></tr></table></figure><p>​    kde主题文件位置</p><p>要么在根目录的usr目录下，要么就在home的.config目录下。</p><p>要删除主题，先把当前使用的主题换成默认的主题，然后根据下面的目录删除即可。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs awk">  AURORAE_DIR=<span class="hljs-string">&quot;/usr/share/aurorae/themes&quot;</span><br>  SCHEMES_DIR=<span class="hljs-string">&quot;/usr/share/color-schemes&quot;</span><br>  PLASMA_DIR=<span class="hljs-string">&quot;/usr/share/plasma/desktoptheme&quot;</span><br>  LOOKFEEL_DIR=<span class="hljs-string">&quot;/usr/share/plasma/look-and-feel&quot;</span><br>  KVANTUM_DIR=<span class="hljs-string">&quot;/usr/share/Kvantum&quot;</span><br>  WALLPAPER_DIR=<span class="hljs-string">&quot;/usr/share/wallpapers&quot;</span><br>或者<br>  AURORAE_DIR=<span class="hljs-string">&quot;$HOME/.local/share/aurorae/themes&quot;</span><br>  SCHEMES_DIR=<span class="hljs-string">&quot;$HOME/.local/share/color-schemes&quot;</span><br>  PLASMA_DIR=<span class="hljs-string">&quot;$HOME/.local/share/plasma/desktoptheme&quot;</span><br>  LOOKFEEL_DIR=<span class="hljs-string">&quot;$HOME/.local/share/plasma/look-and-feel&quot;</span><br>  KVANTUM_DIR=<span class="hljs-string">&quot;$HOME/.config/Kvantum&quot;</span><br>  WALLPAPER_DIR=<span class="hljs-string">&quot;$HOME/.local/share/wallpapers&quot;</span> <br><br>注：<br><span class="hljs-regexp">/home/</span>hzt<span class="hljs-regexp">/.local/</span>share<span class="hljs-regexp">/plasma/</span>desktoptheme 这是存放plasma主题<br><span class="hljs-regexp">/home/</span>hzt<span class="hljs-regexp">/.local/</span>share<span class="hljs-regexp">/plasma/</span>look-and-feel/ 存放全局主题<br><span class="hljs-regexp">/home/</span>hzt<span class="hljs-regexp">/.local/</span>share<span class="hljs-regexp">/plasma/</span>plasmoids/ 存放插件<br><span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/sddm/</span> sddm主题位置<br></code></pre></td></tr></table></figure><hr><h2 id="重启桌面"><a href="#重启桌面" class="headerlink" title="重启桌面"></a>重启桌面</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">kquitapp5 plasmashell    <span class="hljs-comment"># 退出kde桌面</span><br>kstart5 plasmashell<br></code></pre></td></tr></table></figure><h1 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h1><h2 id="ctrl-f2进入tty，中文显示为方块"><a href="#ctrl-f2进入tty，中文显示为方块" class="headerlink" title="ctrl+f2进入tty，中文显示为方块"></a>ctrl+f2进入tty，中文显示为方块</h2><p>解决方法：安装fbterm</p><h2 id="错误：-Cannot-find-the-fakeroot-binary-gt-错误：-Cannot-find-the-strip-binary"><a href="#错误：-Cannot-find-the-fakeroot-binary-gt-错误：-Cannot-find-the-strip-binary" class="headerlink" title="错误： Cannot find the fakeroot binary. ==&gt; 错误： Cannot find the strip binary"></a>错误： Cannot find the fakeroot binary. ==&gt; 错误： Cannot find the strip binary</h2><p>解决方法：因为没安装 fakeroot、binutils 等打包基本工具，所以<code>sudo pacman -S --needed base-devel</code> 装一下。</p><hr><h2 id="使用数位板"><a href="#使用数位板" class="headerlink" title="使用数位板"></a>使用数位板</h2><p>1.查看系统信息中的内核版本，根据内核版本安装linux-header</p><p>2.安装aur源中的驱动：yay -S digimend-drivers-git-dkms  </p><hr><h2 id="关闭watchdog"><a href="#关闭watchdog" class="headerlink" title="关闭watchdog"></a>关闭watchdog</h2><p>根据 <a href="https://en.wikipedia.org/wiki/Watchdog_timer">维基百科：看门狗定时器 </a>： </p><p>由于系统的关键任务（即服务器）或缺少电源重置（即嵌入式设备），许多用户需要此功能。  因此，在某些情况下，此功能是良好操作所必需的。  另一方面，普通用户（例如台式机和笔记本电脑）不需要此功能，可以将其禁用。 </p><p>要禁用看门狗定时器（包括软件和硬件），请附加  <code>nowatchdog</code> 到您的启动参数。 </p><p>要检查新配置，请执行以下操作： </p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"># cat <span class="hljs-regexp">/proc/</span>sys<span class="hljs-regexp">/kernel/</span>watchdog<br></code></pre></td></tr></table></figure><p>或使用： </p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># wdctl</span><br></code></pre></td></tr></table></figure><ul><li><p>附加启动参数到grub</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs gradle">如果要禁用watchdog，需要在内核启动选项里面添加一个参数：<br><br>nowatchdog<br><br>添加的方法是修改 <span class="hljs-regexp">/etc/</span><span class="hljs-keyword">default</span>/grub 文件加上这个参数（用什么编辑器都可以，只要有root权限修改）<br><br>sudo nano <span class="hljs-regexp">/etc/</span><span class="hljs-keyword">default</span>/grub<br><br>找到其中包含 GRUB_CMDLINE_LINUX_DEFAULT 的一行，等号后面的字符串里面加个空格，加上nowatchdog就行了，比如：<br><br>本来是<br><br>GRUB_CMDLINE_LINUX_DEFAULT=<span class="hljs-string">&quot;quiet splash foo=bar&quot;</span><br><br>改成<br><br>GRUB_CMDLINE_LINUX_DEFAULT=<span class="hljs-string">&quot;quiet splash foo=bar nowatchdog&quot;</span><br><br>修改完毕之后<br>在终端中调用 update-grub<br><br></code></pre></td></tr></table></figure></li></ul><p>禁用看门狗后，您也可以 <em>选择</em> 避免加载负责硬件看门狗的模块。 通过 <a href="https://wiki.archlinux.org/index.php/Blacklisting">列入黑名单 </a>将相关模块 ，例如 <code>iTCO_wdt</code>. </p><p><strong>注意：</strong> 一些用户 <a href="https://bbs.archlinux.org/viewtopic.php?id=221239">报告 </a>了 <code>nowatchdog</code> 参数不能按预期工作，但是他们已通过将上述模块列入黑名单而成功禁用了看门狗（至少是硬件之一）。 </p><p>这两种操作都会加快启动和关闭的速度，因为只加载了一个模块。 另外，禁用看门狗定时器可以提高性能并 <a href="https://wiki.archlinux.org/index.php/Power_management#Disabling_NMI_watchdog">降低功耗 </a>。 </p><p>有关 请参见 [<a href="https://bbs.archlinux.org/viewtopic.php?id=163768">3] </a>， ， [<a href="https://bbs.archlinux.org/viewtopic.php?id=165834">4] </a>， [<a href="http://0pointer.de/blog/projects/watchdog.html">5] </a>和 [<a href="https://www.kernel.org/doc/html/latest/watchdog/watchdog-parameters.html">6] </a>更多信息 。 </p><h3 id="将硬件列入黑名单"><a href="#将硬件列入黑名单" class="headerlink" title="将硬件列入黑名单"></a>将硬件列入黑名单</h3><p>在内核模块的上下文中，黑名单是一种防止内核模块加载的机制。  例如，如果不需要关联的硬件，或者如果加载该模块会导致问题，这可能会很有用：例如，可能有两个内核模块试图控制同一硬件，然后将它们一起加载会导致冲突。 </p><p>有些模块作为 <a href="https://wiki.archlinux.org/index.php/Initramfs">initramfs</a> 的一部分装入。</p><p><code>mkinitcpio -M</code> 会显示所有自动检测到到模块：要阻止 initramfs 装入某些模块，可以在 <code>/etc/modprobe.d</code>中将它们加入黑名单。并应在映像生成过程中通过<code>modconf</code>挂钩将其添加。 </p><p>运行 <code>mkinitcpio -v</code> 会显示各种钩子(例如 filesystem 钩子, SCSI 钩子等)装入的模块。如果您的<code>HOOKS</code> 数组中没有 <code>modconf</code> 钩子（例如，和默认配置不同）则请将该”.conf”文件添加到<code>/etc/mkinitcpio.conf</code>中的FILES数组中。一旦您将其列入黑名单，请重新生成 <a href="https://wiki.archlinux.org/index.php/Initramfs">initramfs</a>，然后重新启动。 </p><h4 id="使用-etc-modprobe-d-中的文件"><a href="#使用-etc-modprobe-d-中的文件" class="headerlink" title="使用/etc/modprobe.d/中的文件"></a>使用/etc/modprobe.d/中的文件</h4><p>在 <code>/etc/modprobe.d/</code> 中创建 <code>.conf</code> 文件，使用 <code>blacklist</code> 关键字屏蔽不需要的模块，例如如果不想装入 <code>pcspkr</code> 模块：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/etc/m</span>odprobe.d/nobeep.conf<br><span class="hljs-comment"># Do not load the &#x27;pcspkr&#x27; module on boot.</span><br>blacklist pcspkr<br></code></pre></td></tr></table></figure><p><strong>注：</strong> 该 <code>blacklist</code> 该命令会将一个模块列入黑名单，因此不会自动加载该模块，但是如果另一个未列入黑名单的模块依赖该模块或手动加载该模块，则可能会加载该模块。 </p><p>要避免这个行为，可以让 modprobe 使用自定义的 <code>install</code> 命令，而不是像往常一样将模块插入内核，因此您可以通过以下方式强制模块始终无法加载：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-regexp">/etc/m</span>odprobe.d/blacklist.conf<br>...<br>install MODULE <span class="hljs-regexp">/bin/</span><span class="hljs-keyword">true</span><br>...<br></code></pre></td></tr></table></figure><p>这样就可以 “屏蔽” 模块及所有依赖它的模块。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">也就是在<span class="hljs-regexp">/etc/m</span>odprobe.d我创建watchdog.conf文件，写入下面两行<br>blacklist iTCO_wdt <br>blacklist iTCO_vendor_support<br></code></pre></td></tr></table></figure><h2 id="停用-watchdog"><a href="#停用-watchdog" class="headerlink" title="停用 watchdog"></a>停用 watchdog</h2><p>关机时提示：watchdog: watchdog0: watchdog did not stop! 在台式机和笔记本上安装 Manjaro 时可以停用 watchdog 模块<br><a href="https://wiki.archlinux.org/index.php/Improving_performance#Watchdogs">提高性能#Watchdogs </a></p><blockquote><p>许多用户由于其系统的关键任务角色（即服务器）或缺乏电源重置（即嵌入式设备）而需要此功能。  因此，在某些情况下，良好的操作需要此功能。  另一方面，普通用户（即台式机和笔记本电脑）不需要此功能，可以禁用它。 </p></blockquote><p>按照 archlinux wiki 上的方法，在启动参数中添加  <code>nowatchdog</code> 不能停用 watchdog </p><blockquote><p>注意：一些用户报告 nowatchdog 参数没有按预期工作，但他们通过将上述模块列入黑名单，成功禁用了看门狗（至少是硬件）。 </p></blockquote><p>另一种方法是在内核启动参数中添加  <code>modprobe.blacklist=iTCO_wdt</code> 来禁用  <code>watchdog</code> 模块。<br>编辑  <code>/etc/default/grub</code> 在  <code>GRUB_CMDLINE_LINUX_DEFAULT</code> 后添加  <code>modprobe.blacklist=iTCO_wdt</code> 保存退出后执行  <code>sudo update-grub</code> 来应用配置。   </p><blockquote><p>编辑 <code>/etc/default/grub</code>并附加 <code>modprobe.blacklist=iTCO_wdt</code>到 <code>GRUB_CMDLINE_LINUX_DEFAULT</code>线 </p></blockquote><p><a href="https://wiki.archlinux.org/index.php/Kernel_parameters#GRUB">内核参数#GRUB </a><br><a href="https://bbs.archlinux.org/viewtopic.php?id=221239">静音关机。  看门狗：看门狗0：看门狗没有停止！ </a></p><h2 id="开关机显示-dev-nvme0n1p5-clean-…-files-…blocks"><a href="#开关机显示-dev-nvme0n1p5-clean-…-files-…blocks" class="headerlink" title="开关机显示/dev/nvme0n1p5: clean, … files, …blocks"></a>开关机显示/dev/nvme0n1p5: clean, … files, …blocks</h2><p>1.在论坛里有提及这个问题</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">这两条命令显示一些日志信息<br><span class="hljs-keyword">journalctl </span>-<span class="hljs-keyword">b </span>-g nvme0n1p <br><span class="hljs-keyword">journalctl </span>-<span class="hljs-keyword">b </span>-u <span class="hljs-string">&#x27;systemd-fsck*&#x27;</span><br></code></pre></td></tr></table></figure><p>2.实际上根据</p><p>得到结论：系统在检查硬盘有没有问题，显示<code>/dev/nvme0n1p5: clean</code>就表示没有问题，所以没必要理会这条信息</p><h2 id="调整swap分区使用率"><a href="#调整swap分区使用率" class="headerlink" title="调整swap分区使用率"></a>调整swap分区使用率</h2><p>在内核版本为5.8之前，swappiness范围在0-100，内核大于5.8，范围是0-200。</p><p>总的说来，swappiness值越小，越尽可能的使用内存而不是交换分区。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sysctl</span> -q vm.swappiness 显示当前设置<br><span class="hljs-attribute">sudo</span> sysctl -w vm.swappiness=<span class="hljs-number">10</span> 临时设置为<span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>To set the swappiness value permanently, create a <a href="https://man.archlinux.org/man/sysctl.d.5">sysctl.d(5)</a> configuration file. For example:</p><p>永久的调整该设置，创建下面的配置文件</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/etc/</span>sysctl.d/<span class="hljs-number">99</span>-swappiness.conf<br>vm.swappiness=<span class="hljs-number">10</span>                              <br></code></pre></td></tr></table></figure><h2 id="failed-to-start-pkgfile-database-update"><a href="#failed-to-start-pkgfile-database-update" class="headerlink" title="failed to start pkgfile database update"></a>failed to start pkgfile database update</h2><p>查看<code>pkgfile-update.service</code>和<code>pkgfile-update.timer</code>，我猜测这个任务会每天相隔6小时执行，开机和关机时会因为错过任务而补偿执行，但是开机和关机时没有网络，所以执行失败。在系统设置面板的systemed里找到并修改<code>pkgfile-update.timer</code>，修改为开机后15分钟执行，相隔1天重复执行，就不会看到错误信息了。<br> 这是修改后的<code>pkgfile-update.timer</code>文件。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Unit]</span><br><span class="hljs-attr">Description</span>=pkgfile database update timer<br><br><span class="hljs-section">[Timer]</span><br><span class="hljs-attr">OnBootSec</span>=<span class="hljs-number">15</span>min<br><span class="hljs-attr">OnUnitActiveSec</span>=<span class="hljs-number">1</span>d<br><span class="hljs-attr">Persistent</span>=<span class="hljs-literal">no</span><br><br><span class="hljs-section">[Install]</span><br><span class="hljs-attr">WantedBy</span>=multi-user.target<br></code></pre></td></tr></table></figure><h2 id="软件源里没有grub-customer"><a href="#软件源里没有grub-customer" class="headerlink" title="软件源里没有grub-customer"></a>软件源里没有grub-customer</h2><p>去官网下载</p><h1 id="释放内存"><a href="#释放内存" class="headerlink" title="释放内存"></a>释放内存</h1><p>Kernels 2.6.16  and newer provide a mechanism to have the kernel drop the page cache  and/or inode and dentry caches on command, which can help free up a lot  of memory.  Now you can throw away that script that allocated a ton of  memory just to get rid of the cache… </p><p>To use <code>/proc/sys/vm/drop_caches</code>, just echo a number to it. </p><p>To free pagecache: </p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"># echo <span class="hljs-number">1</span> &gt; <span class="hljs-regexp">/proc/</span>sys<span class="hljs-regexp">/vm/</span>drop_caches<br></code></pre></td></tr></table></figure><p>To free dentries and inodes: </p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"># echo <span class="hljs-number">2</span> &gt; <span class="hljs-regexp">/proc/</span>sys<span class="hljs-regexp">/vm/</span>drop_caches<br></code></pre></td></tr></table></figure><p>To free pagecache, dentries and inodes: </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">echo <span class="hljs-number">3</span> &gt; <span class="hljs-regexp">/proc/</span>sys<span class="hljs-regexp">/vm/</span>drop_caches<br>echo <span class="hljs-number">3</span> | sudo tee <span class="hljs-regexp">/proc/</span>sys<span class="hljs-regexp">/vm/</span>drop_caches <span class="hljs-regexp">//</span>与上面一个作用<br></code></pre></td></tr></table></figure><p>This is a non-destructive operation and will only free things that are  completely unused.  Dirty objects will continue to be in use until  written out to disk and are not freeable.  If you run “sync” first to  flush them out to disk, these drop operations will tend to free more  memory. </p><h1 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a>日志管理</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo journalctl --disk-usage                #查看日志大小<br>sudo journalctl --vacuum-time=5d                  #超过5天的自动删除<br>sudo journalctl --vacuum-size=500M                #超过500M的自动删除<br>sudo rm /var/lib/systemd/coredump/*             #崩溃日志，文件不多，也不大，删不删随你<br></code></pre></td></tr></table></figure><h2 id="清空-var-log-journal-文件的方法"><a href="#清空-var-log-journal-文件的方法" class="headerlink" title="清空 /var/log/journal 文件的方法"></a>清空 /var/log/journal 文件的方法</h2><p>1、用echo命令，将空字符串内容重定向到指定文件中</p><p>echo “” &gt; system.journal</p><p>说明：此方法只会清空一次，一段时间后还要再次手动清空很麻烦，这里可以用以下命令让journalctl 自动维护空间</p><p>2、journalctl 命令自动维护文件大小</p><p>1）只保留近一周的日志</p><p>journalctl –vacuum-time=1w</p><p>2）只保留500MB的日志</p><p>journalctl –vacuum-size=500M</p><p>3）直接删除 <strong>/var/log/journal/</strong> 目录下的日志文件</p><p>rm -rf /var/log/journal/f9d400c5e1e8c3a8209e990d887d4ac1</p><h2 id="问题与分析解决"><a href="#问题与分析解决" class="headerlink" title="问题与分析解决"></a>问题与分析解决</h2><p>执行 journalctl 命令时报错：Error was encountered while opening journal files: Input/output error</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># journalctl --vacuum-time=1w<br><span class="hljs-built_in">Error</span> was encountered <span class="hljs-keyword">while</span> opening journal files: Input/output error<br></code></pre></td></tr></table></figure><p>问题分析：日志文件损坏</p><p>解决方法：删除之前的日志，并重启 journalctl 服务</p><p>mv journal/f9d400c5e1e8c3a8209e990d887d4ac1 journal/f9d400c5e1e8c3a8209e990d887d4ac1_bk_20190122</p><p>systemctl restart systemd-journald.service</p><p>查看 /var/log/journal/ 日志目录如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">#ll /<span class="hljs-keyword">var</span>/log/journal/<br>drwxr-sr-x  <span class="hljs-number">2</span> root systemd-journal  <span class="hljs-number">4096</span> Jan <span class="hljs-number">22</span> <span class="hljs-number">11</span>:<span class="hljs-number">26</span> f9d400c5e1e8c3a8209e990d887d4ac1<br>drwxr-sr-x+ <span class="hljs-number">2</span> root systemd-journal <span class="hljs-number">12288</span> Jan <span class="hljs-number">14</span> <span class="hljs-number">15</span>:<span class="hljs-number">37</span> f9d400c5e1e8c3a8209e990d887d4ac1_bk_20190122<br></code></pre></td></tr></table></figure><p>然后，再执行 journalctl 限制日志的命令：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"># journalctl --vacuum-time=1w<br>Vacuuming done, freed 0B <span class="hljs-keyword">of</span> archived journals on disk.<br># journalctl --vacuum-size=500M<br>Vacuuming done, freed 0B <span class="hljs-keyword">of</span> archived journals on disk.<br></code></pre></td></tr></table></figure><h1 id="pgp密钥管理"><a href="#pgp密钥管理" class="headerlink" title="pgp密钥管理"></a>pgp密钥管理</h1><h2 id="删除密钥"><a href="#删除密钥" class="headerlink" title="删除密钥"></a>删除密钥</h2><p>删除密钥有三个选项：–delete-keys、–delete-secret-keys和–delete-secret-and-public-key。<br>–delete-keys表示从公钥钥匙圈上删除密钥，也就是一同删除公钥和对应的私钥。在分批模式（batch mode）下，密钥必须使用指纹表示，或者使用–yes选项。<br>–delete-secret-keys表示从私钥钥匙圈上删除密钥。<br>–delete-secret-and-public-key和–delete-keys一样，但是如果私钥存在的话，会先移除私钥。在分批模式下，密钥必须使用指纹表示。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs livescript">❯ gpg --<span class="hljs-keyword">list</span>-keys <span class="hljs-comment">#列出自己添加的密钥</span><br><span class="hljs-regexp">/home/kiylx/</span>.gnupg/pubring.kbx<br>------------------------------<br>pub   rsa4096 <span class="hljs-number">2009</span>-<span class="hljs-number">07</span>-<span class="hljs-number">05</span> [SC]<br>      <span class="hljs-number">8</span>C470B2A0B31568E110D432516281F2E007C98D1<br>uid             [ 未知 ] Francois Marier &lt;fmarier@gmail.com&gt;<br>uid             [ 未知 ] Francois Marier &lt;francois@fmarier.org&gt;<br>uid             [ 未知 ] Francois Marier &lt;fmarier@alumni.uwaterloo.ca&gt;<br>uid             [ 未知 ] Francois Marier &lt;francois@debian.org&gt;<br>sub   rsa4096 <span class="hljs-number">2009</span>-<span class="hljs-number">07</span>-<span class="hljs-number">05</span> [E]<br><br>❯ gpg --<span class="hljs-keyword">delete</span>-keys <span class="hljs-number">8</span>C470B2A0B31568E110D432516281F2E007C98D1  <span class="hljs-comment">#删除密钥的公钥和私钥</span><br>gpg (GnuPG) <span class="hljs-number">2.2</span>.<span class="hljs-number">32</span>; Copyright (C) <span class="hljs-number">2021</span> Free Software Foundation, Inc.<br>This <span class="hljs-keyword">is</span> free software: you are free <span class="hljs-keyword">to</span> change <span class="hljs-keyword">and</span> redistribute <span class="hljs-literal">it</span>.<br>There <span class="hljs-keyword">is</span> NO WARRANTY, <span class="hljs-keyword">to</span> the extent permitted <span class="hljs-keyword">by</span> law.<br><br><br>pub  rsa4096/<span class="hljs-number">16281</span>F2E007C98D1 <span class="hljs-number">2009</span>-<span class="hljs-number">07</span>-<span class="hljs-number">05</span> Francois Marier &lt;fmarier@gmail.com&gt;<br><br>要从钥匙环里删除这个密钥吗？(y/N) y<br><br></code></pre></td></tr></table></figure><h1 id="plasmashell"><a href="#plasmashell" class="headerlink" title="plasmashell"></a>plasmashell</h1><p><strong>可以直接在<code>krunner</code>中运行按 <code>alt+F2 </code>打开<code> krunner</code>。</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># kde4</span><br>killall plasmashell &amp;&amp; kstart plasmashell<br>kquitapp5 plasmashell &amp;&amp; kstart plasmashell<br><span class="hljs-comment"># kde5</span><br>killall plasmashell &amp;&amp; kstart5 plasmashell<br>kquitapp5 plasmashell &amp;&amp; kstart5 plasmashell<br></code></pre></td></tr></table></figure><h2 id="重启plasmashell脚本"><a href="#重启plasmashell脚本" class="headerlink" title="重启plasmashell脚本"></a>重启plasmashell脚本</h2><h3 id="脚本文件内容"><a href="#脚本文件内容" class="headerlink" title="脚本文件内容"></a>脚本文件内容</h3><p>具体内容：</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs d">#bash<br><br><span class="hljs-meta">#! /bin/bash</span><br>kquitapp5 plasmashell &amp;&amp; kstart5 plasmashell<br></code></pre></td></tr></table></figure><ul><li>命名：restart_kde，注意，没有后缀名</li></ul><hr><h1 id="脚本放进环境变量（以上面kde-restart为例）"><a href="#脚本放进环境变量（以上面kde-restart为例）" class="headerlink" title="脚本放进环境变量（以上面kde_restart为例）"></a>脚本放进环境变量（以上面kde_restart为例）</h1><h2 id="赋权"><a href="#赋权" class="headerlink" title="赋权"></a>赋权</h2><p>使用文本工具或者<code>vim</code>进行编写，编写完成后对其进行运行权限的赋权：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">sudo chmod +<span class="hljs-keyword">x</span> restart_kde<br></code></pre></td></tr></table></figure><h2 id="复制至bin文件夹"><a href="#复制至bin文件夹" class="headerlink" title="复制至bin文件夹"></a>复制至bin文件夹</h2><p>将脚本文件移至<code>path</code>中指定的系统变量路径，可放至<code>/usr/local/sbin</code>、<code>/usr/local/bin</code>，<code>/usr/bin</code>中。</p><p>移动命令：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo cp restart_kde <span class="hljs-regexp">/usr/</span>bin<br></code></pre></td></tr></table></figure><h2 id="除了系统目录，也可以自己创建存放脚本的目录"><a href="#除了系统目录，也可以自己创建存放脚本的目录" class="headerlink" title="除了系统目录，也可以自己创建存放脚本的目录"></a><strong>除了系统目录，也可以自己创建存放脚本的目录</strong></h2><h3 id="复制至自定义目录"><a href="#复制至自定义目录" class="headerlink" title="复制至自定义目录"></a>复制至自定义目录</h3><p>1.在任意位置创建任意目录：比如<code>~/存档/Linux/bin </code></p><p>2.然后修改环境变量<code>export PATH=$PATH:路径</code></p><ul><li><p>bash</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#m打开.bashrc文件</span><br>nano ~/.bashrc<br>添加下面一行<br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">PATH</span>=<span class="hljs-variable">$PATH</span>:~/存档/Linux/bin<br></code></pre></td></tr></table></figure></li><li><p>zsh</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#打开.zshrc文件</span><br>nano ~/.zshrc<br>添加下面一行<br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">PATH</span>=<span class="hljs-variable">$PATH</span>:~/存档/Linux/bin<br></code></pre></td></tr></table></figure></li></ul><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><ul><li>用<code>KRunner</code>，<code>Alt</code>+<code>Space</code>唤醒，确保<code>KRunner</code>拥有执行命令的功能</li><li>输入<code>restart_kde</code>即可</li></ul><h1 id="安装多个JDK时"><a href="#安装多个JDK时" class="headerlink" title="安装多个JDK时"></a>安装多个<code>JDK</code>时</h1><p>我这里先安装的 <code>jdk8-openjdk</code>，后安装 <code>jdk16</code></p><p><code>sudo pacman -S jdk-openjdk </code>默认就是16版本</p><p>安装 <code>jdk16</code>时提示：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Default</span> Java environment <span class="hljs-keyword">is</span> already <span class="hljs-keyword">set</span> <span class="hljs-keyword">to</span> <span class="hljs-string">&#x27;java-8-openjdk&#x27;</span><br>See <span class="hljs-string">&#x27;archlinux-java help&#x27;</span> <span class="hljs-keyword">to</span> change it<br><span class="hljs-keyword">when</span> you use a non-reparenting <span class="hljs-keyword">window</span> manager,<br><span class="hljs-keyword">set</span> _JAVA_AWT_WM_NONREPARENTING=<span class="hljs-number">1</span> <span class="hljs-keyword">in</span> /etc/profile.d/jre.sh<br></code></pre></td></tr></table></figure><h2 id="切换-JDK-版本"><a href="#切换-JDK-版本" class="headerlink" title="切换 JDK 版本"></a>切换 <code>JDK</code> 版本</h2><h2 id="使用archlinux-java命令切换JDK-版本"><a href="#使用archlinux-java命令切换JDK-版本" class="headerlink" title="使用archlinux-java命令切换JDK 版本"></a>使用<code>archlinux-java</code>命令切换<code>JDK</code> 版本</h2><p><code>archlinux-java help</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">archlinux-java &lt;COMMAND&gt;<br><br>COMMAND:<br>    status      List installed Java environments and enabled one<br>    get     Return the short name of the Java environment <span class="hljs-built_in">set</span> as default<br>    <span class="hljs-built_in">set</span> &lt;JAVA_ENV&gt;  Force &lt;JAVA_ENV&gt; as default<br>    <span class="hljs-built_in">unset</span>       Unset current default Java environment<br>    fix     Fix an invalid/broken default Java environment configuration<br></code></pre></td></tr></table></figure><h3 id="set-lt-JAVA-ENV-gt-就是设置默认环境的方法"><a href="#set-lt-JAVA-ENV-gt-就是设置默认环境的方法" class="headerlink" title="set &lt;JAVA_ENV&gt; 就是设置默认环境的方法"></a><code>set &lt;JAVA_ENV&gt;</code> 就是设置默认环境的方法</h3><ul><li>set 之前</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -version                                                                            1 ↵ ──(六,10月09)─┘<br>openjdk version <span class="hljs-string">&quot;1.8.0_292&quot;</span><br>OpenJDK Runtime Environment (build 1.8.0_292-b10)<br>OpenJDK 64-Bit Server VM (build 25.292-b10, mixed mode)<br></code></pre></td></tr></table></figure><ul><li>set之后</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -version                                                                                ──(六,10月09)─┘<br>openjdk version <span class="hljs-string">&quot;16.0.2&quot;</span> 2021-07-20<br>OpenJDK Runtime Environment (build 16.0.2+7)<br>OpenJDK 64-Bit Server VM (build 16.0.2+7, mixed mode)<br></code></pre></td></tr></table></figure><h1 id="ranger"><a href="#ranger" class="headerlink" title="ranger"></a>ranger</h1><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ol><li><p>配置文件</p><p>首先复制配置文件到主目录:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs none">ranger --copy-config=all<br></code></pre></td></tr></table></figure></li></ol><p>然后自己到~/.config/ranger中配置各种选项即可</p><ol start="2"><li><p>配置ranger<br>在～/.config/ranger中有ranger的配置文件.<br>找到文件<code>scope.sh</code>中, 在externsions部分注释掉不想预览的文件类型, 在那行上面添加”#”注释掉即可. ranger在预览rar等压缩包时会运行得比较慢.<br><code>rc.conf</code>保存着快捷键的说明</p></li><li><p>自动挂载U盘等外部存储位置,需要安装usbmount:</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs none">sudo apt-get install usbmount<br>sudo vim /etc/usbmount/usbmount.conf<br></code></pre></td></tr></table></figure><p>在<code>MOUNTOPTIONS</code>那行添加<code>user</code>即可使普通用户也对挂载的U盘拥有写权限, 如下:<br><code>MOUNTOPTIOS=&quot;rw,user,noatime,nodiratime&quot; </code></p><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p>下面列出常用操作的快捷键</p><p>?  查看帮助</p><h3 id="浏览"><a href="#浏览" class="headerlink" title="浏览:"></a>浏览:</h3><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs maxima">H   后退<br>L   前进<br>gg  跳到顶端<br>G   跳到底端<br>gh  <span class="hljs-built_in">go</span> home<br><span class="hljs-built_in">gn</span>  新建标签<br>f   查找<br>/   搜素<br>g   快速进入目录<br></code></pre></td></tr></table></figure><h3 id="编辑"><a href="#编辑" class="headerlink" title="编辑:"></a>编辑:</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css">space   选择<br>uv      取消选择<br><br>yy      复制<br><span class="hljs-selector-tag">dd</span>      剪切<br>pp      粘贴<br>delete  删除<br>cw      重命名<br><span class="hljs-selector-tag">A</span>       在当前名称基础上重命名<br><span class="hljs-selector-tag">I</span>       类似<span class="hljs-selector-tag">A</span>, 但是光标会跳到起始位置<br>Ctrl-f  向下翻页<br>Ctrl-<span class="hljs-selector-tag">b</span>  向上翻页<br></code></pre></td></tr></table></figure><h3 id="书签"><a href="#书签" class="headerlink" title="书签:"></a>书签:</h3><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">m       新建书签<br>`       打开书签<br>um      删除书签<br></code></pre></td></tr></table></figure><h3 id="标签"><a href="#标签" class="headerlink" title="标签:"></a>标签:</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">gn / C-n        新建标签<br>TAB / S-TAB     切换标签<br><span class="hljs-selector-tag">A</span>-<span class="hljs-attribute">Right</span>, <span class="hljs-selector-tag">A</span>-<span class="hljs-attribute">Left</span> 切换标签<br>gc / C-w        关闭标签<br></code></pre></td></tr></table></figure><h3 id="排序"><a href="#排序" class="headerlink" title="排序:"></a>排序:</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">on</span>/ob   根据文件名进行排序(<span class="hljs-keyword">natural</span>/basename)<br>oc      根据改变时间进行排序 (Change <span class="hljs-type">Time</span> 文件的权限组别和文件自身数据被修改的时间)<br>os      根据文件大小进行排序(Size)<br>ot      根据后缀名进行排序 (<span class="hljs-keyword">Type</span>)<br><br>oa      根据访问时间进行排序 (<span class="hljs-keyword">Access</span> <span class="hljs-type">Time</span> 访问文件自身数据的时间)<br>om      根据修改进行排序 (Modify <span class="hljs-type">time</span> 文件自身内容被修改的时间)<br></code></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他:"></a>其他:</h3><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-built_in">zh</span>      显示隐藏文件<br><br>zp      打开/关闭文件预览功能<br>zP      打开目录预览功能<br></code></pre></td></tr></table></figure><h3 id="链接-Link"><a href="#链接-Link" class="headerlink" title="链接(Link):"></a>链接(Link):</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">pl</span>      粘贴绝对路径的链接<br><span class="hljs-keyword">pL</span>      粘贴相对路径的链接<br>phl     硬链接<br></code></pre></td></tr></table></figure><h3 id="批量改名"><a href="#批量改名" class="headerlink" title="批量改名:"></a>批量改名:</h3><p>批量选择文件后, 键入命令:bulkname, 会打开编辑器, 其中的文件名编辑后保存退出, 再次打开操作确认编辑, 然后就批量改名了, 如果想取消批量改名, 在确认时把文件内容删除即可.</p><h3 id="任务管理"><a href="#任务管理" class="headerlink" title="任务管理:"></a>任务管理:</h3><p>在执行某些操作(比如复制一个大文件)时不能立即完成, 这在 ranger 中就是一个任务. 你可以停止, 启动某个任务, 也可以对某个任务设置优先级.</p><p>w: 打开/关闭任务视图. 在w打开的任务视图中:<br>    dd: 终止一个任务<br>    J: 降低当前任务的优先级<br>    K: 提升当前任务的优先级</p><h3 id="其他-1"><a href="#其他-1" class="headerlink" title="其他:"></a>其他:</h3><ul><li><p>zf      过滤器(如过滤pdf文件, zf+pdf,回车) S       在当前目录打开终端 z(*)    改变设置, <em>表示在弹出选项中的选择 o(</em>)    改变排序方式 ! / s   使用shell命令(！shell -w ls -hl %s,%s代表当前被选中的文件)</p><p>使用ranger命令(3? 查看可用命令) :set colorscheme snow 设置颜色模式</p></li></ul><h2 id="快速预览"><a href="#快速预览" class="headerlink" title="快速预览"></a>快速预览</h2><p>安装以下程序可以实现快速预览:</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-built_in">elinks,</span> html<br><span class="hljs-built_in">highlight,</span>text/code<br><span class="hljs-built_in">img2txt,</span>image<br><span class="hljs-built_in">atool,</span>压缩包<br><span class="hljs-built_in">pdf2text,</span>pdf<br><span class="hljs-built_in">medinfo,</span>audio/video<br></code></pre></td></tr></table></figure><hr><h1 id="字体调整"><a href="#字体调整" class="headerlink" title="字体调整"></a>字体调整</h1><p><strong>提示：</strong> 中文用户在安装思源cjk全集或者noto-cjk全集后，部分文字显示为日文异形字体，可参看<a href="https://wiki.archlinux.org/title/Arch_Linux_Localization_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E4%BF%AE%E6%AD%A3%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%E6%98%BE%E7%A4%BA%E4%B8%BA%E5%BC%82%E4%BD%93%EF%BC%88%E6%97%A5%E6%96%87%EF%BC%89%E5%AD%97%E5%BD%A2">Arch Linux Localization (简体中文)#修正简体中文显示为异体（日文）字形</a> 进行解决。</p><h2 id="字体安装和配置"><a href="#字体安装和配置" class="headerlink" title="字体安装和配置"></a>字体安装和配置</h2><p><code>noto-fonts-cjk</code>-Google Noto CJK 字体， 提供简体中文、繁体中文、日文、韩文一致的设计和外观。它是基于是<code>adobe-source-han-sans-otc-fonts</code>重贴的商标。所以选择一个安装。</p><h2 id="安装的字体"><a href="#安装的字体" class="headerlink" title="安装的字体"></a>安装的字体</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vim">例如<br>sudo pacman -S ttf-roboto noto-fonts ttf-dejavu<br>文泉驿<br>sudo pacman -S wqy-bitmapfont wqy-microhei wqy-microhei-lite wqy-zenhei <br>思源字体<br>sudo pacman -S adobe-<span class="hljs-keyword">source</span>-han-sans-<span class="hljs-keyword">cn</span>-fonts adobe-<span class="hljs-keyword">source</span>-han-serif-<span class="hljs-keyword">cn</span>-fonts<br></code></pre></td></tr></table></figure><ul><li><p>思源字体（不安装cjk版本，仅安装cn版本，避免火狐异体字问题）：</p><ul><li><code>adobe-source-han-serif-cn-fonts</code></li><li><code>adobe-source-han-sans-cn-fonts</code></li></ul></li><li><p>文泉驿正黑</p><ul><li><a href="https://archlinux.org/packages/?name=wqy-zenhei">wqy-zenhei</a> - 文泉驿正黑体，黑体 (无衬线) 的中文轮廓字体，附带文泉驿点阵宋体 (也支持部分日韩字符)。</li><li><a href="https://archlinux.org/packages/?name=wqy-bitmapfont">wqy-bitmapfont</a> - 文泉驿点阵宋体 (衬线) 中文字体。</li></ul></li><li><p>文泉驿微米黑</p><ul><li><a href="https://archlinux.org/packages/?name=wqy-microhei">wqy-microhei</a> - 文泉驿微米黑，无衬线形式字体。</li><li><a href="https://archlinux.org/packages/?name=wqy-microhei-lite">wqy-microhei-lite</a> - 文泉驿微米黑light版（笔画更细）。</li></ul></li><li><p>windows字体</p></li></ul><p>​        把windows的字体复制到<code>~/.local/share/fonts/WindowsFonts</code>目录下</p><h2 id="配置font"><a href="#配置font" class="headerlink" title="配置font"></a>配置font</h2><ul><li>修改<code>~/.config/fontconfig/fonts.conf</code>配置文件</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><code class="hljs xml">原理就是把某些符合条件的字体请求映射到我们定义的字体<br><span class="hljs-meta">&lt;?xml version=&#x27;1.0&#x27;?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">fontconfig</span> <span class="hljs-meta-keyword">SYSTEM</span> <span class="hljs-meta-string">&#x27;urn:fontconfig:fonts.dtd&#x27;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">fontconfig</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">dir</span>&gt;</span>~/.fonts<span class="hljs-tag">&lt;/<span class="hljs-name">dir</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">dir</span>&gt;</span>~/.local/share/fonts/<span class="hljs-tag">&lt;/<span class="hljs-name">dir</span>&gt;</span><br> <span class="hljs-comment">&lt;!-- </span><br><span class="hljs-comment"> Artificial oblique for fonts without an italic or oblique version</span><br><span class="hljs-comment"> --&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">match</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;font&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- check to see if the font is roman --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">test</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;slant&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">const</span>&gt;</span>roman<span class="hljs-tag">&lt;/<span class="hljs-name">const</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">test</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- check to see if the pattern requested non-roman --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">test</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;pattern&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;slant&quot;</span> <span class="hljs-attr">compare</span>=<span class="hljs-string">&quot;not_eq&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">const</span>&gt;</span>roman<span class="hljs-tag">&lt;/<span class="hljs-name">const</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">test</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- multiply the matrix to slant the font --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">edit</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;matrix&quot;</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">&quot;assign&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">times</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>matrix<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">matrix</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">double</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">double</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">double</span>&gt;</span>0.2<span class="hljs-tag">&lt;/<span class="hljs-name">double</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">double</span>&gt;</span>0<span class="hljs-tag">&lt;/<span class="hljs-name">double</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">double</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">double</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">matrix</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">times</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">edit</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- pretend the font is oblique now --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">edit</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;slant&quot;</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">&quot;assign&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">const</span>&gt;</span>oblique<span class="hljs-tag">&lt;/<span class="hljs-name">const</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">edit</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- and disable embedded bitmaps for artificial oblique --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">edit</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;embeddedbitmap&quot;</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">&quot;assign&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">bool</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">bool</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">edit</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">match</span>&gt;</span><br> <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment"> Synthetic emboldening for fonts that do not have bold face available</span><br><span class="hljs-comment"> --&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">match</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;font&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- check to see if the weight in the font is less than medium which possibly need emboldening --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">test</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;weight&quot;</span> <span class="hljs-attr">compare</span>=<span class="hljs-string">&quot;less_eq&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">const</span>&gt;</span>medium<span class="hljs-tag">&lt;/<span class="hljs-name">const</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">test</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- check to see if the pattern requests bold --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">test</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;pattern&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;weight&quot;</span> <span class="hljs-attr">compare</span>=<span class="hljs-string">&quot;more_eq&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">const</span>&gt;</span>bold<span class="hljs-tag">&lt;/<span class="hljs-name">const</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">test</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">  set the embolden flag</span><br><span class="hljs-comment">  needed for applications using cairo, e.g. gucharmap, gedit, ...</span><br><span class="hljs-comment">--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">edit</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;embolden&quot;</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">&quot;assign&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">bool</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">bool</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">edit</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment"> set weight to bold</span><br><span class="hljs-comment"> needed for applications using Xft directly, e.g. Firefox, ...</span><br><span class="hljs-comment">--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">edit</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;weight&quot;</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">&quot;assign&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">const</span>&gt;</span>bold<span class="hljs-tag">&lt;/<span class="hljs-name">const</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">edit</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">match</span>&gt;</span><br> <span class="hljs-comment">&lt;!--   自定义开始--&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">match</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;font&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">edit</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;embeddedbitmap&quot;</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">&quot;assign&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">bool</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">bool</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">edit</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">match</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">match</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">test</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;family&quot;</span> <span class="hljs-attr">qual</span>=<span class="hljs-string">&quot;any&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>serif<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">test</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">edit</span> <span class="hljs-attr">binding</span>=<span class="hljs-string">&quot;strong&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;family&quot;</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">&quot;prepend&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>Noto Serif<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">edit</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">match</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">match</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;pattern&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">test</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;family&quot;</span> <span class="hljs-attr">qual</span>=<span class="hljs-string">&quot;any&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>sans-serif<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">test</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">edit</span> <span class="hljs-attr">binding</span>=<span class="hljs-string">&quot;strong&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;family&quot;</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">&quot;prepend&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>Roboto<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">edit</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">match</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">match</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;pattern&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">test</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;family&quot;</span> <span class="hljs-attr">qual</span>=<span class="hljs-string">&quot;any&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>monospace<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">test</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">edit</span> <span class="hljs-attr">binding</span>=<span class="hljs-string">&quot;strong&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;family&quot;</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">&quot;prepend&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>DejaVu Sans Mono<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">edit</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">match</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">match</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">test</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lang&quot;</span> <span class="hljs-attr">compare</span>=<span class="hljs-string">&quot;contains&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>zh<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">test</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">test</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;family&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>serif<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">test</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">edit</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;family&quot;</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">&quot;prepend&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>Source Han Serif CN<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">edit</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">match</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">match</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">test</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lang&quot;</span> <span class="hljs-attr">compare</span>=<span class="hljs-string">&quot;contains&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>zh<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">test</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">test</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;family&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>sans-serif<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">test</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">edit</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;family&quot;</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">&quot;prepend&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>Source Han Sans CN<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">edit</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">match</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">match</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">test</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lang&quot;</span> <span class="hljs-attr">compare</span>=<span class="hljs-string">&quot;contains&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>zh<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">test</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">test</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;family&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>monospace<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">test</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">edit</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;family&quot;</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">&quot;prepend&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>WenQuanYi Micro Hei Mono<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">edit</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">match</span>&gt;</span><br> <span class="hljs-comment">&lt;!--WenQuanYi Zen Hei -&gt; WenQuanYi Micro Hei --&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">match</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;pattern&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">test</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;family&quot;</span> <span class="hljs-attr">qual</span>=<span class="hljs-string">&quot;any&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>WenQuanYi Zen Hei<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">test</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">edit</span> <span class="hljs-attr">binding</span>=<span class="hljs-string">&quot;same&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;family&quot;</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">&quot;assign&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>WenQuanYi Micro Hei<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">edit</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">match</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">match</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;pattern&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">test</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;family&quot;</span> <span class="hljs-attr">qual</span>=<span class="hljs-string">&quot;any&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>WenQuanYi Zen Hei Lite<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">test</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">edit</span> <span class="hljs-attr">binding</span>=<span class="hljs-string">&quot;same&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;family&quot;</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">&quot;assign&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>WenQuanYi Micro Hei Lite<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">edit</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">match</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">match</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;pattern&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">test</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;family&quot;</span> <span class="hljs-attr">qual</span>=<span class="hljs-string">&quot;any&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>WenQuanYi Zen Hei Mono<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">test</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">edit</span> <span class="hljs-attr">binding</span>=<span class="hljs-string">&quot;same&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;family&quot;</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">&quot;assign&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">string</span>&gt;</span>WenQuanYi Micro Hei Mono<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">edit</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">match</span>&gt;</span><br> <span class="hljs-comment">&lt;!--   自定义结束--&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">match</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;font&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">edit</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hinting&quot;</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">&quot;assign&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">bool</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">bool</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">edit</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">match</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">match</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;font&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">edit</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hintstyle&quot;</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">&quot;assign&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">const</span>&gt;</span>hintslight<span class="hljs-tag">&lt;/<span class="hljs-name">const</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">edit</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">match</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">fontconfig</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h2 id="修正简体中文显示为异体（日文）字形"><a href="#修正简体中文显示为异体（日文）字形" class="headerlink" title="修正简体中文显示为异体（日文）字形"></a>修正简体中文显示为异体（日文）字形</h2><ul><li><p>上面安装了windows字体，要禁用或删除windows字体中的<code>Candara</code>字体，因为它会显示异体字。</p><hr></li></ul><p>安装的 Noto Sans CJK 或 <a href="https://archlinux.org/packages/?name=adobe-source-han-sans-otc-fonts">adobe-source-han-sans-otc-fonts</a>（思源黑体）或 <a href="https://archlinux.org/packages/?name=adobe-source-han-serif-otc-fonts">adobe-source-han-serif-otc-fonts</a>（思源宋体）后，在某些情况下（框架未定义地区）汉字字形与标准形态不符，例如门、关、复等字字形与规范中文不符。</p><p>这是因为每个程序中可以设置不同的默认字体，比如 Arial 或者 Tohamo，而这些字体的属性由 <a href="https://wiki.archlinux.org/title/Fontconfig_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">fontconfig</a> 控制，其使用顺序是据地区代码以 A-Z 字母表顺序成默认排序，由于 <code>ja-JP</code> 在 <code>zh_&#123;CN,HK,SG,TW&#125;</code> 之前，故优先显示日文字形。</p><p><strong>提示：</strong> Chromium/Chrome/Firefox 浏览器的设置中可单独设置字体，例如将字体选项调成 Noto xxx CJK SC。</p><p>可选用以下方法解决（以简体中文为例）：</p><ul><li><p>只安装 cjk 中的简体中文字体，例如思源黑体简体中文包 <a href="https://archlinux.org/packages/?name=adobe-source-han-sans-cn-fonts">adobe-source-han-sans-cn-fonts</a>、<a href="https://archlinux.org/packages/?name=adobe-source-han-serif-cn-fonts">adobe-source-han-serif-cn-fonts</a> 或者 <a href="https://aur.archlinux.org/packages/noto-fonts-sc/">noto-fonts-sc</a>AUR。</p></li><li><p>在 <code>locale.conf</code> 中添加 <code>LANG=zh_CN.UTF-8</code>，以将简体中文设置为默认语言。由于对 <a href="https://wiki.archlinux.org/title/Locale_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">Locale</a> 定义了框架内地区（即 CJK 优先度），使得默认的优先级被忽略。</p></li><li><p>手动调整优先级，将中文字形调整到日文字形之前。[<a href="https://tieba.baidu.com/p/4879946717">3]</a>在 <code>/etc/fonts/conf.d/</code> 或 <code>/etc/fonts/conf.avail/</code> 下创建文件，例如 <code>64-language-selector-prefer.conf</code>，也可以修改或创建 <code>~/.fonts.conf</code>或在<code>~/.config/fontconfig/conf.d/</code>创建后缀为.conf的文件（仅对该用户生效）。例如针对<a href="https://archlinux.org/packages/?name=noto-fonts-cjk">noto-fonts-cjk</a>的规则，写入：</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">fontconfig</span> <span class="hljs-meta-keyword">SYSTEM</span> <span class="hljs-meta-string">&quot;fonts.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">fontconfig</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">alias</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">family</span>&gt;</span>sans-serif<span class="hljs-tag">&lt;/<span class="hljs-name">family</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">prefer</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">family</span>&gt;</span>Noto Sans CJK SC<span class="hljs-tag">&lt;/<span class="hljs-name">family</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">family</span>&gt;</span>Noto Sans CJK TC<span class="hljs-tag">&lt;/<span class="hljs-name">family</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">family</span>&gt;</span>Noto Sans CJK JP<span class="hljs-tag">&lt;/<span class="hljs-name">family</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">prefer</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">alias</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">alias</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">family</span>&gt;</span>monospace<span class="hljs-tag">&lt;/<span class="hljs-name">family</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">prefer</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">family</span>&gt;</span>Noto Sans Mono CJK SC<span class="hljs-tag">&lt;/<span class="hljs-name">family</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">family</span>&gt;</span>Noto Sans Mono CJK TC<span class="hljs-tag">&lt;/<span class="hljs-name">family</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">family</span>&gt;</span>Noto Sans Mono CJK JP<span class="hljs-tag">&lt;/<span class="hljs-name">family</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">prefer</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">alias</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">fontconfig</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果安装的是 <a href="https://archlinux.org/packages/?name=adobe-source-han-sans-otc-fonts">adobe-source-han-sans-otc-fonts</a>，写入：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">fontconfig</span> <span class="hljs-meta-keyword">SYSTEM</span> <span class="hljs-meta-string">&quot;fonts.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">fontconfig</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">alias</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">family</span>&gt;</span>sans-serif<span class="hljs-tag">&lt;/<span class="hljs-name">family</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">prefer</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">family</span>&gt;</span>Source Han Sans SC<span class="hljs-tag">&lt;/<span class="hljs-name">family</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">family</span>&gt;</span>Source Han Sans TC<span class="hljs-tag">&lt;/<span class="hljs-name">family</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">family</span>&gt;</span>Source Han Sans HW<span class="hljs-tag">&lt;/<span class="hljs-name">family</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">family</span>&gt;</span>Source Han Sans K<span class="hljs-tag">&lt;/<span class="hljs-name">family</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">prefer</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">alias</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">alias</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">family</span>&gt;</span>monospace<span class="hljs-tag">&lt;/<span class="hljs-name">family</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">prefer</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">family</span>&gt;</span>Source Han Sans SC<span class="hljs-tag">&lt;/<span class="hljs-name">family</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">family</span>&gt;</span>Source Han Sans TC<span class="hljs-tag">&lt;/<span class="hljs-name">family</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">family</span>&gt;</span>Source Han Sans HW<span class="hljs-tag">&lt;/<span class="hljs-name">family</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">family</span>&gt;</span>Source Han Sans K<span class="hljs-tag">&lt;/<span class="hljs-name">family</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">prefer</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">alias</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">fontconfig</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注意，如果你是在 <code>/etc/fonts/conf.avail</code> 目录下创建的 xml 文件，则将该 xml 文件软链接到 <code>/etc/fonts/conf.d</code> 下，例如：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"># ln -s <span class="hljs-regexp">/etc/</span>fonts<span class="hljs-regexp">/conf.avail/</span><span class="hljs-number">64</span>-language-selector-prefer.conf <span class="hljs-regexp">/etc/</span>fonts<span class="hljs-regexp">/conf.d/</span><span class="hljs-number">64</span>-language-selector-prefer.conf<br></code></pre></td></tr></table></figure><p>然后更新字体缓存即可生效：</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># fc-cache -fv</span><br></code></pre></td></tr></table></figure><p>执行以下命令检查，如果出现 <code>NotoSansCJK-Regular.ttc: &quot;Noto Sans CJK SC&quot; &quot;Regular&quot;</code> 则表示设置成功：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"># fc-<span class="hljs-keyword">match</span> -s | <span class="hljs-keyword">grep</span> <span class="hljs-string">&#x27;Noto Sans CJK&#x27;</span><br></code></pre></td></tr></table></figure><h1 id="kde-美化"><a href="#kde-美化" class="headerlink" title="kde 美化"></a>kde 美化</h1><h2 id="安装kde的一些小工具"><a href="#安装kde的一些小工具" class="headerlink" title="安装kde的一些小工具"></a>安装kde的一些小工具</h2><ul><li>kdialog 某些shell脚本会用他显示一些提示信息</li><li>kmousetool 自动点击，解放你的鼠标</li><li>kipi-plugins  是gwenview的插件集合</li></ul><h2 id="安装主题管理"><a href="#安装主题管理" class="headerlink" title="安装主题管理"></a>安装主题管理</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> pacman -S kvantum-qt<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h2 id="主题位置"><a href="#主题位置" class="headerlink" title="主题位置"></a>主题位置</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs awk">AURORAE_DIR=<span class="hljs-string">&quot;$HOME/.local/share/aurorae/themes&quot;</span><span class="hljs-regexp">//</span>窗口装饰元素<br>PLASMA_DIR=<span class="hljs-string">&quot;$HOME/.local/share/plasma/desktoptheme&quot;</span><span class="hljs-regexp">//</span>plasma样式<br>LAYOUT_DIR=<span class="hljs-string">&quot;$HOME/.local/share/plasma/layout-templates&quot;</span><span class="hljs-regexp">//</span>无<br>LOOKFEEL_DIR=<span class="hljs-string">&quot;$HOME/.local/share/plasma/look-and-feel&quot;</span>总体的预览/全局主题<br>SCHEMES_DIR=<span class="hljs-string">&quot;$HOME/.local/share/color-schemes&quot;</span><span class="hljs-regexp">//</span>颜色<br>KVANTUM_DIR=<span class="hljs-string">&quot;$HOME/.config/Kvantum&quot;</span><br>WALLPAPER_DIR=<span class="hljs-string">&quot;$HOME/.local/share/wallpapers&quot;</span><br>   <span class="hljs-variable">$HOME</span><span class="hljs-regexp">/.local/</span>share<span class="hljs-regexp">/icons/</span> <span class="hljs-regexp">//</span>存放鼠标或图标<br><span class="hljs-variable">$HOME</span><span class="hljs-regexp">/.local/</span>share<span class="hljs-regexp">/plasma/</span>plasmoids/ 存放插件<br><span class="hljs-variable">$HOME</span><span class="hljs-regexp">/.local/</span>share<span class="hljs-regexp">/kwin/</span>scripts/  kwin插件<br>以上目录如果没有就自行创建。<br><br>壁纸位置在<span class="hljs-regexp">/home/</span>kiylx<span class="hljs-regexp">/.local/</span>share/wallpapers 更改为此文件夹下的文件就可以改壁纸<br><span class="hljs-number">1</span>.更换登录壁纸 :菜单-系统设置-工作区-工作空间行为-锁屏-外观-接下来选取你喜欢的图片即可<br><span class="hljs-number">2</span>.更换锁屏壁纸 :菜单-系统设置-工作区-工作空间行为-锁屏-外观-接下来选取你喜欢的图片即可<br><span class="hljs-number">3</span>.更换登录屏幕的壁纸：菜单-系统设置-工作区-开机和关机-登录屏幕-接下来选取你喜欢的动画即可<br><span class="hljs-number">4</span>.更换开机动画：菜单-系统设置-工作区-开机和关机-欢迎屏幕<br><span class="hljs-number">5</span>.设置双击打开文件夹，单击选择：菜单-系统设置-工作区-工作空间行为-常规行为-点击行为<br></code></pre></td></tr></table></figure><h2 id="重启plasmashell"><a href="#重启plasmashell" class="headerlink" title="重启plasmashell"></a>重启plasmashell</h2><h3 id="直接杀死并重启"><a href="#直接杀死并重启" class="headerlink" title="直接杀死并重启"></a>直接杀死并重启</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">killall plasmashell    <span class="hljs-comment"># 杀死 kde plasma 的进程</span><br><span class="hljs-comment"># kde4</span><br>kstart plasmashell    <span class="hljs-comment"># 重新启动 plasma 桌面会话</span><br><span class="hljs-comment"># kde5</span><br>kstart5 plasmashell    <span class="hljs-comment"># 重新启动 plasma 桌面会话</span><br></code></pre></td></tr></table></figure><h3 id="退出并重启"><a href="#退出并重启" class="headerlink" title="退出并重启"></a>退出并重启</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">kquitapp5 plasmashell    <span class="hljs-comment"># 退出kde桌面</span><br><span class="hljs-comment"># kde4</span><br>kstart plasmashell    <span class="hljs-comment"># 重新启动 plasma 桌面会话</span><br><span class="hljs-comment"># kde5</span><br>kstart5 plasmashell    <span class="hljs-comment"># 重新启动 plasma 桌面会话</span><br></code></pre></td></tr></table></figure><hr><h2 id="主题推荐"><a href="#主题推荐" class="headerlink" title="主题推荐"></a>主题推荐</h2><h2 id="图标"><a href="#图标" class="headerlink" title="图标"></a>图标</h2><p><a href="https://github.com/PapirusDevelopmentTeam/papirus-icon-theme">papirus-icon</a><br><a href="https://github.com/vinceliuice/Tela-icon-theme">Tela-icon</a><br><a href="https://github.com/Bonandry/adwaita-plus#home-directory-for-kde">adwaita-plus</a><br><a href="https://gitlab.gnome.org/GNOME/adwaita-icon-theme">adwaita</a></p><h2 id="鼠标指针："><a href="#鼠标指针：" class="headerlink" title="鼠标指针："></a>鼠标指针：</h2><p><a href="https://github.com/vinceliuice/McMojave-cursors">mac样式</a></p><h2 id="整体样式"><a href="#整体样式" class="headerlink" title="整体样式"></a>整体样式</h2><ul><li><p>应用商店搜索：materia-kde</p><p><a href="https://github.com/PapirusDevelopmentTeam/materia-kde">materia-kde地址</a></p></li><li><p>gtk样式：orchis</p><p><a href="https://github.com/vinceliuice/Orchis-theme">orchis地址</a></p></li></ul><h2 id="应用程序样式"><a href="#应用程序样式" class="headerlink" title="应用程序样式"></a>应用程序样式</h2><ul><li>更现代化的样式 <a href="https://github.com/Luwx/Lightly">lightly-qt</a></li><li>gnome的样式 <a href="https://github.com/FedoraQt/adwaita-qt">adwaita-qt</a></li></ul><h2 id="dock栏"><a href="#dock栏" class="headerlink" title="dock栏"></a>dock栏</h2><ul><li>latte dock</li></ul><h2 id="顶栏"><a href="#顶栏" class="headerlink" title="顶栏"></a>顶栏</h2><ul><li><p>applet-window-appmenu</p><p>提供了顶栏的全局菜单，比自带的好用</p><p>应用商店搜索<code>plasma5-applets-window-appmenu-git</code></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs subunit">github： https://github.com/psifidotos/applet-window-appmenu<br>调用 sh install.sh安装，安装之前应该查看INSTALLATION.md安装编译环境，但是可以在<br>应用商店查找plasma5-applets-window-appmenu-git，安装别人做好的。<br>构建依赖：<br>[2021<span class="hljs-string">-08</span><span class="hljs-string">-14</span>T22:20:17<span class="hljs-string">+0800</span>] [ALPM] installed plasma5-applets-window-appmenu-git (0.7.1.r0.gcdbc943<span class="hljs-string">-1</span>)<br>[2021<span class="hljs-string">-08</span><span class="hljs-string">-14</span>T22:19:48<span class="hljs-string">+0800</span>] [ALPM] installed extra-cmake-modules (5.84.0<span class="hljs-string">-1</span>)<br>[2021<span class="hljs-string">-08</span><span class="hljs-string">-14</span>T22:19:48<span class="hljs-string">+0800</span>] [ALPM] installed cmake (3.21.1<span class="hljs-string">-1</span>)<br>[2021<span class="hljs-string">-08</span><span class="hljs-string">-14</span>T22:19:47<span class="hljs-string">+0800</span>] [ALPM] installed libuv (1.42.0<span class="hljs-string">-1</span>)<br>[2021<span class="hljs-string">-08</span><span class="hljs-string">-14</span>T22:19:47<span class="hljs-string">+0800</span>] [ALPM] installed jsoncpp (1.9.4<span class="hljs-string">-1</span>)<br>[2021<span class="hljs-string">-08</span><span class="hljs-string">-14</span>T22:19:47<span class="hljs-string">+0800</span>] [ALPM] installed rhash (1.4.2<span class="hljs-string">-1</span>)<br></code></pre></td></tr></table></figure></li><li><p>applet-window-buttons</p><p>提供窗口管理按钮</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">github：https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/psifidotos/</span>applet-window-buttons<br>上面的菜单使用应用商店安装好后，编译环境还没被卸载，可以直接clone这个applet-window-buttons库下来，调用sh install.sh安装这个button插件<br><br></code></pre></td></tr></table></figure></li><li><p><a href="https://github.com/psifidotos/applet-window-title">顶栏显示应用的标题和图标</a></p><p>应用商店自行安装</p><p>或手动安装：</p><p>克隆仓库</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/psifidotos/</span>applet-window-title.git<br></code></pre></td></tr></table></figure><p>由于此插件使用<code>QML</code>编写，所以可以直接使用命令装入插件</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dos"><span class="hljs-built_in">cd</span> applet-window-<span class="hljs-built_in">title</span><br>plasmapkg2 -i .<br></code></pre></td></tr></table></figure></li></ul><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><h3 id="kwin脚本"><a href="#kwin脚本" class="headerlink" title="kwin脚本"></a>kwin脚本</h3><ul><li><p><a href="https://github.com/JoseBahamonde/hide-titles">窗口最大化隐藏窗口顶部</a></p></li><li><p>另一种“神灯”<a href="https://github.com/zzag/kwin-effects-yet-another-magic-lamp/tree/Plasma/5.23">效果</a></p></li></ul><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs vim">git clone http<span class="hljs-variable">s:</span>//github.<span class="hljs-keyword">com</span>/zzag/kwin-effects-yet-another-magic-lamp.git<br><span class="hljs-keyword">cd</span> kwin-effects-yet-another-magic-lamp<br>git branch -<span class="hljs-keyword">a</span> //查看远程分支<br>git checkout Plasma/<span class="hljs-number">5.23</span>    //切换到与kde桌面版本符合的分支<br><span class="hljs-built_in">mkdir</span> build &amp;&amp; <span class="hljs-keyword">cd</span> build<br>cmake .. \<br>    -DCMAKE_BUILD_TYPE=Release \<br>    -DCMAKE_INSTALL_PREFIX=/usr<br><span class="hljs-keyword">make</span><br>sudo <span class="hljs-keyword">make</span> install<br><br><span class="hljs-keyword">ps</span>：卸载<br>查看克隆文件夹里的<br>kwin-effects-yet-another-magic-lamp/build/install_manifest.txt文件，删除文件中记载的位置的文件<br></code></pre></td></tr></table></figure><h3 id="applet"><a href="#applet" class="headerlink" title="applet"></a>applet</h3><ul><li><p>日历插件<code>plasma5-applets-eventcalendar</code>，可直接在应用商店搜索</p><p><a href="https://github.com/Zren/plasma-applet-eventcalendar">github地址</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>manjaro</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Sqlite基本内容</title>
    <link href="/posts/8d2ce9e6/"/>
    <url>/posts/8d2ce9e6/</url>
    
    <content type="html"><![CDATA[<p>本篇文章可以学到以下内容：</p><ul><li>SQLite操作以及SQL基本语法</li><li>Android中的数据库操作（增删改查）</li><li>Android中ContentProvide内容提供者和ContentResolver内容解析者的使用</li></ul><p>项目地址：</p><blockquote><p><a href="https://link.jianshu.com/?t=https://github.com/liaozhoubei/DatabaseContentProvider">https://github.com/liaozhoubei/DatabaseContentProvider</a></p></blockquote><p>学习android的小伙伴们在使用Android的SQLiteDatabase类进行数据库操作的时候总会有一些力不从心，特别是对于初涉数据库的小伙伴来说更是如此。<br>这是因为Android的SQLiteDatabase原本就不是依赖于Android而存在的，而是单独的作为一个个体而存在的，有着自己特有的体系和语言，而这就是SQL语法了。</p><p>关于SQLite数据库的理论知识网上一搜一大片，这里就不多说。SQLite是一个轻量型的数据库，它对于大型数据库来说功能少，因此只需要学习一些通用的SQL语法就能够轻松掌握，而这些SQL语法对于其他的数据库来说也是基本不变化的。</p><p>但SQLite有个缺点，那就是作为轻量级选手的它，如果要保存大量数据会力有不及，因此它在android中适合保存个人设置等没有大量数据的信息。</p><p>好了，下面就是正式学习SQLite了，只有掌握了SQLite，掌握SQL语法，才能对Android中的数据库操作运用自如。</p><h2 id="SQLite的数据类型"><a href="#SQLite的数据类型" class="headerlink" title="SQLite的数据类型"></a>SQLite的数据类型</h2><p>与Java语言一样，SQLite也有其特有的数据类型，当然相比MySQL来说只有5种数据类型算是很少了</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp">NULL：空值相当于Java中的<span class="hljs-literal">null</span><br>INTEGER：带符号的整型，相当于Java中的<span class="hljs-built_in">int</span>型<br>REAL：浮点数字，相当于Java中<span class="hljs-built_in">float</span>/<span class="hljs-built_in">double</span>型<br>TEXT/VARCHAR：字符串文本，相当于Java中String类<br>BLOB：二进制对象，相当于Java中的<span class="hljs-built_in">byte</span>数组，用于存放图片、声音等文件<br></code></pre></td></tr></table></figure><h2 id="Sqlite3中的约束"><a href="#Sqlite3中的约束" class="headerlink" title="Sqlite3中的约束"></a>Sqlite3中的约束</h2><p>SQLite的约束是什么呢？约束就是限定数据库字段的条件，如果有个student数据表，它里面有一个age年龄的属性字段，我们要求数据库保存age这个字段的时候必须有值，不能为空，那么就可以设置为：”age INTEGER NOT NULL”。这句话的意思就是age字段是不能为空的整型</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php">NOT <span class="hljs-literal">NULL</span> ：非空<br>UNIQUE ： 唯一<br>PRIMARY KEY ：主键<br>FOREIGN KEY : 外键<br>CHECK ：条件检查<br><span class="hljs-keyword">DEFAULT</span> : 默认<br></code></pre></td></tr></table></figure><p>创建表，此时可对表里的结构和字段进行约束限定，将约束条件放在需要约束的字段之后</p><h2 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h2><p>数据库是数据库，数据表是存放在数据库中存放信息的容器，这点大家要区分。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css">语法：<br>  create <span class="hljs-selector-tag">table</span> tabname(col1 type1 <span class="hljs-selector-attr">[not null]</span><span class="hljs-selector-attr">[primary key]</span>, col2 type2<span class="hljs-selector-attr">[not null]</span>, ··· )<br>注：<br>    tabname为表名<br>    col1、col2为字段名字<br>    type1、type2为字段类型<br>    在<span class="hljs-selector-attr">[]</span>中的约束条件是可以选的<br></code></pre></td></tr></table></figure><p>例：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">  字段名       类型            长度           约束            说明<br>  <span class="hljs-keyword">id</span>        INTEGER                       主键，自增长       编号<br>  name      VARCHAR           <span class="hljs-number">20</span>            非空            姓名<br>  cid       INTEGER                                        所在班级<br>  age       INTEGER                      大于<span class="hljs-number">18</span>且小于<span class="hljs-number">60</span>     年龄<br>  gender    BIT                          默认为<span class="hljs-number">1</span>，表示男     性别<br>  score     REAL                                           成绩<br><br>create table student(<br>    <span class="hljs-keyword">id</span> INTEGER PRIMARY KEY AUTOINCREMENT,<br>    name VARCHAR(<span class="hljs-number">20</span>) NOT <span class="hljs-literal">NULL</span>,<br>    cid INTEGER,<br>    age INTEGER CHECK(age&gt;<span class="hljs-number">18</span> and age&lt;<span class="hljs-number">60</span>),<br>    gender BIT DEFAULT(<span class="hljs-number">1</span>),<br>    score REAL);<br><br>注：SQL中不区分大小写<br></code></pre></td></tr></table></figure><h2 id="insert插入语句"><a href="#insert插入语句" class="headerlink" title="insert插入语句"></a>insert插入语句</h2><p>数据库的操作无非四大类，增删改查这几种，因此必须要掌握这几种语句，insert增加也就是在数据表中添加信息</p><p>语法</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function">insert <span class="hljs-keyword">into</span> <span class="hljs-title">table1</span>(<span class="hljs-params">field1, field2</span>) <span class="hljs-title">values</span>(<span class="hljs-params">value1, value2</span>)</span>;<br>语法详解，在表名为table1的表的field1和field2字段分别插入value1和value2的值<br></code></pre></td></tr></table></figure><p>例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">给student表中的各个字段插入值<br><span class="hljs-function">insert <span class="hljs-keyword">into</span> <span class="hljs-title">student</span> (<span class="hljs-params">name, cid, age, gender, score</span>) <span class="hljs-title">values</span> (<span class="hljs-params"><span class="hljs-string">&#x27;tom&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">20</span>, <span class="hljs-number">1</span>, <span class="hljs-number">80.0</span></span>)</span>;<br></code></pre></td></tr></table></figure><p>注：其实可以在student后面不带有字段名，即name，cid···等，但如果不携带字段信息但看insert语句就无法直接明了的知道插入的value是给哪个字段赋值</p><h2 id="update更新语句"><a href="#update更新语句" class="headerlink" title="update更新语句"></a>update更新语句</h2><p>语法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp">update table1 <span class="hljs-keyword">set</span> field1=value1 <span class="hljs-keyword">where</span> 范围<br>语法详解：<span class="hljs-keyword">set</span>后面是某个字段要更改的值，<span class="hljs-keyword">where</span>表示限定field1字段<span class="hljs-keyword">value</span>值在某个范围内才需要修改<br><span class="hljs-keyword">set</span>表示要修改哪个字段的值<br><span class="hljs-keyword">where</span>表示修改字段值的范围<br></code></pre></td></tr></table></figure><p>例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">update student <span class="hljs-keyword">set</span> name=<span class="hljs-string">&#x27;jack&#x27;</span> <span class="hljs-keyword">where</span> name=<span class="hljs-string">&#x27;tom&#x27;</span>;<br>将student表中name字段中<span class="hljs-keyword">value</span>为tom的值修改为jack<br></code></pre></td></tr></table></figure><h2 id="select查询语句"><a href="#select查询语句" class="headerlink" title="select查询语句"></a>select查询语句</h2><p>select查询方法可以说是在数据库操作中使用最频繁的操作了，无论是想获取数据还是得知数据库中的信息都必须使用select语句，同时select语句也算得上在SQL语法中最复杂的语句了。</p><p>语法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp">基础查询：<br>    <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> table1 <span class="hljs-keyword">where</span> 范围<br>    语法详解：* 代表通配符，即所有的字段<br>    <span class="hljs-keyword">select</span> col1, col2, col3 <span class="hljs-keyword">from</span> table1 <span class="hljs-keyword">where</span> 范围;<br>    查看col1, col2, col3字段的信息<br><br>    例：<br><br>        <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> name=<span class="hljs-string">&quot;jack&quot;</span><br>        查询student表中名字叫jack的所有字段的信息<br><br>        <span class="hljs-keyword">select</span> id, name, score <span class="hljs-keyword">from</span> student;<br>        查询student表中所有学生的编号、名字、分数<br></code></pre></td></tr></table></figure><p>限制查询：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp">LIMIT关键字<br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> table1 LIMIT <span class="hljs-number">5</span>;<br>查询table1中前<span class="hljs-number">5</span>行中的数据，LIMIT关键字后面加数字可限定返回多少条数据<br>OFFSET关键字<br> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> table1 limit <span class="hljs-number">5</span> offset <span class="hljs-number">5</span>;<br> 查询table1中从第<span class="hljs-number">5</span>行起的<span class="hljs-number">5</span>行数据，OFFSET前面必须有LIMIT限定<br><br>例子：<br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> student limit <span class="hljs-number">5</span>;<br>查询table1中前<span class="hljs-number">5</span>行中的数据<br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> limit <span class="hljs-number">5</span> offset <span class="hljs-number">5</span>;<br>查询table1中从第<span class="hljs-number">5</span>行起的<span class="hljs-number">5</span>行数据<br></code></pre></td></tr></table></figure><p>排序查询：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs csharp">ORDER BY关键字<br><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> table1 order <span class="hljs-keyword">by</span> col1;<br>查询table1中所有数据，然后按照col1字段的升序排列（A-Z, <span class="hljs-number">0</span><span class="hljs-number">-9</span>)<br> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> table1 order <span class="hljs-keyword">by</span> col1, col2;<br> 查询table1中所有数据，然后先按照col1字段的排列，然后按照col2字段排序<br><br> 例子：<br>     <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> student order <span class="hljs-keyword">by</span> score;<br>     查询student中所有数据，然后按照score字段的升序排列<br>     <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> student order <span class="hljs-keyword">by</span> name, score;<br>     查询student中所有数据，然后先按照name字段的排列，然后按照score字段排序<br><br> DESC关键字<br> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> student order <span class="hljs-keyword">by</span> name, score DESC;<br> 查询student中所有数据，然后先按照name字段的排列，然后按照name字段降序排序<br> 注：DESC为降序排序，即（Z-A,<span class="hljs-number">9</span><span class="hljs-number">-0</span>)，DESC是DESCENDING缩写。<br>     DESC必须跟着ORDER BY关键字后面；<br>     DESC关键字只应用在直接位于其前面的列名；<br>     与DESC相反的是ASC(即ASCENDING)，在升序排序时可指定ASC，但这一关键字并没什么用处，因为升序是默认的<br></code></pre></td></tr></table></figure><h2 id="where过滤语句"><a href="#where过滤语句" class="headerlink" title="where过滤语句"></a>where过滤语句</h2><p>where是过滤语句，数据会根据where自居的搜索条件进行过滤，一般情况下where跟在insert、delete、update、select后面。这是一个需要值得注意的语句，使用它能够极大的提高查询数据库的效率，而使用delete语句如果不带上过滤语句，则会把数据表中的所有信息删除！</p><p>注：当ORDER BY关键字和where一起使用的时候，ORDER BY应该位于where后面，否则会报错。</p><p>where子句后面跟着的是过滤条件，过滤条件可使用逻辑符号，即&gt;、&lt;、=、!=等等逻辑符号，与计算机通用的逻辑符合并没有什么不同</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs csharp">例子：<br>    <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> score&gt;<span class="hljs-number">70.0</span> ORDER BY name;<br>    查询student表中成绩大于<span class="hljs-number">70</span>分的数据，同时按照名字升序排列<br><br>高级过滤：<br>    AND关键字：必须满足前后两个条件的数据<br>    <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> score&gt;<span class="hljs-number">60</span> <span class="hljs-keyword">and</span> score&lt; <span class="hljs-number">100</span>;<br>    查询student表中成绩大于<span class="hljs-number">60</span>分并且小于<span class="hljs-number">100</span>分的数据<br>    OR关键字：只要满足前后任意一个条件即可<br>    <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> score&gt;<span class="hljs-number">90</span> <span class="hljs-keyword">or</span> score&lt;<span class="hljs-number">70</span>;<br>    查询student表中成绩大于<span class="hljs-number">90</span>分并且或者小于<span class="hljs-number">70</span>分的数据<br><br>    AND和OR连用（<span class="hljs-keyword">and</span>的优先级比<span class="hljs-keyword">or</span>要高，两者连用的时候最后在各自的条件中添加圆括号（）进行分组）<br>    <span class="hljs-keyword">select</span> * <span class="hljs-function"><span class="hljs-keyword">from</span> student <span class="hljs-title">where</span> (<span class="hljs-params">score&gt;<span class="hljs-number">90</span> <span class="hljs-keyword">or</span> score&lt;<span class="hljs-number">70</span></span>) <span class="hljs-title">and</span> (<span class="hljs-params">age&gt;<span class="hljs-number">19</span></span>)</span>;<br><br>    BETWEEN关键字：<br>     <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> score between <span class="hljs-number">70</span> <span class="hljs-keyword">and</span> <span class="hljs-number">80</span>;<br>     查询student表中分数在<span class="hljs-number">70</span>至<span class="hljs-number">80</span>分之间的数据<br><br>    IN关键字：用于指定范围，范围中的每个条件都进行匹配，IN由一组逗号分隔、括在圆括号中的合法值<br>    <span class="hljs-keyword">select</span> * <span class="hljs-function"><span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> name <span class="hljs-title">in</span>(<span class="hljs-params"><span class="hljs-string">&#x27;tom&#x27;</span>, <span class="hljs-string">&#x27;Denesy&#x27;</span></span>)</span>;<br>    查询student表中名字为tom和Denesy的数据<br><br>    注：在指定要匹配值得清单的关键字中，IN和OR功能相当<br>    IN可与<span class="hljs-keyword">and</span>和<span class="hljs-keyword">or</span>等其他操作符使用<br>    IN操作符比一组OR操作符执行快<br>    可以包含其他的SELECT语句<br><br>    NOT关键字：否定其后条件的关键字<br>    <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> <span class="hljs-keyword">not</span> name=<span class="hljs-string">&#x27;tom&#x27;</span>;<br>    获取不包含名字为tom的信息<br>    <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> <span class="hljs-keyword">not</span> score&gt;<span class="hljs-number">80</span>;<br>    获取分数不是大于<span class="hljs-number">80</span>分的信息<br><br>    空值检查：<br>    <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> score <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">null</span>;<br>    查询student表中score字段不为空的信息<br></code></pre></td></tr></table></figure><h2 id="delete删除语句"><a href="#delete删除语句" class="headerlink" title="delete删除语句"></a>delete删除语句</h2><p>语法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp">delete <span class="hljs-keyword">from</span> table1 <span class="hljs-keyword">where</span> 范围<br>语法详解：从table中删除某一范围内的数据（只能一条一条的删除，不能删除某个字段中的值）<br>注：不要漏掉<span class="hljs-keyword">where</span>，否则会清空整个表中的信息<br></code></pre></td></tr></table></figure><p>例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp">delete <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> name=<span class="hljs-string">&#x27;tom&#x27;</span>;<br>从student表中删除名字为tom的信息<br><br>delete <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> score&lt; <span class="hljs-number">90</span>;<br>从student表中删除分数小于<span class="hljs-number">90</span>分的信息<br></code></pre></td></tr></table></figure><h2 id="Android中的数据库操作"><a href="#Android中的数据库操作" class="headerlink" title="Android中的数据库操作"></a>Android中的数据库操作</h2><p>Android中的数据库操作其实只要掌握了上面的SQLite的基本知识，那么就很简单了。<br>首先我们要创建一个类继承自SQLiteOpenHelper，这个类的作用在于创建数据库和数据表。在Android中已经帮我们封装好了创建数据库的方法，因此只要写好创建数据表的语句就好了，而创建数据表的方法是使用原生的SQL语法，仅仅如此就让你不得不学习SQL语法了。</p><p>MyDatabaseHelper代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyDatabaseHelper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SQLiteOpenHelper</span> </span>&#123;<br>    <span class="hljs-comment">// 创建Book数据表语法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String CREATE_BOOK = <span class="hljs-string">&quot;create table Book (&quot;</span><br>            + <span class="hljs-string">&quot;id integer primary key autoincrement, &quot;</span> <br>            + <span class="hljs-string">&quot;author text, &quot;</span><br>            + <span class="hljs-string">&quot;price real, &quot;</span> <br>            + <span class="hljs-string">&quot;pages integer, &quot;</span> <br>            + <span class="hljs-string">&quot;bookname text)&quot;</span>;<br>    <br>    <span class="hljs-comment">// 通过构造方法创建数据库，其中name为数据库名称</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyDatabaseHelper</span><span class="hljs-params">(Context context, String name)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(context, name, <span class="hljs-keyword">null</span>, <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(SQLiteDatabase db)</span> </span>&#123;<br>        <span class="hljs-comment">// 执行创建数据表的语法</span><br>        db.execSQL(CREATE_BOOK);<br>    &#125;<br>···<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数据库操作类"><a href="#数据库操作类" class="headerlink" title="数据库操作类"></a>数据库操作类</h3><p>为了方便大家阅读，这里将数据库操作都封装到一个类中，同时，将原本需要从外部传入的数据也直接在类中写入。<br>代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BookDao</span> &#123;<br>    <span class="hljs-keyword">private</span> MyDatabaseHelper helper;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BookDao</span>(<span class="hljs-params">Context context</span>)</span> &#123;<br>        helper = <span class="hljs-keyword">new</span> MyDatabaseHelper(context, <span class="hljs-string">&quot;BookStore.db&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 添加数据到Book表中        </span><br><span class="hljs-comment">     * @return    返回新插入的行号，如果插入失败返回-1</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">long</span> <span class="hljs-title">addData</span>(<span class="hljs-params"></span>)</span> &#123;<br>        SQLiteDatabase database = helper.getReadableDatabase();<br>        <span class="hljs-comment">// 使用anddroid封装的SQL语法</span><br>        ContentValues values = <span class="hljs-keyword">new</span> ContentValues();<br>        values.put(<span class="hljs-string">&quot;bookname&quot;</span>, <span class="hljs-string">&quot;The Da Vinci Code&quot;</span>);<br>        values.put(<span class="hljs-string">&quot;author&quot;</span>, <span class="hljs-string">&quot;Dan Brown&quot;</span>);<br>        values.put(<span class="hljs-string">&quot;pages&quot;</span>, <span class="hljs-number">454</span>);<br>        values.put(<span class="hljs-string">&quot;price&quot;</span>, <span class="hljs-number">16.96</span>);<br>        <span class="hljs-built_in">long</span> insert = database.insert(<span class="hljs-string">&quot;Book&quot;</span>, <span class="hljs-literal">null</span>, values);<br>        values.clear();<br>        values.put(<span class="hljs-string">&quot;bookname&quot;</span>, <span class="hljs-string">&quot;The Lost Symbol&quot;</span>);<br>        values.put(<span class="hljs-string">&quot;author&quot;</span>, <span class="hljs-string">&quot;Dan Brown&quot;</span>);<br>        values.put(<span class="hljs-string">&quot;pages&quot;</span>, <span class="hljs-number">510</span>);<br>        values.put(<span class="hljs-string">&quot;price&quot;</span>, <span class="hljs-number">19.95</span>);<br>        <span class="hljs-built_in">long</span> insert1 = database.insert(<span class="hljs-string">&quot;Book&quot;</span>, <span class="hljs-literal">null</span>, values);<br><br>        <span class="hljs-keyword">return</span> insert;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 更新Book表中的数据</span><br><span class="hljs-comment">     * @return    返回受影响的行</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">updateData</span>(<span class="hljs-params"></span>)</span> &#123;<br>        SQLiteDatabase database = helper.getReadableDatabase();<br>        <span class="hljs-comment">// 使用anddroid封装的SQL语法</span><br>        ContentValues values = <span class="hljs-keyword">new</span> ContentValues();<br>        values.put(<span class="hljs-string">&quot;price&quot;</span>, <span class="hljs-number">10.99</span>);<br>        <span class="hljs-built_in">int</span> update = database.update(<span class="hljs-string">&quot;Book&quot;</span>, values,  <span class="hljs-string">&quot;bookname = ?&quot;</span>, <span class="hljs-keyword">new</span> String[] &#123; <span class="hljs-string">&quot;The Da Vinci Code&quot;</span> &#125;);<br><br>        <span class="hljs-keyword">return</span> update;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除Book中的数据     </span><br><span class="hljs-comment">     * @return    返回受影响的行</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">delete</span>(<span class="hljs-params"></span>)</span> &#123;<br>        SQLiteDatabase database = helper.getReadableDatabase();<br>        <span class="hljs-comment">// 使用anddroid封装的SQL语法</span><br>        <span class="hljs-built_in">int</span> delete = database.delete(<span class="hljs-string">&quot;Book&quot;</span>, <span class="hljs-string">&quot;pages &gt; ?&quot;</span>, <span class="hljs-keyword">new</span> String[] &#123; <span class="hljs-string">&quot;500&quot;</span> &#125;);<br><br>        <span class="hljs-keyword">return</span> delete;    <br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 查询Book表中的数据</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">query</span>(<span class="hljs-params"></span>)</span> &#123;<br>        SQLiteDatabase database = helper.getReadableDatabase();<br>        <span class="hljs-comment">// 使用原生SQL语法</span><br>        Cursor cursor = database.query(<span class="hljs-string">&quot;Book&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;price=?&quot;</span>, <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;10.99&quot;</span>&#125;, <span class="hljs-string">&quot;bookname&quot;</span>, <span class="hljs-string">&quot;author=&#x27;Baby lin&#x27;&quot;</span>, <span class="hljs-string">&quot;author&quot;</span>);<br><br>        <span class="hljs-keyword">if</span> (cursor.moveToFirst()) &#123;<br>            <span class="hljs-keyword">do</span> &#123;<br>                String bookname = cursor.getString(cursor.getColumnIndex(<span class="hljs-string">&quot;bookname&quot;</span>));<br>                String author = cursor.getString(cursor.getColumnIndex(<span class="hljs-string">&quot;author&quot;</span>));<br>                <span class="hljs-built_in">int</span> pages = cursor.getInt(cursor.getColumnIndex(<span class="hljs-string">&quot;pages&quot;</span>));<br>                <span class="hljs-built_in">double</span> price = cursor.getDouble(cursor.getColumnIndex(<span class="hljs-string">&quot;price&quot;</span>));<br>                System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;书名：&quot;</span> + bookname + <span class="hljs-string">&quot;  作者：&quot;</span> + author + <span class="hljs-string">&quot;  页数&quot;</span> + pages + <span class="hljs-string">&quot;   价格&quot;</span> + price);<br>            &#125; <span class="hljs-keyword">while</span> (cursor.moveToNext());<br>        &#125;<br>        cursor.close();    <br>    &#125;    <br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码虽然有些长，但其功能却很简单，也就是实现了数据库的增删查改这是个方法。</p><p>首先我们看到每个方法都有这么一行代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">SQLiteDatabase database = helper.getReadableDatabase();<br></code></pre></td></tr></table></figure><p>这一行代码是通过MyDatabaseHelper使用父类SQLiteOpenHelper 中有两个非常重要的实例方法，getReadableDatabase() 和getWritableDatabase()。这两个方法都可以创建或打开一个现有的数据库（如果数据库已存在则直接打开，否则创建一个新的数据库），并返回一个可对数据库进行读写操作的对象。不同的是，当数据库不可写入的时候（如磁盘空间已满）getReadableDatabase()方法返回的对象将以只读的方式去打开数据库，而getWritableDatabase()方法则将出现异常。</p><h4 id="详解addData-方法"><a href="#详解addData-方法" class="headerlink" title="详解addData()方法"></a>详解addData()方法</h4><p>其次，在addData()插入数据中有ContentValue这个类，这个类是用来存储要插入数据表中的数据的。<br>举个比较熟悉的例子，如ArrayList数据列表，我们可以在它里面存储String或者HashMap&lt;key, value&gt;，而ContentValue就是类似ArrayList这样的容器。<br>实际上ContentValue里面存储的也是HashMap&lt;key, value&gt;。<br>通过ContentValue存储数据，然后再使用Android封装的insert方法，能够解析其中的数据，然后保存到数据表中。<br>其实深入Android中的insert方法，可以看到Android只是将insert方法中的参数取出还原为SQL原生语句，然后保存到数据表中。那么怎么在Android使用原生的SQL方法呢？android在SQLiteDatabase对象中封装了execSQL()方法，可直接使用，当然，execSQL()方法又有完全使用SQL语句，一半使用SQL语句一半使用Android参数的方法。下面是使用原生的SQL语句的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">addData</span><span class="hljs-params">()</span> </span>&#123;<br>    SQLiteDatabase database = helper.<span class="hljs-built_in">getReadableDatabase</span>();<br>    <br>    <span class="hljs-comment">// 使用原生SQL语法</span><br>    database.<span class="hljs-built_in">execSQL</span>(<span class="hljs-string">&quot;insert into Book(bookname, author, pages, price) values(&#x27;The Da Vinci Code&#x27;, &#x27;Dan Brown&#x27;, 454, 16.96)&quot;</span>);<br>    <br>    <span class="hljs-comment">// 使用原生与android封装方法，在values(?,?,?,?)有4个问号，</span><br>    <span class="hljs-comment">// 代表的是占位符，分别对应后面的String数组中的四个值。</span><br>    database.<span class="hljs-built_in">execSQL</span>(<span class="hljs-string">&quot;insert into Book(bookname, author, pages, price) values(?, ?, ?, ?)&quot;</span>, <br>            <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;The Lost Symbol&quot;</span>, <span class="hljs-string">&quot;Dan Brown&quot;</span>, <span class="hljs-string">&quot;510&quot;</span>, <span class="hljs-string">&quot;19.95&quot;</span>&#125;);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们看到如果使用原生的SQL语句来保存数据库，代码量减少了很多。但是android为什么推荐我们使用它封装的方法呢？这是因为使用原生SQL语法不能获取返回值，因此一但出现问题，会造成App崩溃；同时使用SQL语句的时候不能拼错单词或出现其他问题，否则也会崩溃。</p><p>同时我们看到使用SQL语句中保持的数字都是String，与数据表中的限定的值不同，这是因为在保存过程中只要数据类型正确，会自动将”510”还原为整数型。</p><h4 id="详解query-方法"><a href="#详解query-方法" class="headerlink" title="详解query()方法"></a>详解query()方法</h4><p>除此之外，需要特别注意的便是查询数据库的query()方法</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart">query(<span class="hljs-built_in">String</span> table, <span class="hljs-built_in">String</span>[] columns, <span class="hljs-built_in">String</span> selection,<br>        <span class="hljs-built_in">String</span>[] selectionArgs, <span class="hljs-built_in">String</span> groupBy, <span class="hljs-built_in">String</span> having,<br>        <span class="hljs-built_in">String</span> orderBy) ；<br></code></pre></td></tr></table></figure><p>这几个参数的意思是：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp">table：指定查询的表名，对应：<span class="hljs-keyword">from</span> table_name<br>columns：指定查询的列名，对应<span class="hljs-keyword">select</span> column1, column2<br>selection：指定<span class="hljs-keyword">where</span> 的约束条件，对应：<span class="hljs-keyword">where</span> column = <span class="hljs-keyword">value</span><br>selectionArgs：为<span class="hljs-keyword">where</span> 中的占位符提供具体的值<br>groupBy：指定需要<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> 的列，对应：<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> column<br>having：<span class="hljs-keyword">value</span> 对<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> 后的结果进一步约束，对应：having column = <span class="hljs-keyword">value</span><br>orderBy：指定查询结果的排序方式，对应：order <span class="hljs-keyword">by</span> column1, column2<br></code></pre></td></tr></table></figure><p>这些参数中在SQL语法中都是有的，其后面对应的是相应的SQL语句。<br>group By这个关键字是归组的意思，用于与 SELECT 语句一起使用，来对相同的数据进行分组。在 SELECT 语句中，GROUP BY 子句放在 WHERE 子句之后，放在 ORDER BY 子句之前。<br>也就是说如果使用GROUP BY子句，那么会见所有相同的字段的值合并为一条信息返回。<br>HAVING 子句允许指定条件来过滤将出现在最终结果中的分组结果。WHERE 子句在所选列上设置条件，而 HAVING 子句则在由 GROUP BY 子句创建的分组上设置条件。</p><p>为了获取查询结构，首先插入这些数据：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">database.execSQL(<br>        <span class="hljs-string">&quot;insert into Book(bookname, author, pages, price) values(&#x27;The Da Vinci Code&#x27;, &#x27;Dan Brown&#x27;, 454, 16.96)&quot;</span>);<br>database.execSQL(<br>        <span class="hljs-string">&quot;insert into Book(bookname, author, pages, price) values(&#x27;The Lost Symbol&#x27;, &#x27;Dan Brown&#x27;, 510, 19.95)&quot;</span>);<br>database.execSQL(<br>        <span class="hljs-string">&quot;insert into Book(bookname, author, pages, price) values(&#x27;piao liu chuan shuo&#x27;, &#x27;Baby lin&#x27;, 189, 12.99)&quot;</span>);<br>database.execSQL(<br>        <span class="hljs-string">&quot;insert into Book(bookname, author, pages, price) values(&#x27;lv bing xun chuan qi&#x27;, &#x27;Baby lin&#x27;, 470, 10.99)&quot;</span>);<br>database.execSQL(<br>        <span class="hljs-string">&quot;insert into Book(bookname, author, pages, price) values(&#x27;bing yu huo zhi ge&#x27;, &#x27;Dan Brown&#x27;, 624, 10.99)&quot;</span>);<br>database.execSQL(<br>        <span class="hljs-string">&quot;insert into Book(bookname, author, pages, price) values(&#x27;bing yu huo zhi ge&#x27;, &#x27;Dan Brown&#x27;, 624, 10.99)&quot;</span>);<br>database.execSQL(<br>        <span class="hljs-string">&quot;insert into Book(bookname, author, pages, price) values(&#x27;wo yao du shu&#x27;, &#x27;Dan Brown&#x27;, 510, 10.99)&quot;</span>);<br></code></pre></td></tr></table></figure><p>他们只有些许的区别，现在我们想查询价格是10.99元，然后按照bookname进行归组，找出组里作者是Baby lin的那条信息，最后按照author排序（实质只有一条信息，没必要排序）。<br>这条信息由两种写法，一种是上面代码演示的，一种用原生SQL，如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Cursor cursor = database.rawQuery(<br>            <span class="hljs-string">&quot;select * from Book where price=10.99 group by bookname having author=&#x27;Baby lin&#x27; order by author&quot;</span>, <span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure><p>这两种写法都可以的到Cursor这个对象，然后通过Cursor获得数据库中的数据。<br>Cursor的用法相对固定，通过while遍历，每次使用cursor.moveToNext()将游标移到下一行数据，如果能移动下一行数据则返回True，否则为false。<br>cursor.getString(int index)或者cursor.getInt(int index)传入相应字段在数据表中的排序便能获得在当前行的字段的值。</p><h4 id="修改和删除"><a href="#修改和删除" class="headerlink" title="修改和删除"></a>修改和删除</h4><p>修改和删除就比前面两种方法简单多了。<br>修改update数据表的三种方法：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// 使用anddroid封装的SQL语法</span><br>ContentValues values = <span class="hljs-keyword">new</span> ContentValues();<br>values.put(<span class="hljs-string">&quot;price&quot;</span>, <span class="hljs-number">10.99</span>);<br><span class="hljs-built_in">int</span> update = database.update(<span class="hljs-string">&quot;Book&quot;</span>, values, <span class="hljs-string">&quot;bookname = ?&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>[] &#123; <span class="hljs-string">&quot;The Da Vinci Code&quot;</span> &#125;);<br><span class="hljs-comment">// 使用原生SQL语法</span><br><span class="hljs-comment">// database.execSQL(&quot;update Book SET price=10.99 where bookname=&#x27;The Da</span><br><span class="hljs-comment">// Vinci Code&#x27; &quot;);</span><br><span class="hljs-comment">// 使用原生与android封装方法</span><br><span class="hljs-comment">// database.execSQL(&quot;update Book SET price=? where bookname=? &quot;, new String[] &#123; &quot;10.99&quot;, &quot;The Da Vinci Code&quot; &#125;);</span><br></code></pre></td></tr></table></figure><p>删除delete数据表的三种方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> <span class="hljs-keyword">delete</span> = database.<span class="hljs-built_in"><span class="hljs-keyword">delete</span></span>(<span class="hljs-string">&quot;Book&quot;</span>, <span class="hljs-string">&quot;pages &gt; ?&quot;</span>, <span class="hljs-keyword">new</span> String[] &#123; <span class="hljs-string">&quot;500&quot;</span> &#125;);<br><span class="hljs-comment">// 使用原生SQL语法</span><br><span class="hljs-comment">// database.execSQL(&quot;delete from Book where pages &gt; 500&quot;);</span><br><span class="hljs-comment">// 使用原生与android封装方法</span><br><span class="hljs-comment">// database.execSQL(&quot;delete from Book where pages &gt; ?&quot;, new String[] &#123; &quot;500&quot; &#125;);</span><br></code></pre></td></tr></table></figure><p>以上就是android中对于数据库操作的全部内容了！</p><h2 id="内容提供者"><a href="#内容提供者" class="headerlink" title="内容提供者"></a>内容提供者</h2><p>研究完数据库，那么与数据库密切相关的内容提供者就不得不说说的，因为内容提供者也是依赖于数据库的实现的。<br>内容提供者也就是将当前应用的数据提供出去给其他的app使用，这是一个很好的功能，可惜一般情况下没有人会使用你的应用的信息，因为不知道是不是有陷阱。当然啦，支付宝、微博这些肯定会有人用的。<br>言归正传，我们来说说如何构建一个内容提供者,在这里以上一个项目的数据库作为内容提供者。</p><h3 id="创建一个类继承自ContentProvider"><a href="#创建一个类继承自ContentProvider" class="headerlink" title="创建一个类继承自ContentProvider"></a>创建一个类继承自ContentProvider</h3><p>ContentProvider有六个方法必须实现，他们是onCreate()和getType()以及数据库的增删查改四个方法，其中他们每个方法都会使用的Uri参数，这个参数是调用ContentResolver内容解析者的增删改查方法时传递过来的。</p><p>我们首先创建MyContentProvider继承ContentProvider。<br>然后在AndroidManifest.xml的application中添加内容提供者的注册清单：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">provider</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;com.example.databasecontentprovider.MyContentProvider&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:authorities</span>=<span class="hljs-string">&quot;com.example.databasecontentprovider.provider&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:exported</span>=<span class="hljs-string">&quot;true&quot;</span> &gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">provider</span>&gt;</span><br></code></pre></td></tr></table></figure><p>其中android:name是ContentProvider的全类名，android:authorities 属性中指定了该内容提供器的权限，android:exported表示该应用是否可供外部访问。</p><p>然后回到MyContentProvider中，我们写下以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyContentProvider</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ContentProvider</span></span>&#123;<br>    <span class="hljs-comment">//定一个一个uri路径匹配器</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> UriMatcher sUrimatcher = <span class="hljs-keyword">new</span> UriMatcher(UriMatcher.NO_MATCH);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> QUERYSUCESS = <span class="hljs-number">0</span>;  <span class="hljs-comment">//ctrl+shift+X  变大写   小写加y</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> INSERTSUCESS = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> UPDATESUCESS = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DELETESUCESS = <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">private</span> MyDatabaseHelper databaseHelper;<br>    <br>    <span class="hljs-keyword">static</span> &#123;<br>        sUrimatcher.addURI(<span class="hljs-string">&quot;com.example.databasecontentprovider.provider&quot;</span>, <span class="hljs-string">&quot;query&quot;</span>, QUERYSUCESS);<br>        sUrimatcher.addURI(<span class="hljs-string">&quot;com.example.databasecontentprovider.provider&quot;</span>, <span class="hljs-string">&quot;insert&quot;</span>, INSERTSUCESS);<br>        sUrimatcher.addURI(<span class="hljs-string">&quot;com.example.databasecontentprovider.provider&quot;</span>, <span class="hljs-string">&quot;update&quot;</span>, UPDATESUCESS);<br>        sUrimatcher.addURI(<span class="hljs-string">&quot;com.example.databasecontentprovider.provider&quot;</span>, <span class="hljs-string">&quot;delete&quot;</span>, DELETESUCESS);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onCreate</span><span class="hljs-params">()</span> </span>&#123;<br>        databaseHelper = <span class="hljs-keyword">new</span> MyDatabaseHelper(getContext(), <span class="hljs-string">&quot;BookStore.db&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Cursor <span class="hljs-title">query</span><span class="hljs-params">(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> code = sUrimatcher.match(uri);<br>        <span class="hljs-keyword">if</span> (code == QUERYSUCESS) &#123;<br>            SQLiteDatabase readableDatabase = databaseHelper.getReadableDatabase();<br>            Cursor cursor = readableDatabase.query(<span class="hljs-string">&quot;Book&quot;</span>, projection, selection, selectionArgs, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, sortOrder);<br>            <span class="hljs-keyword">return</span> cursor;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getType</span><span class="hljs-params">(Uri uri)</span> </span>&#123;<br>        <span class="hljs-comment">// TODO Auto-generated method stub</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Uri <span class="hljs-title">insert</span><span class="hljs-params">(Uri uri, ContentValues values)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> code = sUrimatcher.match(uri);<br>        <span class="hljs-keyword">if</span> (code == INSERTSUCESS)&#123;<br>            SQLiteDatabase readableDatabase = databaseHelper.getReadableDatabase();<br>            <span class="hljs-keyword">long</span> insert = readableDatabase.insert(<span class="hljs-string">&quot;Book&quot;</span>, <span class="hljs-keyword">null</span>, values);<br>            Uri myUri = Uri.parse(<span class="hljs-string">&quot;com.youCanDoIt/&quot;</span> + insert);<br>            <span class="hljs-keyword">return</span> myUri;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">delete</span><span class="hljs-params">(Uri uri, String selection, String[] selectionArgs)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> code = sUrimatcher.match(uri);<br>        <span class="hljs-keyword">if</span> (code == DELETESUCESS) &#123;<br>            SQLiteDatabase readableDatabase = databaseHelper.getReadableDatabase();<br>            <span class="hljs-keyword">int</span> delete = readableDatabase.delete(<span class="hljs-string">&quot;Book&quot;</span>, selection, selectionArgs);<br>            <span class="hljs-keyword">return</span> delete;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">update</span><span class="hljs-params">(Uri uri, ContentValues values, String selection, String[] selectionArgs)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> code = sUrimatcher.match(uri);<br>        <span class="hljs-keyword">if</span> (code == UPDATESUCESS)&#123;<br>            SQLiteDatabase readableDatabase = databaseHelper.getReadableDatabase();<br>            <span class="hljs-keyword">int</span> update = readableDatabase.update(<span class="hljs-string">&quot;Book&quot;</span>, values, selection, selectionArgs);<br>            <span class="hljs-keyword">return</span> update;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>其中UriMatcher这个实用类，我们可以当作是路径匹配器，它添加访问需要的路径名。<br>在UriMatcher构造方法中有UriMatcher.NO_MATCH这个参数，表示的是Uri不匹配时返回的code<br>其中</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">sUrimatcher<span class="hljs-selector-class">.addURI</span>(&quot;com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.databasecontentprovider</span><span class="hljs-selector-class">.provider</span>&quot;, &quot;query&quot;, QUERYSUCESS);<br></code></pre></td></tr></table></figure><p>这个方法，第一个参数这是在AndroidManifest.xml中内容提供者注册清单中的authorities，第二个参数需要匹配的路径名，第三个参数这是路径匹配时所返回的值。<br>那么query这个路径该怎么访问呢？<br>这时使用</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">Uri</span> url = <span class="hljs-built_in">Uri</span>.parse(<span class="hljs-string">&quot;content://com.example.databasecontentprovider.provider/query&quot;</span>);<br></code></pre></td></tr></table></figure><p>就能够解析这个路径，其中content://是协议，跟http://差不多。</p><p>设置好匹配器，也设置了访问路径，接下来就是提供给外部的权限方法了，现在我们先让其他的app有对数据库增删查改的方法，那么就要重新MyContentProvider中增删查改是个方法。<br>首先判断sUrimatcher.match(uri)是否能够匹配传过来的uri，如果返回的值刚好就与定义好的值相等，那么就返回这里增删查改方法中要返回的数据类型。<br>如public Cursor query(···）中要返回一个Cursor游标，那么就返回一个Cursor对象。<br>而public Uri insert( ···)最特殊，它要返回一个Uri，事实上这个Uri可以自定义，只需要符合相应规则就行，即com.xxxx即可，它最大的功能是让外部应用得到是否成功执行插入数据的操作。</p><p>这样一来，一个内容提供者就完成了。<br>总结一下，有以下几个步骤：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">1、定义内容提供者 定义一个类继承contentProvider  <br>2、在清单文件里面配置一下 内容提供者<br>3、定义一个Urimatcher <br>4、写一个静态代码块 ，添加匹配规则 <br>5、按照我们添加的匹配规则，暴露想暴露的方法 <br></code></pre></td></tr></table></figure><h2 id="内容访问者"><a href="#内容访问者" class="headerlink" title="内容访问者"></a>内容访问者</h2><p>内容提供者设置好之后，便要有访问者，内容访问者很简单，只要得到Uri路径，然后使用ContentResolver内容访问者就好了。<br>我们新建一个MyContentResolver应用，添加增删查改四个按钮，然后在MainActivity中添加以下代码：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs dart">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Activity</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    protected <span class="hljs-keyword">void</span> onCreate(Bundle savedInstanceState) &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_main);<br>        Button addData = (Button) findViewById(R.id.add_data);<br>        Button queryData = (Button) findViewById(R.id.query_data);<br>        Button updateData = (Button) findViewById(R.id.update_data);<br>        Button deleteData = (Button) findViewById(R.id.delete_data);<br>        <br>        addData.setOnClickListener(<span class="hljs-keyword">new</span> OnClickListener() &#123;<br>            <br>            <span class="hljs-meta">@Override</span><br>            public <span class="hljs-keyword">void</span> onClick(View v) &#123;<br>                <span class="hljs-built_in">Uri</span> url = <span class="hljs-built_in">Uri</span>.parse(<span class="hljs-string">&quot;content://com.example.databasecontentprovider.provider/insert&quot;</span>);<br>                ContentValues values = <span class="hljs-keyword">new</span> ContentValues();<br>                values.put(<span class="hljs-string">&quot;bookname&quot;</span>, <span class="hljs-string">&quot;A Clash of Kings&quot;</span>);<br>                values.put(<span class="hljs-string">&quot;author&quot;</span>, <span class="hljs-string">&quot;George Martin&quot;</span>);<br>                values.put(<span class="hljs-string">&quot;pages&quot;</span>, <span class="hljs-number">1040</span>);<br>                values.put(<span class="hljs-string">&quot;price&quot;</span>, <span class="hljs-number">55.55</span>);<br>                ContentResolver contentResolver = getContentResolver();<br>                <span class="hljs-built_in">Uri</span> insert = contentResolver.insert(url, values);<br>                System.out.println(insert);<br>            &#125;<br>        &#125;);<br>        <br>        queryData.setOnClickListener(<span class="hljs-keyword">new</span> OnClickListener() &#123;<br>            <br>            <span class="hljs-meta">@Override</span><br>            public <span class="hljs-keyword">void</span> onClick(View v) &#123;<br>                <span class="hljs-built_in">Uri</span> url = <span class="hljs-built_in">Uri</span>.parse(<span class="hljs-string">&quot;content://com.example.databasecontentprovider.provider/query&quot;</span>);    <br>                ContentResolver contentResolver = getContentResolver();<br>                Cursor query = contentResolver.query(url, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<br>                <span class="hljs-keyword">if</span> (query != <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-keyword">while</span> (query.moveToNext())&#123;<br>                        <span class="hljs-built_in">String</span> autor = query.getString(<span class="hljs-number">1</span>);<br>                        <span class="hljs-built_in">String</span> prices = query.getString(<span class="hljs-number">2</span>);<br>                        <span class="hljs-built_in">String</span> pages = query.getString(<span class="hljs-number">3</span>);<br>                        <span class="hljs-built_in">String</span> bookname = query.getString(<span class="hljs-number">4</span>);<br>                        System.out.println(autor + <span class="hljs-string">&quot;   &quot;</span> + prices + <span class="hljs-string">&quot;   &quot;</span> + pages +<span class="hljs-string">&quot;   &quot;</span> + bookname);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;);<br>        <br>        updateData.setOnClickListener(<span class="hljs-keyword">new</span> OnClickListener() &#123;<br>            <br>            <span class="hljs-meta">@Override</span><br>            public <span class="hljs-keyword">void</span> onClick(View v) &#123;<br>                <span class="hljs-built_in">Uri</span> url = <span class="hljs-built_in">Uri</span>.parse(<span class="hljs-string">&quot;content://com.example.databasecontentprovider.provider/update&quot;</span>);<br>                ContentValues values = <span class="hljs-keyword">new</span> ContentValues();<br>                values.put(<span class="hljs-string">&quot;bookname&quot;</span>, <span class="hljs-string">&quot;A Storm of Swords&quot;</span>);<br>                values.put(<span class="hljs-string">&quot;pages&quot;</span>, <span class="hljs-number">1216</span>);<br>                values.put(<span class="hljs-string">&quot;price&quot;</span>, <span class="hljs-number">24.05</span>);    <br>                ContentResolver contentResolver = getContentResolver();<br>                <span class="hljs-built_in">int</span> update = contentResolver.update(url, values, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<br>                System.out.println(<span class="hljs-string">&quot;更新了&quot;</span> + update + <span class="hljs-string">&quot;条数据&quot;</span>);<br>            &#125;<br>        &#125;);<br>        <br>        deleteData.setOnClickListener(<span class="hljs-keyword">new</span> OnClickListener() &#123;<br>            <br>            <span class="hljs-meta">@Override</span><br>            public <span class="hljs-keyword">void</span> onClick(View v) &#123;<br>                <span class="hljs-built_in">Uri</span> url = <span class="hljs-built_in">Uri</span>.parse(<span class="hljs-string">&quot;content://com.example.databasecontentprovider.provider/delete&quot;</span>);<br>                ContentResolver contentResolver = getContentResolver();<br>                <span class="hljs-built_in">int</span> delete = contentResolver.delete(url, <span class="hljs-string">&quot;bookname = ?&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>[]&#123;<span class="hljs-string">&quot;A Storm of Swords&quot;</span>&#125;);<br>                System.out.println(<span class="hljs-string">&quot;删除了&quot;</span> + delete + <span class="hljs-string">&quot;条数据&quot;</span>);<br>            &#125;<br>        &#125;);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>在这里，我们通过Activity中的getContentResolver()得到ContentResolver()，然后通过ContentResolver对象传出想要修改或查询的数据。当然在这里就不能够写SQL原生的语句了，只能够按照Android的封装的方法来走。<br>内容解析者的操作简略为以下几步：<br>1、通过Uri地址获取Uri对象<br>2、通过getContentResolver()得到ContentResolver对象<br>3、通过ContentResolver对象进行增删改查等动作，方法与数据库操作基本相同。</p><p>好了，这篇文章就到此结束，写的还停长的，但实质上就只有这三方面的内容：<br>SQLite操作以及SQL基本语法；<br>Android中的数据库操作；<br>Android中的内容提供者和内容解析者；</p><h2 id="补充小知识"><a href="#补充小知识" class="headerlink" title="补充小知识"></a>补充小知识</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs css">使用adb进入模拟器：当有多个模拟器开启式使用以下方式<br>    adb -s emulator-<span class="hljs-number">5554</span> shell<br>其中emulator-<span class="hljs-number">5554</span>是你的设备代号，在dos窗口下使用adb devices列出当前所有的设备<br><br>-：普通文件<br>d：目录<br>r：可读<br>w：可写<br>x：可读可写可执行<br><br>直接更改数据库权限为可读可写可执行（在dos窗口中更改数据库全新）：chmod <span class="hljs-number">777</span> xxx<span class="hljs-selector-class">.db</span><br><br>创建或打开D盘中的数据库，在dos窗口：sqlite3<span class="hljs-selector-class">.exe</span> d:\test.db<br><br>然后创建表<br><br>此时如果在D盘中原本没有test.db这个数据库，那么在你创建表的时候会直接创建数据库和表<br><br>.table  展示数据库中已经拥有的表名<br><br>.schema 展示表的创建语句<br></code></pre></td></tr></table></figure><p>项目地址：</p><blockquote><p><a href="https://link.jianshu.com/?t=https://github.com/liaozhoubei/DatabaseContentProvider">https://github.com/liaozhoubei/DatabaseContentProvider</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo整理</title>
    <link href="/posts/a7d9bd28/"/>
    <url>/posts/a7d9bd28/</url>
    
    <content type="html"><![CDATA[<h1 id="简单安装"><a href="#简单安装" class="headerlink" title="简单安装"></a>简单安装</h1><p><a href="https://hexo.io/zh-cn/docs/">hexo官网</a></p><h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装<code>git</code></h2><p>​    不再赘述</p><h1 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装<code>node.js</code></h1><p>可以通过以下命令查看主机中是否安装了<code>node.js</code>和<code>npm</code></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">$ <span class="hljs-keyword">node</span> <span class="hljs-title">--version</span>    <span class="hljs-comment">#检查是否安装了node.js</span><br>$ npm --<span class="hljs-keyword">version</span>     <span class="hljs-comment">#检查是否安装了npm</span><br></code></pre></td></tr></table></figure><p>如下所示表示已经安装了<code>node.js</code>和<code>npm</code></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">root</span>@***:~# node --version<br><span class="hljs-attribute">v8</span>.<span class="hljs-number">11</span>.<span class="hljs-number">3</span><br><span class="hljs-attribute">root</span>@***:~# npm --version<br><span class="hljs-attribute">6</span>.<span class="hljs-number">7</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><a href="https://nodejs.org/en/download/package-manager/">没有安装的话查看官方指南</a></p><h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装<code>hexo</code></h2><ul><li>使用<code>npm</code>安装    </li></ul><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">$ npm install -g hexo-<span class="hljs-keyword">cli</span><br></code></pre></td></tr></table></figure><ul><li><p>安装以后，可以使用以下两种方式执行 <code>Hexo</code>：</p><ol><li><code>npx hexo &lt;command&gt;</code></li><li>将 <code>Hexo</code> 所在的目录下的 <code>node_modules</code> 添加到环境变量之中即可直接使用 <code>hexo &lt;command&gt;</code>：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">复制hexo所在目录中<span class="hljs-string">&quot;node_modules/.bin&quot;</span>目录位置，在<span class="hljs-string">&quot;~/.profile&quot;</span>或<span class="hljs-string">&quot;~/.bash_profile&quot;</span>或<span class="hljs-string">&quot;~/.zshrc&quot;</span>中写入环境变量<br>例如<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-string">&quot;<span class="hljs-variable">$PATH</span>:~/存档/BlogsRepo/blogs/node_modules/.bin&quot;</span><br>我使用的zsh,在<span class="hljs-string">&quot;~/.zshrc&quot;</span>我中写入.<br><br>或使用<span class="hljs-built_in">echo</span>命令写入文件<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;PATH=&quot;$PATH:~/存档/BlogsRepo/blogs/node_modules/.bin&quot;&#x27;</span> &gt;&gt; ~/.zshrc<br></code></pre></td></tr></table></figure></li></ul><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><ul><li>初始化hexo（在自己建立的任意文件夹里，如果没有添加环境变量，需要使用<code>npx hexo &lt;command&gt;</code>）</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> hexo init &lt;folder&gt;<br><span class="hljs-variable">$</span> <span class="hljs-built_in">cd</span> &lt;folder&gt;<br><span class="hljs-variable">$</span> npm install<br></code></pre></td></tr></table></figure><ul><li>接下来,输入两条命令</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs verilog">hexo <span class="hljs-keyword">generate</span>  <br>hexo server  <br>或者输入命令的简写:  <br>hexo g<br>hexo s<br></code></pre></td></tr></table></figure><p>解释:<br>首先执行”hexo generate”生成相应的静态网页，生成的静态网页以及相关资源都会在public目录下<br>hexo-server模块的主要命令如下，输入”hexo generate”以启动服务器，您的网站会在 <a href="http://localhost:4000/">http://localhost:4000</a> 下启动。在服务器启动期间，Hexo 会监视文件变动并自动更新，您无须重启服务器。<br>注: 如果您想要更改端口，或是在执行时遇到了 EADDRINUSE 错误，可以在执行时使用 -p 选项指定其他端口，如下:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">hexo</span> server -p <span class="hljs-number">5000</span><br></code></pre></td></tr></table></figure><ul><li>接下来, 将hexo部署到github</li></ul><ol><li>安装Git部署插件，输入命令：</li></ol><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install hexo-deployer-git <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><ol start="2"><li>将我们的Hexo与GitHub关联起来，打开站点的配置文件_config.yml，翻到最后修改为：</li></ol><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">type:</span> git<br><span class="hljs-symbol">repo:</span> 博客的仓库地址，用ssh的地址，不要用https的地址<br><span class="hljs-symbol">branch:</span> master<br><span class="hljs-symbol">ps:</span>注意缩进<br></code></pre></td></tr></table></figure><p>其实就是给hexo d 这个命令做相应的配置，让hexo知道你要把blog部署在哪个位置，很显然，我们部署在我们GitHub的仓库里。</p><p>接着，我们分别输入三条命令：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs excel">hexo <span class="hljs-built_in">clean</span> <br>hexo g <br>hexo d  将会部署到github<br></code></pre></td></tr></table></figure><p>全部完成  </p><h1 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h1><ul><li><a href="https://github.com/zthxxx/hexo-theme-Wikitten">wiki样式</a></li><li><a href="https://github.com/jerryc127/hexo-theme-butterfly">md样式<code>hexo-theme-butterfly</code></a></li><li> <a href="https://github.com/bollnh/hexo-theme-material">md样式<code>hexo-theme-material</code></a></li><li><a href="https://github.com/fluid-dev/hexo-theme-fluid">md样式<code>hexo-theme-fluid</code></a></li></ul><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>您可以在 <code>_config.yml</code> 中修改大部分的配置。</p><h2 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h2><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>title</code></td><td align="left">网站标题</td></tr><tr><td align="left"><code>subtitle</code></td><td align="left">网站副标题</td></tr><tr><td align="left"><code>description</code></td><td align="left">网站描述</td></tr><tr><td align="left"><code>keywords</code></td><td align="left">网站的关键词。支持多个关键词。</td></tr><tr><td align="left"><code>author</code></td><td align="left">您的名字</td></tr><tr><td align="left"><code>language</code></td><td align="left">网站使用的语言。对于简体中文用户来说，使用不同的主题可能需要设置成不同的值，请参考你的主题的文档自行设置，常见的有 <code>zh-Hans</code>和 <code>zh-CN</code>。</td></tr><tr><td align="left"><code>timezone</code></td><td align="left">网站时区。Hexo 默认使用您电脑的时区。请参考 <a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones">时区列表</a> 进行设置，如 <code>America/New_York</code>, <code>Japan</code>, 和 <code>UTC</code> 。一般的，对于中国大陆地区可以使用 <code>Asia/Shanghai</code>。</td></tr></tbody></table><p>其中，<code>description</code>主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。<code>author</code>参数用于主题显示文章的作者。</p><h2 id="网址"><a href="#网址" class="headerlink" title="网址"></a>网址</h2><table><thead><tr><th align="left">参数</th><th align="left">描述</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left"><code>url</code></td><td align="left">网址, 必须以 <code>http://</code> 或 <code>https://</code> 开头</td><td align="left"></td></tr><tr><td align="left"><code>root</code></td><td align="left">网站根目录</td><td align="left"><code>url&#39;s pathname</code></td></tr><tr><td align="left"><code>permalink</code></td><td align="left">文章的 <a href="https://hexo.io/zh-cn/docs/permalinks">永久链接</a> 格式</td><td align="left"><code>:year/:month/:day/:title/</code></td></tr><tr><td align="left"><code>permalink_defaults</code></td><td align="left">永久链接中各部分的默认值</td><td align="left"></td></tr><tr><td align="left"><code>pretty_urls</code></td><td align="left">改写 <a href="https://hexo.io/zh-cn/docs/variables"><code>permalink</code></a> 的值来美化 URL</td><td align="left"></td></tr><tr><td align="left"><code>pretty_urls.trailing_index</code></td><td align="left">是否在永久链接中保留尾部的 <code>index.html</code>，设置为 <code>false</code> 时去除</td><td align="left"><code>true</code></td></tr><tr><td align="left"><code>pretty_urls.trailing_html</code></td><td align="left">是否在永久链接中保留尾部的 <code>.html</code>, 设置为 <code>false</code> 时去除 (<em>对尾部的 <code>index.html</code>无效</em>)</td><td align="left"><code>true</code></td></tr></tbody></table><blockquote><p>网站存放在子目录</p><p>如果您的网站存放在子目录中，例如 <code>http://example.com/blog</code>，则请将您的 <code>url</code> 设为 <code>http://example.com/blog</code> 并把 <code>root</code> 设为 <code>/blog/</code>。</p></blockquote><p>例如：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-meta"># 比如，一个页面的永久链接是 http:<span class="hljs-comment">//example.com/foo/bar/index.html</span></span><br><span class="hljs-symbol">pretty_urls:</span><br><span class="hljs-symbol">  trailing_index:</span> false<br><span class="hljs-meta"># 此时页面的永久链接会变为 http:<span class="hljs-comment">//example.com/foo/bar/</span></span><br></code></pre></td></tr></table></figure><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><table><thead><tr><th align="left">参数</th><th align="left">描述</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left"><code>source_dir</code></td><td align="left">资源文件夹，这个文件夹用来存放内容。</td><td align="left"><code>source</code></td></tr><tr><td align="left"><code>public_dir</code></td><td align="left">公共文件夹，这个文件夹用于存放生成的站点文件。</td><td align="left"><code>public</code></td></tr><tr><td align="left"><code>tag_dir</code></td><td align="left">标签文件夹</td><td align="left"><code>tags</code></td></tr><tr><td align="left"><code>archive_dir</code></td><td align="left">归档文件夹</td><td align="left"><code>archives</code></td></tr><tr><td align="left"><code>category_dir</code></td><td align="left">分类文件夹</td><td align="left"><code>categories</code></td></tr><tr><td align="left"><code>code_dir</code></td><td align="left">Include code 文件夹，<code>source_dir</code> 下的子目录</td><td align="left"><code>downloads/code</code></td></tr><tr><td align="left"><code>i18n_dir</code></td><td align="left">国际化（i18n）文件夹</td><td align="left"><code>:lang</code></td></tr><tr><td align="left"><code>skip_render</code></td><td align="left">跳过指定文件的渲染。匹配到的文件将会被不做改动地复制到 <code>public</code> 目录中。您可使用 <a href="https://github.com/micromatch/micromatch#extended-globbing">glob 表达式</a>来匹配路径。</td><td align="left"></td></tr></tbody></table><p>例如：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gradle">skip_render: <span class="hljs-string">&quot;mypage/**/*&quot;</span><br># 将会直接将 `<span class="hljs-keyword">source</span><span class="hljs-regexp">/mypage/i</span>ndex.html` 和 `<span class="hljs-keyword">source</span><span class="hljs-regexp">/mypage/</span>code.js` 不做改动地输出到 <span class="hljs-string">&#x27;public&#x27;</span> 目录<br># 你也可以用这种方法来跳过对指定文章文件的渲染<br>skip_render: <span class="hljs-string">&quot;_posts/test-post.md&quot;</span><br># 这将会忽略对 <span class="hljs-string">&#x27;test-post.md&#x27;</span> 的渲染<br></code></pre></td></tr></table></figure><blockquote><p>提示</p><p>如果您刚刚开始接触 Hexo，通常没有必要修改这一部分的值。</p></blockquote><h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><table><thead><tr><th align="left">参数</th><th align="left">描述</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left"><code>new_post_name</code></td><td align="left">新文章的文件名称</td><td align="left">:title.md</td></tr><tr><td align="left"><code>default_layout</code></td><td align="left">预设布局</td><td align="left">post</td></tr><tr><td align="left"><code>auto_spacing</code></td><td align="left">在中文和英文之间加入空格</td><td align="left">false</td></tr><tr><td align="left"><code>titlecase</code></td><td align="left">把标题转换为 title case</td><td align="left">false</td></tr><tr><td align="left"><code>external_link</code></td><td align="left">在新标签中打开链接</td><td align="left">true</td></tr><tr><td align="left"><code>external_link.enable</code></td><td align="left">在新标签中打开链接</td><td align="left"><code>true</code></td></tr><tr><td align="left"><code>external_link.field</code></td><td align="left">对整个网站（<code>site</code>）生效或仅对文章（<code>post</code>）生效</td><td align="left"><code>site</code></td></tr><tr><td align="left"><code>external_link.exclude</code></td><td align="left">需要排除的域名。主域名和子域名如 <code>www</code> 需分别配置</td><td align="left"><code>[]</code></td></tr><tr><td align="left"><code>filename_case</code></td><td align="left">把文件名称转换为 (1) 小写或 (2) 大写</td><td align="left">0</td></tr><tr><td align="left"><code>render_drafts</code></td><td align="left">显示草稿</td><td align="left">false</td></tr><tr><td align="left"><code>post_asset_folder</code></td><td align="left">启动 <a href="https://hexo.io/zh-cn/docs/asset-folders">Asset 文件夹</a></td><td align="left">false</td></tr><tr><td align="left"><code>relative_link</code></td><td align="left">把链接改为与根目录的相对位址</td><td align="left">false</td></tr><tr><td align="left"><code>future</code></td><td align="left">显示未来的文章</td><td align="left">true</td></tr><tr><td align="left"><code>highlight</code></td><td align="left">代码块的设置, 请参考 <a href="https://hexo.io/docs/syntax-highlight#Highlight-js">Highlight.js</a> 进行设置</td><td align="left"></td></tr><tr><td align="left"><code>prismjs</code></td><td align="left">代码块的设置, 请参考 <a href="https://hexo.io/docs/syntax-highlight#PrismJS">PrismJS</a> 进行设置</td><td align="left"></td></tr></tbody></table><blockquote><p>相对地址</p><p>默认情况下，Hexo 生成的超链接都是绝对地址。例如，如果您的网站域名为 <code>example.com</code>,您有一篇文章名为 <code>hello</code>，那么绝对链接可能像这样：<code>http://example.com/hello.html</code>，它是<strong>绝对</strong>于域名的。相对链接像这样：<code>/hello.html</code>，也就是说，无论用什么域名访问该站点，都没有关系，这在进行反向代理时可能用到。通常情况下，建议使用绝对地址。</p></blockquote><h2 id="分类-amp-标签"><a href="#分类-amp-标签" class="headerlink" title="分类 &amp; 标签"></a>分类 &amp; 标签</h2><table><thead><tr><th align="left">参数</th><th align="left">描述</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left"><code>default_category</code></td><td align="left">默认分类</td><td align="left"><code>uncategorized</code></td></tr><tr><td align="left"><code>category_map</code></td><td align="left">分类别名</td><td align="left"></td></tr><tr><td align="left"><code>tag_map</code></td><td align="left">标签别名</td><td align="left"></td></tr></tbody></table><h2 id="日期-时间格式"><a href="#日期-时间格式" class="headerlink" title="日期 / 时间格式"></a>日期 / 时间格式</h2><p>Hexo 使用 <a href="http://momentjs.com/">Moment.js</a> 来解析和显示时间。</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left"><code>date_format</code></td><td align="left">日期格式</td><td align="left"><code>YYYY-MM-DD</code></td></tr><tr><td align="left"><code>time_format</code></td><td align="left">时间格式</td><td align="left"><code>HH:mm:ss</code></td></tr><tr><td align="left"><code>updated_option</code></td><td align="left">当 Front Matter 中没有指定 <a href="https://hexo.io/zh-cn/docs/variables#%E9%A1%B5%E9%9D%A2%E5%8F%98%E9%87%8F"><code>updated</code></a> 时 <code>updated</code> 的取值</td><td align="left"><code>mtime</code></td></tr></tbody></table><blockquote><p>updated_option</p><p><code>updated_option</code> 控制了当 Front Matter 中没有指定 <code>updated</code> 时，<code>updated</code> 如何取值：</p><ul><li><code>mtime</code>: 使用文件的最后修改时间。这是从 Hexo 3.0.0 开始的默认行为。</li><li><code>date</code>: 使用 <code>date</code> 作为 <code>updated</code> 的值。可被用于 Git 工作流之中，因为使用 Git 管理站点时，文件的最后修改日期常常会发生改变</li><li><code>empty</code>: 直接删除 <code>updated</code>。使用这一选项可能会导致大部分主题和插件无法正常工作。</li></ul><p><code>use_date_for_updated</code> 选项已经被废弃，将会在下个重大版本发布时去除。请改为使用 <code>updated_option: &#39;date&#39;</code>。</p></blockquote><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso">use_date_for_updated<span class="hljs-string">` | 启用以后，如果 Front Matter 中没有指定 `</span>updated<span class="hljs-string">`， [`</span>post.updated<span class="hljs-string">`](https://hexo.io/zh-cn/docs/configuration) 将会使用 `</span><span class="hljs-built_in">date</span><span class="hljs-string">` 的值而不是文件的创建时间。在 Git 工作流中这个选项会很有用 | `</span><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><table><thead><tr><th align="left">参数</th><th align="left">描述</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left"><code>per_page</code></td><td align="left">每页显示的文章量 (0 = 关闭分页功能)</td><td align="left"><code>10</code></td></tr><tr><td align="left"><code>pagination_dir</code></td><td align="left">分页目录</td><td align="left"><code>page</code></td></tr></tbody></table><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>theme</code></td><td align="left">当前主题名称。值为<code>false</code>时禁用主题</td></tr><tr><td align="left"><code>theme_config</code></td><td align="left">主题的配置文件。在这里放置的配置会覆盖主题目录下的 <code>_config.yml</code> 中的配置</td></tr><tr><td align="left"><code>deploy</code></td><td align="left">部署部分的设置</td></tr><tr><td align="left"><code>meta_generator</code></td><td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta#%E5%B1%9E%E6%80%A7">Meta generator</a> 标签。 值为 <code>false</code> 时 Hexo 不会在头部插入该标签</td></tr></tbody></table><h3 id="包括或不包括目录和文件"><a href="#包括或不包括目录和文件" class="headerlink" title="包括或不包括目录和文件"></a>包括或不包括目录和文件</h3><p>在 Hexo 配置文件中，通过设置 include/exclude 可以让 Hexo 进行处理或忽略某些目录和文件夹。你可以使用 <a href="https://github.com/isaacs/minimatch">glob 表达式</a> 对目录和文件进行匹配。</p><p><code>include</code> and <code>exclude</code> options only apply to the <code>source/</code> folder, whereas <code>ignore</code> option applies to all folders.</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>include</code></td><td align="left">Hexo 默认会忽略隐藏文件和文件夹（包括名称以下划线和 <code>.</code> 开头的文件和文件夹，Hexo 的 <code>_posts</code> 和 <code>_data</code> 等目录除外）。通过设置此字段将使 Hexo 处理他们并将它们复制到 <code>source</code> 目录下。</td></tr><tr><td align="left"><code>exclude</code></td><td align="left">Hexo 会忽略这些文件和目录</td></tr><tr><td align="left"><code>ignore</code></td><td align="left">Ignore files/folders</td></tr></tbody></table><p>举例：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-meta"># <span class="hljs-meta-keyword">Include</span>/Exclude Files/Folders</span><br>include:<br>  - <span class="hljs-string">&quot;.nojekyll&quot;</span><br>  <span class="hljs-meta"># 包括 <span class="hljs-string">&#x27;source/css/_typing.css&#x27;</span></span><br>  - <span class="hljs-string">&quot;css/_typing.css&quot;</span><br>  <span class="hljs-meta"># 包括 <span class="hljs-string">&#x27;source/_css/&#x27;</span> 中的任何文件，但不包括子目录及其其中的文件。</span><br>  - <span class="hljs-string">&quot;_css/*&quot;</span><br>  <span class="hljs-meta"># 包含 <span class="hljs-string">&#x27;source/_css/&#x27;</span> 中的任何文件和子目录下的任何文件</span><br>  - <span class="hljs-string">&quot;_css/**/*&quot;</span><br><br>exclude:<br>  <span class="hljs-meta"># 不包括 <span class="hljs-string">&#x27;source/js/test.js&#x27;</span></span><br>  - <span class="hljs-string">&quot;js/test.js&quot;</span><br>  <span class="hljs-meta"># 不包括 <span class="hljs-string">&#x27;source/js/&#x27;</span> 中的文件、但包括子目录下的所有目录和文件</span><br>  - <span class="hljs-string">&quot;js/*&quot;</span><br>  <span class="hljs-meta"># 不包括 <span class="hljs-string">&#x27;source/js/&#x27;</span> 中的文件和子目录下的任何文件</span><br>  - <span class="hljs-string">&quot;js/**/*&quot;</span><br>  <span class="hljs-meta"># 不包括 <span class="hljs-string">&#x27;source/js/&#x27;</span> 目录下的所有文件名以 <span class="hljs-string">&#x27;test&#x27;</span> 开头的文件，但包括其它文件和子目录下的单文件</span><br>  - <span class="hljs-string">&quot;js/test*&quot;</span><br>  <span class="hljs-meta"># 不包括 <span class="hljs-string">&#x27;source/js/&#x27;</span> 及其子目录中任何以 <span class="hljs-string">&#x27;test&#x27;</span> 开头的文件</span><br>  - <span class="hljs-string">&quot;js/**/test*&quot;</span><br>  <span class="hljs-meta"># 不要用 exclude 来忽略 <span class="hljs-string">&#x27;source/_posts/&#x27;</span> 中的文件。你应该使用 <span class="hljs-string">&#x27;skip_render&#x27;</span>，或者在要忽略的文件的文件名之前加一个下划线 <span class="hljs-string">&#x27;_&#x27;</span></span><br>  <span class="hljs-meta"># 在这里配置一个 - <span class="hljs-string">&quot;_posts/hello-world.md&quot;</span> 是没有用的。</span><br><br>ignore:<br>  <span class="hljs-meta"># Ignore any folder named <span class="hljs-string">&#x27;foo&#x27;</span>.</span><br>  - <span class="hljs-string">&quot;**/foo&quot;</span><br>  <span class="hljs-meta"># Ignore <span class="hljs-string">&#x27;foo&#x27;</span> folder in <span class="hljs-string">&#x27;themes/&#x27;</span> only.</span><br>  - <span class="hljs-string">&quot;**/themes/*/foo&quot;</span><br>  <span class="hljs-meta"># Same as above, but applies to every subfolders of <span class="hljs-string">&#x27;themes/&#x27;</span>.</span><br>  - <span class="hljs-string">&quot;**/themes/**/foo&quot;</span><br></code></pre></td></tr></table></figure><p>列表中的每一项都必须用单引号或双引号包裹起来。</p><p><code>include</code> 和 <code>exclude</code> 并不适用于 <code>themes/</code> 目录下的文件。如果需要忽略 <code>themes/</code> 目录下的部分文件或文件夹，可以使用 <code>ignore</code> 或在文件名之前添加下划线 <code>_</code>。</p><h3 id="使用代替配置文件"><a href="#使用代替配置文件" class="headerlink" title="使用代替配置文件"></a>使用代替配置文件</h3><p>可以在 hexo-cli 中使用 <code>--config</code> 参数来指定自定义配置文件的路径。你可以使用一个 YAML 或 JSON 文件的路径，也可以使用逗号分隔（无空格）的多个 YAML 或 JSON 文件的路径。例如：</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sml"># use <span class="hljs-symbol">&#x27;custom</span>.yml&#x27; <span class="hljs-keyword">in</span> place <span class="hljs-keyword">of</span> <span class="hljs-symbol">&#x27;_config</span>.yml&#x27;<br>$ hexo server --config custom.yml<br><br># use <span class="hljs-symbol">&#x27;custom</span>.yml&#x27; &amp; <span class="hljs-symbol">&#x27;custom2</span>.json&#x27;, prioritizing <span class="hljs-symbol">&#x27;custom3</span>.yml&#x27;, <span class="hljs-keyword">then</span> <span class="hljs-symbol">&#x27;custom2</span>.json&#x27;<br>$ hexo generate --config custom.yml,custom2.json,custom3.yml<br></code></pre></td></tr></table></figure><p>当你指定了多个配置文件以后，Hexo 会按顺序将这部分配置文件合并成一个 <code>_multiconfig.yml</code>。如果遇到重复的配置，排在后面的文件的配置会覆盖排在前面的文件的配置。这个原则适用于任意数量、任意深度的 YAML 和 JSON 文件。</p><p>例如，使用 <code>--options</code> 指定了两个自定义配置文件：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog">$ hexo <span class="hljs-keyword">generate</span> --<span class="hljs-keyword">config</span> custom<span class="hljs-variable">.yml</span>,custom2<span class="hljs-variable">.json</span><br></code></pre></td></tr></table></figure><p>如果 <code>custom.yml</code> 中指定了 <code>foo: bar</code>，在 custom2.json 中指定了 <code>&quot;foo&quot;: &quot;dinosaur&quot;</code>，那么在 <code>_multiconfig.yml</code> 中你会得到 <code>foo: dinosaur</code>。</p><h3 id="使用代替主题配置文件"><a href="#使用代替主题配置文件" class="headerlink" title="使用代替主题配置文件"></a>使用代替主题配置文件</h3><p>通常情况下，Hexo 主题是一个独立的项目，并拥有一个独立的 <code>_config.yml</code> 配置文件。</p><p>除了自行维护独立的主题配置文件，你也可以在其它地方对主题进行配置。</p><p><strong>配置文件中的 <code>theme_config</code></strong></p><blockquote><p>该特性自 Hexo 2.8.2 起提供</p></blockquote><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-meta"># _config.yml</span><br><span class="hljs-symbol">theme:</span> <span class="hljs-string">&quot;my-theme&quot;</span><br><span class="hljs-symbol">theme_config:</span><br><span class="hljs-symbol">  bio:</span> <span class="hljs-string">&quot;My awesome bio&quot;</span><br><span class="hljs-symbol">  foo:</span><br><span class="hljs-symbol">    bar:</span> <span class="hljs-string">&#x27;a&#x27;</span><br><span class="hljs-meta"># themes/my-theme/_config.yml</span><br><span class="hljs-symbol">bio:</span> <span class="hljs-string">&quot;Some generic bio&quot;</span><br><span class="hljs-symbol">logo:</span> <span class="hljs-string">&quot;a-cool-image.png&quot;</span><br><span class="hljs-symbol">  foo:</span><br><span class="hljs-symbol">    baz:</span> <span class="hljs-string">&#x27;b&#x27;</span><br></code></pre></td></tr></table></figure><p>最终主题配置的输出是：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dts">&#123;<br><span class="hljs-symbol">  bio:</span> <span class="hljs-string">&quot;My awesome bio&quot;</span>,<br><span class="hljs-symbol">  logo:</span> <span class="hljs-string">&quot;a-cool-image.png&quot;</span>,<br><span class="hljs-symbol">  foo:</span> &#123;<br><span class="hljs-symbol">    bar:</span> <span class="hljs-string">&quot;a&quot;</span>,<br><span class="hljs-symbol">    baz:</span> <span class="hljs-string">&quot;b&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>独立的 <code>_config.[theme].yml</code> 文件</strong></p><blockquote><p>该特性自 Hexo 5.0.0 起提供</p></blockquote><p>独立的主题配置文件应放置于站点根目录下，支持 <code>yml</code> 或 <code>json</code> 格式。需要配置站点 <code>_config.yml</code> 文件中的 <code>theme</code> 以供 Hexo 寻找 <code>_config.[theme].yml</code> 文件。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-meta"># _config.yml</span><br><span class="hljs-symbol">theme:</span> <span class="hljs-string">&quot;my-theme&quot;</span><br><span class="hljs-meta"># _config.my-theme.yml</span><br><span class="hljs-symbol">bio:</span> <span class="hljs-string">&quot;My awesome bio&quot;</span><br><span class="hljs-symbol">foo:</span><br><span class="hljs-symbol">  bar:</span> <span class="hljs-string">&#x27;a&#x27;</span><br><span class="hljs-meta"># themes/my-theme/_config.yml</span><br><span class="hljs-symbol">bio:</span> <span class="hljs-string">&quot;Some generic bio&quot;</span><br><span class="hljs-symbol">logo:</span> <span class="hljs-string">&quot;a-cool-image.png&quot;</span><br><span class="hljs-symbol">  foo:</span><br><span class="hljs-symbol">    baz:</span> <span class="hljs-string">&#x27;b&#x27;</span><br></code></pre></td></tr></table></figure><p>最终主题配置的输出是：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dts">&#123;<br><span class="hljs-symbol">  bio:</span> <span class="hljs-string">&quot;My awesome bio&quot;</span>,<br><span class="hljs-symbol">  logo:</span> <span class="hljs-string">&quot;a-cool-image.png&quot;</span>,<br><span class="hljs-symbol">  foo:</span> &#123;<br><span class="hljs-symbol">    bar:</span> <span class="hljs-string">&quot;a&quot;</span>,<br><span class="hljs-symbol">    baz:</span> <span class="hljs-string">&quot;b&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>我们强烈建议你将所有的主题配置集中在一处。如果你不得不在多处配置你的主题，那么这些信息对你将会非常有用：Hexo 在合并主题配置时，Hexo 配置文件中的 <code>theme_config</code> 的优先级最高，其次是 <code>_config.[theme].yml</code> 文件，最后是位于主题目录下的 <code>_config.yml</code> 文件。</p></blockquote><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>安装 <code>Hexo </code>完成后，请执行下列命令，<code>Hexo</code> 将会在指定文件夹中新建所需要的文件。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> hexo init &lt;folder&gt;<br><span class="hljs-variable">$</span> <span class="hljs-built_in">cd</span> &lt;folder&gt;<br><span class="hljs-variable">$</span> npm install<br></code></pre></td></tr></table></figure><p>新建完成后，指定文件夹的目录如下：</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sqf">.<br>├── <span class="hljs-variable">_config</span>.yml<br>├── package.json<br>├── scaffolds<br>├── source<br>|   ├── <span class="hljs-variable">_drafts</span><br>|   └── <span class="hljs-variable">_posts</span><br>└── themes<br></code></pre></td></tr></table></figure><h3 id="config-yml"><a href="#config-yml" class="headerlink" title="_config.yml"></a><code>_config.yml</code></h3><p>网站的 <a href="https://hexo.io/zh-cn/docs/configuration">配置</a> 信息，您可以在此配置大部分的参数。</p><h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a><code>package.json</code></h3><p>应用程序的信息。<a href="https://ejs.co/">EJS</a>, <a href="http://learnboost.github.io/stylus/">Stylus</a> 和 <a href="http://daringfireball.net/projects/markdown/">Markdown</a> renderer 已默认安装，您可以自由移除。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">package</span>.json&#123;<br>  <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;hexo-site&quot;</span>,<br>  <span class="hljs-string">&quot;version&quot;</span>: <span class="hljs-string">&quot;0.0.0&quot;</span>,<br>  <span class="hljs-string">&quot;private&quot;</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-string">&quot;hexo&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;version&quot;</span>: <span class="hljs-string">&quot;&quot;</span><br>  &#125;,<br>  <span class="hljs-string">&quot;dependencies&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;hexo&quot;</span>: <span class="hljs-string">&quot;^3.8.0&quot;</span>,<br>    <span class="hljs-string">&quot;hexo-generator-archive&quot;</span>: <span class="hljs-string">&quot;^0.1.5&quot;</span>,<br>    <span class="hljs-string">&quot;hexo-generator-category&quot;</span>: <span class="hljs-string">&quot;^0.1.3&quot;</span>,<br>    <span class="hljs-string">&quot;hexo-generator-index&quot;</span>: <span class="hljs-string">&quot;^0.2.1&quot;</span>,<br>    <span class="hljs-string">&quot;hexo-generator-tag&quot;</span>: <span class="hljs-string">&quot;^0.2.0&quot;</span>,<br>    <span class="hljs-string">&quot;hexo-renderer-ejs&quot;</span>: <span class="hljs-string">&quot;^0.3.1&quot;</span>,<br>    <span class="hljs-string">&quot;hexo-renderer-stylus&quot;</span>: <span class="hljs-string">&quot;^0.3.3&quot;</span>,<br>    <span class="hljs-string">&quot;hexo-renderer-marked&quot;</span>: <span class="hljs-string">&quot;^0.3.2&quot;</span>,<br>    <span class="hljs-string">&quot;hexo-server&quot;</span>: <span class="hljs-string">&quot;^0.3.3&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="scaffolds"><a href="#scaffolds" class="headerlink" title="scaffolds"></a>scaffolds</h3><p><a href="https://hexo.io/zh-cn/docs/writing">模版</a> 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。</p><p>Hexo的模板是指在新建的文章文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。</p><h3 id="source"><a href="#source" class="headerlink" title="source"></a>source</h3><p>资源文件夹是存放用户资源的地方。除 <code>_posts</code> 文件夹之外，开头命名为 <code>_</code> (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 <code>public</code> 文件夹，而其他文件会被拷贝过去。</p><h3 id="themes"><a href="#themes" class="headerlink" title="themes"></a>themes</h3><p><a href="https://hexo.io/zh-cn/docs/themes">主题</a> 文件夹。Hexo 会根据主题来生成静态页面。</p><h1 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h1><p>可以在命令中指定文章的布局（layout），默认为 <code>post</code>，可以通过修改 <code>_config.yml</code> 中的 <code>default_layout</code> 参数来指定默认布局。</p><h3 id="布局（Layout）"><a href="#布局（Layout）" class="headerlink" title="布局（Layout）"></a>布局（Layout）</h3><p>Hexo 有三种默认布局：<code>post</code>、<code>page</code> 和 <code>draft</code>。在创建这三种不同类型的文件时，它们将会被保存到不同的路径；而您自定义的其他布局和 <code>post</code> 相同，都将储存到 <code>source/_posts</code> 文件夹。</p><table><thead><tr><th align="left">布局</th><th align="left">路径</th></tr></thead><tbody><tr><td align="left"><code>post</code></td><td align="left"><code>source/_posts</code></td></tr><tr><td align="left"><code>page</code></td><td align="left"><code>source</code></td></tr><tr><td align="left"><code>draft</code></td><td align="left"><code>source/_drafts</code></td></tr></tbody></table><blockquote><p>Disabling layout</p><p>If you don’t want an article (post/page) to be processed with a theme, set <code>layout: false</code> in its front-matter. Refer to <a href="https://hexo.io/zh-cn/docs/front-matter#%E5%B8%83%E5%B1%80">this section</a> for more details.</p></blockquote><h3 id="文件名称"><a href="#文件名称" class="headerlink" title="文件名称"></a>文件名称</h3><p>Hexo 默认以标题做为文件名称，但您可编辑 <code>new_post_name</code> 参数来改变默认的文件名称，举例来说，设为 <code>:year-:month-:day-:title.md</code> 可让您更方便的通过日期来管理文章。</p><table><thead><tr><th align="left">变量</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>:title</code></td><td align="left">标题（小写，空格将会被替换为短杠）</td></tr><tr><td align="left"><code>:year</code></td><td align="left">建立的年份，比如， <code>2015</code></td></tr><tr><td align="left"><code>:month</code></td><td align="left">建立的月份（有前导零），比如， <code>04</code></td></tr><tr><td align="left"><code>:i_month</code></td><td align="left">建立的月份（无前导零），比如， <code>4</code></td></tr><tr><td align="left"><code>:day</code></td><td align="left">建立的日期（有前导零），比如， <code>07</code></td></tr><tr><td align="left"><code>:i_day</code></td><td align="left">建立的日期（无前导零），比如， <code>7</code></td></tr></tbody></table><h3 id="草稿"><a href="#草稿" class="headerlink" title="草稿"></a>草稿</h3><p>刚刚提到了 Hexo 的一种特殊布局：<code>draft</code>，这种布局在建立时会被保存到 <code>source/_drafts</code> 文件夹，您可通过 <code>publish</code> 命令将草稿移动到 <code>source/_posts</code> 文件夹，该命令的使用方式与 <code>new</code> 十分类似，您也可在命令中指定 <code>layout</code> 来指定布局。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">$ hexo publish [layout] <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><br></code></pre></td></tr></table></figure><p>草稿默认不会显示在页面中，您可在执行时加上 <code>--draft</code> 参数，或是把 <code>render_drafts</code> 参数设为 <code>true</code> 来预览草稿。</p><h2 id="模版（Scaffold）"><a href="#模版（Scaffold）" class="headerlink" title="模版（Scaffold）"></a>模版（Scaffold）</h2><p>在新建文章时，Hexo 会根据 <code>scaffolds</code> 文件夹内相对应的文件来建立文件，例如：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">$ hexo <span class="hljs-keyword">new</span> <span class="hljs-type">photo</span> <span class="hljs-string">&quot;My Gallery&quot;</span><br></code></pre></td></tr></table></figure><p>在执行这行指令时，Hexo 会尝试在 <code>scaffolds</code> 文件夹中寻找 <code>photo.md</code>，并根据其内容建立文章，以下是您可以在模版中使用的变量：</p><table><thead><tr><th align="left">变量</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>layout</code></td><td align="left">布局</td></tr><tr><td align="left"><code>title</code></td><td align="left">标题</td></tr><tr><td align="left"><code>date</code></td><td align="left">文件建立日期</td></tr></tbody></table><h3 id="支持的格式"><a href="#支持的格式" class="headerlink" title="支持的格式"></a>支持的格式</h3><p>Hexo 支持以任何格式书写文章，只要安装了相应的渲染插件。</p><p>例如，Hexo 默认安装了 <code>hexo-renderer-marked</code> 和 <code>hexo-renderer-ejs</code>，因此你不仅可以用 Markdown 写作，你还可以用 EJS 写作。如果你安装了 <code>hexo-renderer-pug</code>，你甚至可以用 Pug 模板语言书写文章。</p><p>只需要将文章的扩展名从 <code>md</code> 改成 <code>ejs</code>，Hexo 就会使用 <code>hexo-renderer-ejs</code> 渲染这个文件，其他格式同理。</p><h1 id="npm相关问题"><a href="#npm相关问题" class="headerlink" title="npm相关问题"></a><code>npm</code>相关问题</h1><h2 id="1-使用npm命令时报错误Error-EACCES-permission-denied，如何解决？"><a href="#1-使用npm命令时报错误Error-EACCES-permission-denied，如何解决？" class="headerlink" title="1.使用npm命令时报错误Error: EACCES: permission denied，如何解决？"></a>1.使用<code>npm</code>命令时报错误<code>Error: EACCES: permission denied</code>，如何解决？</h2><p>官方的解决方案：<a href="https://docs.npmjs.com/getting-started/fixing-npm-permissions">https://docs.npmjs.com/getting-started/fixing-npm-permissions</a></p><p>官方提供了两种解决方案：</p><ol><li><p>重新安装一个node version manager。（官方推荐）<br>参考地址：<a href="https://docs.npmjs.com/getting-started/installing-node">https://docs.npmjs.com/getting-started/installing-node</a><br>注：这个方法比较繁琐，我选择的是第二种方案。</p></li><li><p>改变<code>npm</code>默认的路径。</p><p>步骤如下：</p></li></ol><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">进入终端，依次输入一下命令<br>（<span class="hljs-number">1</span>）创建<span class="hljs-built_in">global</span>安装任务的目录<br>mkdir ~/.<span class="hljs-built_in">npm</span>-<span class="hljs-built_in">global</span><br>（<span class="hljs-number">2</span>）配置<span class="hljs-built_in">npm</span>使用新的目录<br><span class="hljs-built_in">npm</span> config set prefix <span class="hljs-string">&#x27;~/.npm-global&#x27;</span><br>（<span class="hljs-number">3</span>）在~<span class="hljs-regexp">/.profile文件中增加配置  注：可能没有这个文件。如果用的zsh：是（ ~/</span>.zshrc）；如果用的bash：是(~/.bash_profile)<br><span class="hljs-keyword">export</span> PATH=~/.<span class="hljs-built_in">npm</span>-<span class="hljs-built_in">global</span>/bin:$PATH<br>（<span class="hljs-number">4</span>）配置文件立即生效<br>source ~<span class="hljs-regexp">/.profile 注：我用的zsh,所以命令是（source ~/</span>.zshrc）<br>（<span class="hljs-number">5</span>）重新执行命令<br><span class="hljs-built_in">npm</span> install -g xxxx <br></code></pre></td></tr></table></figure><h2 id="2-通过npm安装主题在哪"><a href="#2-通过npm安装主题在哪" class="headerlink" title="2.通过npm安装主题在哪"></a>2.通过npm安装主题在哪</h2><ul><li>在博客文件夹的node_modules目录下</li></ul><h2 id="3-查看本地安装的所有npm包"><a href="#3-查看本地安装的所有npm包" class="headerlink" title="3. 查看本地安装的所有npm包"></a>3. 查看本地安装的所有npm包</h2><ol><li>查看</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">$ npm list -g --depth 0  // 若需要权限 请加上 sudo 命令<br></code></pre></td></tr></table></figure><ol start="2"><li>更新</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">$ npm update -g xxx<br></code></pre></td></tr></table></figure><ol start="3"><li>删除</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">$ npm uninstall -g xxx<br></code></pre></td></tr></table></figure><h1 id="将-Hexo-部署到-GitHub-Pages"><a href="#将-Hexo-部署到-GitHub-Pages" class="headerlink" title="将 Hexo 部署到 GitHub Pages"></a>将 Hexo 部署到 GitHub Pages</h1><p>Hexo 提供了快速方便的一键部署功能，让您只需一条命令就能将网站部署到服务器上。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>hexo deploy<br></code></pre></td></tr></table></figure><p>在开始之前，您必须先在 <code>_config.yml</code> 中修改参数，一个正确的部署配置中至少要有 <code>type</code> 参数，例如：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br></code></pre></td></tr></table></figure><p>您可同时使用多个 deployer，Hexo 会依照顺序执行每个 deployer。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repo:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">type:</span> <span class="hljs-string">heroku</span><br>  <span class="hljs-attr">repo:</span><br></code></pre></td></tr></table></figure><p>Refer to the <a href="https://hexo.io/plugins/">Plugins</a> list for more deployment plugins.</p><blockquote><p>缩进</p><p>YAML依靠缩进来确定元素间的从属关系。因此，请确保每个deployer的缩进长度相同，并且使用空格缩进。</p></blockquote><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><ol><li>安装 <a href="https://github.com/hexojs/hexo-deployer-git">hexo-deployer-git</a>。</li></ol><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">$ npm install hexo-deployer-git <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><ol><li>修改配置。</li></ol><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repo:</span> <span class="hljs-params">&lt;repository url&gt;</span> <span class="hljs-meta">#https:<span class="hljs-comment">//bitbucket.org/JohnSmith/johnsmith.bitbucket.io</span></span><br><span class="hljs-symbol">  branch:</span> [branch]<br><span class="hljs-symbol">  message:</span> [message]<br></code></pre></td></tr></table></figure><table><thead><tr><th align="left">参数</th><th align="left">描述</th><th align="left">默认</th></tr></thead><tbody><tr><td align="left"><code>repo</code></td><td align="left">库（Repository）地址</td><td align="left"></td></tr><tr><td align="left"><code>branch</code></td><td align="left">分支名称</td><td align="left"><code>gh-pages</code> (GitHub) <code>coding-pages</code> (Coding.net) <code>master</code> (others)</td></tr><tr><td align="left"><code>message</code></td><td align="left">自定义提交信息</td><td align="left"><code>Site updated: &#123;&#123; now('YYYY-MM-DD HH:mm:ss') &#125;&#125;</code>)</td></tr><tr><td align="left"><code>token</code></td><td align="left">Optional token value to authenticate with the repo. Prefix with <code>$</code> to read token from environment variable</td><td align="left"></td></tr></tbody></table><ol><li>生成站点文件并推送至远程库。执行 <code>hexo clean &amp;&amp; hexo deploy</code>。</li></ol><ul><li>You will be prompted with username and password of the target repository, unless you authenticate with a token or ssh key.</li><li>hexo-deployer-git does not store your username and password. Use <a href="https://git-scm.com/docs/git-credential-cache">git-credential-cache</a> to store them temporarily.</li></ul><ol><li>登入 Github/BitBucket/Gitlab，请在库设置（Repository Settings）中将默认分支设置为<code>_config.yml</code>配置中的分支名称。稍等片刻，您的站点就会显示在您的Github Pages中。</li></ol><h3 id="这一切是如何发生的？"><a href="#这一切是如何发生的？" class="headerlink" title="这一切是如何发生的？"></a>这一切是如何发生的？</h3><p>当执行 <code>hexo deploy</code> 时，Hexo 会将 <code>public</code> 目录中的文件和目录推送至 <code>_config.yml</code> 中指定的远端仓库和分支中，并且<strong>完全覆盖</strong>该分支下的已有内容。</p><blockquote><p>For 使用 Git 管理站点目录的用户</p><p>由于 Hexo 的部署默认使用分支 <code>master</code>，所以如果你同时正在使用 Git 管理你的站点目录，你应当注意你的部署分支应当不同于写作分支。<br>一个好的实践是将站点目录和 Pages 分别存放在两个不同的 Git 仓库中，可以有效避免相互覆盖。<br>Hexo 在部署你的站点生成的文件时并不会更新你的站点目录。因此你应该手动提交并推送你的写作分支。</p></blockquote><p>此外，如果您的 Github Pages 需要使用 CNAME 文件<strong>自定义域名</strong>，请将 CNAME 文件置于 <code>source</code> 目录下，只有这样 <code>hexo deploy</code> 才能将 CNAME 文件一并推送至部署分支。</p><h2 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h2><p>Hexo 生成的所有文件都放在 <code>public</code> 文件夹中，您可以将它们复制到您喜欢的地方。</p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><ol><li>安装 <a href="https://github.com/hexojs/hexo-deployer-git">hexo-deployer-git</a>.</li><li>在 <strong>_config.yml</strong>（如果有已存在的请删除）添加如下配置：</li></ol><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repo:</span> https:<span class="hljs-comment">//github.com/&lt;username&gt;/&lt;project&gt;</span><br>  <span class="hljs-meta"># example, https:<span class="hljs-comment">//github.com/hexojs/hexojs.github.io</span></span><br><span class="hljs-symbol">  branch:</span> gh-pages<br></code></pre></td></tr></table></figure><ol><li>运行 <code>hexo clean &amp;&amp; hexo deploy</code> 。</li><li>查看 <em>username</em>.github.io 上的网页是否部署成功。</li></ol><h1 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h1><h2 id="init"><a href="#init" class="headerlink" title="init"></a>init</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">$ hexo <span class="hljs-keyword">init</span> [folder]<br></code></pre></td></tr></table></figure><p>新建一个网站。如果没有设置 <code>folder</code> ，Hexo 默认在目前的文件夹建立网站。</p><p>本命令相当于执行了以下几步：</p><ol><li>Git clone <a href="https://github.com/hexojs/hexo-starter">hexo-starter</a> 和 <a href="https://github.com/hexojs/hexo-theme-landscape">hexo-theme-landscape</a> 主题到当前目录或指定目录。</li><li>使用 <a href="https://classic.yarnpkg.com/lang/en/">Yarn 1</a>、<a href="https://pnpm.js.org/">pnpm</a> 或 <a href="https://docs.npmjs.com/cli/install">npm</a> 包管理器下载依赖（如有已安装多个，则列在前面的优先）。npm 默认随 <a href="https://hexo.io/docs/#Install-Node-js">Node.js</a> 安装。</li></ol><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss">$ hexo <span class="hljs-keyword">new</span> [layout] &lt;<span class="hljs-built_in">title</span>&gt;<br></code></pre></td></tr></table></figure><p>新建一篇文章。如果没有设置 <code>layout</code> 的话，默认使用 <a href="https://hexo.io/zh-cn/docs/configuration">_config.yml</a> 中的 <code>default_layout</code> 参数代替。如果标题包含空格的话，请使用引号括起来。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">$ hexo <span class="hljs-keyword">new</span> <span class="hljs-string">&quot;post title with whitespace&quot;</span><br></code></pre></td></tr></table></figure><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-p</code>, <code>--path</code></td><td align="left">自定义新文章的路径</td></tr><tr><td align="left"><code>-r</code>, <code>--replace</code></td><td align="left">如果存在同名文章，将其替换</td></tr><tr><td align="left"><code>-s</code>, <code>--slug</code></td><td align="left">文章的 Slug，作为新文章的文件名和发布后的 URL</td></tr></tbody></table><p>默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 <code>index.md</code> 文件。你可以使用 <code>--path</code> 参数来覆盖上述行为、自行决定文件的目录：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">hexo <span class="hljs-keyword">new</span> <span class="hljs-type">page</span> --path about/me <span class="hljs-string">&quot;About me&quot;</span><br></code></pre></td></tr></table></figure><p>以上命令会创建一个 <code>source/about/me.md</code> 文件，同时 Front Matter 中的 title 为 <code>&quot;About me&quot;</code></p><p>注意！title 是必须指定的！如果你这么做并不能达到你的目的：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">hexo <span class="hljs-keyword">new</span> page <span class="hljs-comment">--path about/me</span><br></code></pre></td></tr></table></figure><p>此时 Hexo 会创建 <code>source/_posts/about/me.md</code>，同时 <code>me.md</code> 的 Front Matter 中的 title 为 <code>&quot;page&quot;</code>。这是因为在上述命令中，hexo-cli 将 <code>page</code> 视为指定文章的标题、并采用默认的 <code>layout</code>。</p><h2 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h2><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog">$ hexo <span class="hljs-keyword">generate</span><br></code></pre></td></tr></table></figure><p>生成静态文件。</p><table><thead><tr><th align="left">选项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-d</code>, <code>--deploy</code></td><td align="left">文件生成后立即部署网站</td></tr><tr><td align="left"><code>-w</code>, <code>--watch</code></td><td align="left">监视文件变动</td></tr><tr><td align="left"><code>-b</code>, <code>--bail</code></td><td align="left">生成过程中如果发生任何未处理的异常则抛出异常</td></tr><tr><td align="left"><code>-f</code>, <code>--force</code></td><td align="left">强制重新生成文件 Hexo 引入了差分机制，如果 <code>public</code> 目录存在，那么 <code>hexo g</code> 只会重新生成改动的文件。 使用该参数的效果接近 <code>hexo clean &amp;&amp; hexo generate</code></td></tr><tr><td align="left"><code>-c</code>, <code>--concurrency</code></td><td align="left">最大同时生成文件的数量，默认无限制</td></tr></tbody></table><p>该命令可以简写为</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>hexo g<br></code></pre></td></tr></table></figure><h2 id="publish"><a href="#publish" class="headerlink" title="publish"></a>publish</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">$ hexo publish [layout] <span class="hljs-tag">&lt;<span class="hljs-name">filename</span>&gt;</span><br></code></pre></td></tr></table></figure><p>发表草稿。</p><h2 id="server"><a href="#server" class="headerlink" title="server"></a>server</h2><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">$ hexo <span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><p>启动服务器。默认情况下，访问网址为： <code>http://localhost:4000/</code>。</p><table><thead><tr><th align="left">选项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-p</code>, <code>--port</code></td><td align="left">重设端口</td></tr><tr><td align="left"><code>-s</code>, <code>--static</code></td><td align="left">只使用静态文件</td></tr><tr><td align="left"><code>-l</code>, <code>--log</code></td><td align="left">启动日记记录，使用覆盖记录格式</td></tr></tbody></table><h2 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h2><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>hexo deploy<br></code></pre></td></tr></table></figure><p>部署网站。</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-g</code>, <code>--generate</code></td><td align="left">部署之前预先生成静态文件</td></tr></tbody></table><p>该命令可以简写为：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>hexo d<br></code></pre></td></tr></table></figure><h2 id="render"><a href="#render" class="headerlink" title="render"></a>render</h2><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs prolog">$ hexo render &lt;file1&gt; [file2] ...<br></code></pre></td></tr></table></figure><p>渲染文件。</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-o</code>, <code>--output</code></td><td align="left">设置输出路径</td></tr></tbody></table><h2 id="migrate"><a href="#migrate" class="headerlink" title="migrate"></a>migrate</h2><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm">$ hexo migrate &lt;<span class="hljs-keyword">type</span>&gt;<br></code></pre></td></tr></table></figure><p>从其他博客系统 <a href="https://hexo.io/zh-cn/docs/migration">迁移内容</a>。</p><h2 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h2><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>hexo clean<br></code></pre></td></tr></table></figure><p>清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。</p><p>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p><h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm">$ hexo list &lt;<span class="hljs-keyword">type</span>&gt;<br></code></pre></td></tr></table></figure><p>列出网站资料。</p><h2 id="version"><a href="#version" class="headerlink" title="version"></a>version</h2><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">$ hexo <span class="hljs-built_in">version</span><br></code></pre></td></tr></table></figure><p>显示 Hexo 版本。</p><h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><h2 id="部署插件"><a href="#部署插件" class="headerlink" title="部署插件"></a>部署插件</h2><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">安装： npm install hexo-deployer-git <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><p>将我们的Hexo与GitHub关联起来，打开站点的配置文件_config.yml，翻到最后修改为：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">type:</span> git<br><span class="hljs-symbol">repo:</span> 博客的仓库地址，用ssh的地址，不要用https的地址<br><span class="hljs-symbol">branch:</span> master<br><span class="hljs-symbol">ps:</span>注意缩进<br></code></pre></td></tr></table></figure><p>其实就是给hexo d 这个命令做相应的配置，让hexo知道你要把blog部署在哪个位置，很显然，我们部署在我们GitHub的仓库里。</p><h2 id="控制台"><a href="#控制台" class="headerlink" title="控制台"></a>控制台</h2><p>地址：<a href="https://github.com/jaredly/hexo-admin">github</a></p><p><strong>ps</strong>:对于 2.x，请使用此插件的 0.3.0 版。 1.x 及更高版本仅支持 Hexo v3.x。</p><p>其实第三条的 hexo d 就是部署网站命令，d是deploy的缩写。完成后，打开浏览器，在地址栏输入你的放置个人网站的仓库路径，即” <a href="http://xxxx.github.io&quot;,就可以看到你的博客,使用hexo/">http://xxxx.github.io&quot;,就可以看到你的博客,使用Hexo</a> Admin 插件写博客, <a href="%E2%80%9Dhttps://jaredforsyth.com/hexo-admin/%22">官网链接:</a><br>    安装方法<br>    第一步:下载启动</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">npm install --save hexo-admin<br>hexo server -d<br>open http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">4000</span><span class="hljs-regexp">/admin/</span><br></code></pre></td></tr></table></figure><p>第二步：配置<br>在Hexo 全局配置文件_config.yml最后添加类似如下内容</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">admin</span>:<span class="hljs-string"></span><br>  <span class="hljs-attr">username</span>: <span class="hljs-string">AlexLin</span><br>  <span class="hljs-attr">password_hash</span>: <span class="hljs-string">be121740bf988b2225a313fa1f107ca1</span><br>  <span class="hljs-attr">secret</span>: <span class="hljs-string">your admin password</span><br><br><span class="hljs-attr">secret</span> :<span class="hljs-string">你的后台管理密码</span><br><span class="hljs-attr">password_hash</span>: <span class="hljs-string">用密码生成的哈希串.</span><br><span class="hljs-meta">若是部署到github</span> <span class="hljs-string">pages,是不会上传hexo admin的,没有必要添加密码.</span><br></code></pre></td></tr></table></figure><h2 id="永久链接"><a href="#永久链接" class="headerlink" title="永久链接"></a>永久链接</h2><p>地址：<a href="https://github.com/rozbo/hexo-abbrlink">github</a></p><p>使用：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">安装： npm install hexo-abbrlink <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><p>修改 config.yml ：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">permalink: posts<span class="hljs-regexp">/:abbrlink/</span><br></code></pre></td></tr></table></figure><p>There are two settings:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">alg <span class="hljs-comment">-- Algorithm (currently support crc16 and crc32, which crc16 is default)</span><br><span class="hljs-built_in">rep</span> <span class="hljs-comment">-- Represent (the generated link could be presented in hex or dec value)</span><br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># abbrlink config</span><br><span class="hljs-attr">abbrlink:</span><br>  <span class="hljs-attr">alg:</span> <span class="hljs-string">crc32</span>      <span class="hljs-comment">#support crc16(default) and crc32</span><br>  <span class="hljs-attr">rep:</span> <span class="hljs-string">hex</span>        <span class="hljs-comment">#support dec(default) and hex</span><br>  <span class="hljs-attr">drafts:</span> <span class="hljs-literal">false</span>   <span class="hljs-comment">#(true)Process draft,(false)Do not process draft. false(default) </span><br>  <span class="hljs-comment"># Generate categories from directory-tree</span><br>  <span class="hljs-comment"># depth: the max_depth of directory-tree you want to generate, should &gt; 0</span><br>  <span class="hljs-attr">auto_category:</span><br>     <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span>  <span class="hljs-comment">#true(default)</span><br>     <span class="hljs-attr">depth:</span>        <span class="hljs-comment">#3(default)</span><br>     <span class="hljs-attr">over_write:</span> <span class="hljs-literal">false</span> <br>  <span class="hljs-attr">auto_title:</span> <span class="hljs-literal">false</span> <span class="hljs-comment">#enable auto title, it can auto fill the title by path</span><br>  <span class="hljs-attr">auto_date:</span> <span class="hljs-literal">false</span> <span class="hljs-comment">#enable auto date, it can auto fill the date by time today</span><br>  <span class="hljs-attr">force:</span> <span class="hljs-literal">false</span> <span class="hljs-comment">#enable force mode,in this mode, the plugin will ignore the cache, and calc the abbrlink for every post even it already had abbrlink.</span><br></code></pre></td></tr></table></figure><h2 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h2><p>地址：<a href="https://github.com/chenzhutian/hexo-all-minifier">github</a></p><p>使用：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">$ npm install hexo-<span class="hljs-keyword">all</span>-minifier <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><p>对于 Mac 用户，也许你需要安装更多的东西</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">$ brew install libtool <span class="hljs-built_in">auto</span>make <span class="hljs-built_in">auto</span>conf nasm<br></code></pre></td></tr></table></figure><p>修改修改 config.yml 以启用该插件（更多设置查看插件github页面）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">all_minifier:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h2 id="看板娘"><a href="#看板娘" class="headerlink" title="看板娘"></a>看板娘</h2><p>地址： <a href="https://github.com/stevenjoezhang/live2d-widget">github</a></p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ul><li>hexo使用theme出现<code>“ &#123;% extends ‘_layout.swig‘ %&#125; &#123;% import ‘_macro/post.swig‘ as post_template %&#125;“</code>问题：</li></ul><p>​    原因是hexo在5.0之后把swig给删除了需要自己手动安装</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> i hexo-renderer-swig<br></code></pre></td></tr></table></figure><p>​    安装时有可能highlights提示版本过低。（install the latest v10 version of Highlight.js）</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> install highlight.js@latest<br></code></pre></td></tr></table></figure><h6 id="注-常用命令"><a href="#注-常用命令" class="headerlink" title="注: 常用命令"></a>注: 常用命令</h6><ul><li>想要删除hexo</li></ul><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">npm uninstall hexo-<span class="hljs-keyword">cli</span> -g<br></code></pre></td></tr></table></figure><p>文件夹中的blog，手动删除。<br>另外，进行重装之前，如果还是在原来位置，必须手动清理了才能迁移安装。  </p><ul><li>其他常用的Hexo 命令  </li></ul><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs axapta">npm install hexo -g <span class="hljs-meta">#安装Hexo</span><br>npm update hexo -g <span class="hljs-meta">#升级  </span><br>hexo init <span class="hljs-meta">#初始化博客  </span><br>hexo n <span class="hljs-string">&quot;我的博客&quot;</span> == hexo <span class="hljs-keyword">new</span> <span class="hljs-string">&quot;我的博客&quot;</span> <span class="hljs-meta">#新建文章(在/source/_posts文件夹中创建)  </span><br>hexo g == hexo generate <span class="hljs-meta">#生成  </span><br>hexo s == hexo <span class="hljs-keyword">server</span> <span class="hljs-meta">#本地部署, 启动服务预览  </span><br>hexo d == hexo deploy <span class="hljs-meta">#部署,部署到github等  </span><br>hexo <span class="hljs-keyword">server</span> <span class="hljs-meta">#Hexo会监视文件变动并自动更新，无须重启服务器  </span><br>hexo <span class="hljs-keyword">server</span> -s <span class="hljs-meta">#静态模式  </span><br>hexo <span class="hljs-keyword">server</span> -p <span class="hljs-number">5000</span> <span class="hljs-meta">#更改端口  </span><br>hexo <span class="hljs-keyword">server</span> -i <span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span> <span class="hljs-meta">#自定义 IP  </span><br>hexo clean <span class="hljs-meta">#清除缓存，若是网页正常情况下可以忽略这条命令,清除缓存文件为了避免不必要的错误，在生成静态文件前，强烈建议先运行此命令.它会清除本地站点文件夹下的缓存文件（db.json）和已有的静态文件（public)  </span><br><br>注: 修改配置后,需要 “hexo g”重新生成 . 若是修改了themes的配置 , 可以不用重新生成,直接F5刷新浏览器页面就可以预览.<br>对于上面的两种常用命令, hexo提供了简写 hexo s -g(生成并预览)和hexo g -d(生成并远程部署)  <br></code></pre></td></tr></table></figure><ul><li>完善配置文件  </li></ul><p><a href="%22https://hexo.io/zh-cn/docs/configuration%22">官网链接</a><br>修改hexo的根文件夹里的_config.yml :  </p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs vbnet">先修改<br><span class="hljs-symbol">title:</span> <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-symbol">subtitle:</span> <span class="hljs-comment">&#x27;&#x27;</span><br><span class="hljs-symbol">description:</span> <span class="hljs-comment">&#x27;&#x27;</span><br><span class="hljs-symbol">keywords:</span><br><span class="hljs-symbol">author:</span>  <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-symbol">language:</span> zh-CN #此项注意, language文件夹里可能没有zh-Han , 但是由zh-CN .  <br><span class="hljs-symbol">url:</span><span class="hljs-string">&quot;此处修改为自己的网址&quot;</span><br>主题  <br><span class="hljs-symbol">theme:</span> 修改为themes文件夹下的主题名称<br></code></pre></td></tr></table></figure><p>使用init命令后,有如下文件夹  </p><pre><code>.├── _config.yml├── package.json├── scaffolds├── source|   ├── _drafts|   └── _posts└── themes</code></pre><ol><li>node_modules 是node.js各种库的目录  </li><li>public是生成的网页文件目录  </li><li>Scaffold(模版文件夹)<br>在新建文章时，Hexo 会根据 scaffolds 文件夹内相对应的文件来建立文件.<br>Hexo的模板是指在新建的markdown文件中默认填充的内容。<br>例如，如果修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。也就是说，通过hexo命令每新建一个文章，都会包含指定模板文件中的内容。  </li><li>Cource<br>资源文件夹是存放用户资源的地方，如markdown文章。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去.<br>注意：除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略.  </li><li>themes<br>主题文件夹。Hexo 会根据主题来解析source目录中的markdown文件生成静态页面。官网主题详述</li><li>package.json<br>应用程序的信息，以及需要安装的模块信息</li></ol><ul><li>写作,可以执行下列命令来创建一篇新文章。  </li></ul><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss">$ hexo <span class="hljs-keyword">new</span> [layout] &lt;<span class="hljs-built_in">title</span>&gt;<br></code></pre></td></tr></table></figure><p>可以在命令中指定文章的布局（layout），不指定默认为 post，也可以通过修改 _config.yml 中的 default_layout 参数来指定默认布局。创建的新文章会自动加上指定布局对应的模板文件中的内容。 </p><ul><li><p>布局<br>Hexo 有三种默认布局（Layout）：post、page 和 draft，它们分别对应不同的路径，而自定义的其他布局和 post 相同，都将储存到 source/_posts 文件夹.<br>如果你不想你的文章被处理，你可以将 Front-Matter 中的layout: 设为 false  </p></li><li><p>模板<br>例如  </p></li></ul><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">$ hexo <span class="hljs-keyword">new</span> <span class="hljs-type">photo</span> <span class="hljs-string">&quot;My Gallery&quot;</span><br></code></pre></td></tr></table></figure><p>在执行这行指令时，Hexo 会尝试在 scaffolds 文件夹中寻找 photo.md，并根据其内容建立文章. 以下是您可以在模版中使用的变量：<br>变量描述 :<br><code>layout</code>布局<br><code>title</code>标题<br><code>date</code>文件建立日期  </p><ul><li>Front-matter<br>Front-matter是文件最上方以 — 分隔的区域，用于指定个别文件的变量，举例来说：</li></ul><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs applescript"> <span class="hljs-comment">---</span><br>title: Hello World<br><span class="hljs-built_in">date</span>: <span class="hljs-number">2013</span>/<span class="hljs-number">7</span>/<span class="hljs-number">13</span> <span class="hljs-number">20</span>:<span class="hljs-number">46</span>:<span class="hljs-number">25</span><br> <span class="hljs-comment">---</span><br></code></pre></td></tr></table></figure><p><code>注意：一般Front-matter使用的yaml语法，yaml语法需要注意空格，如title: Hello World冒号需要有一个空格，当然除YAML 外，你也可以使用 JSON 来编写 Front-matter。</code></p>]]></content>
    
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java注解-网络博客</title>
    <link href="/posts/fcdbf97b/"/>
    <url>/posts/fcdbf97b/</url>
    
    <content type="html"><![CDATA[<h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a><strong>一、<a href="https://www.baeldung.com/java-annotation-processing-builder">介绍</a></strong></h2><p>本文<strong>介绍了 Java 源代码级别的注释处理，</strong>并提供了使用此技术在编译期间生成其他源文件的示例。</p><h2 id="2-注解处理的应用"><a href="#2-注解处理的应用" class="headerlink" title="2.注解处理的应用"></a><strong>2.注解处理的应用</strong></h2><p>源代码级注释处理首先出现在 Java 5 中。它是一种在编译阶段生成额外源文件的便捷技术。</p><p>源文件不必是 Java 文件——您可以根据源代码中的注释生成任何类型的描述、元数据、文档、资源或任何其他类型的文件。</p><p>注释处理在许多无处不在的 Java 库中被积极使用，例如，在 QueryDSL 和 JPA 中生成元类，在 Lombok 库中使用样板代码扩充类。</p><p>需要注意的重要一点是<strong>注解处理 API 的局限性——它只能用于生成新文件，不能用于更改现有文件</strong>。</p><p>值得注意的例外是<a href="https://projectlombok.org/">Lombok</a>库，它使用注解处理作为引导机制将自身包含到编译过程中并通过一些内部编译器 API 修改 AST。这种 hacky 技术与注释处理的预期目的无关，因此不在本文中讨论。</p><h2 id="3-注解处理API"><a href="#3-注解处理API" class="headerlink" title="3.注解处理API"></a><strong>3.注解处理API</strong></h2><p>注释处理分多轮完成。每一轮都从编译器开始搜索源文件中的注释并选择适合这些注释的注释处理器。依次在相应的源上调用每个注释处理器。</p><p>如果在此过程中生成了任何文件，则以生成的文件作为其输入开始另一轮。这个过程一直持续到在处理阶段没有新文件产生。</p><p>依次在相应的源上调用每个注释处理器。如果在此过程中生成了任何文件，则以生成的文件作为其输入开始另一轮。这个过程一直持续到在处理阶段没有新文件产生。</p><p>注释处理 API 位于<em>javax.annotation.processing</em>包中。您必须实现的主要接口是<em>Processor</em>接口，它具有<em>AbstractProcessor</em>类形式的部分实现。这个类是我们将要扩展以创建我们自己的注释处理器的类。</p><h2 id="4-设置项目"><a href="#4-设置项目" class="headerlink" title="4. 设置项目"></a><strong>4. 设置项目</strong></h2><p>为了演示注释处理的可能性，我们将开发一个简单的处理器来为带注释的类生成流畅的对象构建器。</p><p>我们将把我们的项目分成两个 Maven 模块。其中一个，<em>注释处理器</em>模块，将包含处理器本身和注释，另一个，<em>注释用户</em>模块，将包含被注释的类。这是注释处理的典型用例。</p><p><em>annotation-processor</em>模块的设置如下。我们将使用 Google 的<a href="https://github.com/google/auto/tree/master/service">自动服务</a>库来生成稍后将讨论的处理器元数据文件，以及针对 Java 8 源代码调整的<em>maven-compiler-plugin</em>。这些依赖项的版本被提取到属性部分。</p><p>最新版本的[自动服务](<a href="https://search.maven.org/classic/#search|gav|1|g%3A&quot;com.google.auto.service&quot;">https://search.maven.org/classic/#search|gav|1|g%3A&quot;com.google.auto.service&quot;</a> AND a%3A”auto-service”)库和[maven-compiler-plugin](<a href="https://search.maven.org/classic/#search|gav|1|g%3A&quot;org.apache.maven.plugins&quot;">https://search.maven.org/classic/#search|gav|1|g%3A&quot;org.apache.maven.plugins&quot;</a> AND a%3A”maven-compiler-plugin”)可以在 Maven 中央存储库中找到：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">auto-service.version</span>&gt;</span>1.0-rc2<span class="hljs-tag">&lt;/<span class="hljs-name">auto-service.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">maven-compiler-plugin.version</span>&gt;</span><br>      3.5.1<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">maven-compiler-plugin.version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.auto.service<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>auto-service<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;auto-service.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;maven-compiler-plugin.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><p>带有注释源的<em>annotation-user</em> Maven 模块不需要任何特殊调整，除了在依赖项部分添加对 annotation-processor 模块的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baeldung<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>annotation-processing<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="5-定义注释"><a href="#5-定义注释" class="headerlink" title="5. 定义注释"></a><strong>5. 定义注释</strong></h2><p>假设我们的<em>annotation-user</em>模块中有一个简单的 POJO 类，其中包含几个字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-comment">// getters and setters …</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>我们想创建一个构建器助手类来更流畅地实例化<em>Person</em>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Person person = <span class="hljs-keyword">new</span> PersonBuilder()<br>  .setAge(<span class="hljs-number">25</span>)<br>  .setName(<span class="hljs-string">&quot;John&quot;</span>)<br>  .build();<br></code></pre></td></tr></table></figure><p>这个<em>PersonBuilder</em>类是一代的明显选择，因为它的结构完全由<em>Person</em> setter 方法定义。</p><p>让我们在<em>注释处理器</em>模块中为 setter 方法创建一个*@BuilderProperty<em>注释。它将允许我们为每个注释了 setter 方法的类生成</em>Builder*类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> BuilderProperty &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>带有<em>ElementType.METHOD</em>参数的*@Target*注解确保此注解只能放在一个方法上。</p><p>在<em>SOURCE</em>保留策略的手段，这个注释是唯一可用的源处理过程中，而不是在运行时可用。</p><p>带有*@BuilderProperty<em>注解的属性的</em>Person*类将如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-meta">@BuilderProperty</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-meta">@BuilderProperty</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-comment">// getters …</span><br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-实现-处理器"><a href="#6-实现-处理器" class="headerlink" title="6. 实现*处理器*"></a><strong>6. 实现*处理器*</strong></h2><h3 id="6-1-创建一个-AbstractProcessor-子类"><a href="#6-1-创建一个-AbstractProcessor-子类" class="headerlink" title="6.1. 创建一个*AbstractProcessor*子类"></a><strong>6.1. 创建一个*AbstractProcessor*子类</strong></h3><p>我们将从在<em>注释处理器</em>Maven 模块中扩展<em>AbstractProcessor</em>类开始。</p><p>首先，我们应该指定该处理器能够处理的注释，以及支持的源代码版本。这可以通过实施方法进行<em>getSupportedAnnotationTypes</em>和<em>getSupportedSourceVersion</em>的的<em>处理器</em>接口或通过注释你的类*@SupportedAnnotationTypes<em>和</em>@SupportedSourceVersion*注解。</p><p>所述*@AutoService<em>注释是的一部分</em>自动服务*库，并允许生成，这将在下面的章节进行说明处理器的元数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SupportedAnnotationTypes(</span><br><span class="hljs-meta">  &quot;com.baeldung.annotation.processor.BuilderProperty&quot;)</span><br><span class="hljs-meta">@SupportedSourceVersion(SourceVersion.RELEASE_8)</span><br><span class="hljs-meta">@AutoService(Processor.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BuilderProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractProcessor</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">process</span><span class="hljs-params">(Set&lt;? extends TypeElement&gt; annotations, </span></span><br><span class="hljs-params"><span class="hljs-function">      RoundEnvironment roundEnv)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>您不仅可以指定具体的注释类名称，还可以指定通配符，例如<em>“com.baeldung.annotation.*”</em>来处理<em>com.baeldung.annotation</em>包及其所有子包中的注释，甚至可以<em>“*”</em>来处理所有注释.</p><p>我们必须实现的单一方法是处理本身的<em>process</em>方法。编译器为每个包含匹配注释的源文件调用它。</p><p>注释作为第一个<em>Set&lt;? extends TypeElement&gt; annotations</em>参数，有关当前处理轮次的信息作为<em>RoundEnviroment roundEnv</em>参数传递。</p><p>如果您的注释处理器已经处理了所有传递的注释，并且您不希望它们被传递到列表中的其他注释处理器，则返回<em>布尔</em>值应该为<em>true</em>。</p><h3 id="6-2-收集数据"><a href="#6-2-收集数据" class="headerlink" title="6.2. 收集数据"></a><strong>6.2. 收集数据</strong></h3><p>我们的处理器还没有真正做任何有用的事情，所以让我们用代码填充它。</p><p>首先，我们需要遍历在类中找到的所有注释类型——在我们的例子中，<em>注释</em>集将有一个与*@BuilderProperty*注释相对应的元素，即使这个注释在源文件中多次出现。</p><p>尽管如此，为了完整起见，最好将<em>process</em>方法实现为迭代周期：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">process</span><span class="hljs-params">(Set&lt;? extends TypeElement&gt; annotations, </span></span><br><span class="hljs-params"><span class="hljs-function">  RoundEnvironment roundEnv)</span> </span>&#123;<br><br>    <span class="hljs-keyword">for</span> (TypeElement annotation : annotations) &#123;<br>        Set&lt;? extends Element&gt; annotatedElements <br>          = roundEnv.getElementsAnnotatedWith(annotation);<br>        <br>        <span class="hljs-comment">// …</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在此代码中，我们使用<em>RoundEnvironment</em>实例接收所有使用*@BuilderProperty<em>注释的元素。对于</em>Person<em>类，这些元素对应于</em>setName<em>和</em>setAge*方法。</p><p><em>@BuilderProperty</em>注释的用户可能会错误地注释实际上不是 setter 的方法。setter 方法名称应以<em>set</em>开头，并且该方法应接收单个参数。所以让我们把小麦和谷壳分开。</p><p>在以下代码中，我们使用*Collectors.partitioningBy()*收集器将带注释的方法拆分为两个集合：正确注释的 setter 和其他错误注释的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;Boolean, List&lt;Element&gt;&gt; annotatedMethods = annotatedElements.stream().collect(<br>  Collectors.partitioningBy(element -&gt;<br>    ((ExecutableType) element.asType()).getParameterTypes().size() == <span class="hljs-number">1</span><br>    &amp;&amp; element.getSimpleName().toString().startsWith(<span class="hljs-string">&quot;set&quot;</span>)));<br><br>List&lt;Element&gt; setters = annotatedMethods.get(<span class="hljs-keyword">true</span>);<br>List&lt;Element&gt; otherMethods = annotatedMethods.get(<span class="hljs-keyword">false</span>);<br></code></pre></td></tr></table></figure><p>在这里，我们使用<em>Element.asType()<em>方法来接收</em>TypeMirror</em>类的实例，即使我们仅处于源处理阶段，它也为我们提供了一些内省类型的能力。</p><p>我们应该警告用户有关错误注释的方法，因此让我们使用可从<em>AbstractProcessor.processingEnv</em>保护字段访问的<em>Messager</em>实例。以下几行将在源处理阶段为每个错误注释的元素输出错误：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">otherMethods.forEach(element -&gt;<br>  processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,<br>    <span class="hljs-string">&quot;@BuilderProperty must be applied to a setXxx method &quot;</span> <br>      + <span class="hljs-string">&quot;with a single argument&quot;</span>, element));<br></code></pre></td></tr></table></figure><p>当然，如果正确的 setters 集合为空，则继续当前类型元素集合迭代是没有意义的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (setters.isEmpty()) &#123;<br>    <span class="hljs-keyword">continue</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果 setter 集合至少有一个元素，我们将使用它从封闭元素中获取完全限定的类名，在 setter 方法的情况下，它似乎是源类本身：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">String className = ((TypeElement) setters.get(<span class="hljs-number">0</span>)<br>  .getEnclosingElement()).getQualifiedName().toString();<br></code></pre></td></tr></table></figure><p>生成构建器类所需的最后一点信息是 setter 名称与其参数类型名称之间的映射：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;String, String&gt; setterMap = setters.stream().collect(Collectors.toMap(<br>    setter -&gt; setter.getSimpleName().toString(),<br>    setter -&gt; ((ExecutableType) setter.asType())<br>      .getParameterTypes().get(<span class="hljs-number">0</span>).toString()<br>));<br></code></pre></td></tr></table></figure><h3 id="6-3-生成输出文件"><a href="#6-3-生成输出文件" class="headerlink" title="6.3. 生成输出文件"></a><strong>6.3. 生成输出文件</strong></h3><p>现在我们有了生成构建器类所需的所有信息：源类的名称、它的所有 setter 名称以及它们的参数类型。</p><p>为了生成输出文件，我们将使用<em>AbstractProcessor.processingEnv</em>受保护属性中的对象再次提供的<em>Filer</em>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">JavaFileObject builderFile = processingEnv.getFiler()<br>  .createSourceFile(builderClassName);<br><span class="hljs-keyword">try</span> (PrintWriter out = <span class="hljs-keyword">new</span> PrintWriter(builderFile.openWriter())) &#123;<br>    <span class="hljs-comment">// writing generated file to out …</span><br>&#125;<br></code></pre></td></tr></table></figure><p>下面提供了<em>writeBuilderFile</em>方法的完整代码。我们只需要计算源类和构建器类的包名、完全限定的构建器类名和简单类名。其余的代码非常简单。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeBuilderFile</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  String className, Map&lt;String, String&gt; setterMap)</span> </span><br><span class="hljs-function">  <span class="hljs-keyword">throws</span> IOException </span>&#123;<br><br>    String packageName = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">int</span> lastDot = className.lastIndexOf(<span class="hljs-string">&#x27;.&#x27;</span>);<br>    <span class="hljs-keyword">if</span> (lastDot &gt; <span class="hljs-number">0</span>) &#123;<br>        packageName = className.substring(<span class="hljs-number">0</span>, lastDot);<br>    &#125;<br><br>    String simpleClassName = className.substring(lastDot + <span class="hljs-number">1</span>);<br>    String builderClassName = className + <span class="hljs-string">&quot;Builder&quot;</span>;<br>    String builderSimpleClassName = builderClassName<br>      .substring(lastDot + <span class="hljs-number">1</span>);<br><br>    JavaFileObject builderFile = processingEnv.getFiler()<br>      .createSourceFile(builderClassName);<br>    <br>    <span class="hljs-keyword">try</span> (PrintWriter out = <span class="hljs-keyword">new</span> PrintWriter(builderFile.openWriter())) &#123;<br><br>        <span class="hljs-keyword">if</span> (packageName != <span class="hljs-keyword">null</span>) &#123;<br>            out.print(<span class="hljs-string">&quot;package &quot;</span>);<br>            out.print(packageName);<br>            out.println(<span class="hljs-string">&quot;;&quot;</span>);<br>            out.println();<br>        &#125;<br><br>        out.print(<span class="hljs-string">&quot;public class &quot;</span>);<br>        out.print(builderSimpleClassName);<br>        out.println(<span class="hljs-string">&quot; &#123;&quot;</span>);<br>        out.println();<br><br>        out.print(<span class="hljs-string">&quot;    private &quot;</span>);<br>        out.print(simpleClassName);<br>        out.print(<span class="hljs-string">&quot; object = new &quot;</span>);<br>        out.print(simpleClassName);<br>        out.println(<span class="hljs-string">&quot;();&quot;</span>);<br>        out.println();<br><br>        out.print(<span class="hljs-string">&quot;    public &quot;</span>);<br>        out.print(simpleClassName);<br>        out.println(<span class="hljs-string">&quot; build() &#123;&quot;</span>);<br>        out.println(<span class="hljs-string">&quot;        return object;&quot;</span>);<br>        out.println(<span class="hljs-string">&quot;    &#125;&quot;</span>);<br>        out.println();<br><br>        setterMap.entrySet().forEach(setter -&gt; &#123;<br>            String methodName = setter.getKey();<br>            String argumentType = setter.getValue();<br><br>            out.print(<span class="hljs-string">&quot;    public &quot;</span>);<br>            out.print(builderSimpleClassName);<br>            out.print(<span class="hljs-string">&quot; &quot;</span>);<br>            out.print(methodName);<br><br>            out.print(<span class="hljs-string">&quot;(&quot;</span>);<br><br>            out.print(argumentType);<br>            out.println(<span class="hljs-string">&quot; value) &#123;&quot;</span>);<br>            out.print(<span class="hljs-string">&quot;        object.&quot;</span>);<br>            out.print(methodName);<br>            out.println(<span class="hljs-string">&quot;(value);&quot;</span>);<br>            out.println(<span class="hljs-string">&quot;        return this;&quot;</span>);<br>            out.println(<span class="hljs-string">&quot;    &#125;&quot;</span>);<br>            out.println();<br>        &#125;);<br><br>        out.println(<span class="hljs-string">&quot;&#125;&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-运行示例"><a href="#7-运行示例" class="headerlink" title="7. 运行示例"></a><strong>7. 运行示例</strong></h2><p>要查看代码生成的运行情况，您应该从公共父根编译两个模块，或者首先编译<em>annotation-processor</em>模块，然后编译<em>annotation-user</em>模块。</p><p>生成的<em>PersonBuilder</em>类可以在<em>annotation-user/target/generated-sources/annotations/com/baeldung/annotation/PersonBuilder.java</em>文件中找到，应该如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.baeldung.annotation;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonBuilder</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Person object = <span class="hljs-keyword">new</span> Person();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Person <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> object;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PersonBuilder <span class="hljs-title">setName</span><span class="hljs-params">(java.lang.String value)</span> </span>&#123;<br>        object.setName(value);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PersonBuilder <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        object.setAge(value);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-注册处理器的其他方式"><a href="#8-注册处理器的其他方式" class="headerlink" title="8. 注册处理器的其他方式"></a><strong>8. 注册处理器的其他方式</strong></h2><p>要在编译阶段使用注释处理器，您还有其他几个选项，具体取决于您的用例和您使用的工具。</p><h3 id="8-1-使用注释处理器工具"><a href="#8-1-使用注释处理器工具" class="headerlink" title="8.1. 使用注释处理器工具"></a><strong>8.1. 使用注释处理器工具</strong></h3><p>该<em>贴切</em>工具是用于处理源文件一个特殊的命令行实用程序。它是 Java 5 的一部分，但从 Java 7 开始，它被弃用，取而代之的是其他选项，并在 Java 8 中完全删除。本文不会讨论它。</p><h3 id="8-2-使用编译器密钥"><a href="#8-2-使用编译器密钥" class="headerlink" title="8.2. 使用编译器密钥"></a><strong>8.2. 使用编译器密钥</strong></h3><p>该*-processor*编译器关键是一个标准的JDK设施，以增加编译器的源处理阶段，自己的注释处理器。</p><p>请注意，处理器本身和注释必须已经在单独的编译中编译为类并存在于类路径中，因此您应该做的第一件事是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">javac com/baeldung/annotation/processor/BuilderProcessor<br>javac com/baeldung/annotation/processor/BuilderProperty<br></code></pre></td></tr></table></figure><p>然后，您使用*-processor*键对您的源代码进行实际编译，指定您刚刚编译的注释处理器类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">javac -processor com.baeldung.annotation.processor.MyProcessor Person.java<br></code></pre></td></tr></table></figure><p>要一次性指定多个注释处理器，您可以用逗号分隔它们的类名，如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">javac -processor package1.Processor1,package2.Processor2 SourceFile.java<br></code></pre></td></tr></table></figure><h3 id="8-3-使用-Maven"><a href="#8-3-使用-Maven" class="headerlink" title="8.3. 使用 Maven"></a><strong>8.3. 使用 Maven</strong></h3><p>的<em>Maven的编译器插件</em>允许指定注释处理器作为其结构的一部分。</p><p>这是为编译器插件添加注释处理器的示例。您还可以使用<em>generateSourcesDirectory</em>配置参数指定将生成的源放入的目录。</p><p>请注意，<em>BuilderProcessor</em>类应该已经被编译，例如，从构建依赖项中的另一个 jar 导入：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">encoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">encoding</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">generatedSourcesDirectory</span>&gt;</span>$&#123;project.build.directory&#125;<br>                  /generated-sources/<span class="hljs-tag">&lt;/<span class="hljs-name">generatedSourcesDirectory</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">annotationProcessors</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">annotationProcessor</span>&gt;</span><br>                        com.baeldung.annotation.processor.BuilderProcessor<br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">annotationProcessor</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">annotationProcessors</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="8-4-将处理器-Jar-添加到类路径"><a href="#8-4-将处理器-Jar-添加到类路径" class="headerlink" title="8.4. 将处理器 Jar 添加到类路径"></a><strong>8.4. 将处理器 Jar 添加到类路径</strong></h3><p>您可以简单地将带有处理器类的特殊结构的 jar 添加到编译器的类路径中，而不是在编译器选项中指定注释处理器。</p><p>要自动选择它，编译器必须知道处理器类的名称。因此，您必须在<em>META-INF/services/javax.annotation.processing.Processor</em>文件中将其指定为处理器的完全限定类名：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">com.baeldung.annotation.processor.BuilderProcessor<br></code></pre></td></tr></table></figure><p>您还可以从这个 jar 中指定多个处理器，通过用新行分隔它们来自动拾取：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">package1.Processor1<br>package2.Processor2<br>package3.Processor3<br></code></pre></td></tr></table></figure><p>如果使用Maven构建这个jar，并尝试将这个文件直接放到<em>src/main/resources/META-INF/services</em>目录下，会遇到如下错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">[ERROR] Bad service configuration file, or exception thrown <span class="hljs-keyword">while</span> <br>constructing Processor object: javax.annotation.processing.Processor: <br>Provider com.baeldung.annotation.processor.BuilderProcessor not found<br></code></pre></td></tr></table></figure><p>这是因为当<em>BuilderProcessor</em>文件尚未编译时，编译器会在模块本身的<em>源代码处理</em>阶段尝试使用此文件。在 Maven 构建的资源复制阶段，该文件必须放在另一个资源目录中并复制到<em>META-INF/services</em>目录，或者（甚至更好）在构建期间生成。</p><p>下一节中讨论的 Google<em>自动服务</em>库允许使用简单的注释生成此文件。</p><h3 id="8-5-使用-Google“auto-service”库"><a href="#8-5-使用-Google“auto-service”库" class="headerlink" title="8.5. 使用 Google“auto service”库"></a><strong>8.5. 使用 Google“auto service”库</strong></h3><p>要自动生成注册文件，您可以使用Google 的<em>自动服务</em>库中的*@AutoService*注释，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AutoService(Processor.class)</span><br><span class="hljs-keyword">public</span> BuilderProcessor extends AbstractProcessor &#123;<br>    <span class="hljs-comment">// …</span><br>&#125;<br></code></pre></td></tr></table></figure><p>此注释本身由来自自动服务库的注释处理器处理。该处理器生成包含<em>BuilderProcessor</em>类名的<em>META-INF/services/javax.annotation.processing.Processor</em>文件。</p><h2 id="9-结论"><a href="#9-结论" class="headerlink" title="9. 结论"></a><strong>9. 结论</strong></h2><p>在本文中，我们使用为 POJO 生成 Builder 类的示例演示了源级注释处理。我们还提供了几种在您的项目中注册注释处理器的替代方法。</p><p>本文的源代码可<a href="https://github.com/eugenp/tutorials/tree/master/annotations">在 GitHub 上找到</a>。</p><h1 id="原文："><a href="#原文：" class="headerlink" title="原文："></a>原文：</h1><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a><strong>1. <a href="https://www.baeldung.com/java-annotation-processing-builder">Introduction</a></strong></h2><p>This article is <strong>an intro to Java source-level annotation processing</strong> and provides examples of using this technique for generating additional source files during compilation.</p><h2 id="2-Applications-of-Annotation-Processing"><a href="#2-Applications-of-Annotation-Processing" class="headerlink" title="2. Applications of Annotation Processing"></a><strong>2. Applications of Annotation Processing</strong></h2><p>The source-level annotation processing first appeared in Java 5. It is a handy technique for generating additional source files during the compilation stage.</p><p>The source files don’t have to be Java files — you can generate any kind of description, metadata, documentation, resources, or any other type of files, based on annotations in your source code.</p><p>Annotation processing is actively used in many ubiquitous Java libraries, for instance, to generate metaclasses in QueryDSL and JPA, to augment classes with boilerplate code in Lombok library.</p><p>An important thing to note is <strong>the limitation of the annotation processing API — it can only be used to generate new files, not to change existing ones</strong>.</p><p>The notable exception is the <a href="https://projectlombok.org/">Lombok</a> library which uses annotation processing as a bootstrapping mechanism to include itself into the compilation process and modify the AST via some internal compiler APIs. This hacky technique has nothing to do with the intended purpose of annotation processing and therefore is not discussed in this article.</p><h2 id="3-Annotation-Processing-API"><a href="#3-Annotation-Processing-API" class="headerlink" title="3. Annotation Processing API"></a><strong>3. Annotation Processing API</strong></h2><p>The annotation processing is done in multiple rounds. Each round starts with the compiler searching for the annotations in the source files and choosing the annotation processors suited for these annotations. Each annotation processor, in turn, is called on the corresponding sources.</p><p>If any files are generated during this process, another round is started with the generated files as its input. This process continues until no new files are generated during the processing stage.</p><p>Each annotation processor, in turn, is called on the corresponding sources. If any files are generated during this process, another round is started with the generated files as its input. This process continues until no new files are generated during the processing stage.</p><p>The annotation processing API is located in the <em>javax.annotation.processing</em> package. The main interface that you’ll have to implement is the <em>Processor</em> interface, which has a partial implementation in the form of <em>AbstractProcessor</em> class. This class is the one we’re going to extend to create our own annotation processor.</p><h2 id="4-Setting-Up-the-Project"><a href="#4-Setting-Up-the-Project" class="headerlink" title="4. Setting Up the Project"></a><strong>4. Setting Up the Project</strong></h2><p>To demonstrate the possibilities of annotation processing, we will develop a simple processor for generating fluent object builders for annotated classes.</p><p>We’re going to split our project into two Maven modules. One of them, <em>annotation-processor</em> module, will contain the processor itself together with the annotation, and another, the <em>annotation-user</em> module, will contain the annotated class. This is a typical use case of annotation processing.</p><p>The settings for the <em>annotation-processor</em> module are as follows. We’re going to use the Google’s <a href="https://github.com/google/auto/tree/master/service">auto-service</a> library to generate processor metadata file which will be discussed later, and the <em>maven-compiler-plugin</em> tuned for the Java 8 source code. The versions of these dependencies are extracted to the properties section.</p><p>Latest versions of the [auto-service](<a href="https://search.maven.org/classic/#search|gav|1|g%3A&quot;com.google.auto.service&quot;">https://search.maven.org/classic/#search|gav|1|g%3A&quot;com.google.auto.service&quot;</a> AND a%3A”auto-service”) library and [maven-compiler-plugin](<a href="https://search.maven.org/classic/#search|gav|1|g%3A&quot;org.apache.maven.plugins&quot;">https://search.maven.org/classic/#search|gav|1|g%3A&quot;org.apache.maven.plugins&quot;</a> AND a%3A”maven-compiler-plugin”) can be found in Maven Central repository:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">auto-service.version</span>&gt;</span>1.0-rc2<span class="hljs-tag">&lt;/<span class="hljs-name">auto-service.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">maven-compiler-plugin.version</span>&gt;</span><br>      3.5.1<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">maven-compiler-plugin.version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.auto.service<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>auto-service<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;auto-service.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;maven-compiler-plugin.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><p>The <em>annotation-user</em> Maven module with the annotated sources does not need any special tuning, except adding a dependency on the annotation-processor module in the dependencies section:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baeldung<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>annotation-processing<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="5-Defining-an-Annotation"><a href="#5-Defining-an-Annotation" class="headerlink" title="5. Defining an Annotation"></a><strong>5. Defining an Annotation</strong></h2><p>Suppose we have a simple POJO class in our <em>annotation-user</em> module with several fields:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-comment">// getters and setters …</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>We want to create a builder helper class to instantiate the <em>Person</em> class more fluently:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Person person = <span class="hljs-keyword">new</span> PersonBuilder()<br>  .setAge(<span class="hljs-number">25</span>)<br>  .setName(<span class="hljs-string">&quot;John&quot;</span>)<br>  .build();<br></code></pre></td></tr></table></figure><p>This <em>PersonBuilder</em> class is an obvious choice for a generation, as its structure is completely defined by the <em>Person</em> setter methods.</p><p>Let’s create a <em>@BuilderProperty</em> annotation in the <em>annotation-processor</em> module for the setter methods. It will allow us to generate the <em>Builder</em> class for each class that has its setter methods annotated:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> BuilderProperty &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>The <em>@Target</em> annotation with the <em>ElementType.METHOD</em> parameter ensures that this annotation can be only put on a method.</p><p>The <em>SOURCE</em> retention policy means that this annotation is only available during source processing and is not available at runtime.</p><p>The <em>Person</em> class with properties annotated with the <em>@BuilderProperty</em> annotation will look as follows:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-meta">@BuilderProperty</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-meta">@BuilderProperty</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-comment">// getters …</span><br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-Implementing-a-Processor"><a href="#6-Implementing-a-Processor" class="headerlink" title="6. Implementing a *Processor*"></a><strong>6. Implementing a *Processor*</strong></h2><h3 id="6-1-Creating-an-AbstractProcessor-Subclass"><a href="#6-1-Creating-an-AbstractProcessor-Subclass" class="headerlink" title="6.1. Creating an *AbstractProcessor* Subclass"></a><strong>6.1. Creating an *AbstractProcessor* Subclass</strong></h3><p>We’ll start with extending the <em>AbstractProcessor</em> class inside the <em>annotation-processor</em> Maven module.</p><p>First, we should specify annotations that this processor is capable of processing, and also the supported source code version. This can be done either by implementing the methods <em>getSupportedAnnotationTypes</em> and <em>getSupportedSourceVersion</em> of the <em>Processor</em> interface or by annotating your class with <em>@SupportedAnnotationTypes</em> and <em>@SupportedSourceVersion</em> annotations.</p><p>The <em>@AutoService</em> annotation is a part of the <em>auto-service</em> library and allows to generate the processor metadata which will be explained in the following sections.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SupportedAnnotationTypes(</span><br><span class="hljs-meta">  &quot;com.baeldung.annotation.processor.BuilderProperty&quot;)</span><br><span class="hljs-meta">@SupportedSourceVersion(SourceVersion.RELEASE_8)</span><br><span class="hljs-meta">@AutoService(Processor.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BuilderProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractProcessor</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">process</span><span class="hljs-params">(Set&lt;? extends TypeElement&gt; annotations, </span></span><br><span class="hljs-params"><span class="hljs-function">      RoundEnvironment roundEnv)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>You can specify not only the concrete annotation class names but also wildcards, like <em>“com.baeldung.annotation.*”</em> to process annotations inside the <em>com.baeldung.annotation</em> package and all its sub packages, or even <em>“*”</em> to process all annotations.</p><p>The single method that we’ll have to implement is the <em>process</em> method that does the processing itself. It is called by the compiler for every source file containing the matching annotations.</p><p>Annotations are passed as the first <em>Set&lt;? extends TypeElement&gt; annotations</em> argument, and the information about the current processing round is passed as the <em>RoundEnviroment roundEnv</em> argument.</p><p>The return <em>boolean</em> value should be <em>true</em> if your annotation processor has processed all the passed annotations, and you don’t want them to be passed to other annotation processors down the list.</p><h3 id="6-2-Gathering-Data"><a href="#6-2-Gathering-Data" class="headerlink" title="6.2. Gathering Data"></a><strong>6.2. Gathering Data</strong></h3><p>Our processor does not really do anything useful yet, so let’s fill it with code.</p><p>First, we’ll need to iterate through all annotation types that are found in the class — in our case, the <em>annotations</em> set will have a single element corresponding to the <em>@BuilderProperty</em> annotation, even if this annotation occurs multiple times in the source file.</p><p>Still, it’s better to implement the <em>process</em> method as an iteration cycle, for completeness sake:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">process</span><span class="hljs-params">(Set&lt;? extends TypeElement&gt; annotations, </span></span><br><span class="hljs-params"><span class="hljs-function">  RoundEnvironment roundEnv)</span> </span>&#123;<br><br>    <span class="hljs-keyword">for</span> (TypeElement annotation : annotations) &#123;<br>        Set&lt;? extends Element&gt; annotatedElements <br>          = roundEnv.getElementsAnnotatedWith(annotation);<br>        <br>        <span class="hljs-comment">// …</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>In this code, we use the <em>RoundEnvironment</em> instance to receive all elements annotated with the <em>@BuilderProperty</em> annotation. In the case of the <em>Person</em> class, these elements correspond to the <em>setName</em> and <em>setAge</em> methods.</p><p><em>@BuilderProperty</em> annotation’s user could erroneously annotate methods that are not actually setters. The setter method name should start with <em>set</em>, and the method should receive a single argument. So let’s separate the wheat from the chaff.</p><p>In the following code, we use the <em>Collectors.partitioningBy()</em> collector to split annotated methods into two collections: correctly annotated setters and other erroneously annotated methods:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;Boolean, List&lt;Element&gt;&gt; annotatedMethods = annotatedElements.stream().collect(<br>  Collectors.partitioningBy(element -&gt;<br>    ((ExecutableType) element.asType()).getParameterTypes().size() == <span class="hljs-number">1</span><br>    &amp;&amp; element.getSimpleName().toString().startsWith(<span class="hljs-string">&quot;set&quot;</span>)));<br><br>List&lt;Element&gt; setters = annotatedMethods.get(<span class="hljs-keyword">true</span>);<br>List&lt;Element&gt; otherMethods = annotatedMethods.get(<span class="hljs-keyword">false</span>);<br></code></pre></td></tr></table></figure><p>Here we use the <em>Element.asType()</em> method to receive an instance of the <em>TypeMirror</em> class which gives us some ability to introspect types even though we are only at the source processing stage.</p><p>We should warn the user about incorrectly annotated methods, so let’s use the <em>Messager</em> instance accessible from the <em>AbstractProcessor.processingEnv</em> protected field. The following lines will output an error for each erroneously annotated element during the source processing stage:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">otherMethods.forEach(element -&gt;<br>  processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,<br>    <span class="hljs-string">&quot;@BuilderProperty must be applied to a setXxx method &quot;</span> <br>      + <span class="hljs-string">&quot;with a single argument&quot;</span>, element));<br></code></pre></td></tr></table></figure><p>Of course, if the correct setters collection is empty, there is no point of continuing the current type element set iteration:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (setters.isEmpty()) &#123;<br>    <span class="hljs-keyword">continue</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>If the setters collection has at least one element, we’re going to use it to get the fully qualified class name from the enclosing element, which in case of the setter method appears to be the source class itself:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">String className = ((TypeElement) setters.get(<span class="hljs-number">0</span>)<br>  .getEnclosingElement()).getQualifiedName().toString();<br></code></pre></td></tr></table></figure><p>The last bit of information we need to generate a builder class is a map between the names of the setters and the names of their argument types:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;String, String&gt; setterMap = setters.stream().collect(Collectors.toMap(<br>    setter -&gt; setter.getSimpleName().toString(),<br>    setter -&gt; ((ExecutableType) setter.asType())<br>      .getParameterTypes().get(<span class="hljs-number">0</span>).toString()<br>));<br></code></pre></td></tr></table></figure><h3 id="6-3-Generating-the-Output-File"><a href="#6-3-Generating-the-Output-File" class="headerlink" title="6.3. Generating the Output File"></a><strong>6.3. Generating the Output File</strong></h3><p>Now we have all the information we need to generate a builder class: the name of the source class, all its setter names, and their argument types.</p><p>To generate the output file, we’ll use the <em>Filer</em> instance provided again by the object in the <em>AbstractProcessor.processingEnv</em> protected property:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">JavaFileObject builderFile = processingEnv.getFiler()<br>  .createSourceFile(builderClassName);<br><span class="hljs-keyword">try</span> (PrintWriter out = <span class="hljs-keyword">new</span> PrintWriter(builderFile.openWriter())) &#123;<br>    <span class="hljs-comment">// writing generated file to out …</span><br>&#125;<br></code></pre></td></tr></table></figure><p>The complete code of the <em>writeBuilderFile</em> method is provided below. We only need to calculate the package name, fully qualified builder class name, and simple class names for the source class and the builder class. The rest of the code is pretty straightforward.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeBuilderFile</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  String className, Map&lt;String, String&gt; setterMap)</span> </span><br><span class="hljs-function">  <span class="hljs-keyword">throws</span> IOException </span>&#123;<br><br>    String packageName = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">int</span> lastDot = className.lastIndexOf(<span class="hljs-string">&#x27;.&#x27;</span>);<br>    <span class="hljs-keyword">if</span> (lastDot &gt; <span class="hljs-number">0</span>) &#123;<br>        packageName = className.substring(<span class="hljs-number">0</span>, lastDot);<br>    &#125;<br><br>    String simpleClassName = className.substring(lastDot + <span class="hljs-number">1</span>);<br>    String builderClassName = className + <span class="hljs-string">&quot;Builder&quot;</span>;<br>    String builderSimpleClassName = builderClassName<br>      .substring(lastDot + <span class="hljs-number">1</span>);<br><br>    JavaFileObject builderFile = processingEnv.getFiler()<br>      .createSourceFile(builderClassName);<br>    <br>    <span class="hljs-keyword">try</span> (PrintWriter out = <span class="hljs-keyword">new</span> PrintWriter(builderFile.openWriter())) &#123;<br><br>        <span class="hljs-keyword">if</span> (packageName != <span class="hljs-keyword">null</span>) &#123;<br>            out.print(<span class="hljs-string">&quot;package &quot;</span>);<br>            out.print(packageName);<br>            out.println(<span class="hljs-string">&quot;;&quot;</span>);<br>            out.println();<br>        &#125;<br><br>        out.print(<span class="hljs-string">&quot;public class &quot;</span>);<br>        out.print(builderSimpleClassName);<br>        out.println(<span class="hljs-string">&quot; &#123;&quot;</span>);<br>        out.println();<br><br>        out.print(<span class="hljs-string">&quot;    private &quot;</span>);<br>        out.print(simpleClassName);<br>        out.print(<span class="hljs-string">&quot; object = new &quot;</span>);<br>        out.print(simpleClassName);<br>        out.println(<span class="hljs-string">&quot;();&quot;</span>);<br>        out.println();<br><br>        out.print(<span class="hljs-string">&quot;    public &quot;</span>);<br>        out.print(simpleClassName);<br>        out.println(<span class="hljs-string">&quot; build() &#123;&quot;</span>);<br>        out.println(<span class="hljs-string">&quot;        return object;&quot;</span>);<br>        out.println(<span class="hljs-string">&quot;    &#125;&quot;</span>);<br>        out.println();<br><br>        setterMap.entrySet().forEach(setter -&gt; &#123;<br>            String methodName = setter.getKey();<br>            String argumentType = setter.getValue();<br><br>            out.print(<span class="hljs-string">&quot;    public &quot;</span>);<br>            out.print(builderSimpleClassName);<br>            out.print(<span class="hljs-string">&quot; &quot;</span>);<br>            out.print(methodName);<br><br>            out.print(<span class="hljs-string">&quot;(&quot;</span>);<br><br>            out.print(argumentType);<br>            out.println(<span class="hljs-string">&quot; value) &#123;&quot;</span>);<br>            out.print(<span class="hljs-string">&quot;        object.&quot;</span>);<br>            out.print(methodName);<br>            out.println(<span class="hljs-string">&quot;(value);&quot;</span>);<br>            out.println(<span class="hljs-string">&quot;        return this;&quot;</span>);<br>            out.println(<span class="hljs-string">&quot;    &#125;&quot;</span>);<br>            out.println();<br>        &#125;);<br><br>        out.println(<span class="hljs-string">&quot;&#125;&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-Running-the-Example"><a href="#7-Running-the-Example" class="headerlink" title="7. Running the Example"></a><strong>7. Running the Example</strong></h2><p>To see the code generation in action, you should either compile both modules from the common parent root or first compile the <em>annotation-processor</em> module and then the <em>annotation-user</em> module.</p><p>The generated <em>PersonBuilder</em> class can be found inside the <em>annotation-user/target/generated-sources/annotations/com/baeldung/annotation/PersonBuilder.java</em> file and should look like this:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.baeldung.annotation;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonBuilder</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Person object = <span class="hljs-keyword">new</span> Person();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Person <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> object;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PersonBuilder <span class="hljs-title">setName</span><span class="hljs-params">(java.lang.String value)</span> </span>&#123;<br>        object.setName(value);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PersonBuilder <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        object.setAge(value);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-Alternative-Ways-of-Registering-a-Processor"><a href="#8-Alternative-Ways-of-Registering-a-Processor" class="headerlink" title="8. Alternative Ways of Registering a Processor"></a><strong>8. Alternative Ways of Registering a Processor</strong></h2><p>To use your annotation processor during the compilation stage, you have several other options, depending on your use case and the tools you use.</p><h3 id="8-1-Using-the-Annotation-Processor-Tool"><a href="#8-1-Using-the-Annotation-Processor-Tool" class="headerlink" title="8.1. Using the Annotation Processor Tool"></a><strong>8.1. Using the Annotation Processor Tool</strong></h3><p>The <em>apt</em> tool was a special command line utility for processing source files. It was a part of Java 5, but since Java 7 it was deprecated in favour of other options and removed completely in Java 8. It will not be discussed in this article.</p><h3 id="8-2-Using-the-Compiler-Key"><a href="#8-2-Using-the-Compiler-Key" class="headerlink" title="8.2. Using the Compiler Key"></a><strong>8.2. Using the Compiler Key</strong></h3><p>The <em>-processor</em> compiler key is a standard JDK facility to augment the source processing stage of the compiler with your own annotation processor.</p><p>Note that the processor itself and the annotation have to be already compiled as classes in a separate compilation and present on the classpath, so the first thing you should do is:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">javac com/baeldung/annotation/processor/BuilderProcessor<br>javac com/baeldung/annotation/processor/BuilderProperty<br></code></pre></td></tr></table></figure><p>Then you do the actual compilation of your sources with the <em>-processor</em> key specifying the annotation processor class you’ve just compiled:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">javac -processor com.baeldung.annotation.processor.MyProcessor Person.java<br></code></pre></td></tr></table></figure><p>To specify several annotation processors in one go, you can separate their class names with commas, like this:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">javac -processor package1.Processor1,package2.Processor2 SourceFile.java<br></code></pre></td></tr></table></figure><h3 id="8-3-Using-Maven"><a href="#8-3-Using-Maven" class="headerlink" title="8.3. Using Maven"></a><strong>8.3. Using Maven</strong></h3><p>The <em>maven-compiler-plugin</em> allows specifying annotation processors as part of its configuration.</p><p>Here’s an example of adding annotation processor for the compiler plugin. You could also specify the directory to put generated sources into, using the <em>generatedSourcesDirectory</em> configuration parameter.</p><p>Note that the <em>BuilderProcessor</em> class should already be compiled, for instance, imported from another jar in the build dependencies:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">encoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">encoding</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">generatedSourcesDirectory</span>&gt;</span>$&#123;project.build.directory&#125;<br>                  /generated-sources/<span class="hljs-tag">&lt;/<span class="hljs-name">generatedSourcesDirectory</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">annotationProcessors</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">annotationProcessor</span>&gt;</span><br>                        com.baeldung.annotation.processor.BuilderProcessor<br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">annotationProcessor</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">annotationProcessors</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="8-4-Adding-a-Processor-Jar-to-the-Classpath"><a href="#8-4-Adding-a-Processor-Jar-to-the-Classpath" class="headerlink" title="8.4. Adding a Processor Jar to the Classpath"></a><strong>8.4. Adding a Processor Jar to the Classpath</strong></h3><p>Instead of specifying the annotation processor in the compiler options, you may simply add a specially structured jar with the processor class to the classpath of the compiler.</p><p>To pick it up automatically, the compiler has to know the name of the processor class. So you have to specify it in the <em>META-INF/services/javax.annotation.processing.Processor</em> file as a fully qualified class name of the processor:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">com.baeldung.annotation.processor.BuilderProcessor<br></code></pre></td></tr></table></figure><p>You can also specify several processors from this jar to pick up automatically by separating them with a new line:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">package1.Processor1<br>package2.Processor2<br>package3.Processor3<br></code></pre></td></tr></table></figure><p>If you use Maven to build this jar and try to put this file directly into the <em>src/main/resources/META-INF/services</em> directory, you’ll encounter the following error:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">[ERROR] Bad service configuration file, or exception thrown <span class="hljs-keyword">while</span> <br>constructing Processor object: javax.annotation.processing.Processor: <br>Provider com.baeldung.annotation.processor.BuilderProcessor not found<br></code></pre></td></tr></table></figure><p>This is because the compiler tries to use this file during the <em>source-processing</em> stage of the module itself when the <em>BuilderProcessor</em> file is not yet compiled. The file has to be either put inside another resource directory and copied to the <em>META-INF/services</em> directory during the resource copying stage of the Maven build, or (even better) generated during the build.</p><p>The Google <em>auto-service</em> library, discussed in the following section, allows generating this file using a simple annotation.</p><h3 id="8-5-Using-the-Google-auto-service-Library"><a href="#8-5-Using-the-Google-auto-service-Library" class="headerlink" title="8.5. Using the Google *auto-service* Library"></a><strong>8.5. Using the Google *auto-service* Library</strong></h3><p>To generate the registration file automatically, you can use the <em>@AutoService</em> annotation from the Google’s <em>auto-service</em> library, like this:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AutoService(Processor.class)</span><br><span class="hljs-keyword">public</span> BuilderProcessor extends AbstractProcessor &#123;<br>    <span class="hljs-comment">// …</span><br>&#125;<br></code></pre></td></tr></table></figure><p>This annotation is itself processed by the annotation processor from the auto-service library. This processor generates the <em>META-INF/services/javax.annotation.processing.Processor</em> file containing the <em>BuilderProcessor</em> class name.</p><h2 id="9-Conclusion"><a href="#9-Conclusion" class="headerlink" title="9. Conclusion"></a><strong>9. Conclusion</strong></h2><p>In this article, we’ve demonstrated source-level annotation processing using an example of generating a Builder class for a POJO. We have also provided several alternative ways of registering annotation processors in your project.</p><p>The source code for the article is available <a href="https://github.com/eugenp/tutorials/tree/master/annotations">on GitHub</a>.</p><hr><h1 id="官方qpi文档"><a href="#官方qpi文档" class="headerlink" title="官方qpi文档"></a>官方qpi文档</h1><p>可以看到,AbstractProcessor实现了接口Processor,那么,我们在来看下Processor的api文档:</p><blockquote><p>javax.annotation.processing<br> Interface Processor</p><p>All Known Implementing Classes:<br> <a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/AbstractProcessor.html">AbstractProcessor</a></p><hr><p>public interface Processor</p></blockquote><blockquote><p>The interface for an annotation processor.</p></blockquote><blockquote><p>Annotation processing happens in a sequence of <a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/RoundEnvironment.html">rounds</a>. On each round, a processor may be asked to [process](<a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/Processor.html#process">https://link.jianshu.com?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/Processor.html#process</a>(java.util.Set, javax.annotation.processing.RoundEnvironment)) a subset of the annotations found on the source and class files produced by a prior round. The inputs to the first round of processing are the initial inputs to a run of the tool; these initial inputs can be regarded as the output of a virtual zeroth round of processing. If a processor was asked to process on a given round, it will be asked to process on subsequent rounds, including the last round, even if there are no annotations for it to process. The tool infrastructure may also ask a processor to process files generated implicitly by the tool’s operation.<br> Each implementation of a Processor  must provide a public no-argument constructor to be used by tools to instantiate the processor. The tool infrastructure will interact with classes implementing this interface as follows:</p><ol><li>If an existing Processor object is not being used, to create an instance of a processor the tool calls the no-arg constructor of the processor class.</li><li>Next, the tool calls the <a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/Processor.html#init(javax.annotation.processing.ProcessingEnvironment)">init </a> method with an appropriate ProcessingEnvironment .</li><li>Afterwards, the tool calls <a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/Processor.html#getSupportedAnnotationTypes()">getSupportedAnnotationTypes </a>, <a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/Processor.html#getSupportedOptions()">getSupportedOptions </a>, and <a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/Processor.html#getSupportedSourceVersion()">getSupportedSourceVersion </a>. These methods are only called once per run, not on each round.</li><li>As appropriate, the tool calls the [process<br> ](<a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/Processor.html#process">https://link.jianshu.com?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/Processor.html#process</a>(java.util.Set, javax.annotation.processing.RoundEnvironment)) method on the Processor object; a new Processor object is <em>not</em> created for each round.</li></ol><p>If a processor object is created and used without the above protocol being followed, then the processor’s behavior is not defined by this interface specification.The tool uses a <em>discovery process</em> to find annotation processors and decide whether or not they should be run. By configuring the tool, the set of potential processors can be controlled. For example, for a <a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/tools/JavaCompiler.html">JavaCompiler </a> the list of candidate processors to run can be <a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/tools/JavaCompiler.CompilationTask.html#setProcessors(java.lang.Iterable)">set directly</a> or controlled by a <a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/tools/StandardLocation.html#ANNOTATION_PROCESSOR_PATH">search path</a> used for a <a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/java/util/ServiceLoader.html">service-style</a> lookup. Other tool implementations may have different configuration mechanisms, such as command line options; for details, refer to the particular tool’s documentation. Which processors the tool asks to [run](<a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/Processor.html#process">https://link.jianshu.com?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/Processor.html#process</a>(java.util.Set, javax.annotation.processing.RoundEnvironment)) is a function of what annotations are present on the <a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/RoundEnvironment.html#getRootElements()">root elements</a>, what <a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/Processor.html#getSupportedAnnotationTypes()">annotation types a processor processes</a>, and whether or not a processor [claims the annotations it processes](<a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/Processor.html#process">https://link.jianshu.com?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/Processor.html#process</a>(java.util.Set, javax.annotation.processing.RoundEnvironment)). A processor will be asked to process a subset of the annotation types it supports, possibly an empty set. For a given round, the tool computes the set of annotation types on the root elements. If there is at least one annotation type present, as processors claim annotation types, they are removed from the set of unmatched annotations. When the set is empty or no more processors are available, the round has run to completion. If there are no annotation types present, annotation processing still occurs but only <em>universal processors</em> which support processing “<em>“<br> can claim the (empty) set of annotation types.<br> Note that if a processor supports “</em>“<br> and returns true<br> , all annotations are claimed. Therefore, a universal processor being used to, for example, implement additional validity checks should return false<br> so as to not prevent other such checkers from being able to run.<br> If a processor throws an uncaught exception, the tool may cease other active annotation processors. If a processor raises an error, the current round will run to completion and the subsequent round will indicate an <a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/RoundEnvironment.html#errorRaised()">error was raised</a>. Since annotation processors are run in a cooperative environment, a processor should throw an uncaught exception only in situations where no error recovery or reporting is feasible.<br> The tool environment is not required to support annotation processors that access environmental resources, either <a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/RoundEnvironment.html">per round</a> or <a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/ProcessingEnvironment.html">cross-round</a>, in a multi-threaded fashion.<br> If the methods that return configuration information about the annotation processor return null<br> , return other invalid input, or throw an exception, the tool infrastructure must treat this as an error condition.<br> To be robust when running in different tool implementations, an annotation processor should have the following properties:</p><ol><li>The result of processing a given input is not a function of the presence or absence of other inputs (orthogonality).</li><li>Processing the same input produces the same output (consistency).</li><li>Processing input <em>A</em> followed by processing input <em>B</em> is equivalent to processing <em>B</em> then <em>A</em>(commutativity)</li><li>Processing an input does not rely on the presence of the output of other annotation processors (independence)</li></ol><p>The <a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/Filer.html">Filer </a> interface discusses restrictions on how processors can operate on files.<br> Note that implementors of this interface may find it convenient to extend <a href="https://link.jianshu.com/?t=http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/AbstractProcessor.html">AbstractProcessor </a> rather than implementing this interface directly.</p><p>Since:<br> 1.6</p></blockquote><p>注解处理发生在一系列回合中.每个回合中,注解处理器都有可能被叫去处理由上一次注解产生的源码和类文件中的找到的注解子集.第一次注解处理回合的输入就是工具第一次运行的输入;这些初始输入可以认为是一个虚拟的第零次注解处理回合的输出.如果注解处理器被叫去处理一个特定的回合,那么接下来的回合它都会继续处理,即使后续回合没有它需要处理的注解.注解处理器有可能会被叫去处理由(编译)工具隐式生成的文件.每个注解处理器的实现都必须提供一个公有的无参构造函数,由工具进行实例化.工具会与实现该接口(Processor)的类进行如下交互:</p><ol><li>如果一个已存在的Processor实例未被使用,(编译)工具会调用注解处理器的无参构造函数实例化出一个Processor对象.</li><li>接下来,(编译)工具会调用init函数,并传入一个合适的ProcessingEnvironment.</li><li>之后,(编译)工具会调用getSupportedAnnotationTypes,getSupportedOptions和getSupportedSourceVersion.这些方法只会在每一次运行时被调用一次,而不会在每个注解回合都被调用.</li><li>正常情况下,(编译)工具会调用注解处理器实例的process函数;每个注解回合并不会产生新的注解实例.</li></ol><p>如果一个注解处理器实例被创建,但是使用却没有遵循上述协议,那么这个注解处理器的行为并未被该接口规范定义.(编译)工具使用搜索程序去找到注解处理器并决定它们是否得以运行.通过配置(编译)工具,潜在的注解处理器可以被控制.比如,对于javaCompiler,候选处理器可以直接被指定或者通过使用service-style查找指定搜索路径进行控制.其他(编译)工具可以具有不同的配置机制,比如控制行选项;具体点讲,参考特定工具文档.(编译)工具会调用运行的注解处理器是由root elements指示的注解,是注解处理器处理的注解类型和注解处理器声明它要处理的注解的方法.注解处理器会被叫去处理它支持的注解类型子集,有可能是一个空的集合.在给定回合,(编译)工具会计算root elements的注解类型集合.如果有最少一个注解类型存在,就是注解处理器声明的注解类型之一,它们就会被从未匹配的注解类型集合中移除.当(未匹配)注解集合为空或者没有其它的注解处理器,那么该注解处理回合就结束了.如果没有声明注解类型,只有通用处理器(支持处理”<em>“声明(空)所有注解类型集合)仍然会进行注解处理.注意如果一个注解处理器支持”</em>“并且返回true,则所有的注解类型都被声明.因此,一个通用注解处理器如果被用于实现附加有效检验,那么应该返回false,为了不防止这类检验器得以运行.如果一个注解处理器抛出了一个未捕获异常,(编译)工具可能会停止其他活动的注解处理器.如果一个注解处理器引起了一个错误,当前注解回合会结束,并且后续回合会指明一个错误产生了.因为注解处理器都是运行在共同协作的环境中,只有当错误恢复或报告提交是无法执行的情况下,注解处理器才允许抛出一个未捕获异常.<br> (编译)工具环境不要求要支持注解处理器能以多线程方式在每一回合或交叉回合能访问环境资源.<br> 如果返回注解处理器的配置信息的方法返回null,返回其他无效输入,或者抛出一个异常,(编译)工具必须将这些当做是一个错误条件.<br> 为了在不同的工具实现能够健壮运行,注解处理器必须有以下性能:</p><ol><li>对于一个给定的输入的处理结果,不影响其他输入的存在或缺失(正交性)</li><li>处于相同的输入会产生相同的输出(一致性)</li><li>先处理输入A,然后处于输入B等同于先处理B在处理A(可交换性)</li><li>处理输入会依赖于其他注解处理器的输出(独立性)</li></ol><p>Filer接口讨论了注解处理器操作文件的限定.<br> 请知悉Processor的实现通过继承AbstractProcessor会比直接实现该接口更加方便.</p><p>简单总结如下:</p><ul><li>Annotation Processor可能会被多次调用.</li><li>Annotation Processor被调用一次后,后续若还有注解处理,该Annotation Processor仍然会继续被调用.</li><li>自定义Annotation Processor必须带有一个无参构造函数,让javac进行实例化.</li><li>如果Annotation Processor抛出一个未捕获异常,javac可能会停止其他的Annotation Processor.只有在无法抛出错误或报告的情况下,才允许抛出异常.</li><li>Annotation Processor运行在一个独立的jvm中,所以可以将它看成是一个java应用程序.</li></ul><p>作者：Whyn<br>链接：<a href="https://www.jianshu.com/p/b6b3283968e0">https://www.jianshu.com/p/b6b3283968e0</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><hr><h1 id="插件化注解处理API-Pluggable-Annotation-Processing-API"><a href="#插件化注解处理API-Pluggable-Annotation-Processing-API" class="headerlink" title="插件化注解处理API(Pluggable Annotation Processing API)"></a><a href="https://www.cnblogs.com/throwable/p/9139908.html">插件化注解处理API(Pluggable Annotation Processing API)</a></h1><h1 id="Java奇技淫巧-插件化注解处理API-Pluggable-Annotation-Processing-API"><a href="#Java奇技淫巧-插件化注解处理API-Pluggable-Annotation-Processing-API" class="headerlink" title="Java奇技淫巧-插件化注解处理API(Pluggable Annotation Processing API)"></a>Java奇技淫巧-插件化注解处理API(Pluggable Annotation Processing API)</h1><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://blog.csdn.net/Chinajash/article/details/1471081">JDK6的新特性之六:插入式注解处理API(Pluggable Annotation Processing API)</a></li><li><a href="http://www.baeldung.com/java-annotation-processing-builder">Java Annotation Processing and Creating a Builder</a></li></ul><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>插件化注解处理(Pluggable Annotation Processing)API<a href="http://jcp.org/en/jsr/detail?id=269">JSR 269</a>提供一套标准API来处理Annotations<a href="http://jcp.org/en/jsr/detail?id=175">JSR 175</a>,实际上JSR 269不仅仅用来处理Annotation，我觉得更强大的功能是它建立了Java 语言本身的一个模型,它把method、package、constructor、type、variable、enum、annotation等Java语言元素映射为Types和Elements，从而将Java语言的语义映射成为对象，我们可以在javax.lang.model包下面可以看到这些类。所以我们可以利用JSR 269提供的API来构建一个功能丰富的元编程(metaprogramming)环境。JSR 269用Annotation Processor在编译期间而不是运行期间处理Annotation, Annotation Processor相当于编译器的一个插件,所以称为插入式注解处理.如果Annotation Processor处理Annotation时(执行process方法)产生了新的Java代码，编译器会再调用一次Annotation Processor，如果第二次处理还有新代码产生，就会接着调用Annotation Processor，直到没有新代码产生为止。每执行一次process()方法被称为一个”round”，这样整个Annotation processing过程可以看作是一个round的序列。JSR 269主要被设计成为针对Tools或者容器的API。这个特性虽然在JavaSE 6已经存在，但是很少人知道它的存在。下一篇介绍的<strong>Java奇技淫巧-lombok</strong>就是使用这个特性实现编译期的代码插入的。另外，如果没有猜错，像IDEA在编写代码时候的标记语法错误的红色下划线也是通过这个特性实现的。KAPT(Annotation Processing for Kotlin)，也就是Kotlin的编译也是通过此特性的。</p><p>Pluggable Annotation Processing API的核心是Annotation Processor即注解处理器，一般需要继承抽象类<code>javax.annotation.processing.AbstractProcessor</code>。注意，与运行时注解<code>RetentionPolicy.RUNTIME</code>不同，注解处理器只会处理编译期注解，也就是<code>RetentionPolicy.SOURCE</code>的注解类型，处理的阶段位于Java代码编译期间。</p><h1 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h1><p>插件化注解处理API的使用步骤大概如下：</p><ul><li>1、自定义一个Annotation Processor，需要继承<code>javax.annotation.processing.AbstractProcessor</code>，并覆写process方法。</li><li>2、自定义一个注解，注解的元注解需要指定<code>@Retention(RetentionPolicy.SOURCE)</code>。</li><li>3、需要在声明的自定义Annotation Processor中使用<code>javax.annotation.processing.SupportedAnnotationTypes</code>指定在第2步创建的注解类型的名称(注意需要全类名，”包名.注解类型名称”，否则会不生效)。</li><li>4、需要在声明的自定义Annotation Processor中使用<code>javax.annotation.processing.SupportedSourceVersion</code>指定编译版本。</li><li>5、可选操作，可以通在声明的自定义Annotation Processor中使用<code>javax.annotation.processing.SupportedOptions</code>指定编译参数。</li></ul><h1 id="实战例子"><a href="#实战例子" class="headerlink" title="实战例子"></a>实战例子</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础#"></a>基础<a href="https://www.cnblogs.com/throwable/p/9139908.html#%E5%9F%BA%E7%A1%80">#</a></h2><p>下面我们模仿一下测试框架Junit里面的@Test注解，在运行时通过Annotation Processor获取到使用了自定义的@Test注解对应的方法的信息。因为如果想要动态修改一个类或者方法的代码内容，需要使用到字节码修改工具例如ASM等，这些操作过于深入，日后再谈。先定义一个注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> club.throwable.processor;<br><br><span class="hljs-keyword">import</span> java.lang.annotation.ElementType;<br><span class="hljs-keyword">import</span> java.lang.annotation.Retention;<br><span class="hljs-keyword">import</span> java.lang.annotation.RetentionPolicy;<br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> throwable</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> v1.0</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 2018/5/27 11:18</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Target(&#123;ElementType.METHOD&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Test &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>定义一个注解处理器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SupportedAnnotationTypes(value = &#123;&quot;club.throwable.processor.Test&quot;&#125;)</span><br><span class="hljs-meta">@SupportedSourceVersion(value = SourceVersion.RELEASE_8)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnnotationProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractProcessor</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">process</span><span class="hljs-params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Log in AnnotationProcessor.process&quot;</span>);<br>        <span class="hljs-keyword">for</span> (TypeElement typeElement : annotations) &#123;<br>            System.out.println(typeElement);<br>        &#125;<br>        System.out.println(roundEnv);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编写一个主类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;success&quot;</span>);<br>        test();<br>    &#125;<br><br>    <span class="hljs-meta">@Test(value = &quot;method is test&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span><span class="hljs-keyword">throws</span> Exception</span>&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着需要指定Processor，如果使用IDEA的话，Compiler-&gt;Annotation Processors中的Enable annotation processing必须勾选。然后可以通过下面几种方式指定指定Processor。</p><ul><li>1、直接使用编译参数指定，例如：javac -processor club.throwable.processor.AnnotationProcessor Main.java。</li><li>2、通过服务注册指定，就是META-INF/services/javax.annotation.processing.Processor文件中添加club.throwable.processor.AnnotationProcessor。</li><li>3、通过Maven的编译插件的配置指定如下：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">encoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">encoding</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">annotationProcessors</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">annotationProcessor</span>&gt;</span><br>                club.throwable.processor.AnnotationProcessor<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">annotationProcessor</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">annotationProcessors</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br></code></pre></td></tr></table></figure><p>值得注意的是，以上三点生效的前提是club.throwable.processor.AnnotationProcessor已经被编译过，否则编译的时候就会报错：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-attr">[ERROR]</span> Bad service configuration file, or exception thrown while<br>constructing Processor <span class="hljs-selector-tag">object</span>: javax<span class="hljs-selector-class">.annotation</span><span class="hljs-selector-class">.processing</span><span class="hljs-selector-class">.Processor</span>: <br>Provider club<span class="hljs-selector-class">.throwable</span><span class="hljs-selector-class">.processor</span><span class="hljs-selector-class">.AnnotationProcessor</span> not found<br></code></pre></td></tr></table></figure><p>解决方法有两种，第一种是提前使用命令或者IDEA右键club.throwable.processor.AnnotationProcessor对它进行编译；第二种是把club.throwable.processor.AnnotationProcessor放到一个独立的Jar包引入。我在这里使用第一种方式解决。</p><p>最后，使用Maven命令mvn compile进行编译。输出如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Log <span class="hljs-keyword">in</span> AnnotationProcessor.process<br>[<span class="hljs-attribute">errorRaised</span>=<span class="hljs-literal">false</span>, rootElements=[club.throwable.processor.Test,club.throwable.processor.Main, club.throwable.processor.AnnotationProcessor, <span class="hljs-attribute">processingOver</span>=<span class="hljs-literal">false</span>]<br>Log <span class="hljs-keyword">in</span> AnnotationProcessor.process<br>[<span class="hljs-attribute">errorRaised</span>=<span class="hljs-literal">false</span>, rootElements=[], <span class="hljs-attribute">processingOver</span>=<span class="hljs-literal">false</span>]<br>Log <span class="hljs-keyword">in</span> AnnotationProcessor.process<br>[<span class="hljs-attribute">errorRaised</span>=<span class="hljs-literal">false</span>, rootElements=[], <span class="hljs-attribute">processingOver</span>=<span class="hljs-literal">true</span>]<br></code></pre></td></tr></table></figure><p>可见编译期间AnnotationProcessor生效了。</p><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶#"></a>进阶<a href="https://www.cnblogs.com/throwable/p/9139908.html#%E8%BF%9B%E9%98%B6">#</a></h2><p>下面是一个例子直接修改类的代码，为实体类的Setter方法对应的属性生成一个Builder类，也就是原来的类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-meta">@Builder</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(Integer age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-meta">@Builder</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>生成的Builder类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonBuilder</span> </span>&#123;<br> <br>    <span class="hljs-keyword">private</span> Person object = <span class="hljs-keyword">new</span> Person();<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Person <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> object;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PersonBuilder <span class="hljs-title">setName</span><span class="hljs-params">(java.lang.String value)</span> </span>&#123;<br>        object.setName(value);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PersonBuilder <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        object.setAge(value);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>自定义的注解如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.METHOD&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Builder &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>自定义的注解处理器如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> javax.annotation.processing.AbstractProcessor;<br><span class="hljs-keyword">import</span> javax.annotation.processing.RoundEnvironment;<br><span class="hljs-keyword">import</span> javax.annotation.processing.SupportedAnnotationTypes;<br><span class="hljs-keyword">import</span> javax.annotation.processing.SupportedSourceVersion;<br><span class="hljs-keyword">import</span> javax.lang.model.SourceVersion;<br><span class="hljs-keyword">import</span> javax.lang.model.element.Element;<br><span class="hljs-keyword">import</span> javax.lang.model.element.TypeElement;<br><span class="hljs-keyword">import</span> javax.lang.model.type.ExecutableType;<br><span class="hljs-keyword">import</span> javax.tools.Diagnostic;<br><span class="hljs-keyword">import</span> javax.tools.JavaFileObject;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.PrintWriter;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.util.Set;<br><span class="hljs-keyword">import</span> java.util.stream.Collectors;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> throwable</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> v1.0</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 2018/5/27 11:21</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@SupportedAnnotationTypes(value = &#123;&quot;club.throwable.processor.builder.Builder&quot;&#125;)</span><br><span class="hljs-meta">@SupportedSourceVersion(value = SourceVersion.RELEASE_8)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BuilderProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractProcessor</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">process</span><span class="hljs-params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (TypeElement typeElement : annotations) &#123;<br>            Set&lt;? extends Element&gt; annotatedElements = roundEnv.getElementsAnnotatedWith(typeElement);<br>            Map&lt;Boolean, List&lt;Element&gt;&gt; annotatedMethods<br>                    = annotatedElements.stream().collect(Collectors.partitioningBy(<br>                    element -&gt; ((ExecutableType) element.asType()).getParameterTypes().size() == <span class="hljs-number">1</span><br>                            &amp;&amp; element.getSimpleName().toString().startsWith(<span class="hljs-string">&quot;set&quot;</span>)));<br>            List&lt;Element&gt; setters = annotatedMethods.get(<span class="hljs-keyword">true</span>);<br>            List&lt;Element&gt; otherMethods = annotatedMethods.get(<span class="hljs-keyword">false</span>);<br>            otherMethods.forEach(element -&gt;<br>                    processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR,<br>                            <span class="hljs-string">&quot;@Builder must be applied to a setXxx method &quot;</span><br>                                    + <span class="hljs-string">&quot;with a single argument&quot;</span>, element));<br>            Map&lt;String, String&gt; setterMap = setters.stream().collect(Collectors.toMap(<br>                    setter -&gt; setter.getSimpleName().toString(),<br>                    setter -&gt; ((ExecutableType) setter.asType())<br>                            .getParameterTypes().get(<span class="hljs-number">0</span>).toString()<br>            ));<br>            String className = ((TypeElement) setters.get(<span class="hljs-number">0</span>)<br>                    .getEnclosingElement()).getQualifiedName().toString();<br>            <span class="hljs-keyword">try</span> &#123;<br>                writeBuilderFile(className, setterMap);<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeBuilderFile</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">            String className, Map&lt;String, String&gt; setterMap)</span></span><br><span class="hljs-function">            <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        String packageName = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">int</span> lastDot = className.lastIndexOf(<span class="hljs-string">&#x27;.&#x27;</span>);<br>        <span class="hljs-keyword">if</span> (lastDot &gt; <span class="hljs-number">0</span>) &#123;<br>            packageName = className.substring(<span class="hljs-number">0</span>, lastDot);<br>        &#125;<br>        String simpleClassName = className.substring(lastDot + <span class="hljs-number">1</span>);<br>        String builderClassName = className + <span class="hljs-string">&quot;Builder&quot;</span>;<br>        String builderSimpleClassName = builderClassName<br>                .substring(lastDot + <span class="hljs-number">1</span>);<br><br>        JavaFileObject builderFile = processingEnv.getFiler().createSourceFile(builderClassName);<br><br>        <span class="hljs-keyword">try</span> (PrintWriter out = <span class="hljs-keyword">new</span> PrintWriter(builderFile.openWriter())) &#123;<br><br>            <span class="hljs-keyword">if</span> (packageName != <span class="hljs-keyword">null</span>) &#123;<br>                out.print(<span class="hljs-string">&quot;package &quot;</span>);<br>                out.print(packageName);<br>                out.println(<span class="hljs-string">&quot;;&quot;</span>);<br>                out.println();<br>            &#125;<br>            out.print(<span class="hljs-string">&quot;public class &quot;</span>);<br>            out.print(builderSimpleClassName);<br>            out.println(<span class="hljs-string">&quot; &#123;&quot;</span>);<br>            out.println();<br>            out.print(<span class="hljs-string">&quot;    private &quot;</span>);<br>            out.print(simpleClassName);<br>            out.print(<span class="hljs-string">&quot; object = new &quot;</span>);<br>            out.print(simpleClassName);<br>            out.println(<span class="hljs-string">&quot;();&quot;</span>);<br>            out.println();<br>            out.print(<span class="hljs-string">&quot;    public &quot;</span>);<br>            out.print(simpleClassName);<br>            out.println(<span class="hljs-string">&quot; build() &#123;&quot;</span>);<br>            out.println(<span class="hljs-string">&quot;        return object;&quot;</span>);<br>            out.println(<span class="hljs-string">&quot;    &#125;&quot;</span>);<br>            out.println();<br>            setterMap.forEach((methodName, argumentType) -&gt; &#123;<br>                out.print(<span class="hljs-string">&quot;    public &quot;</span>);<br>                out.print(builderSimpleClassName);<br>                out.print(<span class="hljs-string">&quot; &quot;</span>);<br>                out.print(methodName);<br><br>                out.print(<span class="hljs-string">&quot;(&quot;</span>);<br><br>                out.print(argumentType);<br>                out.println(<span class="hljs-string">&quot; value) &#123;&quot;</span>);<br>                out.print(<span class="hljs-string">&quot;        object.&quot;</span>);<br>                out.print(methodName);<br>                out.println(<span class="hljs-string">&quot;(value);&quot;</span>);<br>                out.println(<span class="hljs-string">&quot;        return this;&quot;</span>);<br>                out.println(<span class="hljs-string">&quot;    &#125;&quot;</span>);<br>                out.println();<br>            &#125;);<br>            out.println(<span class="hljs-string">&quot;&#125;&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>主类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>      <span class="hljs-comment">//PersonBuilder在编译之后才会生成，这里需要编译后才能这样写</span><br>      Person person  = <span class="hljs-keyword">new</span> PersonBuilder().setAge(<span class="hljs-number">25</span>).setName(<span class="hljs-string">&quot;doge&quot;</span>).build();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>先手动编译BuilderProcessor，然后在META-INF/services/javax.annotation.processing.Processor文件中添加<code>club.throwable.processor.builder.BuilderProcessor</code>，最后执行Maven命令mvn compile进行编译。</p><p>编译后控制台输出:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[errorRaised=<span class="hljs-literal">false</span>, rootElements=[club.throwable.processor.builder.PersonBuilder], processingOver=<span class="hljs-literal">false</span>]<br></code></pre></td></tr></table></figure><p>编译成功之后，target/classes包下面的club.throwable.processor.builder子包路径中会新增了一个类<code>PersonBuilder</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> club.throwable.processor.builder;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonBuilder</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Person object = <span class="hljs-keyword">new</span> Person();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PersonBuilder</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Person <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.object;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PersonBuilder <span class="hljs-title">setName</span><span class="hljs-params">(String value)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.object.setName(value);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PersonBuilder <span class="hljs-title">setAge</span><span class="hljs-params">(Integer value)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.object.setAge(value);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个类就是编译期新增的。在这个例子中，编译期新增的类貌似没有什么作用。但是，如果像lombok那样对原来的实体类添加新的方法，那样的话就比较有用了。因为些类或者方法是编译期添加的，因此在代码中直接使用会标红。因此，lombok提供了IDEA或者eclipse的插件，插件的功能的实现估计也是用了插件式注解处理API。</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>注解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java注解</title>
    <link href="/posts/3f6454bb/"/>
    <url>/posts/3f6454bb/</url>
    
    <content type="html"><![CDATA[<h1 id="process方法的调用方式"><a href="#process方法的调用方式" class="headerlink" title="process方法的调用方式"></a>process方法的调用方式</h1><p>注释处理分多轮完成。每一轮都从编译器开始搜索源文件中的注释并选择适合这些注释的注释处理器。依次在相应的源上调用每个注释处理器。</p><p>如果在此过程中生成了任何文件，则以生成的文件作为其输入开始另一轮。这个过程一直持续到在处理阶段没有新文件产生。</p><p>依次在相应的源上调用每个注释处理器。如果在此过程中生成了任何文件，则以生成的文件作为其输入开始另一轮。这个过程一直持续到在处理阶段没有新文件产生。</p><p>注释处理 <code>API </code>位于<code>javax.annotation.processing</code>包中。您必须实现的主要接口是<em>Processor</em>接口，它具有<code>AbstractProcessor</code>类形式的部分实现。这个类是我们将要扩展以创建我们自己的注释处理器的类。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">原文：<br>The annotation processing <span class="hljs-keyword">is</span> done <span class="hljs-keyword">in</span> multiple rounds. <span class="hljs-keyword">Each</span> round starts <span class="hljs-keyword">with</span> the compiler searching <span class="hljs-keyword">for</span> the annotations <span class="hljs-keyword">in</span> the source files <span class="hljs-keyword">and</span> choosing the annotation processors suited <span class="hljs-keyword">for</span> these annotations. <span class="hljs-keyword">Each</span> annotation processor, <span class="hljs-keyword">in</span> turn, <span class="hljs-keyword">is</span> <span class="hljs-keyword">called</span> <span class="hljs-keyword">on</span> the corresponding sources.<br><br><span class="hljs-keyword">If</span> <span class="hljs-keyword">any</span> files are <span class="hljs-keyword">generated</span> during this process, another round <span class="hljs-keyword">is</span> started <span class="hljs-keyword">with</span> the <span class="hljs-keyword">generated</span> files <span class="hljs-keyword">as</span> its <span class="hljs-keyword">input</span>. This process continues <span class="hljs-keyword">until</span> <span class="hljs-keyword">no</span> <span class="hljs-built_in">new</span> files are <span class="hljs-keyword">generated</span> during the processing stage.<br><br><span class="hljs-keyword">Each</span> annotation processor, <span class="hljs-keyword">in</span> turn, <span class="hljs-keyword">is</span> <span class="hljs-keyword">called</span> <span class="hljs-keyword">on</span> the corresponding sources. <span class="hljs-keyword">If</span> <span class="hljs-keyword">any</span> files are <span class="hljs-keyword">generated</span> during this process, another round <span class="hljs-keyword">is</span> started <span class="hljs-keyword">with</span> the <span class="hljs-keyword">generated</span> files <span class="hljs-keyword">as</span> its <span class="hljs-keyword">input</span>. This process continues <span class="hljs-keyword">until</span> <span class="hljs-keyword">no</span> <span class="hljs-built_in">new</span> files are <span class="hljs-keyword">generated</span> during the processing stage.<br><br>The annotation processing API <span class="hljs-keyword">is</span> located <span class="hljs-keyword">in</span> the javax.annotation.processing package. The main interface that you’ll have <span class="hljs-keyword">to</span> implement <span class="hljs-keyword">is</span> the Processor interface, which has a partial implementation <span class="hljs-keyword">in</span> the form <span class="hljs-keyword">of</span> AbstractProcessor <span class="hljs-keyword">class</span>. This <span class="hljs-keyword">class</span> <span class="hljs-keyword">is</span> the one we’re going <span class="hljs-keyword">to</span> extend <span class="hljs-keyword">to</span> <span class="hljs-keyword">create</span> our own annotation processor.<br><br><br></code></pre></td></tr></table></figure><p>这是一个实现处理器的例子：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@SupportedAnnotationTypes</span>(<span class="hljs-string">&quot;com.baeldung.annotation.processor.BuilderProperty&quot;</span>)<span class="hljs-comment">//指定这个处理器能处理的注解</span><br><span class="hljs-variable">@SupportedSourceVersion</span>(SourceVersion.RELEASE_8)<br><span class="hljs-variable">@AutoService</span>(Processor.class)<br>public class BuilderProcessor extends AbstractProcessor &#123;<br><br>    <span class="hljs-variable">@Override</span><br>    public boolean process(Set&lt;? extends TypeElement&gt; annotations, <br>      RoundEnvironment roundEnv) &#123;<br>        <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不仅可以指定具体的注释类名称，还可以指定通配符，例如<code>“com.baeldung.annotation.\*”</code> 来处理<code>com.baeldung.annotation</code>包及其所有子包中的注释，甚至可以<em>“*”</em>来处理所有注释.</p><p>我们必须实现的单一方法是处理本身的<code>process</code>方法。编译器为每个包含匹配注释的源文件调用它。</p><p>注释作为第一个<code>Set&lt;? extends TypeElement&gt; annotations</code>参数，有关当前处理轮次的信息作为<code>RoundEnviroment roundEnv</code>参数传递。</p><p>如果您的注释处理器已经处理了所有传递的注释，并且您不希望它们被传递到列表中的其他注释处理器，则返回<em>布尔</em>值应该为<em>true</em>。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">原文：<br>You can specify <span class="hljs-keyword">not</span> only <span class="hljs-keyword">the</span> concrete annotation class names but also wildcards, like “com.baeldung.annotation.*” <span class="hljs-built_in">to</span> <span class="hljs-built_in">process</span> annotations inside <span class="hljs-keyword">the</span> com.baeldung.annotation package <span class="hljs-keyword">and</span> all its sub packages, <span class="hljs-keyword">or</span> even “*” <span class="hljs-built_in">to</span> <span class="hljs-built_in">process</span> all annotations.<br><br>The single method that we’ll have <span class="hljs-built_in">to</span> implement is <span class="hljs-keyword">the</span> <span class="hljs-built_in">process</span> method that does <span class="hljs-keyword">the</span> processing itself. It is called <span class="hljs-keyword">by</span> <span class="hljs-keyword">the</span> compiler <span class="hljs-keyword">for</span> every source <span class="hljs-built_in">file</span> containing <span class="hljs-keyword">the</span> matching annotations.<br><br>Annotations are passed <span class="hljs-keyword">as</span> <span class="hljs-keyword">the</span> <span class="hljs-keyword">first</span> Set<span class="hljs-meta">&lt;?</span> extends TypeElement&gt; annotations argument, <span class="hljs-keyword">and</span> <span class="hljs-keyword">the</span> information about <span class="hljs-keyword">the</span> current processing <span class="hljs-built_in">round</span> is passed <span class="hljs-keyword">as</span> <span class="hljs-keyword">the</span> RoundEnviroment roundEnv argument.<br><br>The <span class="hljs-literal">return</span> boolean <span class="hljs-built_in">value</span> should be <span class="hljs-literal">true</span> <span class="hljs-keyword">if</span> your annotation processor has processed all <span class="hljs-keyword">the</span> passed annotations, <span class="hljs-keyword">and</span> you don<span class="hljs-string">&#x27;t want them to be passed to other annotation processors down the list.</span><br></code></pre></td></tr></table></figure><p>总结：</p><p>在我们自定义的处理器类中，我们指定了这个处理器类可以处理的注解。</p><p>然后，<code>java</code>编译器会依次调用注册好的注解处理器处理注解，这会有多轮处理。</p><p>在调用注解处理器的时候，编译器会筛选出这个注解处理器可以处理的注解信息给它处理。</p><p>在当前注解处理器处理注解的时候，如果产生的新类里依旧包含注解，那么，在其他所有注解处理器完成处理之后，会进行第二轮处理，第三轮，直到没有新的注解产生。</p><ul><li><p>例子：</p><ul><li><p><strong>MainActivity</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>&#123;<br><br>    <span class="hljs-meta">@BindView</span>(<span class="hljs-type">R</span>.id.tv_hello)<br>    <span class="hljs-type">TextView</span> tvHello;<br>  &#125;<br></code></pre></td></tr></table></figure></li><li><p>在第一轮处理注解时，我们生成了新的类,而这个类使用**@Keep**注解标记了，那么注解处理器就会        开始下一轮的处理，直到生成的类里面再也没有任何注解了。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">@Keep<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">MainActivity</span>$<span class="hljs-symbol">Binding</span> &#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h1 id="解析注解的步骤"><a href="#解析注解的步骤" class="headerlink" title="解析注解的步骤"></a>解析注解的步骤</h1><h2 id="插件化注解处理API的使用步骤大概如下："><a href="#插件化注解处理API的使用步骤大概如下：" class="headerlink" title="插件化注解处理API的使用步骤大概如下："></a>插件化注解处理API的使用步骤大概如下：</h2><ul><li>1、自定义一个Annotation Processor，需要继承<code>javax.annotation.processing.AbstractProcessor</code>，需要重写<code>process()</code>方法。<ul><li> 1.1、此外还需要实现几个简单的方法<code>init ()</code>、<code>getSupportedSourceVersion()</code>、<code>getSupportedAnnotationTypes()</code> </li></ul></li><li>2、自定义一个注解，注解的元注解需要指定<code>@Retention(RetentionPolicy.SOURCE)</code>。</li><li>3、需要在声明的自定义Annotation Processor中使用<code>javax.annotation.processing.SupportedAnnotationTypes</code>指定在第2步创建的注解类型的名称(注意需要全类名，”包名.注解类型名称”，否则会不生效)。</li><li>4、需要在声明的自定义Annotation Processor中使用<code>javax.annotation.processing.SupportedSourceVersion</code>指定编译版本。</li><li>5、可选操作，可以通在声明的自定义Annotation Processor中使用<code>javax.annotation.processing.SupportedOptions</code>指定编译参数。</li></ul><h2 id="配置和注册"><a href="#配置和注册" class="headerlink" title="配置和注册"></a>配置和注册</h2><ul><li>创建一个自定义Annotation Processor继承于AbstractProcessor</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AutoService(Processor.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractProcessor</span> </span>&#123;<br> 。。。省略。。。<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>@AutoService(Processor.class) :向javac注册我们这个自定义的注解处理器，这样，在javac编译时，才会调用到我们这个自定义的注解处理器方法。<br> AutoService这里主要是用来生成<br> <strong>建议直接采用@AutoService(Processor.class)进行自定义注解处理器注册，简洁方便</strong></p></li><li><p>其他方式注册</p><p>例如：</p><p>我们模仿一下测试框架Junit里面的@Test注解，在运行时通过Annotation Processor获取到使用了自定义的@Test注解对应的方法的信息。因为如果想要动态修改一个类或者方法的代码内容，需要使用到字节码修改工具例如ASM等，这些操作过于深入，日后再谈。先定义一个注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> club.throwable.processor;<br><br><span class="hljs-keyword">import</span> java.lang.annotation.ElementType;<br><span class="hljs-keyword">import</span> java.lang.annotation.Retention;<br><span class="hljs-keyword">import</span> java.lang.annotation.RetentionPolicy;<br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> throwable</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> v1.0</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 2018/5/27 11:18</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Target(&#123;ElementType.METHOD&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Test &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>定义一个注解处理器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SupportedAnnotationTypes(value = &#123;&quot;club.throwable.processor.Test&quot;&#125;)</span><br><span class="hljs-meta">@SupportedSourceVersion(value = SourceVersion.RELEASE_8)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnnotationProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractProcessor</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">process</span><span class="hljs-params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Log in AnnotationProcessor.process&quot;</span>);<br>        <span class="hljs-keyword">for</span> (TypeElement typeElement : annotations) &#123;<br>            System.out.println(typeElement);<br>        &#125;<br>        System.out.println(roundEnv);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编写一个主类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;success&quot;</span>);<br>        test();<br>    &#125;<br><br>    <span class="hljs-meta">@Test(value = &quot;method is test&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span><span class="hljs-keyword">throws</span> Exception</span>&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着需要指定Processor，如果使用IDEA的话，Compiler-&gt;Annotation Processors中的Enable annotation processing必须勾选。然后可以通过下面几种方式指定指定Processor。</p><ul><li><p>1、直接使用编译参数指定，例如：javac -processor club.throwable.processor.AnnotationProcessor Main.java。</p></li><li><p>2、<strong>通过服务注册指定</strong>，就是META-INF/services/javax.annotation.processing.Processor文件中添加club.throwable.processor.AnnotationProcessor。</p><ul><li><p>具体手动注册方法如下：</p><ol><li><p>创建一个<br>META-INF/services/javax.annotation.processing.Processor文件，<br>其内容是一系列的自定义注解处理器完整有效类名集合，以换行切割。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.MyProcessor</span><br>com<span class="hljs-selector-class">.foo</span><span class="hljs-selector-class">.OtherProcessor</span><br>net<span class="hljs-selector-class">.blabla</span>.SpecialProcessor<br></code></pre></td></tr></table></figure><ul><li>文件放在<code>/src/main/resources/META-INF/services/javax.annotation.processing.Processor</code></li><li>处理器类文件放在<code>/src/main/java/com/example/annotationcomplierlib/AnnotationComplier.java</code></li></ul></li><li><p>将自定义注解处理器和<br>META-INF/services/javax.annotation.processing.Processor打包成一个.jar文件。所以其目录结构大概如下所示：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css">MyProcessor<span class="hljs-selector-class">.jar</span><br>    - com<br>        - example<br>            - MyProcessor<span class="hljs-selector-class">.class</span><br><br>    - META-INF<br>        - services<br>            - javax<span class="hljs-selector-class">.annotation</span><span class="hljs-selector-class">.processing</span><span class="hljs-selector-class">.Processor</span><br></code></pre></td></tr></table></figure></li></ol></li></ul></li><li><p>3、通过Maven的编译插件的配置指定如下：</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">encoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">encoding</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">annotationProcessors</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">annotationProcessor</span>&gt;</span><br>                club.throwable.processor.AnnotationProcessor<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">annotationProcessor</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">annotationProcessors</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br></code></pre></td></tr></table></figure><p>值得注意的是，以上三点生效的前提是club.throwable.processor.AnnotationProcessor已经被编译过，否则编译的时候就会报错：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-attr">[ERROR]</span> Bad service configuration file, or exception thrown while<br>constructing Processor <span class="hljs-selector-tag">object</span>: javax<span class="hljs-selector-class">.annotation</span><span class="hljs-selector-class">.processing</span><span class="hljs-selector-class">.Processor</span>: <br>Provider club<span class="hljs-selector-class">.throwable</span><span class="hljs-selector-class">.processor</span><span class="hljs-selector-class">.AnnotationProcessor</span> not found<br></code></pre></td></tr></table></figure><p>解决方法有两种，第一种是提前使用命令或者IDEA右键club.throwable.processor.AnnotationProcessor对它进行编译；第二种是把club.throwable.processor.AnnotationProcessor放到一个独立的Jar包引入。我在这里使用第一种方式解决。</p><p>最后，使用Maven命令mvn compile进行编译。输出如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Log <span class="hljs-keyword">in</span> AnnotationProcessor.process<br>[<span class="hljs-attribute">errorRaised</span>=<span class="hljs-literal">false</span>, rootElements=[club.throwable.processor.Test,club.throwable.processor.Main, club.throwable.processor.AnnotationProcessor, <span class="hljs-attribute">processingOver</span>=<span class="hljs-literal">false</span>]<br>Log <span class="hljs-keyword">in</span> AnnotationProcessor.process<br>[<span class="hljs-attribute">errorRaised</span>=<span class="hljs-literal">false</span>, rootElements=[], <span class="hljs-attribute">processingOver</span>=<span class="hljs-literal">false</span>]<br>Log <span class="hljs-keyword">in</span> AnnotationProcessor.process<br>[<span class="hljs-attribute">errorRaised</span>=<span class="hljs-literal">false</span>, rootElements=[], <span class="hljs-attribute">processingOver</span>=<span class="hljs-literal">true</span>]<br></code></pre></td></tr></table></figure><p>可见编译期间AnnotationProcessor生效了。</p></li></ul><h2 id="备注："><a href="#备注：" class="headerlink" title="备注："></a>备注：</h2><ul><li>Gradle配置如下：</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs php"><br>dependencies &#123;<br>    implementation fileTree(<span class="hljs-keyword">include</span>: [<span class="hljs-string">&#x27;*.jar&#x27;</span>], dir: <span class="hljs-string">&#x27;libs&#x27;</span>)<br><br>    implementation project(<span class="hljs-string">&#x27;:annotation&#x27;</span>)<br>    <span class="hljs-comment">//用于自动为 JAVA Processor 生成 META-INF 信息。</span><br>    implementation <span class="hljs-string">&#x27;com.google.auto.service:auto-service:1.0-rc3&#x27;</span><br>    <span class="hljs-comment">//快速生成.java文件的库</span><br>    implementation <span class="hljs-string">&#x27;com.squareup:javapoet:1.8.0&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><code>Processor</code> 重写父类的几个方法：</p><ul><li><code>process()</code>方法，这里是处理注解内部逻辑的，也是本文的关键点之一；</li><li><code>getSupportedSourceVersion()</code>：设置支持的版本，一般用最新的就好；</li></ul><ul><li><p><code>getSupportedAnnotationTypes()</code>：添加支持的注解类型，可以是单个／多个，用Set存储；</p></li><li><p><code>init ()</code>：一些初始化操作，获取一些有用的系统工具类，比如生成文件、打印信息、处理元素等；</p></li></ul></li></ul><p>​            <code>getSupportedSourceVersion()</code>、<code>getSupportedAnnotationTypes()</code>这2个方法还有一种    简单的方式来实现，如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@AutoService</span>(Processor.class)<br>@SupportedAnnotationTypes(&#123;&quot;com<span class="hljs-selector-class">.zx</span><span class="hljs-selector-class">.annotation</span>&quot;&#125;)<br><span class="hljs-keyword">@SupportedSourceVersion</span>(SourceVersion.RELEASE_8)<br>public class ViewInjectProcessor extends AbstractProcessor &#123;&#125;<br></code></pre></td></tr></table></figure><p>是通过注解来实现的，看上去是比较简洁</p><ul><li><code>@SupportedAnnotationTypes()</code>可以申明一个注解数组，但是这种字符串拼接容易出错；</li><li><code>@SupportedSourceVersion</code>：设置支持的源码版本，可以是RELEASE_0～RELEASE_8，但是不能使用<code>latestSupported()</code>设置最新的版本；</li></ul><h1 id="方法讲解"><a href="#方法讲解" class="headerlink" title="方法讲解"></a>方法讲解</h1><p>我们今天只说Processor。先从接口的方法介绍起把。</p><table><thead><tr><th>变量和类型</th><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>Iterable&lt;? extends Completion&gt;</code></td><td>getCompletions(Element element, AnnotationMirror annotation, ExecutableElement member, String userText)</td><td>返回一个空的迭代完成。</td></tr><tr><td><code>Set&lt;String&gt;</code></td><td>getSupportedAnnotationTypes()</td><td>如果处理器类使用SupportedAnnotationTypes进行批注，则返回与注释具有相同字符串集的不可修改集。</td></tr><tr><td><code>Set&lt;String&gt;</code></td><td>getSupportedOptions()</td><td>如果处理器类使用SupportedOptions进行批注，则返回具有与批注相同的字符串集的不可修改集。</td></tr><tr><td><code>SourceVersion</code></td><td>getSupportedSourceVersion()</td><td>如果处理器类使用SupportedSourceVersion进行批注，请在批注中返回源版本。</td></tr><tr><td><code>void</code></td><td>init(ProcessingEnvironment processingEnv)</td><td>通过将 processingEnv字段设置为 processingEnv参数的值，使用处理环境初始化处理器。</td></tr><tr><td><code>boolean</code></td><td>process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</td><td>处理源自前一轮的类型元素的一组注释类型，并返回此处理器是否声明了这些注释类型。 如果返回true ，则声明注释类型，并且不会要求后续处理器处理它们; 如果返回false ，则注释类型无人认领，可能会要求后续处理器处理它们。 处理器可以总是返回相同的布尔值，或者可以根据其自己选择的标准改变结果。</td></tr></tbody></table><ul><li><p>init：<br>初始化工作，我们可以得到一些有用的工具，例如 Filer，我们需要它将生成的代码写入文件中</p><p>init(ProcessingEnvironment env):每个Annotation Processor必须***<br> 有一个空的构造函数 ***。编译期间，init()会自动被注解处理工具调用，并传入ProcessingEnviroment参数，通过该参数可以获取到很多有用的工具类:  <strong>Elements , Types , Filer</strong>  等等</p></li><li><p>process：<br>最重要的方法，所有的注解处理都是在此完成</p><p>process(Set&lt;? extends TypeElement&gt; annoations, RoundEnvironment roundEnv):Annotation Processor扫描出的结果会存储进roundEnv中，可以在这里获取到注解内容，编写你的操作逻辑。注意,process()函数中不能直接进行异常抛出,否则的话,运行Annotation Processor的进程会异常崩溃,然后弹出一大堆让人捉摸不清的堆栈调用日志显示.</p></li><li><p>getSupportedAnnotationTypes：<br>返回我们所要处理的注解的一个集合</p><p>getSupportedAnnotationTypes(): 该函数用于指定该自定义注解处理器(Annotation Processor)是注册给哪些注解的(Annotation),注解(Annotation)指定必须是完整的包名+类名(eg:com.example.MyAnnotation)</p></li><li><p>getSupportedSourceVersion：<br>要支持的java版本</p><p>getSupportedSourceVersion():用于指定你的java版本，一般返回：SourceVersion.latestSupported()。当然，你也可以指定具体java版本：<br> return SourceVersion.RELEASE_7;</p></li></ul><h2 id="ProcessingEnvironment"><a href="#ProcessingEnvironment" class="headerlink" title="ProcessingEnvironment"></a>ProcessingEnvironment</h2><p>这个类很重要，要考的。这个类会在函数init的时候被传入，主要的工具类方法都在这个类上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ProcessingEnvironment</span> </span>&#123;<br>    <span class="hljs-function">Map&lt;String, String&gt; <span class="hljs-title">getOptions</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">Messager <span class="hljs-title">getMessager</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">Filer <span class="hljs-title">getFiler</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">Elements <span class="hljs-title">getElementUtils</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">Types <span class="hljs-title">getTypeUtils</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">SourceVersion <span class="hljs-title">getSourceVersion</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">Locale <span class="hljs-title">getLocale</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Filer 就是文件流输出路径，当我们用AbstractProcess生成一个java类的时候，我们需要保存在Filer指定的目录下。</p><p>Messager 输出日志工具，需要输出一些日志相关的时候我们就要使用这个了。</p><p>Elements 获取元素信息的工具，比如说一些类信息继承关系等。</p><p>Types 类型相关的工具类，processor java代码不同的是，当process执行的时候，class的由于类并没有被传递出来，所以大部分都行都是用element来代替了，所以很多类型比较等等的就会转化成type相关的进行比较了。</p><p>类型相关的都被转化成了一个叫TypeMirror，其getKind方法返回类型信息，其中包含了基础类型以及引用类型。</p><p>举个简单的例子，当一个实现了注解的Element被传入的时候，我们要判断Element是不是实现了特定接口，那么应该如何做呢？</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">private</span> Elements elementUtils;<br><span class="hljs-keyword">private</span> Types types;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> synchronized <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">init</span>(<span class="hljs-params">ProcessingEnvironment processingEnv</span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>.init(processingEnv);<br>    types = processingEnv.getTypeUtils();<br>    elementUtils = processingEnv.getElementUtils();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-function"><span class="hljs-title">isSubType</span>(<span class="hljs-params">Element element, <span class="hljs-built_in">String</span> className</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> element != <span class="hljs-literal">null</span> &amp;&amp; isSubType(element.asType(), className);<br>&#125;<br><br><span class="hljs-keyword">public</span> TypeMirror <span class="hljs-function"><span class="hljs-title">typeMirror</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> className</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> typeElement(className).asType();<br>&#125;<br><br><span class="hljs-keyword">public</span> TypeElement <span class="hljs-function"><span class="hljs-title">typeElement</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> className</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> elementUtils.getTypeElement(className);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-function"><span class="hljs-title">isSubType</span>(<span class="hljs-params">TypeMirror <span class="hljs-keyword">type</span>, <span class="hljs-built_in">String</span> className</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">type</span> != <span class="hljs-literal">null</span> &amp;&amp; types.isSubtype(<span class="hljs-keyword">type</span>, typeMirror(className));<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>其中isSubType方法是判断传入的Element是不是一个接口的实现类。首先我们要将对象都转化成Element, 然后将两个element转化成TypeMirror，之后调用Types的isSubtype方法对两个TypeMirror进行比较，如果发现类型一样，则该输入的Element是特定接口的实现类。</strong></p><h2 id="process"><a href="#process" class="headerlink" title="process()"></a>process()</h2><p>扫描代码的时候会把当前获取到的，此processer能处理的annotations传入当前方法</p><h3 id="Processor的kapt优化"><a href="#Processor的kapt优化" class="headerlink" title="Processor的kapt优化"></a>Processor的kapt优化</h3><p>kotlin对apt做了很多优化，内部完成了增量编译。但是对于低版本的autoservice，其增量编译会被关闭。</p><p>这里简单给各位大佬做下这方面的升级就好了。</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs clean">apply plugin: <span class="hljs-string">&#x27;java-library&#x27;</span><br>apply plugin: <span class="hljs-string">&#x27;kotlin&#x27;</span><br>apply plugin: <span class="hljs-string">&#x27;kotlin-kapt&#x27;</span><br><br>dependencies &#123;<br>    <span class="hljs-keyword">implementation</span> <span class="hljs-string">&#x27;com.google.auto.service:auto-service:1.0-rc5&#x27;</span><br>    <span class="hljs-keyword">implementation</span> <span class="hljs-string">&#x27;com.squareup:javapoet:1.10.0&#x27;</span><br>    <span class="hljs-keyword">implementation</span> <span class="hljs-string">&#x27;com.github.leifzhang:RouterAnnotation:0.5.0&#x27;</span><br>    <span class="hljs-keyword">implementation</span> <span class="hljs-string">&quot;org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version&quot;</span><br>    kapt <span class="hljs-string">&quot;com.google.auto.service:auto-service:1.0-rc5&quot;</span><br>&#125;<br>sourceCompatibility = <span class="hljs-number">1.8</span><br>targetCompatibility = <span class="hljs-number">1.8</span><br><br></code></pre></td></tr></table></figure><p>简单的说就是把processor 升级到rc5，然后用kapt的方式去把它注册起来就行了。</p><h2 id="缺点和总结"><a href="#缺点和总结" class="headerlink" title="缺点和总结"></a>缺点和总结</h2><p>缺点：apt能做的事情还是比较有限的</p><ol><li>javapoet只能新增一个类，而不能对当前类进行更改。</li><li>proessor在javac执行之前，所以只能对当前moudule生效</li><li>当Module一多，可能会有类名冲突的问题</li></ol><p>但是apt还是能帮助我们解决很多问题的，我们可以把一些机械化的操作，通过anntation的方式去简化，比如butterknife，这样开发就可以有更多的精力去专注做写别的事情。一部分abtest赋值的操作其实也可以用同样的方式去调整。</p><hr><h2 id="一些疑问"><a href="#一些疑问" class="headerlink" title="一些疑问"></a>一些疑问</h2><ul><li>注解处理器processor为什么要在META-INF注册？</li><li>注解处理器processor是如何被系统调用的？</li><li>注解申明和注解处理器为什么要分Module处理？</li><li>apt项目不会增加apk体积？</li></ul><p>先来回顾一下之前项目的部分目录结构</p><p><img src="https://upload-images.jianshu.io/upload_images/4134622-6cfb718f3055b89b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p><p>image.png</p><p>先明确一些概念：<br> <code>AbstractProcessor</code>是抽象处理器，开发apt时都必须继承这个类来生成<code>.java</code>文件，实现的这个类后叫做注解处理器，也就是这里的<code>ButterKnifeProcessor</code>。</p><h4 id="Q1-注解处理器processor为什么要在META-INF注册？"><a href="#Q1-注解处理器processor为什么要在META-INF注册？" class="headerlink" title="Q1:注解处理器processor为什么要在META-INF注册？"></a>Q1:注解处理器processor为什么要在META-INF注册？</h4><hr><p><code>META-INF</code>的作用<br> META-INF, 相当于一个信息包，用于存放一些meta information相关的文件。用来配置应用程序、扩展程序、类加载器和服务<a href="https://links.jianshu.com/go?to=https://www.baidu.com/s?wd=manifest.mf&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">manifest.mf</a>文件，在用jar打包时自动生成。</p><p>在之前的文章中说过，通过<code>@AutoService(Processor.class)</code>注解把注解处理器<code>ButterKnifeProcessor</code>注册到META-INF/services中，这里的包名是<code>META-INF/services/javax.annotation.processing.Processor</code>,<br> 这个文件的内容是</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">com<span class="hljs-selector-class">.zx</span><span class="hljs-selector-class">.processor</span><span class="hljs-selector-class">.ButterKnifeProcessor</span><br></code></pre></td></tr></table></figure><p>这个包名其实就是<code>@AutoService(Processor.class)</code>里面的<code>Processor</code>类；而文件内容就是注解处理器。</p><p><strong>在编译时，java编译器（javac）会去META-INF中查找实现了的AbstractProcessor的子类，并且调用该类的process函数，最终生成<code>.java</code>文件。</strong>其实就像activity需要注册一样，就是要到META-INF注册 ，javac才知道要给你调用哪个类来处理注解。</p><h4 id="Q2：注解处理器processor是如何被系统调用的？"><a href="#Q2：注解处理器processor是如何被系统调用的？" class="headerlink" title="Q2：注解处理器processor是如何被系统调用的？"></a>Q2：注解处理器processor是如何被系统调用的？</h4><hr><p>一些细心的同学应该发现了这个问题，我们并没有手动调用<code>AbstractProcessor</code>这个注解处理器类，那系统是什么时间调用的？又是如何调用的？这其实就牵扯到apt工作机制。</p><p>在上一问中，我们已经了解到，在编译时javac会查找所有的 在META_INF 中注册的注解处理器来处理注解。</p><p>到这里，好像有点清楚了，大概知道javac会去找到Processor并调用。但是呢还是没找到直接源头，因为它不像我们面向对象编程中可以准确追踪到是哪个对象调用的。</p><p>别着急，先来看这么个东西.<br> 是我项目中使用到注解的<code>app.Gradle</code></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp">dependencies &#123;<br>    <span class="hljs-function">implementation <span class="hljs-title">project</span>(<span class="hljs-params"><span class="hljs-string">&#x27;:annotation&#x27;</span></span>)</span><br><span class="hljs-function">    implementation <span class="hljs-title">project</span>(<span class="hljs-params"><span class="hljs-string">&#x27;:inject_api&#x27;</span></span>)</span><br><span class="hljs-function">    <span class="hljs-comment">//gradle3.0以上apt的实现方式</span></span><br><span class="hljs-function">    annotationProcessor <span class="hljs-title">project</span>(<span class="hljs-params"><span class="hljs-string">&#x27;:processor&#x27;</span></span>)</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><p>这里的<code>annotationProcessor</code>有点特别，没错，它是<strong>APT</strong>实现方案的一种。这里简单介绍一下：</p><blockquote><p>APT实现方案<br> <code>android-apt</code>和<code>annotationProcessor</code>功能是一样的，都是apt的实现方案，前者是个人开发者提供，比较早（现在不再维护了），后者是google官方开发的内置在<code>gradle</code>里的apt。</p><p>annotationProcessor是APT工具中的一种，是google开发的内置框架，不需要引入，可以直接在<code>build.gradle</code>文件中使用。</p></blockquote><p>只有在你使用注解的地方引入了<code>annotationProcessor</code>，系统才会主动调用注解处理类<code>Processor</code>,才会最终生成如下的<code>.java</code>文件</p><p><img src="TyporaRaw/java%E6%B3%A8%E8%A7%A3.assets/4134622-86775724faaeaa3e.png" alt="img"></p><p>apt生成类.png</p><p>这里先简单总结一下：<br> 2.1、在完成注解处理类<code>Processor</code>之后，需要做2件事情：</p><ul><li>1、在META-INF目录下注册<code>Processor</code>；</li><li>2、在项目中使用注解的地方添加apt工具<code>annotationProcessor</code></li></ul><p>2.2、APT 4要素<br> 　<strong>注解处理器（AbstractProcess）+ 代码处理（javaPoet）+ 处理器注册（AutoService）+ apt（annotationProcessor）</strong></p><p><code>APT(Annotation Processing Tool)总结</code><br> 首先，APT是javac提供的一种工具，它在编译时扫描、解析、处理注解。它会对源代码文件进行检测，找出用户自定义的注解，根据注解、注解处理器和相应的apt工具自动生成代码。这段代码是根据用户编写的注解处理逻辑去生成的。<strong>最终将生成的新的源文件与原来的源文件共同编译（注意：APT并不能对源文件进行修改操作，只能生成新的文件，例如往原来的类中添加方法）</strong>。具体流程图如下图所示：</p><p><img src="TyporaRaw/java%E6%B3%A8%E8%A7%A3.assets/4134622-b1f7494d18e216d1.png" alt="img"></p><p>apt工作流程.png</p><p>APT技术的使用，需要我们遵守一定的规则。大家先看一下整个APT项目项目构建的一个规则图，具体如下所示：</p><p><img src="TyporaRaw/java%E6%B3%A8%E8%A7%A3.assets/4134622-55d88199566ac011.png" alt="img"></p><h4 id="Q3：注解申明和注解处理器为什么要分Module处理？"><a href="#Q3：注解申明和注解处理器为什么要分Module处理？" class="headerlink" title="Q3：注解申明和注解处理器为什么要分Module处理？"></a>Q3：注解申明和注解处理器为什么要分Module处理？</h4><hr><p>先来回顾一下之前的项目结构：</p><p><img src="TyporaRaw/java%E6%B3%A8%E8%A7%A3.assets/4134622-1a701ad9e6425883.png" alt="img"></p><ul><li><code>annotation</code>：申明注解 （java lib）</li><li><code>processor</code>：注解处理器（java lib）</li><li><code>inject_api</code>：调用处理器中生成的类 （android lib）</li><li><code>app</code>：项目使用 （android lib）</li></ul><p>我们都知道注解处理器都需要继承<code>AbstractProcessor</code>类，但是<code>AbstractProcessor</code>是JDK中的类，不在android sdk中，所以需要放在单独的java lib中；而<code>processor</code>中需要依赖自定义注解，把<code>annotation</code>抽成一个独立的lib，便于维护。</p><p><strong>那注解声明和注解处理为什么要分开呢？可不可以放在一起？</strong><br> 先说结论：可以放在一起，放在一起对功能上没有什么影响；但是一般不放在一起，原因如下：</p><blockquote><p>我们都知道<code>processor</code>的作用是：在编译器解析注解、生成新的<code>.java</code>文件。<strong>这个lib只在编译器用到，是不会被打包进apk的。</strong>对于调用者来说，你只是想使用这个注解，而不希望你已经编译好的项目中引进注解处理器相关的内容，所以为了不引入没必要的文件，我们一般选择将注解声明和注解处理分开处理。</p></blockquote><p>到这里apt相关知识就说完了，我们也可以理解为什么<code>ButterKnife</code>这种注解库不会增加项目体积了。</p><p>想了解更多apt知识，可以参考：<br> <a href="https://www.jianshu.com/p/b6b3283968e0">https://www.jianshu.com/p/b6b3283968e0</a></p><p>感谢<br> <a href="https://links.jianshu.com/go?to=https://blog.csdn.net/xx326664162/article/details/68490059">你必须知道的APT、annotationProcessor、android-apt、Provided、自定义注解</a></p><p>作者：唠嗑008<br>链接：<a href="https://www.jianshu.com/p/89ac9a2513c4">https://www.jianshu.com/p/89ac9a2513c4</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>注解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nix包管理</title>
    <link href="/posts/321c9b4b/"/>
    <url>/posts/321c9b4b/</url>
    
    <content type="html"><![CDATA[<h1 id="在manjaro上使用nix包管理"><a href="#在manjaro上使用nix包管理" class="headerlink" title="在manjaro上使用nix包管理"></a>在manjaro上使用nix包管理</h1><h1 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h1><ol><li><a href="https://nixos.org/manual/nix/stable/installation/installing-binary.html">手册</a></li></ol><h1 id="普通安装"><a href="#普通安装" class="headerlink" title="普通安装"></a>普通安装</h1><ol><li><p> 分一个ext4分区</p></li><li><p>在根目录下创建nix文件夹</p></li><li><p>使用<code>chown username /nix</code> 改变nix目录的所属者</p></li><li><p>使用磁盘工具，将分好的分区挂载到<code>/nix</code>目录</p></li><li><p>安装nix</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ sh &lt;(curl -L https:<span class="hljs-regexp">//</span>nixos.org<span class="hljs-regexp">/nix/i</span>nstall) --no-daemon  <span class="hljs-comment">#单用户</span><br></code></pre></td></tr></table></figure></li><li><p>卸载nix：删除<code>/nix</code>目录即可</p></li></ol><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>查询可供安装的软件包。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">nix-<span class="hljs-keyword">env</span> -qa<br></code></pre></td></tr></table></figure><p>查找软件包</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim">nix-env -<span class="hljs-keyword">qa</span> firefox<br>和<br>nix-env -<span class="hljs-keyword">qa</span> | <span class="hljs-keyword">grep</span> <span class="hljs-string">&quot;firefox&quot;</span> <br></code></pre></td></tr></table></figure><p> 要安装软件包，通过指定软件包版本使用以下命令，例如安装火狐</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">nix-env -<span class="hljs-selector-tag">i</span> firefox<br></code></pre></td></tr></table></figure><p>在本地系统上，Nix将包存储在<strong>Nix存储中</strong> ，默认情况下为**/ nix / store**目录，其中每个包都有自己唯一的子目录。 例如， <strong>apache-tomcat</strong>包存储在：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/nix/</span>store/<span class="hljs-number">95</span>gmgnxlrcpkhlm00fa5ax8kvd6189py-apache-tomcat-<span class="hljs-number">9.0</span>.<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>在此路径中，随机字符<strong>95gmgnxlrcpkhlm00fa5ax8kvd6189py</strong>是包的唯一标识符，它考虑了所有依赖项。</p><p>您可以使用以下命令列出已安装的软件包。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">$ nix-<span class="hljs-keyword">env</span> -q<br></code></pre></td></tr></table></figure><p>要升级<strong>apache-tomcat</strong>软件包，可以使用<code>-u</code> upgrade开关</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">$ nix-<span class="hljs-keyword">env</span> -u apache-tomcat<br></code></pre></td></tr></table></figure><p>如果要删除/擦除<strong>apache-tomcat</strong> ，请使用<code>-e</code>标志。 这里，包不会立即从系统中删除，只会使其未使用。 这很有用，因为您想要进行回滚，或者它可能位于其他用户的配置文件中。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">$ nix-<span class="hljs-keyword">env</span> -e apache-tomcat<br></code></pre></td></tr></table></figure><p>删除包后，您可以使用<strong>nix-collect-garbage</strong>实用程序进行一些垃圾<strong>回收</strong> 。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>nix-collect-garbage<br></code></pre></td></tr></table></figure><h3 id="多用户安装-如何在Linux中删除Nix包管理器"><a href="#多用户安装-如何在Linux中删除Nix包管理器" class="headerlink" title="多用户安装 如何在Linux中删除Nix包管理器"></a>多用户安装 如何在Linux中删除Nix包管理器</h3><p>要卸载Nix，请一次删除所有与nix相关的文件。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo rm -rf <span class="hljs-regexp">/etc/</span>profile<span class="hljs-regexp">/nix.sh /</span>etc<span class="hljs-regexp">/nix /</span>nix ~root<span class="hljs-regexp">/.nix-profile ~root/</span>.nix-defexpr ~root<span class="hljs-regexp">/.nix-channels ~/</span>.nix-profile ~<span class="hljs-regexp">/.nix-defexpr ~/</span>.nix-channels<br></code></pre></td></tr></table></figure><p>在具有systemd的系统上，运行以下命令以停止所有与nix相关的服务并禁用它们。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> sudo systemctl stop nix-daemon.socket</span><br><span class="hljs-meta">$</span><span class="bash"> sudo systemctl stop nix-daemon.service</span><br><span class="hljs-meta">$</span><span class="bash"> sudo systemctl <span class="hljs-built_in">disable</span> nix-daemon.socket</span><br><span class="hljs-meta">$</span><span class="bash"> sudo systemctl <span class="hljs-built_in">disable</span> nix-daemon.service</span><br><span class="hljs-meta">$</span><span class="bash"> sudo systemctl daemon-reload</span><br></code></pre></td></tr></table></figure><p>如果使用的macos,你需要运行</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">sudo launchctl unload /Library/LaunchDaemons/org<span class="hljs-selector-class">.nixos</span><span class="hljs-selector-class">.nix-daemon</span><span class="hljs-selector-class">.plist</span><br>sudo rm /Library/LaunchDaemons/org<span class="hljs-selector-class">.nixos</span><span class="hljs-selector-class">.nix-daemon</span>.plist<br></code></pre></td></tr></table></figure><p>此外，您需要删除这些文件中对Nix的任何引用： <strong>/ etc / profile</strong> ， <strong>/ etc / bashrc</strong>和**/ etc / zshrc** 。</p><p>有关更多信息，请参阅我们已查看的上述实用程序的手册页。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> <span class="hljs-built_in">man</span> nix<span class="hljs-literal">-channel</span><br><span class="hljs-variable">$</span> <span class="hljs-built_in">man</span> nix<span class="hljs-literal">-env</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>nix os</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安装fbterm</title>
    <link href="/posts/d4eef720/"/>
    <url>/posts/d4eef720/</url>
    
    <content type="html"><![CDATA[<h1 id="安装fbterm"><a href="#安装fbterm" class="headerlink" title="安装fbterm:"></a>安装fbterm:</h1><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pamac <span class="hljs-keyword">install</span> fbterm<br></code></pre></td></tr></table></figure><h1 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h1><h2 id="将用户加入video组-并更改fbterm权限"><a href="#将用户加入video组-并更改fbterm权限" class="headerlink" title="将用户加入video组,并更改fbterm权限:"></a>将用户加入video组,并更改fbterm权限:</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">==&gt; 若想使用非根用户运行fbterm，需要把用户加入video组：<br><span class="hljs-comment">#username为用户名，video为fbterm所在组</span><br>sudo gpasswd -a YOUR_USERNAME video<br><br>==&gt; 若想非根用户可使用键盘快捷方式，需要：<br>sudo setcap <span class="hljs-string">&#x27;cap_sys_tty_config+ep&#x27;</span> <span class="hljs-regexp">/usr/</span>bin/fbterm<br>或者：<br>sudo chmod u+s <span class="hljs-regexp">/usr/</span>bin/fbterm<br></code></pre></td></tr></table></figure><h2 id="tty自动进入fbterm"><a href="#tty自动进入fbterm" class="headerlink" title="tty自动进入fbterm"></a>tty自动进入fbterm</h2><p>修改用户配置文件“home/.bashrc”或“home/.zshrc”。在.bashrc或.zshrc最后中添加如下判断:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#进入tty自动启动fbterm</span><br><span class="hljs-keyword">if</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$TERM</span>&quot;</span> = <span class="hljs-string">&quot;linux&quot;</span> ]; <span class="hljs-keyword">then</span><br><span class="hljs-comment"># 此处使用了别名,如此当我们退出fbterm后,便能够通过简单的命令:fbterm,</span><br><span class="hljs-comment"># 重新启动fbterm了,而不用再指定LANG.</span><br><span class="hljs-built_in">alias</span> fbterm=<span class="hljs-string">&#x27;LANG=zh_CN.UTF-8 fbterm&#x27;</span><br>fbterm<br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure><h1 id="创建fbterm的配置文件"><a href="#创建fbterm的配置文件" class="headerlink" title="创建fbterm的配置文件"></a>创建fbterm的配置文件</h1><p><strong>在~/.config/位置创建fbterm文件夹，在此文件夹下创建fbtermrc文件</strong></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade">mkdir ~<span class="hljs-regexp">/.config/</span>fbterm<br>cd ~<span class="hljs-regexp">/.config/</span>fbterm<br>touch fbtermrc<br></code></pre></td></tr></table></figure><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><p>配置文件在 ~/.config/fbterm/fbtermrc</p><p>首先注意，konsole/gnome-terminal 等 X11 环境的终端模拟器的字体拿到 fbterm 中百分之百会走形。因此一些很漂亮的比如 consolas，monaco，andale 等都很丑。你可以在 .fbtermrc 中自己试验。原因是 fbterm 使用 fontconfig 挑字体，freetype 渲染，但是 <strong>freetype 中依赖 libxft 的部分它作为一个终端无法使用</strong>。</p><p>中文字体测试过文泉驿微米黑、正黑、点阵宋和 unibit，都不行。其中点阵宋显示很清晰，但是宽度太大，其他完全就不清晰。微软、苹果家的字体都是要求 freetype 渲染的，就不要想了。我摸索出的最佳字体配置如下：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">font-names</span>=DejaVu Sans Mo<span class="hljs-literal">no</span>,Droid Sans Fallback<br><span class="hljs-attr">font-size</span>=<span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">text-encodings</span>=UTF-<span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p>也在 .fbtermrc 中配置。</p><h3 id="键盘快捷键"><a href="#键盘快捷键" class="headerlink" title="键盘快捷键"></a>键盘快捷键</h3><p>启动提示：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">[<span class="hljs-keyword">input</span>] can&#x27;t change kernel keymap <span class="hljs-keyword">table</span>, all shortcuts will NOT work,  see SECURITY <span class="hljs-keyword">NOTES</span> section of <span class="hljs-keyword">man</span> page <span class="hljs-keyword">for</span> solution.<br></code></pre></td></tr></table></figure><p>原因：fbterm 需要设置内核键盘映射表来设定快捷键。这就需要 fbterm 是一个 setuid 0 的程序（不然普通用户还是设置不了快捷键因为没权限操作内核）。fbterm 也只在设置快捷键时会自动转为 root。因此安全上是可以放心的。</p><p>解决：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo chmod u+s <span class="hljs-regexp">/usr/</span>bin/fbterm<br></code></pre></td></tr></table></figure><h3 id="背景图片"><a href="#背景图片" class="headerlink" title="背景图片"></a>背景图片</h3><p>安装 home:MargueriteSu 源的 fbv 软件，把下面脚本保存成 cfbterm</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">    #!/bin/bash<br><br>    # fbterm-bi: a <span class="hljs-keyword">wrapper</span> script <span class="hljs-keyword">to</span>  <span class="hljs-keyword">enable</span>  background<br>image <span class="hljs-keyword">with</span> fbterm<br>    # <span class="hljs-keyword">usage</span>: fbterm-bi /<span class="hljs-type">path</span>/<span class="hljs-keyword">to</span>/image fbterm-<span class="hljs-keyword">options</span><br><br>    echo -ne &quot;\e[?25l&quot; # hide <span class="hljs-keyword">cursor</span><br><br>    fbv -ciuker &quot;这里是你的图片的完整路径&quot; &lt;&lt; EOF<br>    q<br>    EOF<br><br>    shift<br>    export FBTERM_BACKGROUND_IMAGE=<span class="hljs-number">1</span><br>    exec fbterm &quot;$@&quot;<br></code></pre></td></tr></table></figure><p>然后：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo cp -r cfbterm <span class="hljs-regexp">/usr/</span>bin<br></code></pre></td></tr></table></figure><p>以后每次都用 cfbterm 命令启动控制台。图片支持 png/jpeg/jpg/bmp 格式，建议用 png，jpeg 的颜色渐变在终端下显示很丑。</p><h3 id="输入法"><a href="#输入法" class="headerlink" title="输入法"></a>输入法</h3><p>安装 fcitx-fbterm。然后在 /home/marguerite/.fbtermrc 的最后：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">input-<span class="hljs-function"><span class="hljs-keyword">method</span>=<span class="hljs-title">fcitx</span>-<span class="hljs-title">fbterm</span></span><br></code></pre></td></tr></table></figure><p>网上有说 fcitx 和 fbterm 的进终端自动启动，但那个不支持背景图片。如果你不需要背景图片，可以把：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua"># If you <span class="hljs-keyword">do</span> console login, it will start fbterm <span class="hljs-keyword">and</span> fcitx-fbterm by default.<br><br><span class="hljs-string">[[ $(tty) == \/dev\/tty[0-9]* ]]</span> &amp;&amp; fcitx-fbterm-helper<br></code></pre></td></tr></table></figure><p>写入到 /home/marguerite/.bashrc。</p><p>使用背景图片的启动方法是：</p><ul><li>登录终端</li><li>cfbterm 启动 fbterm</li><li>在 fbterm 中运行 fcitx -d 启动 fcitx</li></ul><h3 id="256-色"><a href="#256-色" class="headerlink" title="256 色"></a>256 色</h3><p>fbterm 支持 256 色，使用：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">TERM</span>=fbterm vim .fbtermrc<br></code></pre></td></tr></table></figure><p>这样的命令来启动程序即可。不想每次都这么做，在 .fbtermrc 的最后写入：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">TERM</span>=fbterm<br></code></pre></td></tr></table></figure><p>即可。</p><h3 id="灰白改纯白"><a href="#灰白改纯白" class="headerlink" title="灰白改纯白"></a>灰白改纯白</h3><p>fbterm 里面默认的白色实际上是灰白，不习惯的可以在 .fbtermrc 的最后写入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># restore white color</span><br><span class="hljs-built_in">echo</span> -ne <span class="hljs-string">&quot;\e]P7ffffff&quot;</span><br></code></pre></td></tr></table></figure><p>即可。</p><h3 id="鼠标"><a href="#鼠标" class="headerlink" title="鼠标"></a>鼠标</h3><p>要先设置 gpm。使用：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo yast mouse</span> <br></code></pre></td></tr></table></figure><p>来选择你想在终端中使用的鼠标。然后，</p><p>在终端登录后<strong>默认的 bash</strong> 中，使用：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo <span class="hljs-regexp">/etc/i</span>nit.d/gpm start <br></code></pre></td></tr></table></figure><p>启动 gpm 鼠标服务器。之后正常进入 fbterm 用鼠标。</p><h3 id="终端截图"><a href="#终端截图" class="headerlink" title="终端截图"></a>终端截图</h3><p>安装 home:MargueriteSu 源中的 fbshot。使用：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">fbshot</span> -s 读秒 图片保存路径<br></code></pre></td></tr></table></figure><p>来截图。</p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件，终端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>aria2整理</title>
    <link href="/posts/49c06d08/"/>
    <url>/posts/49c06d08/</url>
    
    <content type="html"><![CDATA[<h1 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h1><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> pacman -S aria<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h2 id="2-Aria2-配置说明"><a href="#2-Aria2-配置说明" class="headerlink" title="2.Aria2 配置说明"></a>2.Aria2 配置说明</h2><ol><li>创建<code>/home/用户名/.config/aria2/</code>文件夹，新建一个名为aria2.conf的配置文件，并把下面的配置示例修改后复制进去</li><li>创建<code>/home/用户名/.aria2/</code>文件夹，用touch命令建立两个文件<code>aria2.session</code>和<code>input.session</code></li><li>第二步里的路径可以自行修改，在配置文件里填写好就行</li></ol><ul><li><p><strong>完整选项说明请参考 <a href="https://aria2.github.io/manual/en/html/aria2c.html">Aria2 Manual</a></strong></p></li><li><p><strong>参数 <code>--dir</code> <code>--input-file</code> <code>--save-session</code> 根据实际情况修改路径</strong></p></li><li><p>配置示例, 可根据需要修改各项参数</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta">## &#x27;#&#x27;开头为注释内容, 选项都有相应的注释说明, 根据需要修改 ##</span><br><span class="hljs-meta">## 被注释的选项填写的是默认值, 建议在需要修改时再取消注释  ##</span><br><br><span class="hljs-meta">## 文件保存相关 ##</span><br><br><span class="hljs-meta"># 文件的保存路径(可使用绝对路径或相对路径), 默认: 当前启动位置</span><br>dir=$&#123;HOME&#125;/下载<br><span class="hljs-meta"># 启用磁盘缓存, 0为禁用缓存, 需1.16以上版本, 默认:16M</span><br><span class="hljs-meta">#disk-cache=32M</span><br><span class="hljs-meta"># 文件预分配方式, 能有效降低磁盘碎片, 默认:prealloc</span><br><span class="hljs-meta"># 预分配所需时间: none &lt; falloc ? trunc &lt; prealloc</span><br><span class="hljs-meta"># falloc和trunc则需要文件系统和内核支持</span><br><span class="hljs-meta"># NTFS建议使用falloc, EXT3/4建议trunc, MAC 下需要注释此项</span><br><span class="hljs-meta">#file-allocation=none</span><br><span class="hljs-meta"># 断点续传</span><br>continue=<span class="hljs-literal">true</span><br><br><span class="hljs-meta">## 下载连接相关 ##</span><br><br><span class="hljs-meta"># 最大同时下载任务数, 运行时可修改, 默认:5</span><br><span class="hljs-meta">#max-concurrent-downloads=5</span><br><span class="hljs-meta"># 同一服务器连接数, 添加时可指定, 默认:1</span><br>max-connection-per-server=<span class="hljs-number">5</span><br><span class="hljs-meta"># 最小文件分片大小, 添加时可指定, 取值范围1M -1024M, 默认:20M</span><br><span class="hljs-meta"># 假定size=10M, 文件为20MiB 则使用两个来源下载; 文件为15MiB 则使用一个来源下载</span><br>min-split-size=<span class="hljs-number">10</span>M<br><span class="hljs-meta"># 单个任务最大线程数, 添加时可指定, 默认:5</span><br><span class="hljs-meta">#split=5</span><br><span class="hljs-meta"># 整体下载速度限制, 运行时可修改, 默认:0</span><br><span class="hljs-meta">#max-overall-download-limit=0</span><br><span class="hljs-meta"># 单个任务下载速度限制, 默认:0</span><br><span class="hljs-meta">#max-download-limit=0</span><br><span class="hljs-meta"># 整体上传速度限制, 运行时可修改, 默认:0</span><br><span class="hljs-meta">#max-overall-upload-limit=0</span><br><span class="hljs-meta"># 单个任务上传速度限制, 默认:0</span><br><span class="hljs-meta">#max-upload-limit=0</span><br><span class="hljs-meta"># 禁用IPv6, 默认:false</span><br><span class="hljs-meta">#disable-ipv6=true</span><br><span class="hljs-meta"># 连接超时时间, 默认:60</span><br><span class="hljs-meta">#timeout=60</span><br><span class="hljs-meta"># 最大重试次数, 设置为0表示不限制重试次数, 默认:5</span><br><span class="hljs-meta">#max-tries=5</span><br><span class="hljs-meta"># 设置重试等待的秒数, 默认:0</span><br><span class="hljs-meta">#retry-wait=0</span><br><br><span class="hljs-meta">## 进度保存相关 ##</span><br><br><span class="hljs-meta"># 从会话文件中读取下载任务。比如： /etc/aria2/aria2.session</span><br>input-file=$&#123;HOME&#125;/.aria2/input.session<br><span class="hljs-meta"># 在Aria2退出时保存`错误/未完成`的下载任务到会话文件。比如： /etc/aria2/aria2.session</span><br>save-session=$&#123;HOME&#125;/.aria2/aria2.session<br><span class="hljs-meta"># 定时保存会话, 0为退出时才保存, 需1.16.1以上版本, 默认:0</span><br><span class="hljs-meta">#save-session-interval=60</span><br><br><span class="hljs-meta">## RPC相关设置 ##</span><br><br><span class="hljs-meta"># 启用RPC, 默认:false</span><br>enable-rpc=<span class="hljs-literal">true</span><br><span class="hljs-meta"># 允许所有来源, 默认:false</span><br>rpc-allow-origin-all=<span class="hljs-literal">true</span><br><span class="hljs-meta"># 允许非外部访问, 默认:false</span><br>rpc-listen-all=<span class="hljs-literal">true</span><br><span class="hljs-meta"># 事件轮询方式, 取值:[epoll, kqueue, port, poll, select], 不同系统默认值不同</span><br><span class="hljs-meta">#event-poll=select</span><br><span class="hljs-meta"># RPC监听端口, 端口被占用时可以修改, 默认:6800</span><br><span class="hljs-meta">#rpc-listen-port=6800</span><br><span class="hljs-meta"># 设置的RPC授权令牌, v1.18.4新增功能, 取代 --rpc-user 和 --rpc-passwd 选项</span><br><span class="hljs-meta">#rpc-secret=&lt;TOKEN&gt;</span><br><span class="hljs-meta"># 设置的RPC访问用户名, 此选项新版已废弃, 建议改用 --rpc-secret 选项</span><br><span class="hljs-meta">#rpc-user=&lt;USER&gt;</span><br><span class="hljs-meta"># 设置的RPC访问密码, 此选项新版已废弃, 建议改用 --rpc-secret 选项</span><br><span class="hljs-meta">#rpc-passwd=&lt;PASSWD&gt;</span><br><span class="hljs-meta"># 是否启用 RPC 服务的 SSL/TLS 加密,</span><br><span class="hljs-meta"># 启用加密后 RPC 服务需要使用 https 或者 wss 协议连接</span><br><span class="hljs-meta">#rpc-secure=true</span><br><span class="hljs-meta"># 在 RPC 服务中启用 SSL/TLS 加密时的证书文件,</span><br><span class="hljs-meta"># 使用 PEM 格式时，您必须通过 --rpc-private-key 指定私钥</span><br><span class="hljs-meta">#rpc-certificate=/path/to/certificate.pem</span><br><span class="hljs-meta"># 在 RPC 服务中启用 SSL/TLS 加密时的私钥文件</span><br><span class="hljs-meta">#rpc-private-key=/path/to/certificate.key</span><br><br><span class="hljs-meta">## BT/PT下载相关 ##</span><br><br><span class="hljs-meta"># 当下载的是一个种子(以.torrent结尾)时, 自动开始BT任务, 默认:true</span><br><span class="hljs-meta">#follow-torrent=true</span><br><span class="hljs-meta"># BT监听端口, 当端口被屏蔽时使用, 默认:6881-6999</span><br>listen-port=<span class="hljs-number">51413</span><br><span class="hljs-meta"># 单个种子最大连接数, 默认:55</span><br><span class="hljs-meta">#bt-max-peers=55</span><br><span class="hljs-meta"># 打开DHT功能, PT需要禁用, 默认:true</span><br>enable-dht=<span class="hljs-literal">false</span><br><span class="hljs-meta"># 打开IPv6 DHT功能, PT需要禁用</span><br><span class="hljs-meta">#enable-dht6=false</span><br><span class="hljs-meta"># DHT网络监听端口, 默认:6881-6999</span><br><span class="hljs-meta">#dht-listen-port=6881-6999</span><br><span class="hljs-meta"># 本地节点查找, PT需要禁用, 默认:false</span><br><span class="hljs-meta">#bt-enable-lpd=false</span><br><span class="hljs-meta"># 种子交换, PT需要禁用, 默认:true</span><br>enable-peer-exchange=<span class="hljs-literal">false</span><br><span class="hljs-meta"># 每个种子限速, 对少种的PT很有用, 默认:50K</span><br><span class="hljs-meta">#bt-request-peer-speed-limit=50K</span><br><span class="hljs-meta"># 客户端伪装, PT需要</span><br>peer-id-prefix=-TR2770-<br>user-agent=Transmission/<span class="hljs-number">2.77</span><br>peer-agent=Transmission/<span class="hljs-number">2.77</span><br><span class="hljs-meta"># 当种子的分享率达到这个数时, 自动停止做种, 0为一直做种, 默认:1.0</span><br>seed-ratio=<span class="hljs-number">0</span><br><span class="hljs-meta"># 强制保存会话, 即使任务已经完成, 默认:false</span><br><span class="hljs-meta"># 较新的版本开启后会在任务完成后依然保留.aria2文件</span><br><span class="hljs-meta">#force-save=false</span><br><span class="hljs-meta"># BT校验相关, 默认:true</span><br><span class="hljs-meta">#bt-hash-check-seed=true</span><br><span class="hljs-meta"># 继续之前的BT任务时, 无需再次校验, 默认:false</span><br>bt-seed-unverified=<span class="hljs-literal">true</span><br><span class="hljs-meta"># 保存磁力链接元数据为种子文件(.torrent文件), 默认:false</span><br>bt-save-metadata=<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="使用aria2下载"><a href="#使用aria2下载" class="headerlink" title="使用aria2下载"></a>使用aria2下载</h2><ol><li><p>在终端里输入<code>aria2c</code> 启动服务，出现监听端口</p></li><li><p>用浏览器打开<a href="http://aria2c.com/">Aria2 Web 控制台</a></p></li><li><p>不使用aria2时在终端里按下<code>ctrl+c</code>回车停止aria2服务</p></li></ol><h2 id="Aria2-相关下载"><a href="#Aria2-相关下载" class="headerlink" title="Aria2 相关下载"></a>Aria2 相关下载</h2><ul><li><p><a href="https://github.com/aria2/aria2/releases/latest">Aria2 源码/程序下载</a></p></li><li><p><a href="http://aria2c.com/archiver/aria2.conf">配置示例下载</a></p></li><li><p>重要文件</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs 1c">aria2.conf    <span class="hljs-meta"># 配置文件 可以自己根据说明修改</span><br>aria2.session <span class="hljs-meta"># 任务保存文件 错误/未完成任务会保存在这里（下载历史）</span><br>Aria2.<span class="hljs-built_in">log</span> <span class="hljs-meta">#（日志，空文件就行）</span><br>input.session <span class="hljs-meta"># 从会话文件中读取下载任务</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h1><p>推荐使用AriaNG</p><p><a href="http://ariang.mayswind.net/zh_Hans/">ariaNg下载到本地使用</a></p><h2 id="创建-systemd-守护进程"><a href="#创建-systemd-守护进程" class="headerlink" title="创建 systemd 守护进程"></a>创建 systemd 守护进程</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo vim /etc/systemd/user/aria2.service<br>[Unit]<br><span class="hljs-attribute">Description</span>=Aria2<span class="hljs-built_in"> Service</span><br><span class="hljs-built_in"></span><span class="hljs-attribute">After</span>=network.target<br><br>[Service]<br><span class="hljs-attribute">Type</span>=forking<br><span class="hljs-attribute">WorkingDirectory</span>=%h<br><span class="hljs-attribute">ExecStart</span>=/usr/bin/aria2c --daemon --enable-rpc --rpc-listen-all --rpc-allow-origin-all -c -D  <span class="hljs-attribute">--conf-path</span>=%h/.config/aria2/aria2.conf<br><br>[Install]<br><span class="hljs-attribute">WantedBy</span>=default.target<br><span class="hljs-comment"># 启动</span><br>systemctl --user start aria2.service<br>systemctl --user <span class="hljs-builtin-name">enable</span> aria2.service<br></code></pre></td></tr></table></figure><h2 id="YAAW-使用说明"><a href="#YAAW-使用说明" class="headerlink" title="YAAW 使用说明"></a>YAAW 使用说明</h2><p><strong>JSON-RPC Path</strong></p><ul><li><p><code>JSON-RPC Path</code> 默认为: <code>http://localhost:6800/jsonrpc</code></p></li><li><p>如果提示 </p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">Aria2</span> RPC 服务器错误<br></code></pre></td></tr></table></figure><p> 按照以下方法修改             </p><ul><li><p><strong><code>host</code></strong>: 指运行 Aria2 所在机器的 IP 或者名字</p></li><li><p><strong><code>port</code></strong>: 使用 <code>--rpc-listen-port</code> 选项设置的端口, 未设置则是 <code>6800</code></p></li><li><p>普通情况设置为: <code>http://host:port/jsonrpc</code></p></li><li><p>使用 <code>--rpc-secret=xxxxxx</code> 选项设置为: <code>http://token:xxxxxx@host:port/jsonrpc</code></p></li><li><p>使用 <code>--rpc-user=user --rpc-passwd=pwd </code> 选项设置为: <code>http://user:pwd@host:port/jsonrpc</code></p></li><li><p>以上 <code>JSON-RPC Path</code> 中的 <code>http</code> 可以用 <code>ws</code> 替代, 代表使用 <code>WebSocket 协议</code></p></li><li><p>当使用 <a href="https://aria2c.com/">https://aria2c.com</a> 访问时, 需要使用 <code>https</code> 或 <code>wss</code> 协议</p></li></ul></li></ul><p><strong>Tips</strong></p><ul><li>在 YAAW 中对 Aria2 的设置会在 Aria2 重启后丢失, 必要的设置请写入配置文件</li><li>已经下载完成的任务会在 Aria2 重启后消失, 除非启用了 <code>--force-save</code> 选项</li><li>因界面已汉化, 其他不再赘述.</li></ul><h2 id="YAAW-搭配脚本"><a href="#YAAW-搭配脚本" class="headerlink" title="YAAW 搭配脚本"></a>YAAW 搭配脚本</h2><p><strong>迅雷离线</strong></p><ul><li><p>Chrome Extension: <a href="https://chrome.google.com/webstore/detail/eehlmkfpnagoieibahhcghphdbjcdmen">ThunderLixianAssistant</a></p></li><li><p>UserScript: <a href="https://github.com/binux/ThunderLixianExporter">ThunderLixianExporter</a></p></li><li><p><a href="https://greasyfork.org/scripts/2398-lixianexporter">https://greasyfork.org/scripts/2398-lixianexporter</a>)</p></li></ul><p><strong>百度网盘</strong></p><ul><li>Chrome Extension: <a href="https://chrome.google.com/webstore/detail/mjaenbjdjmgolhoafkohbhhbaiedbkno">BaiduExporter</a></li><li>Firefox Addons: <a href="https://github.com/acgotaku/BaiduExporter">BaiduExporter</a></li><li>UserScript: <a href="https://greasyfork.org/scripts/294-baidupandownloadhelper">BaiduPanDownloadHelper</a></li></ul><p><strong>其他脚本</strong></p><ul><li>Chrome Extension: <a href="https://chrome.google.com/webstore/detail/nimeojfecmndgolmlmjghjmbpdkhhogl">添加到aria2</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>aria2</tag>
      
      <tag>软件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ssh使用</title>
    <link href="/posts/f4bf1653/"/>
    <url>/posts/f4bf1653/</url>
    
    <content type="html"><![CDATA[<h1 id="实践原理："><a href="#实践原理：" class="headerlink" title="实践原理："></a>实践原理：</h1><p>读者一定很好奇SSH认证的流程，这里给出一张粗陋的图简单解释一下：</p><p><img src="TyporaRaw/SSH%E4%BD%BF%E7%94%A8.assets/1200.jpeg" alt="img"></p><p>如果我们事先在服务器中存储了USER1的公钥(后面会讲解如何做)，则USER1发起SSH连接服务器的流程如下：</p><ul><li>1.USER1发起SSH请求</li><li>2.服务器生成随机数R1发给USER1，USER1用私钥加密生成R2。</li><li>3.USER1把R2回发给服务器，服务器用公钥解密并对比R1，相同则成功连接。</li></ul><p>其实很简单，但是如果还不懂，没有关系，可以先做一遍，再会过头来看，让我们开始吧。</p><h2 id="实践步骤1：生成密钥对"><a href="#实践步骤1：生成密钥对" class="headerlink" title="实践步骤1：生成密钥对"></a>实践步骤1：生成密钥对</h2><p>读者可能有两个疑惑：</p><h3 id="第一，生成的密钥对应当放在何处？"><a href="#第一，生成的密钥对应当放在何处？" class="headerlink" title="第一，生成的密钥对应当放在何处？"></a>第一，生成的密钥对应当放在何处？</h3><p>因为密钥一定要牢牢把握在自己手中，不能让别人知道。所以我们一定要在自己的物理机上生成密钥对，千万不能在远程计算机上生成，否则就不符合密钥的定义了。</p><h3 id="第二，如何生成密钥对？"><a href="#第二，如何生成密钥对？" class="headerlink" title="第二，如何生成密钥对？"></a>第二，如何生成密钥对？</h3><ol><li><p>在本机终端运行<code>ssh-keygen</code>命令, 即可生成一对默认的RSA密钥。使用<code> -t</code>命令指定密钥类型， 使用<code>-f</code> 选项指定生成文件的文件名具体可以通过<code>man ssh-keygen</code>查看。我们用默认的RSA密钥即可: <code>ssh-keygen -t rsa</code>。</p></li><li><p>然后自己输入保存的路径和文件名，推荐保存到home目录的.ssh文件夹下。</p></li><li><p>输入管理密码(不建议为空，并且需记住)。注意，这里的密码是防止别人用你的电脑SSH无密码登陆远程服务器，可以理解成开机密码，可防止别人乱动你的电脑。</p></li></ol><h3 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h3><p>生成ssh key的时候，可以通过 <code>-f</code> 选项指定生成文件的文件名，如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ssh-keygen -t rsa -f <span class="hljs-built_in">test</span>   -C <span class="hljs-string">&quot;test key&quot;</span><br>                     ~~文件名   ~~~~ 备注<br></code></pre></td></tr></table></figure><p>如果没有指定文件名，会询问你输入文件名:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">$ ssh-keygen<br>Generating public/private rsa key pair.<br>Enter file in which to save the key (/home/huqiu/.ssh/id_rsa):<br></code></pre></td></tr></table></figure><p>你可以输入你想要的文件名，这里我们输入<code>test</code>。</p><h4 id="密码"><a href="#密码" class="headerlink" title="密码"></a>密码</h4><p>之后，会询问你是否需要输入密码。输入密码之后，以后每次都要输入密码。请根据你的安全需要决定是否需要密码，如果不需要，直接回车:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ssh-keygen -t rsa -f <span class="hljs-built_in">test</span> -C <span class="hljs-string">&quot;test key&quot;</span><br>Generating public/private rsa key pair.<br>Enter passphrase (empty <span class="hljs-keyword">for</span> no passphrase):<br>Enter same passphrase again:<br></code></pre></td></tr></table></figure><h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><p>如果文件名是<code>test</code>，结果是:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ll <span class="hljs-built_in">test</span>*<br>-rw------- 1 username username 1675 Sep 15 13:24 <span class="hljs-built_in">test</span><br>-rw-r--r-- 1 username username  390 Sep 15 13:24 test.pub<br></code></pre></td></tr></table></figure><h4 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h4><p>上面生成的命令中，<code>-C</code>选项是公钥文件中的备注:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ cat test.pub<br>ssh-rsa<br>。。。。省略。。。。== <span class="hljs-built_in">test</span> key<br>                 ~~~~备注<br></code></pre></td></tr></table></figure><h4 id="文件的权限"><a href="#文件的权限" class="headerlink" title="文件的权限"></a>文件的权限</h4><p>为了让私钥文件和公钥文件能够在认证中起作用，请确保权限正确。</p><p>对于<code>.ssh</code> 以及父文件夹，当前用户用户一定要有执行权限，其他用户最多只能有执行权限。</p><p>对于公钥和私钥文件也是: 当前用户一定要有执行权限，其他用户最多只能有执行权限。</p><blockquote><p>对于利用公钥登录，对其他用户配置执行权限是没有问题的。但是对于git，公钥和私钥, 以及config等相关文件的权限，其他用户不可有任何权限。</p></blockquote><h2 id="实践步骤2：把公钥内容复制到服务器的认证列表中"><a href="#实践步骤2：把公钥内容复制到服务器的认证列表中" class="headerlink" title="实践步骤2：把公钥内容复制到服务器的认证列表中"></a>实践步骤2：把公钥内容复制到服务器的认证列表中</h2><p>这里读者可能又有三个问题。</p><h4 id="第一，什么是服务器认证列表？"><a href="#第一，什么是服务器认证列表？" class="headerlink" title="第一，什么是服务器认证列表？"></a>第一，什么是服务器认证列表？</h4><p>服务器认证列表是一个文件，可以理解为&lt;存储用户SSH公钥的地方&gt;，因为SSH是一个验证过程，所以服务器需要事先保存对方的公钥，这样管理员就可以指定哪些用户(准确说是密钥对)可以登录了。</p><h4 id="第二，认证列表的路径是什么？"><a href="#第二，认证列表的路径是什么？" class="headerlink" title="第二，认证列表的路径是什么？"></a>第二，认证列表的路径是什么？</h4><p>在服务器的配置文件<code>/etc/ssh/sshd_config</code>中记录的着认证列表的目录。</p><p>首先, 我们可以先进入服务器(若没有设置SSH登陆只能用密码登陆)，然后进入此路径查看：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">cd <span class="hljs-regexp">/etc/</span>ssh<br>cat sshd_config<br></code></pre></td></tr></table></figure><p>sshd_config文件示例：</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs vala">。。。省略<br><br><span class="hljs-meta">#LoginGraceTime 2m</span><br><span class="hljs-meta"># 登录宽限期</span><br>PermitRootLogin no<br><span class="hljs-meta">#PermitRootLogin值改为 prohibit-password 允许root登录，但是禁止root用密码登录。允许root登录，设为yes。不允许root登录，设为no。</span><br><span class="hljs-meta">#StrictModes yes</span><br><span class="hljs-meta"># 严格模式</span><br><span class="hljs-meta">#MaxAuthTries 6</span><br><span class="hljs-meta"># 最大验证次数</span><br><span class="hljs-meta">#MaxSessions 10</span><br><span class="hljs-meta"># 最大会话数</span><br><br><span class="hljs-meta"># PubkeyAuthentication yes</span><br><span class="hljs-meta"># 公钥认证</span><br><br><span class="hljs-meta"># The default is to check both .ssh/authorized_keys and .ssh/authorized_keys2</span><br><span class="hljs-meta"># but this is overridden so installations will only check .ssh/authorized_keys</span><br><span class="hljs-meta"># 默认是同时检查 .ssh/authorized_keys 和 .ssh/authorized_keys2</span><br><span class="hljs-meta"># 但这是被覆盖的，所以安装只会检查 .ssh/authorized_keys</span><br><br><br>AuthorizedKeysFile      .ssh/authorized_keys # 注意这一句！！！（<span class="hljs-number">1</span>）<br><br><br><span class="hljs-meta"># To disable tunneled clear text passwords, change to no here!</span><br><span class="hljs-meta"># 要禁用明文密码，请在此处更改为 no！</span><br>PasswordAuthentication no<br><span class="hljs-meta"># no是禁止用户密码登陆</span><br><span class="hljs-meta">#PermitEmptyPasswords no</span><br><span class="hljs-meta">#yes允许空密码 no不允许空密码</span><br><br>。。。省略<br></code></pre></td></tr></table></figure><p>（1）即<code>~/.ssh/authorized_keys</code>(注意，此文件不一定存在)</p><h4 id="第三，如何把公钥复制进认证列表？"><a href="#第三，如何把公钥复制进认证列表？" class="headerlink" title="第三，如何把公钥复制进认证列表？"></a>第三，如何把公钥复制进认证列表？</h4><p>首先，认证列表文件不一定存在，所以我们要先在远程服务器上执行创建命令, 并设置权限：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">mkdir .ssh  <span class="hljs-comment">//创建文件夹</span><br>touch .ssh/authorized_keys  <span class="hljs-comment">// 创建文件</span><br>chmod <span class="hljs-number">700</span> .ssh      <span class="hljs-comment">//设置权限</span><br>chmod <span class="hljs-number">644</span> .ssh/auauthorized_keys  <span class="hljs-comment">//设置权限</span><br></code></pre></td></tr></table></figure><p>然后用<code>nano</code>编辑器打开:</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">nano ~<span class="hljs-regexp">/.ssh/</span>authorized_keys<br></code></pre></td></tr></table></figure><p>如果没设置过SSH的公钥，里面内容是为空的。如果设置过SSH公钥，则空行添加公钥。</p><p>最后把实践步骤1中生成的公钥内容复制粘贴到里面。可以采用文本打开复制，也可以用<code>nano</code>编辑器复制。这里演示方式为<code>nano</code>打开复制：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsx">nano ~<span class="hljs-regexp">/.ssh/</span>MyLinux.pub<br></code></pre></td></tr></table></figure><p>运行后复制粘贴到远程服务器的认证列表中退出保存即可：</p><p>这样我们就可以用SSH登陆了。</p><h2 id="实践步骤3：SSH远程连接Linux服务器"><a href="#实践步骤3：SSH远程连接Linux服务器" class="headerlink" title="实践步骤3：SSH远程连接Linux服务器"></a>实践步骤3：SSH远程连接Linux服务器</h2><p>一切设置都已完成，我们如何连接到远程服务器呢？<br> 命令格式如下：</p><p>1首先开启ssh <strong><code>systemctl start sshd</code>开启<code>sshd</code>服务</strong></p><p>2连接命令格式如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">ssh student<span class="hljs-keyword">@127</span>.0.0.1 -p <span class="hljs-number">2222</span> -i ~/.ssh/MyLinux<br></code></pre></td></tr></table></figure><p><img src="TyporaRaw/SSH%E4%BD%BF%E7%94%A8.assets/990.jpeg" alt="img"></p><ul><li>1表示ssh连接</li><li>2表示服务器上的用户名</li><li>3表示远程主机的host IP(这里是本机)</li><li>4表示远程主机端口(默认22，<a href="https://link.jianshu.com/?t=https://www.vagrantup.com/docs/getting-started/">vagrant</a>采用2222, 本文不讨论)</li><li>5表示用户私钥</li></ul><p>然后输入该密钥对的管理密码即可连接服务器。</p><h2 id="实践步骤4：设置只许SSH登录不可密码登陆"><a href="#实践步骤4：设置只许SSH登录不可密码登陆" class="headerlink" title="实践步骤4：设置只许SSH登录不可密码登陆"></a>实践步骤4：设置只许SSH登录不可密码登陆</h2><p>最终我们的目的是消除密码登陆这一留给黑客的安全隐患，而只采用用SSH登陆，故我们在服务器配置文件<code>/etc/ssh/sshd_config</code>里小小的设置一下即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">nano /etc/ssh/sshd_config<br></code></pre></td></tr></table></figure><p>把其中的<code>PasswordAuthentication</code>中的yes改成no就不可再用密码登陆了。</p><h2 id="ssh配置文件"><a href="#ssh配置文件" class="headerlink" title="ssh配置文件"></a>ssh配置文件</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle">* ssh-server配置文件位于<span class="hljs-regexp">/etc/</span>ssh/sshd_config，在这里可以定义SSH的服务端口，默认端口是<span class="hljs-number">22</span><br>* 作为服务端，~<span class="hljs-regexp">/.ssh/</span>authorized_keys文件中<br>* ssh会把你每个你访问过计算机的公钥(<span class="hljs-keyword">public</span> key)都记录在~<span class="hljs-regexp">/.ssh/</span>known_hosts<br></code></pre></td></tr></table></figure><ul><li><p><strong>home/.ssh/.config</strong></p><p>这个文件里可以管理ssh连接，不同的主机使用不同的密钥，例如：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># gitee</span><br>Host gitee.com<br>HostName gitee.com<br>PreferredAuthentications publickey<br>IdentityFile ~<span class="hljs-regexp">/.ssh/gi</span>tee_id_rsa<br><span class="hljs-comment"># github</span><br>Host github.com<br>HostName github.com<br>PreferredAuthentications publickey<br>IdentityFile ~<span class="hljs-regexp">/.ssh/i</span>d_rsa<br></code></pre></td></tr></table></figure></li><li><p><strong>authorized_keys</strong></p></li></ul><p>我们需要本地机器ssh访问远程服务器时为了减少输入密码的步骤，基本上都会在本地机器生成ssh公钥，然后将本地ssh公钥复制到远程服务器的<code>.ssh/authorized_keys</code>中，这样就可以免密登录了。（ 服务器之间访问同理）。<br>流程如下</p><pre><code>本机生成 ssh公钥；复制本机公钥到远程服务器.ssh/authorized_keys中，authorized_keys文件不存在则创建；本机直接ssh连接远程；结束</code></pre><ul><li><strong>known_hosts</strong></li></ul><p>第一次连接远程数据库时我们可以发现我们本地的.ssh/目录下多了一个文件<code>known_hosts</code>，里面有我们刚刚连接的服务器的信息（如果以前就存在<code>known_hosts</code>，则会发现多了刚刚连接的服务器的信息）。<br><code>known_hosts</code>文件每连接一个新的远程服务器都会产生一份数据，如下：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">0.0.0.0</span> ecdsa-sha2-nistp256 AAAA...........=<br></code></pre></td></tr></table></figure><p>包括远程机器<code>ip</code>、远程机器公钥<br><code>known_hosts</code>有什么用？<br>手动修改一下远程机器A的密钥，然后再连接远程机器A，提示：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vbnet">The authenticity <span class="hljs-keyword">of</span> host <span class="hljs-comment">&#x27;0.0.0.0 (0.0.0.0)&#x27; can&#x27;t be established.</span><br>ECDSA <span class="hljs-keyword">key</span> fingerprint <span class="hljs-built_in">is</span> SHA256:xxxxxxxx.<br>Are you sure you want <span class="hljs-keyword">to</span> <span class="hljs-keyword">continue</span> connecting (yes/no)?<br></code></pre></td></tr></table></figure><p>得到类似这种提示，大概意思就是登录远程机器A验证失败，然后向你确定是否需要继续连接。<br>known_hosts的作用就很明显了，known_hosts的作用就是记录你曾经远程连接过的机器信息。如果远程机器信息不变，则直接连接，如果改变了ssh就会问你一下，小子，你还连不连了？<br>如果你yes， 他就重新保存一份到known_hosts文件了。</p><ul><li>总结一下： 1. authorized_keys由本地主机生成，多用于放在远程主机实现免密登录 2. known_hosts放在本地主机，用来记录连接过的远程主机</li></ul>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>ssh</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git常用</title>
    <link href="/posts/d6fdba1b/"/>
    <url>/posts/d6fdba1b/</url>
    
    <content type="html"><![CDATA[<h2 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h2><p>安装完成后，还需要配置git，在命令行输入：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs verilog">$ git <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> user<span class="hljs-variable">.name</span> <span class="hljs-string">&quot;Your Name&quot;</span><br>$ git <span class="hljs-keyword">config</span> --<span class="hljs-keyword">global</span> user<span class="hljs-variable">.email</span> <span class="hljs-string">&quot;email@example.com&quot;</span><br></code></pre></td></tr></table></figure><p>Git 使用一系列配置文件来保存你自定义的行为。 它首先会查找系统级的 <code>/etc/gitconfig</code> 文件，该文件含有系统里每位用户及他们所拥有的仓库的配置值。 如果你传递 <code>--system</code> 选项给 <code>git config</code>，它就会读写该文件。</p><p>接下来 Git 会查找每个用户的 <code>~/.gitconfig</code> 文件（或者 <code>~/.config/git/config</code> 文件）。 你可以传递 <code>--global</code> 选项让 Git 读写该文件。</p><p>最后 Git 会查找你正在操作的仓库所对应的 Git 目录下的配置文件（<code>.git/config</code>）。 这个文件中的值只对该仓库有效，它对应于向 <code>git config</code> 传递 <code>--local</code> 选项。</p><p>以上三个层次中每层的配置（系统、全局、本地）都会覆盖掉上一层次的配置，所以 <code>.git/config</code> 中的值会覆盖掉 <code>/etc/gitconfig</code> 中所对应的值。</p><ul><li><p>注</p><p>注意<code>git config</code>命令的<code>--global</code>参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p><p>Git 的配置文件是纯文本的，所以你可以直接手动编辑这些配置文件，输入合乎语法的值。 但是运行 <code>git config</code> 命令会更简单些。</p></li></ul><h3 id="配置ssh"><a href="#配置ssh" class="headerlink" title="配置ssh"></a>配置ssh</h3><p>第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有<code>id_rsa</code>和<code>id_rsa.pub</code>这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>ssh-keygen -t rsa -C <span class="hljs-string">&quot;youremail@example.com&quot;</span><br></code></pre></td></tr></table></figure><p>你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。</p><p>如果一切顺利的话，可以在用户主目录里找到<code>.ssh</code>目录，里面有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，这两个就是SSH Key的秘钥对，<code>id_rsa</code>是私钥，不能泄露出去，<code>id_rsa.pub</code>是公钥，可以放心地告诉任何人。</p><p>第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：</p><p>然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴<code>id_rsa.pub</code>文件的内容。</p><p>使用下面命令</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Swift">ssh <span class="hljs-operator">-</span><span class="hljs-type">T</span> git<span class="hljs-meta">@github</span>.com<br></code></pre></td></tr></table></figure><p>测试是否配置成功</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">Hi RoninLee! You<span class="hljs-symbol">&#x27;ve</span> successfully authenticated, but GitHub does <span class="hljs-keyword">not</span> provide shell <span class="hljs-keyword">access</span>.<br></code></pre></td></tr></table></figure><p>出现这样一段话，即证明配置成功。</p><h2 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h2><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">git</span>@github.com:Knightwood/Aplayer.git <span class="hljs-comment">#克隆项目</span><br>git <span class="hljs-keyword">clone</span> <span class="hljs-title">-b</span> <span class="hljs-tag">&lt;分支名称&gt;</span> git@github.com:Knightwood/Aplayer.git <span class="hljs-comment">#克隆特定的分支</span><br></code></pre></td></tr></table></figure><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">git <span class="hljs-keyword">branch </span><span class="hljs-comment"># 查看分支</span><br>git <span class="hljs-keyword">branch </span>&lt;分支名称&gt; <span class="hljs-comment">#创建新分支</span><br>git checkout -<span class="hljs-keyword">b </span>&lt;分支名称&gt; <span class="hljs-comment">#创建新分支并切换到新分支</span><br>git checkout &lt;分支名称&gt; <span class="hljs-comment">#切换到新的分支</span><br>git <span class="hljs-keyword">branch </span>-r <span class="hljs-comment">#查看远程分支</span><br>git <span class="hljs-keyword">branch </span>-a <span class="hljs-comment">#查看所有分支</span><br>git push <span class="hljs-keyword">origin </span>[<span class="hljs-keyword">branch </span>name] <span class="hljs-comment">#将新分支推送到github</span><br>git <span class="hljs-keyword">branch </span>-d [<span class="hljs-keyword">branch </span>name] <span class="hljs-comment">#删除本地分支</span><br>git push <span class="hljs-keyword">origin </span>:[<span class="hljs-keyword">branch </span>name] <span class="hljs-comment">#删除github远程分支</span><br></code></pre></td></tr></table></figure><h2 id="提交代码"><a href="#提交代码" class="headerlink" title="提交代码"></a>提交代码</h2><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">git <span class="hljs-built_in">add</span> all <span class="hljs-comment">#可以提交未跟踪、修改和删除文件（无论在哪个目录执行都会提交相应文件）</span><br>git <span class="hljs-built_in">add</span> . <span class="hljs-comment">#可以提交未跟踪和修改文件，但是不处理删除文件（只能够提交当前目录或者它后代目录下相应文件）</span><br><span class="hljs-comment">-----</span><br>git commit <span class="hljs-comment">#提交代码</span><br>git commit -m <span class="hljs-string">&quot;add my code to new branchB&quot;</span> <span class="hljs-comment"># -m 参数：可以直接在后面添加提交信息。</span><br>git push origin [branch name] <span class="hljs-comment">#push 到git仓库</span><br>git commit -<span class="hljs-keyword">a</span> -m <span class="hljs-string">&#x27;合并module&#x27;</span> <span class="hljs-comment"># -a 把所有未暂存的提交.-m 附带了题解信息</span><br></code></pre></td></tr></table></figure><h2 id="删除历史版本，保留当前状态"><a href="#删除历史版本，保留当前状态" class="headerlink" title="删除历史版本，保留当前状态"></a>删除历史版本，保留当前状态</h2><blockquote><p>有时候，我们误提交了某些隐私文件，使用<code>git rm xxx</code>删除后，其实版本库中是有历史记录的，想要删除这些记录，但是又不想删除仓库，重建来提交。那么就想办法删除历史记录了。<br>我们当然不能直接删除.git文件夹，这将导致git存储库出现不可预知的问题。<br>要删除所有提交历史记录，但将代码保持在当前状态，可以按照以下方式安全地执行此操作：</p></blockquote><ol><li><p>创建并切换到<code>latest_branch</code>分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout --orphan latest_branch 创建orphan分支，名为latest_branch<br>注：<br>如果不提交东西，这个分支实际上没有创建<br></code></pre></td></tr></table></figure></li><li><p>添加所有文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add -A<br></code></pre></td></tr></table></figure></li><li><p>提交更改</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git commit -am <span class="hljs-string">&quot;删除历史版本记录，初始化仓库&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>删除分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch -D master<br></code></pre></td></tr></table></figure></li><li><p>将当前分支重命名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch -m master<br></code></pre></td></tr></table></figure></li><li><p>强制更新存储库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push -f origin master<br></code></pre></td></tr></table></figure></li></ol><p><em>解决方案来自：<a href="https://cloud.tencent.com/developer/ask/30403/answer/39134">如何删除GitHub中的所有提交历史记录？</a></em></p><ul><li><p>git checkout –orphan的核心用途是在非新存储库上以类似git init的状态创建分支。</p><p>没有这种能力，您所有的git分支都将有一个共同的祖先，即您的初始提交。这是很常见的情况，但绝不是唯一的情况。例如，git允许您将多个独立项目作为单个存储库中的不同分支进行跟踪。</p><p>这就是为什么您的文件被报告为”要提交的更改”的原因：在git init状态下，尚未创建第一个提交，因此所有文件都是git新的。</p><p>用途：例如GitHub Pages，将存储库的网站存储在存储库中但位于单独的分支上。除了该网站的历史记录外，没有任何其他原因可以存储该分支机构。</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>manjaro常用命令</title>
    <link href="/posts/bc52529d/"/>
    <url>/posts/bc52529d/</url>
    
    <content type="html"><![CDATA[<h3 id="常规配置"><a href="#常规配置" class="headerlink" title="常规配置"></a>常规配置</h3><h4 id="软件源"><a href="#软件源" class="headerlink" title="软件源"></a>软件源</h4><p>配置中国的镜像</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gauss">sudo pacman-mirrors -g  <span class="hljs-meta"># 排列源，可不执行</span><br>sudo pacman-mirrors -c China -m <span class="hljs-built_in">rank</span> <span class="hljs-meta"># 更改源，在跳出的对话框里选择想要的源</span><br></code></pre></td></tr></table></figure><p>同步并更新系统：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo pacman -Syyu</span><br></code></pre></td></tr></table></figure><h4 id="pacman常用命令"><a href="#pacman常用命令" class="headerlink" title="pacman常用命令"></a>pacman常用命令</h4><h5 id="更新系统"><a href="#更新系统" class="headerlink" title="更新系统"></a>更新系统</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">sudo</span> <span class="hljs-string">pacman</span> <span class="hljs-string">-Syu</span>    <span class="hljs-comment">#对整个系统进行更新</span><br><span class="hljs-string">sudo</span> <span class="hljs-string">acman</span> <span class="hljs-string">-Syy</span>        <span class="hljs-comment">#强制更新</span><br><span class="hljs-string">sudo</span> <span class="hljs-string">acman</span> <span class="hljs-string">-Syudd</span>    <span class="hljs-comment">#  使用 -dd跳过所有检测</span><br><span class="hljs-attr">sudo acman -Sy:</span> <span class="hljs-string">从服务器下载新的软件包数据库（实际上就是下载远程仓库最新软件列表到本地）。</span><br><span class="hljs-attr">sudo acman -Su:</span> <span class="hljs-string">升级所有已安装的软件包。</span><br><span class="hljs-attr">sudo acman -Syyu:</span> <span class="hljs-string">更新软件库并更新系统</span><br></code></pre></td></tr></table></figure><h5 id="搜索包"><a href="#搜索包" class="headerlink" title="搜索包"></a>搜索包</h5><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs ceylon">pacman 使用 -Q 参数查询本地软件包数据库， -S 查询同步数据库，以及 -F查询文件数据库。<br><br>pacman -Ss keyword在仓库中搜索含关键字的包，查询位置包含了软件包的名字和描述<br>有时，-s的内置正则会匹配很多不需要的结果，所以应当指定仅搜索包名，而非描述或其他子段: <br>pacman -Ss <span class="hljs-string">&#x27;^vim-&#x27;</span><br><br><br>pacman -Sl &lt;repo&gt;:<br>显示软件仓库中所有软件的列表<br>    可以省略，通常这样用:pacman -Sl | 关键字<br><br>pacman -Qs keyword搜索已安装的包（常用）<br>pacman -Qu: 列出所有可升级的软件包<br>pacman -Qt: 列出不被任何软件要求的软件包<br><br>pacman -Q 软件名: 查看软件包是否已安装，已安装则显示软件包名称和版本<br>pacman -Qi <span class="hljs-keyword">package</span><span class="hljs-number">_n</span>ame查询本地安装包的详细信息<br>pacman -Ql <span class="hljs-keyword">package</span><span class="hljs-number">_n</span>ame列出该包的文件<br>pacman -F string<span class="hljs-number">1</span> string<span class="hljs-number">2</span> ... 按文件名查找软件库：<br>pacman -Si <span class="hljs-keyword">package</span><span class="hljs-number">_n</span>ame显示远程软件包的详尽的信息<br>pacman -Qii <span class="hljs-keyword">package</span><span class="hljs-number">_n</span>ame使用两个 -i 将同时显示备份文件和修改状态<br>pacman -Ql <span class="hljs-keyword">package</span><span class="hljs-number">_n</span>ame要获取已安装软件包所包含文件的列表<br>pacman -Fl <span class="hljs-keyword">package</span><span class="hljs-number">_n</span>ame查询远程库中软件包包含的文件<br>pacman -Qk <span class="hljs-keyword">package</span><span class="hljs-number">_n</span>ame检查软件包安装的文件是否都存在<br>pacman -Fo /path/to/file<span class="hljs-number">_n</span>ame查询文件属于远程数据库中的哪个软件包<br>pacman -Qdt要罗列所有不再作为依赖的软件包(孤立orphans)<br>pacman -Qet要罗列所有明确安装而且不被其它包依赖的软件包<br><br>pacman -Sg: 列出软件仓库上所有的软件包组<br>pacman -Qg: 列出本地已经安装的软件包组和子包（pacman -Qg 软件包组: 和pacman -Sg 软件包组完全一样）<br></code></pre></td></tr></table></figure><h5 id="软件依赖"><a href="#软件依赖" class="headerlink" title="软件依赖"></a>软件依赖</h5><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ceylon">pactree <span class="hljs-keyword">package</span><span class="hljs-number">_n</span>ame要显示软件包的依赖树<br>whoneeds <span class="hljs-keyword">package</span><span class="hljs-number">_n</span>ame检查一个安装的软件包被那些包依赖pkgtoolsAUR中的whoneeds<br>pactree -r <span class="hljs-keyword">package</span><span class="hljs-number">_n</span>ame检查一个安装的软件包被那些包依赖<br></code></pre></td></tr></table></figure><h5 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h5><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">pacman -S package_name执行 pacman -S firefox 将安装 Firefox（常用）你也可以同时安装多个包，只需以空格分隔包名即<br>pacman -S --needed 软件名<span class="hljs-number">1</span> 软件名<span class="hljs-number">2</span>: 安装软件，但不重新安装已经是最新的软件。<br>pacman -Sy package_name与上面命令不同的是，该命令将在同步包数据库后再执行安装。<br>pacman -Sv package_name在显示一些操作信息后执行安装。<br>pacman -Sw 软件名: 只下载软件包，不安装。<br>pacman -U local_package_name安装本地包，其扩展名为pkg.tar.gz或pkg.tar.xz<br>pacman -U url安装一个远程包（不在 pacman 配置的源里面）例：pacman -U http:<span class="hljs-regexp">//</span>www.example.com<span class="hljs-regexp">/repo/</span>example.pkg.tar.xz<br></code></pre></td></tr></table></figure><h5 id="卸载软件"><a href="#卸载软件" class="headerlink" title="卸载软件"></a>卸载软件</h5><figure class="highlight ldif"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ldif"><span class="hljs-attribute">pacman -R 软件名</span>: 该命令将只删除包，保留其全部已经安装的依赖关系<br><span class="hljs-attribute">pacman -Rv 软件名</span>: 删除软件，并显示详细的信息<br><span class="hljs-attribute">pacman -Rs 软件名</span>: 删除软件，同时删除本机上只有该软件依赖的软件。<br><span class="hljs-attribute">pacman -Rsc 软件名</span>: 删除软件，并删除所有依赖这个软件的程序，慎用<br><span class="hljs-attribute">pacman -Ru 软件名</span>: 删除软件,同时删除不再被任何软件所需要的依赖<br></code></pre></td></tr></table></figure><h5 id="清理缓存"><a href="#清理缓存" class="headerlink" title="清理缓存"></a>清理缓存</h5><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">pacman -Sc 清理未安装的包文件，包文件位于 <span class="hljs-regexp">/var/</span>cache<span class="hljs-regexp">/pacman/</span>pkg/ 目录。<br><br>pacman -Scc 要删除缓存中的全部文件，使用两次-c开关。这是最为激进的方式，将会清空缓存文件夹。<br>注： 应当避免从缓存中删除所有过去版本和卸载的包，除非需要更多磁盘空间。这样会导致无法降级或重新安装包而不再次下载他们<br></code></pre></td></tr></table></figure><h4 id="yay"><a href="#yay" class="headerlink" title="yay"></a>yay</h4><p>Yay 是用 Go 编写的 Arch Linux AUR 包管理工具。AUR 的全称是 Arch User Repository，是  Arch Linux/Manjaro 用户的社区驱动存储库，创建 AUR 的目的是使共享社区包的过程更容易和有条理。使用它可以在 Arch  Linux/Manjaro 系统中安装和更新软件包。这个软件仓库的软件包是相当丰富，可以查看这个网站的统计<a href="https://repology.org/repositories/statistics/total">Repository statistics</a>，它的软件列表可以在<a href="https://aur.archlinux.org/packages/">Archlinux AUR</a>查看。具体可以查看 Arch Wiki</p><blockquote><p>注意：很多教程比较老了，yaourt 目前已经停止维护，用户可以考虑迁移到 aurman 或 yay</p></blockquote><p><strong>安装 yay：</strong></p><p>配置 yay 的 aur 源为清华源 AUR 镜像：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">yay <span class="hljs-params">--aururl</span> <span class="hljs-string">&quot;https://aur.tuna.tsinghua.edu.cn&quot;</span> <span class="hljs-params">--save</span><br></code></pre></td></tr></table></figure><p>修改的配置文件位于 ~/.config/yay/config.json ，还可通过以下命令查看修改过的配置:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">yay -<span class="hljs-selector-tag">P</span> -g<br></code></pre></td></tr></table></figure><p>yay 的常用命令：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs haxe">yay -S <span class="hljs-keyword">package</span> <span class="hljs-meta"># 从 AUR 安装软件包</span><br>yay -Rns <span class="hljs-keyword">package</span> <span class="hljs-meta"># 删除包</span><br>yay -Syu <span class="hljs-meta"># 升级所有已安装的包</span><br>yay -Ps <span class="hljs-meta"># 打印系统统计信息</span><br>yay -Qi <span class="hljs-keyword">package</span> <span class="hljs-meta"># 检查安装的版本</span><br>yay 安装命令不需要加 sudo。<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>manjaro</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pacman包管理</title>
    <link href="/posts/dd409eba/"/>
    <url>/posts/dd409eba/</url>
    
    <content type="html"><![CDATA[<h1 id="pacman包管理"><a href="#pacman包管理" class="headerlink" title="pacman包管理"></a>pacman包管理</h1><h4 id="安装指定的包"><a href="#安装指定的包" class="headerlink" title="安装指定的包"></a>安装指定的包</h4><p>安装或者升级单个软件包，或者一列软件包（包含依赖包），使用如下命令：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-attr"># pacman -S package_name1</span> package_<span class="hljs-symbol">name2</span> ...<br></code></pre></td></tr></table></figure><p>用正则表达式安装多个软件包（参见 <a href="https://bbs.archlinux.org/viewtopic.php?id=7179">这个帖子</a>）：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"># pacman -S <span class="hljs-constructor">$(<span class="hljs-params">pacman</span> -Ssq <span class="hljs-params">package_regex</span>)</span><br></code></pre></td></tr></table></figure><p>有时候在不同的软件仓库中，一个软件包有多个版本（比如[extra]和[testing]）。可以选择一个来安装：</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># pacman -S extra/package_name</span><br></code></pre></td></tr></table></figure><p>安装多个含有相似名称的软件包，而并非整个包组或全部匹配的软件包； 例如，<a href="https://archlinux.org/groups/x86_64/plasma/">plasma</a>:</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># pacman -S plasma-&#123;desktop,mediacenter,nm&#125;</span><br></code></pre></td></tr></table></figure><p>当然，可以多层扩展，并不作限制：</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># pacman -S plasma-&#123;workspace&#123;,-wallpapers&#125;,pa&#125;</span><br></code></pre></td></tr></table></figure><h5 id="虚包"><a href="#虚包" class="headerlink" title="虚包"></a>虚包</h5><p>虚拟软件包是一个特殊的软件包，它本身并不存在，但由一或多个其它软件包提供。虚拟软件包允许其它软件包不以某一个特定的包为依赖，以应对有多个候选的情况。虚包不能用它们的名称安装，相反它们会在你安装<em>提供</em>虚包的软件包时被安装到你的系统中。</p><h4 id="安装包组"><a href="#安装包组" class="headerlink" title="安装包组"></a>安装包组</h4><p>一些包属于一个可以同时安装的<a href="https://wiki.archlinux.org/index.php/Meta_package_and_package_group_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">软件包组</a>。例如，运行下面的命令</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># pacman -S gnome</span><br></code></pre></td></tr></table></figure><p>会提醒用户选择 <code>gnome</code> 内需要安装的包。</p><p>有的包组包含大量的软件包，有时用户只需其中几个。除了逐一键入序号外，pacman 还支持选择或排除某个区间内的的软件包：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Enter</span> a selection (default=<span class="hljs-literal">all</span>): <span class="hljs-number">1</span>-<span class="hljs-number">10</span> <span class="hljs-number">15</span><br></code></pre></td></tr></table></figure><p>这将选中序号 1 至 10 和 15 的软件包。而</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Enter</span> a selection (default=<span class="hljs-literal">all</span>): ^<span class="hljs-number">5</span>-<span class="hljs-number">8</span> ^<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>将会选中除了序号 5 至 8 和 2 之外的所有软件包。</p><p>想要查看哪些包属于 gnome 组，运行：</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># pacman -Sg gnome</span><br></code></pre></td></tr></table></figure><p>也可以访问 <a href="https://archlinux.org/groups/">https://archlinux.org/groups/</a> 查看可用的包组。</p><p><strong>注意：</strong> 如果列表中的包已经安装在系统中，它会被重新安装，即使它已经是最新的。可以用 <code>--needed</code> 选项覆盖这种行为。</p><h3 id="删除软件包"><a href="#删除软件包" class="headerlink" title="删除软件包"></a>删除软件包</h3><p>删除单个软件包，保留其全部已经安装的依赖关系</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># pacman -R package_name</span><br></code></pre></td></tr></table></figure><p>删除指定软件包，及其所有没有被其他已安装软件包使用的依赖关系：</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># pacman -Rs package_name</span><br></code></pre></td></tr></table></figure><p>上面这条命令在移除包含其他所需包的组时有时候会拒绝运行。这种情况下可以尝试</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># pacman -Rsu package_name</span><br></code></pre></td></tr></table></figure><p>要删除软件包和所有依赖这个软件包的程序:</p><p><strong>警告：</strong> 此操作是递归的，请小心检查，可能会一次删除大量的软件包。</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># pacman -Rsc package_name</span><br></code></pre></td></tr></table></figure><p>要删除一个被其他软件包依赖的软件包，但是不删除依赖这个软件包的其他软件包：</p><p><strong>警告：</strong> 此操作有破坏系统的能力，应该尽量避免使用。详情请看 <a href="https://wiki.archlinux.org/index.php/System_maintenance#Avoid_certain_pacman_commands">避免某些 Pacman 命令</a>。</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># pacman -Rdd package_name</span><br></code></pre></td></tr></table></figure><p><em>pacman</em> 删除某些程序时会备份重要配置文件，在其后面加上*.pacsave扩展名。-n 选项可以避免备份这些文件：</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ceylon">pacman -Rn <span class="hljs-keyword">package</span><span class="hljs-number">_n</span>ame<br></code></pre></td></tr></table></figure><p><strong>注意：</strong> <em>pacman</em> 不会删除软件自己创建的文件（例如主目录中的“点文件”不会被删除。）</p><h3 id="升级软件包"><a href="#升级软件包" class="headerlink" title="升级软件包"></a>升级软件包</h3><p><strong>警告：</strong></p><ul><li>建议用户遵守<a href="https://wiki.archlinux.org/index.php/System_maintenance_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E6%9B%B4%E6%96%B0%E7%B3%BB%E7%BB%9F">System maintenance (简体中文)#更新系统</a>的指导，定期更新系统，并不盲目地执行这些命令。</li><li>Arch 只支持系统完整升级，详细参见<a href="https://wiki.archlinux.org/index.php/System_maintenance_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E4%B8%8D%E6%94%AF%E6%8C%81%E9%83%A8%E5%88%86%E5%8D%87%E7%BA%A7">System maintenance (简体中文)#不支持部分升级</a>和<a href="https://wiki.archlinux.org/index.php/Pacman_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E5%8C%85">#安装软件包</a>。</li></ul><p>一个 <em>pacman</em> 命令就可以升级整个系统。花费的时间取决于系统有多老。这个命令会同步非本地(local)软件仓库并升级系统的软件包：</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># pacman -Syu</span><br></code></pre></td></tr></table></figure><h3 id="查询包数据库"><a href="#查询包数据库" class="headerlink" title="查询包数据库"></a>查询包数据库</h3><p><em>pacman</em> 使用 <code>-Q</code> 参数查询本地软件包数据库， <code>-S</code> 查询同步数据库，以及 <code>-F</code>查询文件数据库。要了解每个参数的子选项，分别参见 <a href="https://wiki.archlinux.org/index.php?title=Template:Pacman_-Q_--help&action=edit&redlink=1">Template:Pacman -Q –help</a>，<a href="https://wiki.archlinux.org/index.php?title=Template:Pacman_-S_--help&action=edit&redlink=1">Template:Pacman -S –help</a>和<a href="https://wiki.archlinux.org/index.php?title=Template:Pacman_-F_--help&action=edit&redlink=1">Template:Pacman -F –help</a>。</p><p><em>pacman</em> 可以在包数据库中查询软件包，查询位置包含了软件包的名字和描述：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">$ pacman -Ss <span class="hljs-built_in">string</span>1 <span class="hljs-built_in">string</span>2 ...<br></code></pre></td></tr></table></figure><p>有时，<code>-s</code>的内置正则会匹配很多不需要的结果，所以应当指定仅搜索包名，而非描述或其他子段:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>pacman -Ss <span class="hljs-string">&#x27;^vim-&#x27;</span><br></code></pre></td></tr></table></figure><p>要查询已安装的软件包：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">$ pacman -Qs <span class="hljs-built_in">string</span>1 <span class="hljs-built_in">string</span>2 ...<br></code></pre></td></tr></table></figure><p>按文件名查找软件库：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">$ pacman -F <span class="hljs-built_in">string</span>1 <span class="hljs-built_in">string</span>2 ...<br></code></pre></td></tr></table></figure><p>显示软件包的详尽的信息：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>pacman -Si package_name<br></code></pre></td></tr></table></figure><p>查询本地安装包的详细信息：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>pacman -Qi package_name<br></code></pre></td></tr></table></figure><p>使用两个 <code>-i</code> 将同时显示备份文件和修改状态：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>pacman -Qii package_name<br></code></pre></td></tr></table></figure><p>要获取已安装软件包所包含文件的列表：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>pacman -Ql package_name<br></code></pre></td></tr></table></figure><p>查询远程库中软件包包含的文件：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>pacman -Fl package_name<br></code></pre></td></tr></table></figure><p>检查软件包安装的文件是否都存在：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>pacman -Qk package_name<br></code></pre></td></tr></table></figure><p>两个参数<code>k</code>将会执行一次更彻底的检查。 查询数据库获取某个文件属于哪个软件包：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ pacman -Qo <span class="hljs-regexp">/path/</span>to/file_name<br></code></pre></td></tr></table></figure><p>查询文件属于远程数据库中的哪个软件包：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ pacman -F <span class="hljs-regexp">/path/</span>to/file_name<br></code></pre></td></tr></table></figure><p>要罗列所有不再作为依赖的软件包(孤立orphans)：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>pacman -Qdt<br></code></pre></td></tr></table></figure><p><strong>提示：</strong> 将上述命令添加到 pacman 的一个处理后 <a href="https://wiki.archlinux.org/index.php/Pacman_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#Hooks">hook</a>用于在如果有处理产生孤立包后获得提示。这在当有软件包被仓库放弃时是有用的，因为任何被抛弃的包都会成为本地的一个孤立包（除非它是被显式安装的）。要避免在没有找到孤立包时”failed to execute command”的错误，在你的 hook 中为<code>Exec</code>使用如下的指令: <code>/usr/bin/bash -c &quot;/usr/bin/pacman -Qtd || /usr/bin/echo &#39;=&gt; None found.&#39;&quot;</code></p><p>要罗列所有明确安装而且不被其它包依赖的软件包：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>pacman -Qet<br></code></pre></td></tr></table></figure><p>更多例子查看<a href="https://wiki.archlinux.org/index.php/Pacman_tips">pacman tips</a>。</p><h4 id="Pactree"><a href="#Pactree" class="headerlink" title="Pactree"></a>Pactree</h4><p><strong>注意：</strong> <a href="https://man.archlinux.org/man/pactree.8">pactree(8)</a>不再是<a href="https://archlinux.org/packages/?name=pacman">pacman</a>的一部分。它现在在<a href="https://archlinux.org/packages/?name=pacman-contrib">pacman-contrib</a>中。</p><p>要显示软件包的依赖树：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>pactree package_name<br></code></pre></td></tr></table></figure><p>检查一个<em>安装</em>的软件包被那些包依赖，将递归标识<code>-r</code>传递给 <em>pactree</em>，或者使用 <a href="https://aur.archlinux.org/packages/pkgtools/">pkgtools</a>AUR中的<em>whoneeds</em></p><h4 id="数据库结构"><a href="#数据库结构" class="headerlink" title="数据库结构"></a>数据库结构</h4><p>pacman数据库通常位于 <code>/var/lib/pacman/sync</code>. 对于每一个在<code>/etc/pacman.conf</code>中指定的软件仓库， 这里都有一个一致的数据库。数据库文件夹里每个tar.gz文件都包含着一个仓库的软件包信息。例如<a href="https://archlinux.org/packages/?name=which">which</a> 包:</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">$ tree which<span class="hljs-string">-2</span>.21<span class="hljs-string">-5</span><br>which<span class="hljs-string">-2</span>.21<span class="hljs-string">-5</span><br>|-- desc<br></code></pre></td></tr></table></figure><p>这个 <code>depends</code> 项列出了该软件的依赖包， 而<code>desc</code>有该包的介绍，例如文件大小和MD5值 。</p><h3 id="清理软件包缓存"><a href="#清理软件包缓存" class="headerlink" title="清理软件包缓存"></a>清理软件包缓存</h3><p><em>pacman</em> 将下载的软件包保存在 <code>/var/cache/pacman/pkg/</code> 并且不会自动移除旧的和未安装版本的软件包。这样做有一些好处：</p><ol><li>这样允许<a href="https://wiki.archlinux.org/index.php/Downgrading_packages_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">降级</a>软件包而不需要通过其他方式提取旧版本，例如 <a href="https://wiki.archlinux.org/index.php/Arch_Linux_Archive_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">Arch Linux Archive</a>.</li><li>被卸载的软件包可以轻易地直接从缓存文件夹重新安装，不需要重新从软件仓库下载。</li></ol><p>然而，需要定期手动清理缓存来避免该文件夹无限制增大。</p><p><a href="https://archlinux.org/packages/?name=pacman-contrib">pacman-contrib</a> 提供的 <a href="https://man.archlinux.org/man/paccache.8">paccache(8)</a> 脚本默认会删除所有缓存的版本和已卸载的软件包，除了最近的3个会被保留：</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># paccache -r</span><br></code></pre></td></tr></table></figure><p><a href="https://wiki.archlinux.org/index.php/Enable">启用</a> 和 <a href="https://wiki.archlinux.org/index.php/Start">启动</a> <code>paccache.timer</code>来每周删除不使用的包。</p><p><strong>提示：</strong> 可以使用 <a href="https://wiki.archlinux.org/index.php/Pacman_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#Hooks">hook</a> 自动执行清理，参考[<a href="https://bbs.archlinux.org/viewtopic.php?pid=1694743#p1694743">1]</a>和<a href="https://aur.archlinux.org/packages/pacman-cleanup-hook/">pacman-cleanup-hook</a>AUR。</p><p>也可以自己设置保留最近几个版本：</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># paccache -rk1</span><br></code></pre></td></tr></table></figure><p>添加<code>-u</code>/<code>--uninstalled</code>开关来限制<em>paccache</em>的行为只作用于卸载的包。例如清理所有卸载的包的缓存版本，可以用以下命令:</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># paccache -ruk0</span><br></code></pre></td></tr></table></figure><p>或者你可以将安装其结合，同时作用于安装的和卸载的包，例如想要保留最近两个安装的包但是移除所有卸载的包的缓存版本，使用以下命令：</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># paccache -rk2 -ruk0</span><br></code></pre></td></tr></table></figure><p>更多参数参见<code>paccache -h</code>。</p><p><em>pacman</em>也有一些内建参数用于清除缓存和那些不再在<code>/etc/pacman.conf</code>配置文件中列出的软件仓库残留数据库文件。然而<em>pacman</em>并不提供保留一定数量的过去版本的功能，因此它比<em>paccache</em>的默认选项更加激进。</p><p>要删除目前没有安装的所有缓存的包，和没有被使用的同步数据库，执行：</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># pacman -Sc</span><br></code></pre></td></tr></table></figure><p>要删除缓存中的全部文件，使用两次<code>-c</code>开关。这是最为激进的方式，将会清空缓存文件夹：</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># pacman -Scc</span><br></code></pre></td></tr></table></figure><p><strong>警告：</strong> 应当避免从缓存中删除所有过去版本和卸载的包，除非需要更多磁盘空间。这样会导致无法降级或重新安装包而不再次下载他们</p><p><a href="https://aur.archlinux.org/packages/pkgcacheclean/">pkgcacheclean</a>AUR以及<a href="https://aur.archlinux.org/packages/pacleaner/">pacleaner</a>AUR是两个进一步清理缓存的替代工具</p><h3 id="其它命令"><a href="#其它命令" class="headerlink" title="其它命令"></a>其它命令</h3><p>升级系统时安装其他软件包：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-attr"># pacman -Syu package_name1</span> package_<span class="hljs-symbol">name2</span> ...<br></code></pre></td></tr></table></figure><p>下载包而不安装它：</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># pacman -Sw package_name</span><br></code></pre></td></tr></table></figure><p>安装一个<strong>本地</strong>包(不从源里下载）：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"># pacman -U <span class="hljs-regexp">/path/</span>to<span class="hljs-regexp">/package/</span>package_name-version.pkg.tar.xz<br></code></pre></td></tr></table></figure><p>要将本地包保存至缓存，可执行：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"># pacman -U file:///<span class="hljs-type">path</span>/<span class="hljs-keyword">to</span>/package/package_name-<span class="hljs-keyword">version</span>.pkg.tar.xz<br></code></pre></td></tr></table></figure><p>安装一个<strong>远程</strong>包（不在 <em>pacman</em> 配置的源里面）：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta"># pacman -U http:<span class="hljs-comment">//www.example.com/repo/example.pkg.tar.xz</span></span><br></code></pre></td></tr></table></figure><p>要禁用 <code>-S</code>, <code>-U</code> 和 <code>-R</code> 动作，可以使用 <code>-p</code> 选项.</p><p><em>pacman</em> 会列出需要安装和删除的软件，并在执行动作前要求需要的权限。</p><h3 id="安装原因"><a href="#安装原因" class="headerlink" title="安装原因"></a>安装原因</h3><p><em>pacman</em>数据库按照软件包被安装的原因，将其分为两类：</p><ul><li><strong>显式安装</strong>：那些真正地被传递给通用<em>pacman</em><code>-S</code>和<code>-U</code>命令的包；</li><li><strong>依赖</strong>：那些虽然（一般）从未被传递给<em>pacman</em>安装命令，但由于被其它显式安装的包<a href="https://wiki.archlinux.org/index.php/Dependency">需要</a>从而被隐式安装的包</li></ul><p>当安装软件包时，可以把安装原因强制设为<strong>依赖</strong>:</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># pacman -S --asdeps package_name</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong> 用<code>--asdeps</code>安装可选依赖将导致如果你<a href="https://wiki.archlinux.org/index.php/Pacman/Tips_and_tricks#Removing_unused_packages_.28orphans.29">移除孤立包</a>，<em>pacman</em>将会一同移除剩下的可选依赖。</p><p>但是当重新安装该软件包时，安装原因将会被设为软件包所默认的。</p><p>显式安装的软件包列表可用<code>pacman -Qe</code>获取, 与之互补的已安装的依赖包可用<code>pacman -Qd</code>获取。</p><p>改变某个已安装软件包的安装原因，可以执行：</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># pacman -D --asdeps package_name</span><br></code></pre></td></tr></table></figure><p><strong>注意：</strong> 在升级时使用<code>--asdeps</code>和<code>--asexplicit</code>选项，例如<code>pacman -Syu *package_name* --asdeps</code>，是不被推荐的。这会导致不仅改变要被安装的软件包的安装原因，也会改变被升级的软件包的安装原因。</p><h3 id="查询一个包含具体文件的包名"><a href="#查询一个包含具体文件的包名" class="headerlink" title="查询一个包含具体文件的包名"></a>查询一个包含具体文件的包名</h3><p>同步文件数据库:</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># pacman -Fy</span><br></code></pre></td></tr></table></figure><p>查询包含某个文件的包名，比如:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># pacman -F pacman</span><br>core/pacman <span class="hljs-number">5.0</span>.<span class="hljs-number">1</span>-<span class="hljs-number">4</span><br>    usr<span class="hljs-regexp">/bin/</span>pacman<br>    usr<span class="hljs-regexp">/share/</span>bash-completion<span class="hljs-regexp">/completions/</span>pacman<br>extra/xscreensaver <span class="hljs-number">5.36</span>-<span class="hljs-number">1</span><br>    usr<span class="hljs-regexp">/lib/</span>xscreensaver/pacman<br></code></pre></td></tr></table></figure><p><strong>提示：</strong>  可以设置一个 <code>crontab</code> 或者 <code>systemd timer</code> 来定期同步文件信息数据库。</p><p>如果需要高级功能请安装 <a href="https://wiki.archlinux.org/index.php/Pkgfile">pkgfile</a>，它使用一个单独的数据库来保存文件和它们所关联的软件包的信息。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p><em>pacman</em> 的配置文件位于<code>/etc/pacman.conf</code>。 <a href="https://archlinux.org/pacman/pacman.conf.5.html">man pacman.conf</a> 可以查看配置文件的进一步信息。</p><h3 id="通用选项"><a href="#通用选项" class="headerlink" title="通用选项"></a>通用选项</h3><p>通用选项都在<code>[options]</code>段。阅读 man 手册或者查看默认的 pacman.conf 可以获得有关信息和用法。</p><h3 id="升级前对比版本"><a href="#升级前对比版本" class="headerlink" title="升级前对比版本"></a>升级前对比版本</h3><p>要查看旧版和新版的有效安装包，请取消<code>/etc/pacman.conf</code>中”VerbosePkgLists”的注释。修改后的<code>pacman -Syu</code>输出如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Package</span> (<span class="hljs-number">6</span>)             Old Version  New Version  Net Change  Download Size<br><br><span class="hljs-attribute">extra</span>/libmariadbclient  <span class="hljs-number">10</span>.<span class="hljs-number">1</span>.<span class="hljs-number">9</span>-<span class="hljs-number">4</span>     <span class="hljs-number">10</span>.<span class="hljs-number">1</span>.<span class="hljs-number">10</span>-<span class="hljs-number">1</span>      <span class="hljs-number">0</span>.<span class="hljs-number">03</span> MiB       <span class="hljs-number">4</span>.<span class="hljs-number">35</span> MiB<br><span class="hljs-attribute">extra</span>/libpng            <span class="hljs-number">1</span>.<span class="hljs-number">6</span>.<span class="hljs-number">19</span>-<span class="hljs-number">1</span>     <span class="hljs-number">1</span>.<span class="hljs-number">6</span>.<span class="hljs-number">20</span>-<span class="hljs-number">1</span>       <span class="hljs-number">0</span>.<span class="hljs-number">00</span> MiB       <span class="hljs-number">0</span>.<span class="hljs-number">23</span> MiB<br><span class="hljs-attribute">extra</span>/mariadb           <span class="hljs-number">10</span>.<span class="hljs-number">1</span>.<span class="hljs-number">9</span>-<span class="hljs-number">4</span>     <span class="hljs-number">10</span>.<span class="hljs-number">1</span>.<span class="hljs-number">10</span>-<span class="hljs-number">1</span>      <span class="hljs-number">0</span>.<span class="hljs-number">26</span> MiB      <span class="hljs-number">13</span>.<span class="hljs-number">80</span> MiB<br></code></pre></td></tr></table></figure><h4 id="在升级时跳过软件包"><a href="#在升级时跳过软件包" class="headerlink" title="在升级时跳过软件包"></a>在升级时跳过软件包</h4><p><strong>警告：</strong> 在跳过软件包时要小心，因为<a href="https://wiki.archlinux.org/index.php/System_maintenance_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E4%B8%8D%E6%94%AF%E6%8C%81%E9%83%A8%E5%88%86%E5%8D%87%E7%BA%A7">部分升级不受支持</a></p><p>要想在<a href="https://wiki.archlinux.org/index.php/Pacman_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E5%8D%87%E7%BA%A7%E8%BD%AF%E4%BB%B6%E5%8C%85">升级</a>系统时跳过特定的软件包，用像如下的命令指明：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">IgnorePkg</span>=linux<br></code></pre></td></tr></table></figure><p>多软件包可以用空格隔开，或者用另外的<code>IgnorePkg</code>行。也可使用 <a href="https://en.wikipedia.org/wiki/glob_(programming)">glob</a> 模式。如果只打算忽略一次升级，可以使用 <code>--ignore</code> 选项，这时使用逗号隔开的列表。</p><p>忽略了的软件包依然可通过 <code>pacman -S</code> 升级。这种情况下<em>pacman</em>会提醒你这些软件包已经被包含在<code>IgnorePkg</code>声明中。</p><h4 id="在升级时跳过软件包组"><a href="#在升级时跳过软件包组" class="headerlink" title="在升级时跳过软件包组"></a>在升级时跳过软件包组</h4><p><strong>警告：</strong> 在跳过软件包时要小心，因为<a href="https://wiki.archlinux.org/index.php/System_maintenance_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E4%B8%8D%E6%94%AF%E6%8C%81%E9%83%A8%E5%88%86%E5%8D%87%E7%BA%A7">部分升级不受支持</a></p><p>和软件包一样，也可以不升级某个软件包组：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">IgnoreGroup</span> = gnome<br></code></pre></td></tr></table></figure><h4 id="在升级时跳过文件"><a href="#在升级时跳过文件" class="headerlink" title="在升级时跳过文件"></a>在升级时跳过文件</h4><p>所有在<code>NoUpgrade</code>指令中列出的文件都会在软件包被安装/升级时不会被更改，并且新文件会以带有*.pacnew*后缀名的形式安装</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">NoUpgrade=path<span class="hljs-regexp">/to/</span><span class="hljs-keyword">file</span><br></code></pre></td></tr></table></figure><p><strong>注意：</strong> 这个路径指软件包中的文件，所以不要包括开头的斜线。</p><h4 id="在安装时跳过文件"><a href="#在安装时跳过文件" class="headerlink" title="在安装时跳过文件"></a>在安装时跳过文件</h4><p>要总是跳过某些文件夹的安装，可以将它们放到 <code>NoExtract</code> 中，例如不想安装 <a href="https://wiki.archlinux.org/index.php/Systemd">systemd</a> 模块：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">NoExtract=usr<span class="hljs-regexp">/lib/</span>systemd<span class="hljs-regexp">/system/</span>*<br></code></pre></td></tr></table></figure><p>后面的规则覆盖前面的规则，加上 <code>!</code> 可以取消跳过效果。</p><p><strong>提示：</strong> <em>pacman</em>会在更新locales已经被<em>localepurge</em>或者<em>bleachbit</em>清除的包时发出警告。将<code>CheckSpace</code>参数加入<code>pacman.conf</code>能够抑制这种警告，但是要意识到space-check功能将会对所有软件包禁用。</p><h3 id="保留多个配置文件"><a href="#保留多个配置文件" class="headerlink" title="保留多个配置文件"></a>保留多个配置文件</h3><p>如果你有多个配置文件（比如，主配置和启用了<a href="https://wiki.archlinux.org/index.php/Official_repositories_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#testing_%E4%BB%93%E5%BA%93">测试仓库</a>的配置文件），需要共享一些设置，你可以在配置文件中使用<code>Include</code>选项，例如：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">Include</span> = <span class="hljs-regexp">/path/</span>to<span class="hljs-regexp">/common/</span>settings<br></code></pre></td></tr></table></figure><p><code>*/path/to/common/settings*</code>文件中是两个配置文件共享的相同配置。</p><h3 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h3><p><em>pacman</em>可以在处理前后，运行<code>/usr/share/libalpm/hooks/</code>文件夹下的hooks，更多的hooks文件夹可以通过<code>HooDir</code>选项在<code>pacman.conf</code>中指明，默认<code>/etc/pacman.d/hooks</code>。Hook文件必须以*.hook*为后缀。Pacman hooks不是交互式的。</p><p><em>pacman</em> hooks用于，比如说，和<code>systemd-sysusers</code>和<code>systemd-tmpfiles</code>结合来在安装包时自动创建系统用户和文件。例如，<a href="https://archlinux.org/packages/?name=tomcat8">tomcat8</a>指明它想要创建一个叫做<code>tomcat8</code>的系统用户和一些属于该用户的文件。当<em>pacman</em>确定<a href="https://archlinux.org/packages/?name=tomcat8">tomcat8</a>包含文件指明用户和临时文件时，<em>pacman</em> hooks <code>systemd-sysusers.hook</code>和<code>systemd-tmpfiles.hook</code>唤起<code>systemd-sysusers</code>和<code>systemd-tmpfiles</code>。</p><p>有关 alpm hooks 的更多信息，参见<a href="https://man.archlinux.org/man/alpm-hooks.5">alpm-hooks(5)</a>。</p><h3 id="软件仓库"><a href="#软件仓库" class="headerlink" title="软件仓库"></a>软件仓库</h3><p>除了特殊的<a href="https://wiki.archlinux.org/index.php/Pacman_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E9%80%9A%E7%94%A8%E9%80%89%E9%A1%B9">通用选项</a>节, 每个<code>pacman.conf</code>中的<code>[section]</code>都定义了一个使用的软件包仓库，<em>仓库</em>是多个软件包的<em>逻辑</em>上的集合，他们<em>物理</em>上存储在一个或多个服务器：这也是为什么每一个服务器都叫做这个仓库的<em>镜像</em>。</p><p>仓库区分为<a href="https://wiki.archlinux.org/index.php/Official_repositories_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">官方仓库</a>与<a href="https://wiki.archlinux.org/index.php/Unofficial_user_repositories_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">非官方仓库</a>。配置文件中仓库的顺序十分重要；当几个仓库出现同名安装包，不管版本号如何，<em>pacman</em>将使用配置文件中排前的仓库。要在添加后使用某个仓库，你需要先<a href="https://wiki.archlinux.org/index.php/Pacman_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)#%E5%8D%87%E7%BA%A7%E8%BD%AF%E4%BB%B6%E5%8C%85">升级</a>整个系统</p><p>每个仓库节都可以直接指定镜像列表或者<code>Include</code>引用其他的文件：例如，官方镜像引用了<code>/etc/pacman.d/mirrorlist/</code>。具体查看<a href="https://wiki.archlinux.org/index.php/Mirrors_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">Mirrors (简体中文)</a>。</p><h3 id="软件包的安全性"><a href="#软件包的安全性" class="headerlink" title="软件包的安全性"></a>软件包的安全性</h3><p><em>pacman</em> 支持软件包签名，会为软件包提供额外的安全性。默认配置，<code>SigLevel = Required DatabaseOptional</code> 将启用全局签名验证，但会被每个软件仓库的 <code>SigLevel</code> 行所覆盖。有关软件包签名和签名验证的更多细节，参见 <a href="https://wiki.archlinux.org/index.php/Pacman-key_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">pacman-key</a>。</p><hr><h2 id="Manjaro包管理常用命令"><a href="#Manjaro包管理常用命令" class="headerlink" title="Manjaro包管理常用命令"></a>Manjaro包管理常用命令</h2><ul><li>对整个系统进行更新</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo pacman -Syu   <br></code></pre></td></tr></table></figure><ul><li>升级软件包</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo pacman -Syu<br></code></pre></td></tr></table></figure><ul><li>安装或者升级单个软件包，或者一列软件包（包含依赖包），使用如下命令：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo pacman -S package_name1 package_name2 ...<br></code></pre></td></tr></table></figure><ul><li>与上面命令不同的是，该命令将在同步包数据库后再执行安装</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo pacman -Sy package_name<br></code></pre></td></tr></table></figure><ul><li>安装本地包</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo pacman -U local_package_name#其扩展名为pkg.tar.gz或pkg.tar.xz<br></code></pre></td></tr></table></figure><ul><li>安装一个远程包</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo pacman -U url#不在 pacman 配置的源里面，例：pacman -U http://www.example.com/repo/example.pkg.tar.xz<br></code></pre></td></tr></table></figure><ul><li>在仓库中搜索含关键字的包</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo pacman -Ss keyword<br></code></pre></td></tr></table></figure><ul><li>查看已安装软件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo pacman -Qs keyword     <br></code></pre></td></tr></table></figure><ul><li>删除单个软件包，保留其全部已经安装的依赖关系</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo pacman -R package_name<br></code></pre></td></tr></table></figure><ul><li>删除指定软件包，及其所有没有被其他已安装软件包使用的依赖关系：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo pacman -Rs package_name#要删除软件包和所有依赖这个软件包的程序，警告: 此操作是递归的，请小心检查，可能会一次删除大量的软件包。<br></code></pre></td></tr></table></figure><ul><li>清理软件包缓存</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo pacman -Sc<br></code></pre></td></tr></table></figure><ul><li>清理所有的缓存文件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo pacman -Scc<br></code></pre></td></tr></table></figure><ul><li>清除系统中无用的包</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo pacman -R $(pacman -Qdtq)<br></code></pre></td></tr></table></figure><ul><li><strong>从 AUR 安装软件包</strong>  </li><li>yay 安装命令不需要加 sudo</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">yay -S package <br></code></pre></td></tr></table></figure><ul><li>yay删除包</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">yay -Rns package <br></code></pre></td></tr></table></figure><ul><li>升级所有已安装的包</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">yay -Syu<br></code></pre></td></tr></table></figure><ul><li>打印系统统计信息</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">yay -Ps<br></code></pre></td></tr></table></figure><ul><li>检查安装的版本</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">yay -Qi package<br></code></pre></td></tr></table></figure><hr><h1 id="AUR国内源"><a href="#AUR国内源" class="headerlink" title="AUR国内源"></a>AUR国内源</h1><p>笔者在写这篇文章的时候，网上的资料并不多。毕竟选择Arch的用户较少，而选择<strong>Yay</strong>的用户更少。<strong>Yay</strong>默认使用法国的aur.archlinux.org作为AUR源，这样的速度显然不是我们可以接受的，因此我们需要切换为国内的tuna源</p><p><strong>Yay</strong>在安装好以后是默认不生成配置文件的。这就难以去更改默认源。笔者搜罗GIthub上的issue，根据 <a href="https://github.com/Jguer/yay/issues/697">#697</a> Issue，运行以下命令更新软件源和系统，顺便创建配置文件</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">yay</span> <span class="hljs-literal">-</span><span class="hljs-comment">Syu</span> --<span class="hljs-comment">devel</span> --<span class="hljs-comment">combinedupgrade</span> --<span class="hljs-comment">save</span><br></code></pre></td></tr></table></figure><p>然后编辑<code>~/.config/yay/config.json</code>文件，就可以看到熟悉的aururl参数啦，那么把它替换为<code>https://aur.tuna.tsinghua.edu.cn</code>即可</p><hr><h1 id="yay命令"><a href="#yay命令" class="headerlink" title="yay命令"></a>yay命令</h1><table><thead><tr><th align="left"><code>yay &lt;Search Term&gt;</code></th><th>Present package-installation selection menu.</th></tr></thead><tbody><tr><td align="left"><code>yay -Ps</code></td><td>Print system statistics.</td></tr><tr><td align="left"><code>yay -Yc</code></td><td>Clean unneeded dependencies.</td></tr><tr><td align="left"><code>yay -G &lt;AUR Package&gt;</code></td><td>Download PKGBUILD from ABS or AUR.</td></tr><tr><td align="left"><code>yay -Y --gendb</code></td><td>Generate development package database used for devel update.</td></tr><tr><td align="left"><code>yay -Syu --devel --timeupdate</code></td><td>Perform system upgrade, but also check for development package  updates and use PKGBUILD modification time (not version number) to  determine update.</td></tr></tbody></table><p>使用 yay：</p><p>搜索：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">yay -Ss &lt;package-name&gt;<br></code></pre></td></tr></table></figure><p>安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">yay -S &lt;package-name&gt;<br></code></pre></td></tr></table></figure><hr><h1 id="有关yay的基本用法，请参阅下面的示例。"><a href="#有关yay的基本用法，请参阅下面的示例。" class="headerlink" title="有关yay的基本用法，请参阅下面的示例。"></a>有关yay的基本用法，请参阅下面的示例。</h1><p>示例1：使用yay安装包</p><p>使用选项-S使用yay从AUR安装软件包：</p><p>$ yay -S package</p><p>示例2：使用yay删除包</p><p>要删除包，请使用-Rns选项：</p><p>$ yay -Rns package</p><p>示例3：启动包选择菜单</p><p>使用：</p><p>$ yay <Search Term></p><p>示例4：使用yay升级已安装的软件包</p><p>要升级所有已安装的包，请使用以下选项：</p><p>$ yay -Syu</p><p> 要包含开发包，请使用：</p><p>$ yay -Syu –devel –timeupdate</p><p>示例5：使用yay清除不需要的依赖项</p><p>使用选项可删除系统上所有不需要的依赖项：</p><p>$ yay -Yc</p><p>示例6：使用yay打印系统统计信息</p><p>要打印系统统计信息，请使用-Ps：</p><p>$ yay -Ps</p><p>示例7：生成用于开发更新的开发包DB</p><p>$ yay -Y –gendb</p><p>至此，yay基本使用方法就讲到这了。</p><hr><h1 id="snap"><a href="#snap" class="headerlink" title="snap"></a>snap</h1><h3 id="如何使用snap"><a href="#如何使用snap" class="headerlink" title="如何使用snap"></a>如何使用snap</h3><p>列出计算机上所有snap安装情况：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo snap list</span><br></code></pre></td></tr></table></figure><p>在应用商店中查找snap：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo snap <span class="hljs-builtin-name">find</span> &lt;软件包名&gt;<br></code></pre></td></tr></table></figure><p>安装Snap软件：</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bnf">sudo snap install <span class="hljs-attribute">&lt;snap软件包名&gt;</span><br></code></pre></td></tr></table></figure><p>更新Snap软件：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">sudo snap <span class="hljs-built_in">ref</span>resh &lt;snap软件包名&gt;<br></code></pre></td></tr></table></figure><p>更新所有的snap软件包：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">sudo snap <span class="hljs-keyword">refresh</span> <span class="hljs-keyword">all</span><br></code></pre></td></tr></table></figure><p>要将Snap还原到以前安装的版本：</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bnf">sudo snap revert <span class="hljs-attribute">&lt;snap软件包名&gt;</span><br></code></pre></td></tr></table></figure><p>卸载snap软件：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo snap <span class="hljs-builtin-name">remove</span> &lt;snap软件包名&gt;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>pacman</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ohmyzsh整理</title>
    <link href="/posts/f46218d0/"/>
    <url>/posts/f46218d0/</url>
    
    <content type="html"><![CDATA[<h1 id="手动安装"><a href="#手动安装" class="headerlink" title="手动安装"></a>手动安装</h1><h2 id="github"><a href="#github" class="headerlink" title="github"></a>github</h2><p><code>https://github.com/ohmyzsh/ohmyzsh</code></p><h3 id="1-克隆仓库"><a href="#1-克隆仓库" class="headerlink" title="1 克隆仓库"></a>1 克隆仓库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://github.com/ohmyzsh/ohmyzsh.git ~/.oh-my-zsh<br>或者<br>git clone git@github.com:ohmyzsh/ohmyzsh.git ~/.oh-my-zsh<br></code></pre></td></tr></table></figure><h3 id="2-将原来的～-zshrc备份"><a href="#2-将原来的～-zshrc备份" class="headerlink" title="2 将原来的～/.zshrc备份"></a>2 将原来的<code>～/.zshrc</code>备份</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp ~/.zshrc ~/.zshrc.bak<br></code></pre></td></tr></table></figure><h3 id="3-用新的zsh配置文件"><a href="#3-用新的zsh配置文件" class="headerlink" title="3 用新的zsh配置文件"></a>3 用新的zsh配置文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc<br></code></pre></td></tr></table></figure><h3 id="4-使得zsh变成默认的shell"><a href="#4-使得zsh变成默认的shell" class="headerlink" title="4 使得zsh变成默认的shell"></a>4 使得zsh变成默认的shell</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">nano .bashrc<br>在第一行添加<br>zsh<br></code></pre></td></tr></table></figure><h2 id="5-配置文件"><a href="#5-配置文件" class="headerlink" title="5 配置文件"></a>5 配置文件</h2><p>zsh的配置文件存在当前用户目录中的.zshrc文件，如果你发现切换了shell之后，以前的配置的环境变量不生效了，可以打开 .zshrc文件，找到：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># User configuration</span><br><span class="hljs-built_in">source</span> ~/.bash_profile<br></code></pre></td></tr></table></figure><p>指定配置的环境变量文件，之后运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> .zshrc<br></code></pre></td></tr></table></figure><h1 id="设置主题"><a href="#设置主题" class="headerlink" title="设置主题"></a>设置主题</h1><h2 id="设置固定主题"><a href="#设置固定主题" class="headerlink" title="设置固定主题"></a>设置固定主题</h2><ul><li><strong>安装完毕后，我们就可以使用了，先来简单配置一下，Oh My Zsh 提供了很多主题风格，我们可以根据自己的喜好，设置主题风格</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">open ~/.zshrc<br><br><span class="hljs-comment"># 找到 ZSH_THEME</span><br><span class="hljs-comment"># robbyrussell 是默认的主题</span><br>ZSH_THEME=<span class="hljs-string">&quot;robbyrussell&quot;</span><br><br><span class="hljs-comment"># ZSH_THEME=&quot;样式名称&quot; </span><br></code></pre></td></tr></table></figure><ul><li>保存这个文件文件，重新打开终端。</li></ul><h2 id="设置随机主题"><a href="#设置随机主题" class="headerlink" title="设置随机主题"></a>设置随机主题</h2><ul><li><strong>我们还可以随机设置主题：</strong></li><li>步骤同上</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ZSH_THEME=<span class="hljs-string">&quot;random&quot;</span><br></code></pre></td></tr></table></figure><ul><li>每次打开终端主题是随机的。</li><li>终端输出：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">[oh-my-zsh] Random theme <span class="hljs-string">&#x27;/Users/xxxx/.oh-my-zsh/themes/zhann.zsh-theme&#x27;</span> loaded...<br></code></pre></td></tr></table></figure><ul><li>其中 <strong>zhann.zsh-theme</strong> 是主题的名称， 有喜欢的童鞋可以记录保留.</li></ul><h2 id="查看主题名称"><a href="#查看主题名称" class="headerlink" title="查看主题名称"></a>查看主题名称</h2><ul><li><strong>Oh My Zsh</strong> 默认自带了一些默认主题，存放在 <strong>~/.oh-my-zsh/themes</strong> 目录中。我们可以查看这些主题</li><li>终端输入：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/.oh-my-zsh/themes &amp;&amp; ls<br></code></pre></td></tr></table></figure><h2 id="卸载-Oh-My-Zsh"><a href="#卸载-Oh-My-Zsh" class="headerlink" title="卸载 Oh My Zsh"></a>卸载 Oh My Zsh</h2><ul><li>终端输入 ：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">uninstall_oh_my_zsh<br>Are you sure you want to remove Oh My Zsh? [y/N]  Y<br></code></pre></td></tr></table></figure><ul><li>终端提示信息：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">Removing ~/.oh-my-zsh<br>Looking <span class="hljs-keyword">for</span> original zsh config...<br>Found ~/.zshrc.pre-oh-my-zsh -- Restoring to ~/.zshrc<br>Found ~/.zshrc -- Renaming to ~/.zshrc.omz-uninstalled-20170820200007<br>Your original zsh config was restored. Please restart your session.<br>Thanks <span class="hljs-keyword">for</span> trying out Oh My Zsh. It<span class="hljs-string">&#x27;s been uninstalled.</span><br></code></pre></td></tr></table></figure><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><h3 id="manjaro自带插件"><a href="#manjaro自带插件" class="headerlink" title="manjaro自带插件"></a>manjaro自带插件</h3><p>自己下载的插件放在<code>/home/kiylx/.oh-my-zsh/custom/plugins/</code></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vim">位置/usr/share/zsh/plugins/<br>一共三个<br>zsh-autosuggestions<br>zsh-<span class="hljs-keyword">history</span>-substring-<span class="hljs-built_in">search</span><br>zsh-<span class="hljs-keyword">syntax</span>-highlighting<br><br><span class="hljs-keyword">ps</span>：<br><span class="hljs-number">1</span>.其中zsh-<span class="hljs-keyword">history</span>-substring-<span class="hljs-built_in">search</span>是ohmyzsh自带的，只是名称不同，是<span class="hljs-keyword">history</span>-substring-<span class="hljs-built_in">search</span>。<br><span class="hljs-number">2</span>.zsh-<span class="hljs-keyword">syntax</span>-highligting必须排最后一个<br></code></pre></td></tr></table></figure><h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><p>这个是装好<a href="https://link.zhihu.com/?target=http://ohmyz.sh/">oh-my-zsh</a>就默认已经开启的</p><p>查看所有的git命令<a href="https://link.zhihu.com/?target=http://man.linuxde.net/alias?oqnsle=octhb">alias</a></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">~<span class="hljs-regexp">/.oh-my-zsh/</span>plugins<span class="hljs-regexp">/git/gi</span>t.plugin.zsh<br></code></pre></td></tr></table></figure><h3 id="z"><a href="#z" class="headerlink" title="z"></a>z</h3><p>这个是oh-my-zsh默认就装好的，需要自己开启。还有一个<code>autojump</code>的插件和<code>z</code>功能差不多，<code>autojump</code>需要单独装，</p><p>如果z插件历史记录太多，并且有一些不是自己想要的，可以删除</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">z -<span class="hljs-keyword">x</span> 不要的路径<br></code></pre></td></tr></table></figure><h3 id="auto-suggestions"><a href="#auto-suggestions" class="headerlink" title="auto-suggestions"></a>auto-suggestions</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions<br></code></pre></td></tr></table></figure><h3 id="zsh-syntax-highligting"><a href="#zsh-syntax-highligting" class="headerlink" title="zsh-syntax-highligting"></a>zsh-syntax-highligting</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $ZSH_CUSTOM/plugins/zsh-syntax-highlighting<br></code></pre></td></tr></table></figure><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-meta">## git open 插件</span><br>$ git <span class="hljs-keyword">open</span><br><span class="hljs-meta"># opens https:<span class="hljs-comment">//github.com/TRACKED_REMOTE_USER/CURRENT_REPO/tree/CURRENT_BRANCH</span></span><br><br>$ git <span class="hljs-keyword">open</span> someremote<br><span class="hljs-meta"># opens https:<span class="hljs-comment">//github.com/PROVIDED_REMOTE_USER/CURRENT_REPO/tree/CURRENT_BRANCH</span></span><br><br>$ git <span class="hljs-keyword">open</span> someremote somebranch<br><span class="hljs-meta"># opens https:<span class="hljs-comment">//github.com/PROVIDED_REMOTE_USER/CURRENT_REPO/tree/PROVIDED_BRANCH</span></span><br><br>$ git <span class="hljs-keyword">open</span> --issue<br><span class="hljs-meta"># If branches use naming convention of issues/#123,</span><br><span class="hljs-meta"># opens https:<span class="hljs-comment">//github.com/TRACKED_REMOTE_USER/CURRENT_REPO/issues/123</span></span><br><br>$ git <span class="hljs-keyword">open</span> --<span class="hljs-keyword">print</span><br><span class="hljs-meta"># prints https:<span class="hljs-comment">//github.com/TRACKED_REMOTE_USER/CURRENT_REPO/tree/CURRENT_BRANCH</span></span><br><br>$ git <span class="hljs-keyword">open</span> --suffix pulls<br><span class="hljs-meta"># opens https:<span class="hljs-comment">//github.com/TRACKED_REMOTE_USER/CURRENT_REPO/pulls</span></span><br><br></code></pre></td></tr></table></figure><hr><h3 id="thefuck修正命令"><a href="#thefuck修正命令" class="headerlink" title="thefuck修正命令"></a>thefuck修正命令</h3><p><a href="https://github.com/nvbn/thefuck#manual-installation">github</a></p><ul><li>安装thefuck  使用python的pip</li></ul><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pip <span class="hljs-keyword">install</span> thefuck<br></code></pre></td></tr></table></figure><ul><li><p>配置</p><p>在<code>.bash_profile</code>, <code>.bashrc</code>, <code>.zshrc</code> or 其他启动脚本文件中添加</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">eval</span> $(thefuck --<span class="hljs-built_in">alias</span>)<br><span class="hljs-comment"># You can use whatever you want as an alias, like for Mondays:</span><br><span class="hljs-comment"># 你可以使用其他名称替代默认的别名，比如：</span><br><span class="hljs-built_in">eval</span> $(thefuck --<span class="hljs-built_in">alias</span> FUCK)<br></code></pre></td></tr></table></figure><p>让配置立即生效，需要重启终端，，或者，输入<code>source ~/.bashrc</code> (或者你的shell配置文件名称 <code>.zshrc</code>).</p></li></ul><h2 id="修改～-zshrc文件"><a href="#修改～-zshrc文件" class="headerlink" title="修改～/.zshrc文件"></a>修改～/.zshrc文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">例子<br>plugins=(<br>git <br>pip<br>extract <br>z <br>wd<br>auto-suggestions<br>zsh-syntax-highligting<br>auto-jumplast-working-dir<br>)<br><br>ZSH_THEME=&quot;robbyrussell&quot;<br></code></pre></td></tr></table></figure><p>如果想要启用某个插件，装好之后直接修改<br>plugins = (插件A 插件B 插件C)<br>git<br>这个是装好<a href="https://link.zhihu.com/?target=http://ohmyz.sh/">oh-my-zsh</a>就默认已经开启的<br>查看所有的git命令<a href="https://link.zhihu.com/?target=http://man.linuxde.net/alias?oqnsle=octhb">alias</a><br>~/.oh-my-zsh/plugins/git/git.plugin.zsh<br>z<br>这个是oh-my-zsh默认就装好的，需要自己开启。还有一个<code>autojump</code>的插件和<code>z</code>功能差不多，<code>autojump</code>需要单独装，<br>如果z插件历史记录太多，并且有一些不是自己想要的，可以删除<br>z -x 不要的路径</p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>终端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件整理</title>
    <link href="/posts/c43f5235/"/>
    <url>/posts/c43f5235/</url>
    
    <content type="html"><![CDATA[<h3 id="wps"><a href="#wps" class="headerlink" title="wps"></a>wps</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">yay -S wps-office wps-office-mui-zh-cn<br><br>安装完后启动WPS，可能会弹出窗口，提示「系统缺失字体」。问题原因是wps for 没有自带Windows的字体。<br>在终端中输入以下命令进入tmp目录<br><span class="hljs-keyword">cd</span> <span class="hljs-string">/tmp</span><br>将字体库克隆下来<br>git clone git@github.com<span class="hljs-function">:IamDH4</span>/ttf-wps-fonts.git<br>进入下面的目录<br><span class="hljs-keyword">cd</span> ttf-wps-fonts<br>使用安装脚本安装字体<br>sudo bash install.sh<br>清理tmp目录<br>rm -rf <span class="hljs-string">/tmp/ttf-wps-fonts</span><br>完成<br><br>如果需要修改WPS的界面语言，先打开WPS Writer，新建一个文件，界面的右上方有个A字符的按钮，点进去后，取消勾选「跟随系统语言」选项，然后选择你想要的语言即可。<br> <br> 注：使用wps的用户还需要编辑~<span class="hljs-string">/.xprofile</span>添加以下内容（在新版中bug被修复了，但是如果有问题的话，可以尝试此方法）<br>export QT_IM_MODULE=fcitx5<br><br></code></pre></td></tr></table></figure><p>解决无法输入中文问题：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo vim /usr/bin/wps，在第一行（#!/bin/bash）下面添加：<br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">XMODIFIERS</span>=<span class="hljs-string">&quot;@im=fcitx&quot;</span><br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">QT_IM_MODULE</span>=<span class="hljs-string">&quot;fcitx&quot;</span><br><span class="hljs-attribute">gOpt</span>=gTemplateExt=(&quot;wpt&quot; <span class="hljs-string">&quot;dot&quot;</span> <span class="hljs-string">&quot;dotx&quot;</span>)<br></code></pre></td></tr></table></figure><hr><h3 id="使用timeshift备份系统"><a href="#使用timeshift备份系统" class="headerlink" title="使用timeshift备份系统"></a>使用timeshift备份系统</h3><p>安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">yay -S timeshift<br></code></pre></td></tr></table></figure><p>打开软件，保持默认。</p><p>在【用户】选项内设置需要备份的分区，</p><ul><li>root选择【包含一切】或者【排除一切】</li><li>home选择【排除一切】</li></ul><p>注： <strong>root</strong>默认就是全备份的，经测试更改也是无效的，也就是<strong>root</strong>必须备份。</p><p>在【筛选】选项内可以自定义备份文件或文件夹</p><p>建议这样配置：</p><ul><li><p>先将home整个目录排除，添加<code>/home/用户名/**</code></p></li><li><p>home目录下比较重要的如：<code>.local</code>、<code>.config</code>等，需要加入，切记要加上<code>***</code>三个星</p></li><li><p>创建快照</p><p>此时timeshift会根据时间生成一个带有时间戳的快照，此过程需要等待一段时间，并且期间不要对电脑执行任何操作。</p></li></ul><h5 id="如果只能进入登录界面"><a href="#如果只能进入登录界面" class="headerlink" title="如果只能进入登录界面"></a>如果只能进入登录界面</h5><p>一般系统崩溃后不能进入桌面，但是能够进入登录界面，现象就是在登录界面输入密码后不会进入桌面，那么就要通过命令行的方式进行还原。</p><ol><li><p>通过<code>Ctrl+Alt+F1</code>（一般是F1-F6都可）进入tty终端：</p></li><li><p>输入用户和密码登录</p></li><li><p>执行下面命令获取系统当前可以还原的节点：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">sudo timeshift <span class="hljs-comment">--list</span><br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>输出内容：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs subunit">Device : /dev/sdb4<br>UUID   : 197c4161-abc6<span class="hljs-string">-4069</span><span class="hljs-string">-8544</span>-d86594211f04<br>Path   : /home<br>Mode   : RSYNC<br>Device is OK<br>12 snapshots, 92.5 GB free<br><br>Num     Name                 Tags  Description  <br>------------------------------------------------------------------------------<br>0    &gt;  2018<span class="hljs-string">-08</span><span class="hljs-string">-08</span>_11<span class="hljs-string">-49</span><span class="hljs-string">-26</span>  O D                <br>1    &gt;  2018<span class="hljs-string">-08</span><span class="hljs-string">-13</span>_23<span class="hljs-string">-02</span><span class="hljs-string">-06</span>  O                  <br>2    &gt;  2018<span class="hljs-string">-08</span><span class="hljs-string">-15</span>_22<span class="hljs-string">-53</span><span class="hljs-string">-24</span>  O                  <br>3    &gt;  2018<span class="hljs-string">-08</span><span class="hljs-string">-21</span>_09<span class="hljs-string">-37</span><span class="hljs-string">-29</span>  O                  <br>4    &gt;  2018<span class="hljs-string">-11</span><span class="hljs-string">-19</span>_17<span class="hljs-string">-43</span><span class="hljs-string">-59</span>  O                  <br>5    &gt;  2019<span class="hljs-string">-01</span><span class="hljs-string">-20</span>_19<span class="hljs-string">-36</span><span class="hljs-string">-34</span>  O                  <br>6    &gt;  2019<span class="hljs-string">-03</span><span class="hljs-string">-01</span>_11<span class="hljs-string">-18</span><span class="hljs-string">-09</span>  O                  <br>7    &gt;  2019<span class="hljs-string">-03</span><span class="hljs-string">-01</span>_14<span class="hljs-string">-54</span><span class="hljs-string">-37</span>  O                  <br>8    &gt;  2019<span class="hljs-string">-03</span><span class="hljs-string">-04</span>_14<span class="hljs-string">-48</span><span class="hljs-string">-57</span>  O                  <br>9    &gt;  2019<span class="hljs-string">-03</span><span class="hljs-string">-10</span>_20<span class="hljs-string">-50</span><span class="hljs-string">-00</span>  O                  <br>10   &gt;  2019<span class="hljs-string">-03</span><span class="hljs-string">-14</span>_11<span class="hljs-string">-51</span><span class="hljs-string">-54</span>  O                  <br>11   &gt;  2019<span class="hljs-string">-07</span><span class="hljs-string">-16</span>_16<span class="hljs-string">-35</span><span class="hljs-string">-42</span>  O<br>123456789101112131415161718192021<br></code></pre></td></tr></table></figure></li><li><p>选择一个节点进行还原</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> timeshift --restore --snapshot &#x27;<span class="hljs-number">2019</span>-<span class="hljs-number">07</span>-<span class="hljs-number">16</span>_<span class="hljs-number">16</span>-<span class="hljs-number">35</span>-<span class="hljs-number">42</span>&#x27; --skip-grub<br><span class="hljs-attribute">1</span><br></code></pre></td></tr></table></figure><blockquote><p>–skip-grub 选项为跳过grub安装，一般来说grub不需要重新安装，除非bios启动无法找到正确的grub启动项，才需要安装。</p></blockquote><p>在输出的内容中依次输入【Enter】键和【y】键。</p><p>当然也可以直接输入下面的命令，忽略交互式的安装界面：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> timeshift --restore --snapshot &#x27;<span class="hljs-number">2019</span>-<span class="hljs-number">07</span>-<span class="hljs-number">16</span>_<span class="hljs-number">16</span>-<span class="hljs-number">35</span>-<span class="hljs-number">42</span>&#x27; --skip-grub --scripted<br><span class="hljs-attribute">1</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="无法进入系统，通过U盘启动系统"><a href="#无法进入系统，通过U盘启动系统" class="headerlink" title="无法进入系统，通过U盘启动系统"></a>无法进入系统，通过U盘启动系统</h3><p>当登录界面和桌面环境都无法进入时，一般系统已经彻底崩溃，此时只能通过Linux live CD进行还原。</p><ol><li><p>制作Linux Mint 启动盘，制作过程略。</p></li><li><p>进入Live系统后打开 <strong>Timeshift</strong> 软件，点击设置按钮，设置快照的存储位置：</p></li><li><blockquote><p>快照的存储位置是<strong>Timeshift</strong>在做备份的时候就已经设置好的。</p></blockquote></li><li><p>后续步骤和【如果能够进入系统】内的还原方式一样。</p></li></ol><p>其实此时还可以通过命令行的方式进行还原，但是首先需要设置快照存储的位置：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo timeshift --snapshot-device <span class="hljs-regexp">/dev/</span>sdb4<br><br></code></pre></td></tr></table></figure><p>后续步骤和【如果只能进入登录界面】内的还原方式一样。</p><hr><h5 id="错误：-Cannot-find-the-fakeroot-binary-gt-错误：-Cannot-find-the-strip-binary-required-for-object-fil…"><a href="#错误：-Cannot-find-the-fakeroot-binary-gt-错误：-Cannot-find-the-strip-binary-required-for-object-fil…" class="headerlink" title="错误： Cannot find the fakeroot binary. ==&gt; 错误： Cannot find the strip binary required for object fil…"></a>错误： Cannot find the fakeroot binary. ==&gt; 错误： Cannot find the strip binary required for object fil…</h5><p>解决方法：因为没安装 fakeroot、binutils 等打包基本工具，所以<code> sudo pacman -S base-devel</code> 装一下。(<code>sudo pacman -S -needed base-devel</code>安装包，且不重新安装已安装的包)</p><hr><h3 id="imwheel-调整鼠标滚轮速度"><a href="#imwheel-调整鼠标滚轮速度" class="headerlink" title="imwheel 调整鼠标滚轮速度"></a>imwheel 调整鼠标滚轮速度</h3><p><a href="https://wiki.archlinux.org/index.php/IMWheel#Run_IMWheel_on_startup_using_a_service">Arch Wiki上的方法</a></p><p>Arch：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">sudo pacman -S imwheel<br></code></pre></td></tr></table></figure><h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a><strong>配置</strong></h5><p>创建<code>~/.imwheelrc</code>文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">nano ~/.imwheelrc<br></code></pre></td></tr></table></figure><p>编辑内容：</p><p>后面的数字就是速度的倍数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">&quot;.*&quot;<br>None,      Up,   Button4, 4<br>None,      Down, Button5, 4<br>Control_L, Up,   Control_L|Button4<br>Control_L, Down, Control_L|Button5<br>Shift_L,   Up,   Shift_L|Button4<br>Shift_L,   Down, Shift_L|Button5<br></code></pre></td></tr></table></figure><h5 id="运行"><a href="#运行" class="headerlink" title="运行"></a><strong>运行</strong></h5><p>运行测试一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">imwheel<br></code></pre></td></tr></table></figure><p>重新运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">imwheel kill<br></code></pre></td></tr></table></figure><p>看到提示就成功了。</p><p>使用systemed服务或者shell脚本在系统启动后自动调用<code>imwheel</code>，参照wiki.</p><h5 id="Run-IMWheel-on-startup-using-a-service"><a href="#Run-IMWheel-on-startup-using-a-service" class="headerlink" title="Run IMWheel on startup using a service"></a>Run IMWheel on startup using a service</h5><p>To avoid starting IMWheel manually, you can run it as part of your systemd startup.</p><p>Example:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs routeros">~/.config/systemd/user/imwheel.service<br>[Unit]<br><span class="hljs-attribute">Description</span>=IMWheel<br><span class="hljs-attribute">Wants</span>=display-manager.service<br><span class="hljs-attribute">After</span>=display-manager.service<br><br>[Service]<br><span class="hljs-attribute">Type</span>=simple<br><span class="hljs-attribute">Environment</span>=XAUTHORITY=%h/.Xauthority<br><span class="hljs-attribute">ExecStart</span>=/usr/bin/imwheel -d<br><span class="hljs-attribute">ExecStop</span>=/usr/bin/pkill imwheel<br><span class="hljs-attribute">RemainAfterExit</span>=<span class="hljs-literal">yes</span><br><br>[Install]<br><span class="hljs-attribute">WantedBy</span>=graphical-session.target<br></code></pre></td></tr></table></figure><p>After installing the above:</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">systemctl --<span class="hljs-keyword">user</span> <span class="hljs-title">daemon-reload</span><br>systemctl --<span class="hljs-keyword">user</span> <span class="hljs-title">enable</span> --now imwheel<br>journalctl --<span class="hljs-keyword">user</span> <span class="hljs-title">--unit</span> imwheel<br></code></pre></td></tr></table></figure><h5 id="Run-IMWheel-on-startup-using-a-shell-script"><a href="#Run-IMWheel-on-startup-using-a-shell-script" class="headerlink" title="Run IMWheel on startup using a shell script"></a>Run IMWheel on startup using a shell script</h5><p>Alternatively, you can create a startup.sh script in /etc/profile.d</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh</span><br><br>imwheel<br></code></pre></td></tr></table></figure><p>And then, on restart, it will automatically read and run the file. Always test your script manually before putting it in /etc/profile.d</p><hr><h3 id="安装配置vmware-workstation"><a href="#安装配置vmware-workstation" class="headerlink" title="安装配置vmware workstation"></a>安装配置vmware workstation</h3><h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>在manjaro的安装配置中，关于vmware的安装着实让我头疼;新建虚拟机打开出现错误</p><blockquote><p>could not open /dev/vmmon:?????? please make sure that the kernel moduel vmmon is load</p></blockquote><p>google、baidu搜索有遇到同样问题的，但是没有一个能够解决！！！前后折腾了许久，还选择安装了VirtulBox但是使用不习惯，后来突然醒悟可以去<code>manjaro</code>的论坛找找，这才找到解决方法。<br> 感慨：</p><ul><li>使用linux真的可以很好锻炼自我解决问题的能力。</li><li>找资料要有的放矢，不能盲目,否则就是浪费时间，要缩小查找范围。</li></ul><h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><ul><li>使用manjaro提供的方法Install vmware-workstation</li></ul><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">pamac build vmware-workstation</span><br></code></pre></td></tr></table></figure><ul><li>安装之后，重启你的设备，执行下面命令加载vmmon模块</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">sudo modprobe -<span class="hljs-selector-tag">a</span> vmw_vmci vmmon<br></code></pre></td></tr></table></figure><ul><li>Start and enable services（开启以及自启动服务）</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">sudo systemctl <span class="hljs-keyword">enable</span> <span class="hljs-comment">--now vmware-networks.service</span><br>sudo systemctl <span class="hljs-keyword">enable</span> <span class="hljs-comment">--now vmware-usbarbitrator.service</span><br>sudo systemctl <span class="hljs-keyword">enable</span> <span class="hljs-comment">--now vmware-hostd.service</span><br></code></pre></td></tr></table></figure><blockquote><p>上述服务的用处：<br>vmware-networks.service: Provides network access inside VMs, most people will want this enabled<br>vmware-usbarbitrator.service: Allows USB devices to be connected inside VMs<br>vmware-hostd.service: Enables sharing of VMs on the network</p></blockquote><p><em>至此，vmmon的问题应该完美解决了;如果你的问题还没有解决可以参考以下链接或者到manjaro frum提出问题</em><br> <a href="https://wiki.manjaro.org/index.php?title=VMware#Installing_VMWare_Workstation_on_Manjaro">Installing VMWare Workstation on Manjaro</a></p><h3 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">sudo pacman -S netease-cloud-music <span class="hljs-comment">#安装网易云音乐</span><br>高分屏缩放 可以通过 env QT_SCREEN_SCALE_FACTORS=<span class="hljs-number">1.25</span> netease-cloud-music 启动来解决,也就是在启动文件里添加。<br><br>如果应用商店下载时遇到下面错误<br>错误：未知下载协议：<span class="hljs-keyword">https</span><br>问题的解决办法是，修改一下 PKGBUILD 的第 <span class="hljs-number">18</span> 行，把 <span class="hljs-keyword">http</span> 改成 <span class="hljs-keyword">https</span> 就可以了。<br>DLAGENTS=(<span class="hljs-string">&quot;https::/usr/bin/curl -A &#x27;Mozilla&#x27; -fLC - --retry 3 --retry-delay 3 -o %o %u&quot;</span>)<br><br></code></pre></td></tr></table></figure><p>可能无法输入中文</p><p><a href="https://gitee.com/ForMat1/netease-cloud-music_For_Arch">这里有个解决bug的</a></p><ul><li>高颜值、开发活跃的第三方客户端：<code>yay -S yesplaymusic</code></li><li>qq音乐 <code>yay -S qqmusic-bin</code></li><li>一个支持全平台听歌的软件：FeelUown <code>yay -S feeluown</code></li></ul><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><ul><li><p>为知笔记：全平台通用、有云端同步、支持md的笔记 ： <code>yay -S wiznote</code></p></li><li><p>如果你更喜欢开源软件，这里还有个很好的选择： joplin <code>yay -S joplin</code></p></li><li><p>还有个选择：notion ： <code>yay -S notion-app</code></p></li><li><p>mkdown编辑器Typora： <code>yay -S typora</code></p></li><li><p>LaTeX是学术出版的标准排版软件。可以直接从软件仓库中安装，不需要完全安装，安装基础组件以及中文语言包即可：<code>sudo pacman -S texlive-most texlive-langchinese</code></p><p>编辑器TexStudio也是必备的：<code>sudo pacman -S texstudio</code></p></li></ul><h3 id="Android反编译"><a href="#Android反编译" class="headerlink" title="Android反编译"></a>Android反编译</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim">sudo pacman -S jadx<br>#官网：http<span class="hljs-variable">s:</span>//github.<span class="hljs-keyword">com</span>/skylot/jadx<br>打开<span class="hljs-keyword">gui</span>界面：jadx-<span class="hljs-keyword">gui</span><br></code></pre></td></tr></table></figure><h3 id="腾讯软件"><a href="#腾讯软件" class="headerlink" title="腾讯软件"></a>腾讯软件</h3><ul><li><p>安装qq</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">yay -S com<span class="hljs-selector-class">.qq</span><span class="hljs-selector-class">.im</span><span class="hljs-selector-class">.deepin</span><br>这个使用的是deepin-wine5<br>调整qq的缩放<br>WINEPREFIX=~/.deepinwine/Deepin-QQ deepin-wine5 winecfg<br></code></pre></td></tr></table></figure></li><li><p>安装Tim</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">yay -S deepin-wine-tim<br></code></pre></td></tr></table></figure><p>安装过程中出现选择输入n就好</p><p>切换deepin-wine环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">sh /opt/deepinwine/apps/Deepin-Tim/run.sh -d<br></code></pre></td></tr></table></figure><p>如果这个版本的卡或者有其他问题，建议安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">yay -S deepin.com.qq.office<br></code></pre></td></tr></table></figure><p>如果这个也没办法装，则使用linuxqq</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">yay -S linuxqq<br></code></pre></td></tr></table></figure><ul><li>安装微信</li></ul><p>deepin-wine版：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">yay -S deepin-wine-wechat<br></code></pre></td></tr></table></figure><p>切换到deepin-wine环境：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">/opt/apps/com.qq.weixin.deepin/files/run.sh -d<br></code></pre></td></tr></table></figure><p>关于字体发虚问题：</p><p>在切换到deepin-wine环境后，在terminal输入下面的指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">env WINEPREFIX=<span class="hljs-string">&quot;<span class="hljs-variable">$HOME</span>/.deepinwine/Deepin-TIM&quot;</span> /usr/bin/deepin-wine winecfg<br></code></pre></td></tr></table></figure><p>在弹出的窗口中选择windows xp，将DPI调大（默认是96），我调成了120</p><p>微信的同样，只需要将命令改为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">env WINEPREFIX=<span class="hljs-string">&quot;<span class="hljs-variable">$HOME</span>/.deepinwine/Deepin-WeChat&quot;</span> /usr/bin/deepin-wine winecfg<br></code></pre></td></tr></table></figure><p>electron版：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">yay -S electron-wechat<br></code></pre></td></tr></table></figure><hr><h5 id="隔离应用"><a href="#隔离应用" class="headerlink" title="隔离应用"></a>隔离应用</h5><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">firejail或者他的<span class="hljs-keyword">gui</span>版本风传讹<br></code></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><p><a href="https://github.com/Swordfish90/cool-retro-term">复古的终端</a></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">wget https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/Swordfish90/</span>cool-retro-term<span class="hljs-regexp">/releases/</span>download<span class="hljs-regexp">/1.1.1/</span>Cool-Retro-Term-<span class="hljs-number">1.1</span>.<span class="hljs-number">1</span>-x86_64.AppImage<br>chmod a+x Cool-Retro-Term-<span class="hljs-number">1.1</span>.<span class="hljs-number">1</span>-x86_64.AppImage<br>./Cool-Retro-Term-<span class="hljs-number">1.1</span>.<span class="hljs-number">1</span>-x86_64.AppImage<br></code></pre></td></tr></table></figure></li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># deepin 系的软件</span><br>sudo pacman -S deepin-picker <span class="hljs-comment"># 深度取色器</span><br>sudo pacman -S deepin-screen-recorder <span class="hljs-comment"># 录屏软件，可以录制 Gif 或者 MP4 格式</span><br>sudo pacman -S deepin-screenshot <span class="hljs-comment"># 深度截图</span><br>sudo pacman -S deepin-system-monitor <span class="hljs-comment"># 系统状态监控</span><br>yay -s deepin-wine-wechat<br>yay -S deepin-wine-tim<br>yay -S deepin-wine-baidupan<br>yay -S deepin.com.thunderspeed<br><br><span class="hljs-comment"># 开发软件</span><br>sudo pacman -S jdk8-openjdk<br>sudo pacman -S make<br>sudo pacman -S cmake<br>sudo pacman -S clang<br>sudo pacman -S nodejs<br>sudo pacman -S npm<br>sudo pacman -S goland<br>sudo pacman -S vim<br>sudo pacman -S maven<br>sudo pacman -S pycharm-professional <span class="hljs-comment"># Python IDE</span><br>sudo pacman -S intellij-idea-ultimate-edition <span class="hljs-comment"># JAVA IDE</span><br>yay -S pycharm pycharm-jre <span class="hljs-comment">#pycharm</span><br>sudo pacman -S goland <span class="hljs-comment"># Go IDE</span><br>sudo pacman -S visual-studio-code-bin <span class="hljs-comment"># vscode</span><br>sudo pacman -S qtcreator <span class="hljs-comment"># 一款QT开发软件</span><br>sudo pacman -S postman-bin<br>sudo pacman -S insomnia <span class="hljs-comment"># REST模拟工具</span><br>sudo pacman -S gitkraken <span class="hljs-comment"># GIT管理工具</span><br>sudo pacman -S wireshark-qt <span class="hljs-comment"># 抓包</span><br>sudo pacman -S zeal<br>sudo pacman -S gitkraken <span class="hljs-comment"># Git 管理工具</span><br><br><span class="hljs-comment"># 办公&amp;文本</span><br>yay -S youdao-dict <span class="hljs-comment">#安装有道词典安装 </span><br>yay -S foxitreader <span class="hljs-comment">#福昕pdf阅读器 </span><br>sudo pacman -S bookworm <span class="hljs-comment"># 电子书阅读</span><br>sudo pacman -S unrar unzip p7zip<br>sudo pacman -S goldendict <span class="hljs-comment"># 翻译、取词</span><br>yay -S typora <span class="hljs-comment"># markdown 编辑</span><br>yay -S electron-ssr <span class="hljs-comment"># 缺少我需要的加密算法</span><br>yay -S xmind-<span class="hljs-number">2020</span>  <span class="hljs-comment">#xmind-2020</span><br>yay -S calibre <span class="hljs-comment"># calibre：电子书管理</span><br><br><span class="hljs-comment"># 设计</span><br>sudo pacman -S pencil <span class="hljs-comment"># 免费开源界面原型图绘制工具</span><br><br><span class="hljs-comment"># 娱乐软件</span><br>sudo pacman -S netease-cloud-music     <span class="hljs-comment"># 网易云音乐</span><br>（注：直接安装完Wireshark后启动软件，会提示<span class="hljs-regexp">/usr/</span>bin/dumpcap无权限，运行下面的命令即可解决问题： sudo gpasswd -a username wireshark  <span class="hljs-comment"># username是用户名）</span><br><br><span class="hljs-comment"># 下载软件&amp;网络浏览</span><br>sudo pacman -S aria2<br>sudo pacman -S filezilla  <span class="hljs-comment"># filezilla 强大的FTP工具</span><br>yay -Sy filezilla <span class="hljs-comment"># filezilla 强大的FTP工具</span><br><br>yay -S baidunetdisk-bin <span class="hljs-comment">#百度云</span><br>yay -S xunlei-bin <span class="hljs-comment">#迅雷</span><br>sudo pacman -S google-chrome<br>yay -S microsoft-edge-dev-bin <span class="hljs-comment">#edge浏览器</span><br>sudo pacman -S you-get <span class="hljs-comment">#强大的Web内容（视频，音频，图片）下载工具</span><br>yay -S nutstore <span class="hljs-comment">#坚果云</span><br>注： yay -S python-gobject <span class="hljs-comment">#如果出现坚果云打不开或者没有登录页面的情况，安装坚果云相关依赖</span><br><br><br><span class="hljs-comment"># 图形</span><br>sudo pacman -S gimp <span class="hljs-comment"># 修图</span><br>sudo pacman -Sy obs-studio <span class="hljs-comment"># OBS</span><br><br><span class="hljs-comment"># 系统工具</span><br>sudo pacman -S albert <span class="hljs-comment">#类似Mac Spotlight，另外一款https://cerebroapp.com/</span><br>yay -S copyq <span class="hljs-comment">#  剪贴板工具，类似 Windows 上的 Ditto</span><br>sudo pacman -S gufw<span class="hljs-comment">#安装防火墙Linux 世界中最简单的防火墙之一</span><br>sudo pacman -S yay                     <span class="hljs-comment"># AUR助手</span><br>yay -S latte-dock <span class="hljs-comment"># 安装latte-dock</span><br><br><span class="hljs-comment"># 终端</span><br>sudo pacman -S screenfetch <span class="hljs-comment"># 终端打印出你的系统信息，screenfetch -A &#x27;Arch Linux&#x27;</span><br>sudo pacman -S htop     <span class="hljs-comment">#可以在终端中直接管理进程</span><br>sudo pacman -S bat<br>sudo pacman -S yakuake <span class="hljs-comment"># 堪称 KDE 下的终端神器，KDE 已经自带，F12 可以唤醒</span><br>sudo pacman -S net-tools <span class="hljs-comment"># 这样可以使用 ifconfig 和 netstat</span><br>yay -S tldr<br>yay -S tig <span class="hljs-comment"># 命令行下的 git 历史查看工具</span><br>yay -S tree<br>yay -S ncdu <span class="hljs-comment"># 命令行下的磁盘分析器，支持Vim操作</span><br>yay -S mosh <span class="hljs-comment"># 一款速度更快的 ssh 工具，网络不稳定时使用有奇效</span><br>sudo pacman -S thefuck <span class="hljs-comment">#自动纠正上一个控制台命令</span><br>sudo pacman -S tmux<span class="hljs-comment">#强大的终端复用工具</span><br>yay -S lolcat <span class="hljs-comment">#终端渐变色工具</span><br>yay -S ranger <span class="hljs-comment">#终端文件浏览器</span><br><br>其他：<br>sudo pacman -S clang make cmake gdb    <span class="hljs-comment"># 编译调试环境</span><br>sudo pacman -S visual-studio-code-bin  <span class="hljs-comment"># 牛逼的编辑器</span><br>sudo pacman -S vim                     <span class="hljs-comment"># 命令行下的编辑器</span><br>sudo pacman -S qtcreator               <span class="hljs-comment"># IDE for Qt</span><br>sudo pacman -S wireshark-qt            <span class="hljs-comment"># 抓包工具</span><br>sudo pacman -S git                     <span class="hljs-comment"># 版本管理工具</span><br>sudo pacman -S octave                  <span class="hljs-comment"># Matlab的开源替代</span><br><br><span class="hljs-comment"># zsh</span><br>zsh以默认安装在系统中，F12中输入zsh即可使用，输入<span class="hljs-keyword">exit</span>退出zsh<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件</tag>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>scroller</title>
    <link href="/posts/3697a639/"/>
    <url>/posts/3697a639/</url>
    
    <content type="html"><![CDATA[<p>Scroller的总结<br>内容来自各个博客</p><ul><li>本质及作用：<br>Scroller本质就是一个Helper类，里面保存了目标对象要移动的距离，时间等属性！     </li></ul><p>Android ViewGroup中的Scroller与computeScroll的有什么关系？</p><p>答：没有直接的关系</p><p>1.Scroller到底是什么？</p><p>答：Scroller只是个计算器，提供插值计算，让滚动过程具有动画属性，但它并不是UI，也不是辅助UI滑动，反而是单纯地为滑动提供计算。</p><p>无论从构造方法还是其他方法，以及Scroller的属性可知，其并不会持有View，辅助ViewGroup滑动</p><p>2.Scroller只是提供计算，那谁来调用computeScroll使得ViewGroup滑动</p><p>答：computeScroll也不是来让ViewGroup滑动的，真正让ViewGroup滑动的是scrollTo,scrollBy。computeScroll的作用是计算ViewGroup如何滑动。而computeScroll是通过draw来调用的。</p><p>3.computeScroll和Scroller都是计算，两者有啥关系？</p><p>答：文章开始已作答，没有直接的关系。computeScroll和Scroller要是飞得拉关系的话，那就是computeScroll可以参考Scroller计算结果来影响scrollTo,scrollBy,从而使得滑动发生改变。也就是Scroller不会调用computeScroll，反而是computeScroll调用Scroller。</p><p>4.滑动时连续的，如何让Scroller的计算也是连续的？</p><p>这个就问到了什么时候调用computeScroll了，如上所说computeScroll调用Scroller，只要computeScroll调用连续，Scroller也会连续，实质上computeScroll的连续性又invalidate方法控制，scrollTo,scrollBy都会调用invalidate，而invalidate回去触发draw,从而computeScroll被连续调用，综上，Scroller也会被连续调用，除非invalidate停止调用。</p><p>5.computeScroll如何和Scroller的调用过程保持一致。</p><p>computeScroll参考Scroller影响scrollTo,scrollBy，实质上，为了不重复影响scrollTo,scrollBy，那么Scroller必须终止计算currX，currY。要知道计算有没有终止，需要通过mScroller.computeScrollOffset()</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">computeScroll</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">super</span>.computeScroll();<br><span class="hljs-keyword">if</span>(!mScroll.computeScrollOffset())&#123;<br><span class="hljs-comment">//计算currX,currY,并检测是否已完成&quot;滚动&quot;</span><br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">int</span> tempX=mScroll.getCurrX();<br>scrollTo(tempX,<span class="hljs-number">0</span>);<span class="hljs-comment">//会重复调用invalidate</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>注意：在移动平台中，要明确知道“滑动”与“滚动”的不同，具体来说，滑动和滚动的方向总是相反的。</code></p><p>再来看一下scrollTo,scrollBy这两个方法的区别, scrollTo()方法是让View相对于初始的位置滚动某段距离，由于View的初始位置是不变的，因此不管我们点击多少次scrollTo按钮滚动到的都将是同一个位置。而scrollBy()方法则是让View相对于当前的位置滚动某段距离，那每当我们点击一次scrollBy按钮，View的当前位置都进行了变动，因此不停点击会一直移动。</p><p>通过这个例子来理解，相信大家已经把scrollTo()和scrollBy()这两个方法的区别搞清楚了，但是现在还有一个问题，目前使用这两个方法完成的滚动效果是跳跃式的，没有任何平滑滚动的效果。没错，只靠scrollTo()和scrollBy()这两个方法是很难完成ViewPager这样的效果的，因此我们还需要借助另外一个关键性的工具，也就我们今天的主角Scroller。<br>Scroller的基本用法其实还是比较简单的，主要可以分为以下几个步骤：</p><p>1.创建Scroller的实例<br>2.调用startScroll()方法来初始化滚动数据并刷新界面<br>3.重写computeScroll()方法，并在其内部完成平滑滚动的逻辑<br>那么下面我们就按照上述的步骤，通过一个模仿ViewPager的简易例子来学习和理解一下Scroller的用法。<br>新建一个ScrollerLayout并让它继承自ViewGroup来作为我们的简易ViewPager布局，代码如下所示：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Created by guolin on 16/1/12.</span><br><span class="hljs-comment"> */</span><br>public <span class="hljs-keyword">class</span> ScrollerLayout extends ViewGroup &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用于完成滚动操作的实例</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Scroller mScroller;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判定为拖动的最小移动像素数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> mTouchSlop;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 手机按下时的屏幕坐标</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span> mXDown;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 手机当时所处的屏幕坐标</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span> mXMove;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 上次触发ACTION_MOVE事件时的屏幕坐标</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span> mXLastMove;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 界面可滚动的左边界</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> leftBorder;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 界面可滚动的右边界</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> rightBorder;<br><br>    public <span class="hljs-constructor">ScrollerLayout(Context <span class="hljs-params">context</span>, AttributeSet <span class="hljs-params">attrs</span>)</span> &#123;<br>        super(context, attrs);<br>        <span class="hljs-comment">// 第一步，创建Scroller的实例</span><br>        mScroller = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Scroller(<span class="hljs-params">context</span>)</span>;<br>        ViewConfiguration configuration = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ViewConfiguration</span>.</span></span>get(context);<br>        <span class="hljs-comment">// 获取TouchSlop值</span><br>        mTouchSlop = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ViewConfigurationCompat</span>.</span></span>get<span class="hljs-constructor">ScaledPagingTouchSlop(<span class="hljs-params">configuration</span>)</span>;<br>    &#125;<br><br>    @Override<br>    protected void on<span class="hljs-constructor">Measure(<span class="hljs-params">int</span> <span class="hljs-params">widthMeasureSpec</span>, <span class="hljs-params">int</span> <span class="hljs-params">heightMeasureSpec</span>)</span> &#123;<br>        super.on<span class="hljs-constructor">Measure(<span class="hljs-params">widthMeasureSpec</span>, <span class="hljs-params">heightMeasureSpec</span>)</span>;<br>        <span class="hljs-built_in">int</span> childCount = get<span class="hljs-constructor">ChildCount()</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; childCount; i++) &#123;<br>            View childView = get<span class="hljs-constructor">ChildAt(<span class="hljs-params">i</span>)</span>;<br>            <span class="hljs-comment">// 为ScrollerLayout中的每一个子控件测量大小</span><br>            measure<span class="hljs-constructor">Child(<span class="hljs-params">childView</span>, <span class="hljs-params">widthMeasureSpec</span>, <span class="hljs-params">heightMeasureSpec</span>)</span>;<br>        &#125;<br>    &#125;<br><br>    @Override<br>    protected void on<span class="hljs-constructor">Layout(<span class="hljs-params">boolean</span> <span class="hljs-params">changed</span>, <span class="hljs-params">int</span> <span class="hljs-params">l</span>, <span class="hljs-params">int</span> <span class="hljs-params">t</span>, <span class="hljs-params">int</span> <span class="hljs-params">r</span>, <span class="hljs-params">int</span> <span class="hljs-params">b</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (changed) &#123;<br>            <span class="hljs-built_in">int</span> childCount = get<span class="hljs-constructor">ChildCount()</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; childCount; i++) &#123;<br>                View childView = get<span class="hljs-constructor">ChildAt(<span class="hljs-params">i</span>)</span>;<br>                <span class="hljs-comment">// 为ScrollerLayout中的每一个子控件在水平方向上进行布局</span><br>                childView.layout(i<span class="hljs-operator"> * </span>childView.get<span class="hljs-constructor">MeasuredWidth()</span>, <span class="hljs-number">0</span>, (i + <span class="hljs-number">1</span>)<span class="hljs-operator"> * </span>childView.get<span class="hljs-constructor">MeasuredWidth()</span>, childView.get<span class="hljs-constructor">MeasuredHeight()</span>);<br>            &#125;<br>            <span class="hljs-comment">// 初始化左右边界值</span><br>            leftBorder = get<span class="hljs-constructor">ChildAt(0)</span>.get<span class="hljs-constructor">Left()</span>;<br>            rightBorder = get<span class="hljs-constructor">ChildAt(<span class="hljs-params">getChildCount</span>()</span> - <span class="hljs-number">1</span>).get<span class="hljs-constructor">Right()</span>;<br>        &#125;<br>    &#125;<br><br>    @Override<br>    public boolean on<span class="hljs-constructor">InterceptTouchEvent(MotionEvent <span class="hljs-params">ev</span>)</span> &#123;<br>        switch (ev.get<span class="hljs-constructor">Action()</span>) &#123;<br>            case MotionEvent.ACTION_DOWN:<br>                mXDown = ev.get<span class="hljs-constructor">RawX()</span>;<br>                mXLastMove = mXDown;<br>                break;<br>            case MotionEvent.ACTION_MOVE:<br>                mXMove = ev.get<span class="hljs-constructor">RawX()</span>;<br>                <span class="hljs-built_in">float</span> diff = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>abs(mXMove - mXDown);<br>                mXLastMove = mXMove;<br>                <span class="hljs-comment">// 当手指拖动值大于TouchSlop值时，认为应该进行滚动，拦截子控件的事件</span><br>                <span class="hljs-keyword">if</span> (diff &gt; mTouchSlop) &#123;<br>                    return <span class="hljs-literal">true</span>;<br>                &#125;<br>                break;<br>        &#125;<br>        return super.on<span class="hljs-constructor">InterceptTouchEvent(<span class="hljs-params">ev</span>)</span>;<br>    &#125;<br><br>    @Override<br>    public boolean on<span class="hljs-constructor">TouchEvent(MotionEvent <span class="hljs-params">event</span>)</span> &#123;<br>        switch (event.get<span class="hljs-constructor">Action()</span>) &#123;<br>            case MotionEvent.ACTION_MOVE:<br>                mXMove = event.get<span class="hljs-constructor">RawX()</span>;<br>                <span class="hljs-built_in">int</span> scrolledX = (<span class="hljs-built_in">int</span>) (mXLastMove - mXMove);<br>                <span class="hljs-keyword">if</span> (get<span class="hljs-constructor">ScrollX()</span> + scrolledX &lt; leftBorder) &#123;<br>                    scroll<span class="hljs-constructor">To(<span class="hljs-params">leftBorder</span>, 0)</span>;<br>                    return <span class="hljs-literal">true</span>;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (get<span class="hljs-constructor">ScrollX()</span> + get<span class="hljs-constructor">Width()</span> + scrolledX &gt; rightBorder) &#123;<br>                    scroll<span class="hljs-constructor">To(<span class="hljs-params">rightBorder</span> - <span class="hljs-params">getWidth</span>()</span>, <span class="hljs-number">0</span>);<br>                    return <span class="hljs-literal">true</span>;<br>                &#125;<br>                scroll<span class="hljs-constructor">By(<span class="hljs-params">scrolledX</span>, 0)</span>;<br>                mXLastMove = mXMove;<br>                break;<br>            case MotionEvent.ACTION_UP:<br>                <span class="hljs-comment">// 当手指抬起时，根据当前的滚动值来判定应该滚动到哪个子控件的界面</span><br>                <span class="hljs-built_in">int</span> targetIndex = (get<span class="hljs-constructor">ScrollX()</span> + get<span class="hljs-constructor">Width()</span><span class="hljs-operator"> / </span><span class="hljs-number">2</span>)<span class="hljs-operator"> / </span>get<span class="hljs-constructor">Width()</span>;<br>                <span class="hljs-built_in">int</span> dx = targetIndex<span class="hljs-operator"> * </span>get<span class="hljs-constructor">Width()</span> - get<span class="hljs-constructor">ScrollX()</span>;<br>                <span class="hljs-comment">// 第二步，调用startScroll()方法来初始化滚动数据并刷新界面</span><br>                mScroller.start<span class="hljs-constructor">Scroll(<span class="hljs-params">getScrollX</span>()</span>, <span class="hljs-number">0</span>, dx, <span class="hljs-number">0</span>);<br>                invalidate<span class="hljs-literal">()</span>;<br>                break;<br>        &#125;<br>        return super.on<span class="hljs-constructor">TouchEvent(<span class="hljs-params">event</span>)</span>;<br>    &#125;<br><br>    @Override<br>    public void compute<span class="hljs-constructor">Scroll()</span> &#123;<br>        <span class="hljs-comment">// 第三步，重写computeScroll()方法，并在其内部完成平滑滚动的逻辑</span><br>        <span class="hljs-keyword">if</span> (mScroller.compute<span class="hljs-constructor">ScrollOffset()</span>) &#123;<br>            scroll<span class="hljs-constructor">To(<span class="hljs-params">mScroller</span>.<span class="hljs-params">getCurrX</span>()</span>, mScroller.get<span class="hljs-constructor">CurrY()</span>);<br>            invalidate<span class="hljs-literal">()</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>整个Scroller用法的代码都在这里了，代码并不长，一共才100多行，我们一点点来看。<br>首先在ScrollerLayout的构造函数里面我们进行了上述步骤中的第一步操作，即创建Scroller的实例，由于Scroller的实例只需创建一次，因此我们把它放到构造函数里面执行。另外在构建函数中我们还初始化的TouchSlop的值，这个值在后面将用于判断当前用户的操作是否是拖动。</p><p>接着重写onMeasure()方法和onLayout()方法，在onMeasure()方法中测量ScrollerLayout里的每一个子控件的大小，在onLayout()方法中为ScrollerLayout里的每一个子控件在水平方向上进行布局。</p><p>接着重写onInterceptTouchEvent()方法， 在这个方法中我们记录了用户手指按下时的X坐标位置，以及用户手指在屏幕上拖动时的X坐标位置，当两者之间的距离大于TouchSlop值时，就认为用户正在拖动布局，然后我们就将事件在这里拦截掉，阻止事件传递到子控件当中。</p><p>那么当我们把事件拦截掉之后，就会将事件交给ScrollerLayout的onTouchEvent()方法来处理。如果当前事件是ACTION_MOVE，说明用户正在拖动布局，那么我们就应该对布局内容进行滚动从而影响拖动事件，实现的方式就是使用我们刚刚所学的scrollBy()方法，用户拖动了多少这里就scrollBy多少。另外为了防止用户拖出边界这里还专门做了边界保护，当拖出边界时就调用scrollTo()方法来回到边界位置。</p><p>如果当前事件是ACTION_UP时，说明用户手指抬起来了，但是目前很有可能用户只是将布局拖动到了中间，我们不可能让布局就这么停留在中间的位置，因此接下来就需要借助Scroller来完成后续的滚动操作。首先这里我们先根据当前的滚动位置来计算布局应该继续滚动到哪一个子控件的页面，然后计算出距离该页面还需滚动多少距离。接下来我们就该进行上述步骤中的第二步操作，调用startScroll()方法来初始化滚动数据并调用invalidate()来刷新界面。startScroll()方法接收四个参数，第一个参数是滚动开始时X的坐标，第二个参数是滚动开始时Y的坐标，第三个参数是横向滚动的距离，正值表示向左滚动，第四个参数是纵向滚动的距离，正值表示向上滚动。紧接着调用invalidate()方法来刷新界面。</p><p>现在前两步都已经完成了，最后我们还需要进行第三步操作，即重写computeScroll()方法，并在其内部完成平滑滚动的逻辑 。在整个后续的平滑滚动过程中，computeScroll()方法是会一直被调用的，因此我们需要不断调用Scroller的computeScrollOffset()方法来进行判断滚动操作是否已经完成了，如果还没完成的话，那就继续调用scrollTo()方法，并把Scroller的curX和curY坐标传入，然后刷新界面从而完成平滑滚动的操作。</p><hr><p>实现惯性滚动 (Scroller的妙用)<br><a href="%22https://blog.csdn.net/u011387817/article/details/80313184%22">Android实现圆弧滑动效果之ArcSlidingHelper篇</a><br>说到Scroller，相信大家第一时间想到要配合View中的computeScroll方法来使用对吧，但是呢，我们这篇文章的主题是辅助类，并不打算继承View，而且不持有Context引用，这个时候，可能有同学就会有以下疑问了：</p><ul><li>这种情况下，Scroller还能正常工作吗？</li><li>调用它的startScroll或fling方法后，不是还要调用View中的invalidate方法来触发的吗？</li><li>不继承View，哪来的 invalidate方法？  </li><li>不继承View，怎么重写computeScroll方法？在哪里处理惯性滚动？  </li><li>哈哈，其实Scroller是完全可以脱离View来使用的，既然说是妙用，妙在哪里呢？在开始之前，我们先来了解一下Scroller：  </li></ul><p>1.它看上去更像是一个ValueAnimator，但它跟ValueAnimator有个明显的区别就是：它不会主动更新动画的值。我们在获取最新值之前，总是要先调用computeScrollOffset方法来刷新内部的mCurrX、mCurrY的值，如果是惯性滚动模式(调用fling方法)，还会刷新mCurrVelocity的值。  </p><p>2.在这里先分享大家一个理解源码调用顺序的方法：<br>比如我们想知道是哪个方法调用了computeScroll：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">@Override<br>public void compute<span class="hljs-constructor">Scroll()</span> &#123;<br>    StackTraceElement<span class="hljs-literal">[]</span> elements = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">StackTrace()</span>;<br>    <span class="hljs-keyword">for</span> (StackTraceElement element : elements) &#123;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>i(<span class="hljs-string">&quot;computeScroll&quot;</span>, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">String</span>.</span></span>format(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Locale</span>.</span></span>get<span class="hljs-constructor">Default()</span>, <span class="hljs-string">&quot;%s-----&gt;%s\tline: %d&quot;</span>,<br>                element.get<span class="hljs-constructor">ClassName()</span>, element.get<span class="hljs-constructor">MethodName()</span>, element.get<span class="hljs-constructor">LineNumber()</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>日志输出：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">com.wuyr.testview.MyView<span class="hljs-comment">-----&gt;computeScrollline: 141</span><br>android.<span class="hljs-keyword">view</span>.<span class="hljs-keyword">View</span><span class="hljs-comment">-----&gt;updateDisplayListIfDirtyline: 15361</span><br>android.<span class="hljs-keyword">view</span>.<span class="hljs-keyword">View</span><span class="hljs-comment">-----&gt;drawline: 16182</span><br>android.<span class="hljs-keyword">view</span>.ViewGroup<span class="hljs-comment">-----&gt;drawChildline: 3777</span><br>android.<span class="hljs-keyword">view</span>.ViewGroup<span class="hljs-comment">-----&gt;dispatchDrawline: 3567</span><br>android.<span class="hljs-keyword">view</span>.<span class="hljs-keyword">View</span><span class="hljs-comment">-----&gt;updateDisplayListIfDirtyline: 15373</span><br>android.<span class="hljs-keyword">view</span>.<span class="hljs-keyword">View</span><span class="hljs-comment">-----&gt;drawline: 16182</span><br>android.<span class="hljs-keyword">view</span>.ViewGroup<span class="hljs-comment">-----&gt;drawChildline: 3777</span><br>android.<span class="hljs-keyword">view</span>.ViewGroup<span class="hljs-comment">-----&gt;dispatchDrawline: 3567</span><br>android.<span class="hljs-keyword">view</span>.<span class="hljs-keyword">View</span><span class="hljs-comment">-----&gt;updateDisplayListIfDirtyline: 15373</span><br>android.<span class="hljs-keyword">view</span>.<span class="hljs-keyword">View</span><span class="hljs-comment">-----&gt;drawline: 16182</span><br></code></pre></td></tr></table></figure><p>这样我们就能够很清晰的看到它的调用链了。</p><p>回到正题，所谓的调用invalidate方法来触发，是这样的：我们都知道，调用了这个方法之后，onDraw方法就会回调，而调用onDraw的那个方法，是draw(Canvas canvas)，再上一级，是draw(Canvas canvas, ViewGroup parent, long drawingTime)，重点来了：<br>computeScroll也是在这个方法中回调的，现在可以得出一个结论：<br>我们在View中调用invalidate方法，也就是间接地调用computeScroll，而computeScroll中，是我们处理滚动的方法，在使用Scroller时，我们都会重写这个方法，并在里面调用Scroller的computeScrollOffset方法，然后调用getCurrX或getCurrY来获取到最新的值。(好像我前面说的都是多余的) 但是！有没有发现，这个过程，我们完全可以不依赖View来做到的？</p><p>3.现在思路就很清晰了，invalidate方法？对于Scroller来说，它的作用只是回调computeScroll从而更新x和y的值而已。</p><p>4.所以完全可以自己写两个方法来实现Scroller在View中的效果，我们这次打算利用Hanlder来帮我们处理异步的问题，这样的话，我们就不用自己新开线程去不断的调用方法啦。</p><p>好了，现在我们所遇到的问题，都已经有解决方案了，可以动手咯！</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"> <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 处理触摸事件</span><br><span class="hljs-comment">     */</span><br>    public void handle<span class="hljs-constructor">Movement(MotionEvent <span class="hljs-params">event</span>)</span> &#123;<br>     .....<br>        mVelocityTracker.add<span class="hljs-constructor">Movement(<span class="hljs-params">event</span>)</span>;<br>        switch (event.get<span class="hljs-constructor">Action()</span>) &#123;<br>            case MotionEvent.ACTION_DOWN:<br>             .....<br>                break;<br>            case MotionEvent.ACTION_MOVE:<br>                handle<span class="hljs-constructor">ActionMove(<span class="hljs-params">x</span>, <span class="hljs-params">y</span>)</span>;<br>                break;<br>            case MotionEvent.ACTION_UP:<br>            case MotionEvent.ACTION_CANCEL:<br>            case MotionEvent.ACTION_OUTSIDE:<br>                <span class="hljs-keyword">if</span> (isInertialSlidingEnable) &#123;<br>                    mVelocityTracker.compute<span class="hljs-constructor">CurrentVelocity(1000)</span>;<br>                    mScroller.fling(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, (<span class="hljs-built_in">int</span>) mVelocityTracker.get<span class="hljs-constructor">XVelocity()</span>, (<span class="hljs-built_in">int</span>) mVelocityTracker.get<span class="hljs-constructor">YVelocity()</span>,Integer.MIN_VALUE, Integer.MAX_VALUE, Integer.MIN_VALUE, Integer.MAX_VALUE); <br>                    <span class="hljs-comment">//我们在调用Scroller的fling方法之后，并没有调用invalidate方法，而是我们自定义的startFling方法. </span><br>                    start<span class="hljs-constructor">Fling()</span>;<br>                &#125;<br>                break;<br>           .....<br>        &#125;<br> .....<br>    &#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 处理惯性滚动</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> void compute<span class="hljs-constructor">InertialSliding()</span> &#123;<br>        check<span class="hljs-constructor">IsRecycled()</span>;<br>        <span class="hljs-keyword">if</span> (mScroller.compute<span class="hljs-constructor">ScrollOffset()</span>) &#123;<br>            <span class="hljs-built_in">float</span> y = ((isShouldBeGetY ? mScroller.get<span class="hljs-constructor">CurrY()</span> : mScroller.get<span class="hljs-constructor">CurrX()</span>)<span class="hljs-operator"> * </span>mScrollAvailabilityRatio);<br>            <span class="hljs-keyword">if</span> (mLastScrollOffset != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-built_in">float</span> offset = fix<span class="hljs-constructor">Angle(Math.<span class="hljs-params">abs</span>(<span class="hljs-params">y</span> - <span class="hljs-params">mLastScrollOffset</span>)</span>);<br>                mSlidingListener.on<span class="hljs-constructor">Sliding(<span class="hljs-params">isClockwiseScrolling</span> ? <span class="hljs-params">offset</span> : -<span class="hljs-params">offset</span>)</span>;<br>            &#125;<br>            mLastScrollOffset = y;<br>            start<span class="hljs-constructor">Fling()</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mScroller.is<span class="hljs-constructor">Finished()</span>) &#123;<br>            mLastScrollOffset = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (mSlideFinishListener != null) &#123;<br>                mSlideFinishListener.on<span class="hljs-constructor">SlideFinished()</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 开始惯性滚动</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> void start<span class="hljs-constructor">Fling()</span> &#123;<br>        mHandler.send<span class="hljs-constructor">EmptyMessage(0)</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 主线程回调惯性滚动</span><br><span class="hljs-comment">     *Handler来处理异步的问题，这样就不用自己去新开线程了。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> static <span class="hljs-keyword">class</span> InertialSlidingHandler extends Handler &#123;<br><br>        ArcSlidingHelper mHelper;<br><br>        <span class="hljs-constructor">InertialSlidingHandler(ArcSlidingHelper <span class="hljs-params">helper</span>)</span> &#123;<br>            mHelper = helper;<br>        &#125;<br><br>        @Override<br>        public void handle<span class="hljs-constructor">Message(Message <span class="hljs-params">msg</span>)</span> &#123;<br>            mHelper.compute<span class="hljs-constructor">InertialSliding()</span>;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>我们用computeInertialSliding来代替了View中的computeScroll方法，用startFling代替了invalidate，可以说是完全脱离了View来使用Scroller，妙就妙在这里啦，嘻嘻。</p><hr><p>Scroller主要使用的滚动方法有：startScroll、fling。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">start<span class="hljs-constructor">Scroll(<span class="hljs-params">int</span> <span class="hljs-params">startX</span>, <span class="hljs-params">int</span> <span class="hljs-params">startY</span>, <span class="hljs-params">int</span> <span class="hljs-params">dx</span>, <span class="hljs-params">int</span> <span class="hljs-params">dy</span>, <span class="hljs-params">int</span> <span class="hljs-params">duration</span>)</span>：<br>指定起点（startX，startY），从起点平滑变化（dx，dy），耗时duration，通常用于：知道起点与需要改变的距离的平滑滚动等。<br><br>fling(<span class="hljs-built_in">int</span> startX, <span class="hljs-built_in">int</span> startY, <span class="hljs-built_in">int</span> velocityX, <span class="hljs-built_in">int</span> velocityY, <span class="hljs-built_in">int</span> minX, <span class="hljs-built_in">int</span> maxX, <span class="hljs-built_in">int</span> minY, <span class="hljs-built_in">int</span> maxY)：<br>惯性滑动。  给定一个初始速度（ velocityX， velocityY ），该方法内部会根据这个速度去计算需要滑动的距离以及需要耗费的时间。通常用于：界面的惯性滑动等。<br></code></pre></td></tr></table></figure><p>scroller的实例化：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Scroller mScroller = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Scroller(Context <span class="hljs-params">mContext</span>)</span>&#123;&#125;; :采用默认插值器<br>Scroller mScroller = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Scroller(Context <span class="hljs-params">mContext</span>，Interpolator <span class="hljs-params">interpolator</span>)</span>&#123;&#125;;采用指定的插值器<br></code></pre></td></tr></table></figure><p>调用过程：</p><pre><code>   public void startScroll( int startX, int startY, int dx,int dy)&#123;&#125;;</code></pre><p>这方法并不是真正意义上的开始Scroll，它的作用是为Scroller做一些准备工作,比如设置移动的初始位置，滑动的位移以及持续时间等。</p><pre><code>   public boolean computeScrollOffset()&#123;&#125;</code></pre><p>这方法用于判断移动过程是否完成</p><pre><code>   getCurrX、getCurrY、getFinalX、getFinalY、</code></pre><p>这些方法用于获取scroll的一些位置信息</p><ul><li>Scroller与View结合使用：</li></ul><p>首先需要在自定义的View中定义一个私有成员 mScroller，用于记录view滚动的位置，然后再重写View的<code>computeScroll（）</code>方法来实现具体移动</p><p>注意：Scroller的作用只是保存一些信息，以及判断是否移动完成，所以我们得知道<code>computeScroll（）</code>这个方法的调用流程，在查看Android源码时发现<br>View.java中的<code>computeScroll（）</code>方法是一个空函数，所以我们需要在自定义的View中重写这个方法来实现我们想要的功能，那么<code>computeScroll（）</code>是怎么样被调用的呢？</p><p>调用<code>invalidate()</code>（UI线程）或者<code>postInvalidate（）</code>使View（Viewgroup）树重绘.<br>重绘分成两种情况：</p><p>1、Viewgroup的重绘<br><code>ViewGroup的绘制流程：onDraw（）--&gt;dispatchDraw()--&gt;drawChild()--&gt;child.computeScroll()</code></p><p>2、View的重绘：</p><p>View没有子view所以在View的源码中看到<code>dispatchDraw（）</code>方法是一个空方法，那么其调用流程就和ViewGroup是不一样的，那么View是怎样调用<code>computeScroll（）</code>的呢？</p><p>我们注意到invalidate是重绘整个View树或者ViewGroup树，所以当View重绘时其所在父容器也会重绘，so，父容器就会经历<code>onDraw（）--&gt;dispatchDraw()--&gt;drawChild() --&gt;child.computeScroll()</code>流程，这时候自定义View中重写的computeScroll（）方法就会被调用。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"> <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ViewGroup</span>.</span></span>java：<br><br>@Override  <br>protected void dispatch<span class="hljs-constructor">Draw(Canvas <span class="hljs-params">canvas</span>)</span>&#123; <br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;  <br>            final View child = children<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>;  <br>            <span class="hljs-keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK)<span class="hljs-operator"> == </span>VISIBLE<span class="hljs-operator"> || </span>child.get<span class="hljs-constructor">Animation()</span> != null)  <br>  <br>            &#123;  <br>                more <span class="hljs-pattern-match">|= draw<span class="hljs-constructor">Child(<span class="hljs-params">canvas</span>, <span class="hljs-params">child</span>, <span class="hljs-params">drawingTime</span>)</span>;  </span><br><span class="hljs-pattern-match">            &#125;  </span><br><span class="hljs-pattern-match">draw<span class="hljs-constructor">Child</span>函数：</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">protected boolean draw<span class="hljs-constructor">Child(Canvas <span class="hljs-params">canvas</span>, View <span class="hljs-params">child</span>, <span class="hljs-params">long</span> <span class="hljs-params">drawingTime</span>)</span> &#123;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">                  ----------</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">child.compute<span class="hljs-constructor">Scroll()</span>;</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match">              -----------------</span><br><span class="hljs-pattern-match"></span><br><span class="hljs-pattern-match"> <span class="hljs-keyword">if</span> ((child.m<span class="hljs-constructor">PrivateFlags</span> &amp; <span class="hljs-constructor">SKIP_DRAW</span>) <span class="hljs-operator">==</span> <span class="hljs-constructor">SKIP_DRAW</span>) &#123;</span><br><span class="hljs-pattern-match">        <span class="hljs-keyword">if</span> (<span class="hljs-constructor">ViewDebug</span>.<span class="hljs-constructor">TRACE_HIERARCHY</span>) &#123;</span><br><span class="hljs-pattern-match">            <span class="hljs-constructor">ViewDebug</span>.trace(this, <span class="hljs-constructor">ViewDebug</span>.<span class="hljs-constructor">HierarchyTraceType</span>.<span class="hljs-constructor">DRAW</span>);</span><br><span class="hljs-pattern-match">        &#125;</span><br><span class="hljs-pattern-match">        child.dispatch<span class="hljs-constructor">Draw(<span class="hljs-params">canvas</span>)</span>;</span><br><span class="hljs-pattern-match">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="hljs-pattern-match">        child.draw(canvas);</span><br><span class="hljs-pattern-match">    &#125;</span><br></code></pre></td></tr></table></figure><ul><li>自定义View：</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> CustomView extends View &#123;  <br>  <br>    <span class="hljs-keyword">private</span> Scroller mScroller;  <br> <br>    public <span class="hljs-constructor">CustomView(Context <span class="hljs-params">context</span>, AttributeSet <span class="hljs-params">attrs</span>)</span> &#123;  <br>        super(context, attrs);  <br>        mScroller = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Scroller(<span class="hljs-params">context</span>)</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//调用此方法滚动到目标位置  </span><br>    public void smooth<span class="hljs-constructor">ScrollTo(<span class="hljs-params">int</span> <span class="hljs-params">fx</span>, <span class="hljs-params">int</span> <span class="hljs-params">fy</span>)</span> &#123;  <br>        <span class="hljs-built_in">int</span> dx = fx - mScroller.get<span class="hljs-constructor">FinalX()</span>;  <br>        <span class="hljs-built_in">int</span> dy = fy - mScroller.get<span class="hljs-constructor">FinalY()</span>;  <br>        smooth<span class="hljs-constructor">ScrollBy(<span class="hljs-params">dx</span>, <span class="hljs-params">dy</span>)</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">//调用此方法设置滚动的相对偏移  </span><br>    public void smooth<span class="hljs-constructor">ScrollBy(<span class="hljs-params">int</span> <span class="hljs-params">dx</span>, <span class="hljs-params">int</span> <span class="hljs-params">dy</span>)</span> &#123;  <br>        <span class="hljs-comment">//设置mScroller的滚动偏移量  </span><br>        mScroller.start<span class="hljs-constructor">Scroll(<span class="hljs-params">mScroller</span>.<span class="hljs-params">getFinalX</span>()</span>, mScroller.get<span class="hljs-constructor">FinalY()</span>, dx, dy);  <br>        invalidate<span class="hljs-literal">()</span>;<span class="hljs-comment">//这里必须调用invalidate()才能保证computeScroll()会被调用，否则不一定会刷新界面，看不到滚动效果  </span><br>    &#125;  <br>      <br>    @Override  <br>    public void compute<span class="hljs-constructor">Scroll()</span> &#123;  <br>        <span class="hljs-comment">//先判断mScroller滚动是否完成  </span><br>        <span class="hljs-keyword">if</span> (mScroller.compute<span class="hljs-constructor">ScrollOffset()</span>) &#123;  <br>            <span class="hljs-comment">//这里调用View的scrollTo()完成实际的滚动  </span><br>            scroll<span class="hljs-constructor">To(<span class="hljs-params">mScroller</span>.<span class="hljs-params">getCurrX</span>()</span>, mScroller.get<span class="hljs-constructor">CurrY()</span>);  <br>              <br>            <span class="hljs-comment">//必须调用该方法，否则不一定能看到滚动效果  </span><br>            post<span class="hljs-constructor">Invalidate()</span>;  <br>        &#125;  <br>        super.compute<span class="hljs-constructor">Scroll()</span>;  <br>    &#125;  <br>&#125;  <br></code></pre></td></tr></table></figure><hr><p>android.view.VelocityTracker主要用跟踪触摸屏事件（flinging事件和其他gestures手势事件）的速率。用addMovement(MotionEvent)函数将Motion event加入到VelocityTracker类实例中.你可以使用getXVelocity() 或getXVelocity()获得横向和竖向的速率到速率时，但是使用它们之前请先调用computeCurrentVelocity(int)来初始化速率的单位 。  </p><p>示例： </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> VelocityTracker mVelocityTracker;<span class="hljs-comment">//生命变量 </span><br><span class="hljs-comment">//在onTouchEvent(MotionEvent ev)中 </span><br><span class="hljs-keyword">if</span> (mVelocityTracker<span class="hljs-operator"> == </span>null) &#123; <br>        mVelocityTracker = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">VelocityTracker</span>.</span></span>obtain<span class="hljs-literal">()</span>;<span class="hljs-comment">//获得VelocityTracker类实例 </span><br>&#125; <br>mVelocityTracker.add<span class="hljs-constructor">Movement(<span class="hljs-params">ev</span>)</span>;<span class="hljs-comment">//将事件加入到VelocityTracker类实例中 </span><br><span class="hljs-comment">//判断当ev事件是MotionEvent.ACTION_UP时：计算速率 </span><br>final VelocityTracker velocityTracker = mVelocityTracker; <br><span class="hljs-comment">// 1000 provides pixels per second </span><br>velocityTracker.compute<span class="hljs-constructor">CurrentVelocity(1, (<span class="hljs-params">float</span>)</span><span class="hljs-number">0.01</span>); <span class="hljs-comment">//设置maxVelocity值为0.1时，速率大于0.01时，显示的速率都是0.01,速率小于0.01时，显示正常 </span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>i(<span class="hljs-string">&quot;test&quot;</span>,<span class="hljs-string">&quot;velocityTraker&quot;</span>+velocityTracker.get<span class="hljs-constructor">XVelocity()</span>);                     <br>velocityTracker.compute<span class="hljs-constructor">CurrentVelocity(1000)</span>; <span class="hljs-comment">//设置units的值为1000，意思为一秒时间内运动了多少个像素 </span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>i(<span class="hljs-string">&quot;test&quot;</span>,<span class="hljs-string">&quot;velocityTraker&quot;</span>+velocityTracker.get<span class="hljs-constructor">XVelocity()</span>); <br></code></pre></td></tr></table></figure><p>大体的使用是这样的：<br>当你需要跟踪触摸屏事件的速度的时候,使用obtain()方法来获得VelocityTracker类的一个实例对象<br>在onTouchEvent回调函数中，使用addMovement(MotionEvent)函数将当前的移动事件传递给VelocityTracker对象<br>使用computeCurrentVelocity  (int units)函数来计算当前的速度，使用 getXVelocity  ()、 getYVelocity  ()函数来获得当前的速度</p>]]></content>
    
    
    <categories>
      
      <category>android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>android</tag>
      
      <tag>scroll</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
